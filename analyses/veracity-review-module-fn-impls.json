[
  {
    "id": 1,
    "function": "sort_vec",
    "file": "Chap36/QuickSortMtEph.rs",
    "lines": "43-46",
    "spec_strength": "unknown",
    "snippet": "    fn sort_vec<T: TotalOrder + Copy>(a: &ArraySeqMtEphS<T>) -> (result: Vec<T>)\n        requires a.spec_len() <= usize::MAX,\n        ensures result@ =~= a.seq@.sort_by(spec_leq::<T>())\n        decreases a.spec_len(),"
  },
  {
    "id": 2,
    "function": "quick_sort_first",
    "file": "Chap36/QuickSortMtEph.rs",
    "lines": "345-347",
    "spec_strength": "unknown",
    "snippet": "    pub fn quick_sort_first<T: TotalOrder + Copy>(a: &mut ArraySeqMtEphS<T>)\n        requires old(a).spec_len() <= usize::MAX,\n        ensures a.seq@ =~= old(a).seq@.sort_by(spec_leq::<T>())"
  },
  {
    "id": 3,
    "function": "quick_sort_median3",
    "file": "Chap36/QuickSortMtEph.rs",
    "lines": "353-355",
    "spec_strength": "unknown",
    "snippet": "    pub fn quick_sort_median3<T: TotalOrder + Copy>(a: &mut ArraySeqMtEphS<T>)\n        requires old(a).spec_len() <= usize::MAX,\n        ensures a.seq@ =~= old(a).seq@.sort_by(spec_leq::<T>())"
  },
  {
    "id": 4,
    "function": "quick_sort_random",
    "file": "Chap36/QuickSortMtEph.rs",
    "lines": "361-363",
    "spec_strength": "unknown",
    "snippet": "    pub fn quick_sort_random<T: TotalOrder + Copy>(a: &mut ArraySeqMtEphS<T>)\n        requires old(a).spec_len() <= usize::MAX,\n        ensures a.seq@ =~= old(a).seq@.sort_by(spec_leq::<T>())"
  },
  {
    "id": 5,
    "function": "pivot_mt_first",
    "file": "Chap36/QuickSortMtEphSlice.rs",
    "lines": "16-18",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(1), Span Θ(1)\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1) — agrees with APAS.\n        fn pivot_mt_first(&self, lo: N, hi: N)   -> T;"
  },
  {
    "id": 6,
    "function": "pivot_mt_median3",
    "file": "Chap36/QuickSortMtEphSlice.rs",
    "lines": "19-21",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(1), Span Θ(1)\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1) — agrees with APAS.\n        fn pivot_mt_median3(&self, lo: N, hi: N) -> T;"
  },
  {
    "id": 7,
    "function": "pivot_mt_random",
    "file": "Chap36/QuickSortMtEphSlice.rs",
    "lines": "22-24",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(1), Span Θ(1)\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1) — agrees with APAS.\n        fn pivot_mt_random(&self, lo: N, hi: N)  -> T;"
  },
  {
    "id": 8,
    "function": "quick_sort_mt_first",
    "file": "Chap36/QuickSortMtEphSlice.rs",
    "lines": "25-27",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(n log n) expected / Θ(n²) worst, Span Θ(log² n) expected / Θ(n) worst\n        /// - Claude-Opus-4.6: Work Θ(n log n) expected / Θ(n²) worst, Span Θ(log² n) expected / Θ(n) worst — parallel via thread::scope (slice-based, no copy); partition is sequential Θ(n).\n        fn quick_sort_mt_first(&self);"
  },
  {
    "id": 9,
    "function": "quick_sort_mt_median3",
    "file": "Chap36/QuickSortMtEphSlice.rs",
    "lines": "28-30",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(n log n) expected / Θ(n²) worst, Span Θ(log² n) expected / Θ(n) worst\n        /// - Claude-Opus-4.6: Work Θ(n log n) expected / Θ(n²) worst, Span Θ(log² n) expected / Θ(n) worst — parallel via thread::scope (slice-based, no copy); partition is sequential Θ(n).\n        fn quick_sort_mt_median3(&self);"
  },
  {
    "id": 10,
    "function": "quick_sort_mt_random",
    "file": "Chap36/QuickSortMtEphSlice.rs",
    "lines": "31-33",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(n log n) expected / Θ(n²) worst, Span Θ(log² n) expected / Θ(n) worst\n        /// - Claude-Opus-4.6: Work Θ(n log n) expected / Θ(n²) worst, Span Θ(log² n) expected / Θ(n) worst — parallel via thread::scope (slice-based, no copy); partition is sequential Θ(n).\n        fn quick_sort_mt_random(&self);"
  },
  {
    "id": 11,
    "function": "sort`",
    "file": "Chap36/QuickSortMtEphSlice.rs",
    "lines": "64-94",
    "spec_strength": "",
    "snippet": "                /// - APAS: Work Θ(n log n) expected / Θ(n²) worst, Span Θ(log² n) expected / Θ(n) worst\n                /// - Claude-Opus-4.6: Work Θ(n log n) expected / Θ(n²) worst, Span Θ(log² n) expected / Θ(n) worst — parallel via thread::scope with first-element pivot.\n                fn sort<T: StTInMtT + Ord>(data: &mut [T]) {\n                    let len = data.len();\n                    if len <= 1 {\n                        return;\n                    }\n                    let pivot = data[0].clone();\n                    let mut lt = 0;\n                    let mut i = 0;\n                    let mut gt = len;\n                    while i < gt {\n                        if data[i] < pivot {\n                            data.swap(lt, i);\n                            lt += 1;\n                            i += 1;\n                        } else if data[i] > pivot {\n                            gt -= 1;\n                            data.swap(i, gt);\n                        } else {\n                            i += 1;\n                        }\n                    }\n                    let (left, mid_and_right) = data.split_at_mut(lt);\n                    let (_, right) = mid_and_right.split_at_mut(gt - lt);\n                    // Unconditionally parallel - no thresholding\n                    thread::scope(|scope| {\n                        scope.spawn(|| sort(left));\n                        sort(right);\n                    });\n                }"
  },
  {
    "id": 12,
    "function": "sort_vec",
    "file": "Chap36/QuickSortStEph.rs",
    "lines": "44-47",
    "spec_strength": "unknown",
    "snippet": "    fn sort_vec<T: TotalOrder + Copy>(a: &ArraySeqStEphS<T>) -> (result: Vec<T>)\n        requires a.spec_len() <= usize::MAX,\n        ensures result@ =~= a.seq@.sort_by(spec_leq::<T>())\n        decreases a.spec_len(),"
  },
  {
    "id": 13,
    "function": "quick_sort_first",
    "file": "Chap36/QuickSortStEph.rs",
    "lines": "358-360",
    "spec_strength": "unknown",
    "snippet": "    pub fn quick_sort_first<T: TotalOrder + Copy>(a: &mut ArraySeqStEphS<T>)\n        requires old(a).spec_len() <= usize::MAX,\n        ensures a.seq@ =~= old(a).seq@.sort_by(spec_leq::<T>())"
  },
  {
    "id": 14,
    "function": "quick_sort_median3",
    "file": "Chap36/QuickSortStEph.rs",
    "lines": "368-370",
    "spec_strength": "unknown",
    "snippet": "    pub fn quick_sort_median3<T: TotalOrder + Copy>(a: &mut ArraySeqStEphS<T>)\n        requires old(a).spec_len() <= usize::MAX,\n        ensures a.seq@ =~= old(a).seq@.sort_by(spec_leq::<T>())"
  },
  {
    "id": 15,
    "function": "quick_sort_random",
    "file": "Chap36/QuickSortStEph.rs",
    "lines": "378-380",
    "spec_strength": "unknown",
    "snippet": "    pub fn quick_sort_random<T: TotalOrder + Copy>(a: &mut ArraySeqStEphS<T>)\n        requires old(a).spec_len() <= usize::MAX,\n        ensures a.seq@ =~= old(a).seq@.sort_by(spec_leq::<T>())"
  },
  {
    "id": 16,
    "function": "new`",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "54-56",
    "spec_strength": "",
    "snippet": "        /// Construct an empty tree (alias).\n        /// APAS: Work Θ(1), Span Θ(1).\n        fn new()                                   -> Self;"
  },
  {
    "id": 17,
    "function": "empty",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "49-52",
    "spec_strength": "",
    "snippet": "        /// Construct an empty tree.\n        /// APAS: Work Θ(1), Span Θ(1).\n        /// claude-4-sonet: Work Θ(1), Span Θ(1).\n        fn empty()                                 -> Self;"
  },
  {
    "id": 18,
    "function": "length",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "58-60",
    "spec_strength": "",
    "snippet": "        /// Return number of elements.\n        /// APAS: Work Θ(1), Span Θ(1).\n        fn length(&self)                           -> N;"
  },
  {
    "id": 19,
    "function": "nth",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "62-64",
    "spec_strength": "",
    "snippet": "        /// Return a reference to the in-order `index`-th element. Panics if out of bounds.\n        /// APAS: Work Θ(lg(n)), Span Θ(lg(n)).\n        fn nth(&self, index: N)                    -> &T;"
  },
  {
    "id": 20,
    "function": "set",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "66-68",
    "spec_strength": "",
    "snippet": "        /// Set the in-order `index`-th element to `item`.\n        /// APAS: Work Θ(lg(n)), Span Θ(lg(n)).\n        fn set(&mut self, index: N, item: T)       -> Result<&mut AVLTreeS<T>, &'static str>;"
  },
  {
    "id": 21,
    "function": "singleton",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "70-72",
    "spec_strength": "",
    "snippet": "        /// Construct a singleton sequence.\n        /// APAS: Work Θ(1), Span Θ(1).\n        fn singleton(item: T)                      -> Self;"
  },
  {
    "id": 22,
    "function": "isEmpty",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "74-76",
    "spec_strength": "",
    "snippet": "        /// Predicates.\n        /// APAS: Work Θ(1), Span Θ(1).\n        fn isEmpty(&self)                          -> B;"
  },
  {
    "id": 23,
    "function": "isSingleton",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "77",
    "spec_strength": "",
    "snippet": "        fn isSingleton(&self)                      -> B;"
  },
  {
    "id": 24,
    "function": "subseq_copy",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "79-83",
    "spec_strength": "",
    "snippet": "        /// Return subsequence [start, start+length) as a new tree.\n        /// APAS: Work Θ(1 + lg(|a|)), Span Θ(1 + lg(|a|)).\n        fn subseq_copy(&self, start: N, length: N) -> Self\n        where\n            T: Clone + Eq;"
  },
  {
    "id": 25,
    "function": "new_root",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "84",
    "spec_strength": "",
    "snippet": "        fn new_root()                              -> Self;"
  },
  {
    "id": 26,
    "function": "update",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "85",
    "spec_strength": "",
    "snippet": "        fn update(&mut self, item_at: (N, T))      -> &mut AVLTreeS<T>;"
  },
  {
    "id": 27,
    "function": "from_vec",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "86-88",
    "spec_strength": "",
    "snippet": "        fn from_vec(values: Vec<T>)                -> AVLTreeS<T>\n        where\n            T: Clone;"
  },
  {
    "id": 28,
    "function": "to_arrayseq",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "89-91",
    "spec_strength": "",
    "snippet": "        fn to_arrayseq(&self)                      -> ArraySeqS<T>\n        where\n            T: Clone;"
  },
  {
    "id": 29,
    "function": "iter",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "92",
    "spec_strength": "",
    "snippet": "        fn iter<'a>(&'a self)                      -> AVLTreeSeqIter<'a, T>;"
  },
  {
    "id": 30,
    "function": "push_back",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "93",
    "spec_strength": "",
    "snippet": "        fn push_back(&mut self, value: T);"
  },
  {
    "id": 31,
    "function": "contains_value",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "94-96",
    "spec_strength": "",
    "snippet": "        fn contains_value(&self, target: &T)       -> B\n        where\n            T: PartialEq;"
  },
  {
    "id": 32,
    "function": "insert_value",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "97",
    "spec_strength": "",
    "snippet": "        fn insert_value(&mut self, value: T);"
  },
  {
    "id": 33,
    "function": "delete_value",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "98-100",
    "spec_strength": "",
    "snippet": "        fn delete_value(&mut self, target: &T)     -> bool\n        where\n            T: Clone + PartialEq;"
  },
  {
    "id": 34,
    "function": "is_tree_empty",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "101",
    "spec_strength": "",
    "snippet": "        fn is_tree_empty(&self)                    -> bool;"
  },
  {
    "id": 35,
    "function": "values_in_order",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "102-104",
    "spec_strength": "",
    "snippet": "        fn values_in_order(&self)                  -> Vec<T>\n        where\n            T: Clone;"
  },
  {
    "id": 36,
    "function": "eq",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "263-273",
    "spec_strength": "",
    "snippet": "        fn eq(&self, other: &Self) -> bool {\n            if self.length() != other.length() {\n                return false;\n            }\n            for i in 0..self.length() {\n                if self.nth(i) != other.nth(i) {\n                    return false;\n                }\n            }\n            true\n        }"
  },
  {
    "id": 37,
    "function": "push_left",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "317-323",
    "spec_strength": "",
    "snippet": "        fn push_left(&mut self, link: &'a Link<T>) {\n            let mut cursor = link;\n            while let Some(node) = cursor.as_ref() {\n                self.stack.push(node);\n                cursor = &node.left;\n            }\n        }"
  },
  {
    "id": 38,
    "function": "next",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "328-333",
    "spec_strength": "",
    "snippet": "        fn next(&mut self) -> Option<Self::Item> {\n            let node = self.stack.pop()?;\n            let value_ref: &T = &node.value;\n            self.push_left(&node.right);\n            Some(value_ref)\n        }"
  },
  {
    "id": 39,
    "function": "h",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "336",
    "spec_strength": "",
    "snippet": "    fn h<T: StT>(n: &Link<T>) -> N { n.as_ref().map_or(0, |b| b.height) }"
  },
  {
    "id": 40,
    "function": "size_link",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "337-343",
    "spec_strength": "",
    "snippet": "    fn size_link<T: StT>(n: &Link<T>) -> N {\n        if let Some(b) = n {\n            1 + b.left_size + b.right_size\n        } else {\n            0\n        }\n    }"
  },
  {
    "id": 41,
    "function": "update_meta",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "345-351",
    "spec_strength": "",
    "snippet": "    fn update_meta<T: StT>(n: &mut Box<AVLTreeNode<T>>) {\n        n.left_size = size_link(&n.left);\n        n.right_size = size_link(&n.right);\n        let hl = h(&n.left);\n        let hr = h(&n.right);\n        n.height = 1 + hl.max(hr);\n    }"
  },
  {
    "id": 42,
    "function": "rotate_right",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "353-364",
    "spec_strength": "",
    "snippet": "    fn rotate_right<T: StT>(mut y: Box<AVLTreeNode<T>>) -> Box<AVLTreeNode<T>> {\n        let mut x = y.left.take().expect(\"rotate_right requires left child\");\n        let t2 = x.right.take();\n\n        y.left = t2;\n        update_meta(&mut y);\n\n        x.right = Some(y);\n        update_meta(x.right.as_mut().unwrap());\n        update_meta(&mut x);\n        x\n    }"
  },
  {
    "id": 43,
    "function": "rotate_left",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "366-377",
    "spec_strength": "",
    "snippet": "    fn rotate_left<T: StT>(mut x: Box<AVLTreeNode<T>>) -> Box<AVLTreeNode<T>> {\n        let mut y = x.right.take().expect(\"rotate_left requires right child\");\n        let t2 = y.left.take();\n\n        x.right = t2;\n        update_meta(&mut x);\n\n        y.left = Some(x);\n        update_meta(y.left.as_mut().unwrap());\n        update_meta(&mut y);\n        y\n    }"
  },
  {
    "id": 44,
    "function": "rebalance",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "379-400",
    "spec_strength": "",
    "snippet": "    fn rebalance<T: StT>(mut n: Box<AVLTreeNode<T>>) -> Box<AVLTreeNode<T>> {\n        update_meta(&mut n);\n        let hl = h(&n.left);\n        let hr = h(&n.right);\n        if hl > hr.saturating_add(1) {\n            // Left heavy: check for Left-Right case\n            if h(&n.left.as_ref().unwrap().right) > h(&n.left.as_ref().unwrap().left) {\n                let left = n.left.take().unwrap();\n                n.left = Some(rotate_left(left));\n            }\n            return rotate_right(n);\n        }\n        if hr > hl.saturating_add(1) {\n            // Right heavy: check for Right-Left case\n            if h(&n.right.as_ref().unwrap().left) > h(&n.right.as_ref().unwrap().right) {\n                let right = n.right.take().unwrap();\n                n.right = Some(rotate_right(right));\n            }\n            return rotate_left(n);\n        }\n        n\n    }"
  },
  {
    "id": 45,
    "function": "insert_at_link",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "402-421",
    "spec_strength": "",
    "snippet": "    #[doc(hidden)]\n    pub(crate) fn insert_at_link<T: StT>(node: Link<T>, index: N, value: T, next_key: &mut N) -> Link<T> {\n        match node {\n            | None => {\n                debug_assert!(index == 0, \"insert_at_link reached None with index > 0\");\n                let key = *next_key;\n                *next_key += 1;\n                Some(Box::new(AVLTreeNode::new(value, key)))\n            }\n            | Some(mut n) => {\n                let left_size = n.left_size;\n                if index <= left_size {\n                    n.left = insert_at_link(n.left.take(), index, value, next_key);\n                } else {\n                    n.right = insert_at_link(n.right.take(), index - left_size - 1, value, next_key);\n                }\n                Some(rebalance(n))\n            }\n        }\n    }"
  },
  {
    "id": 46,
    "function": "nth_link",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "423-433",
    "spec_strength": "",
    "snippet": "    fn nth_link<T: StT>(node: &Link<T>, index: N) -> &T {\n        let n = node.as_ref().expect(\"index out of bounds\");\n        let left_size = n.left_size;\n        if index < left_size {\n            return nth_link(&n.left, index);\n        }\n        if index == left_size {\n            return &n.value;\n        }\n        nth_link(&n.right, index - left_size - 1)\n    }"
  },
  {
    "id": 47,
    "function": "set_link",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "435-450",
    "spec_strength": "",
    "snippet": "    fn set_link<T: StT>(node: &mut Link<T>, index: N, value: T) -> Result<(), &'static str> {\n        match node {\n            | None => Err(\"Index out of bounds\"),\n            | Some(n) => {\n                let left_size = n.left_size;\n                if index < left_size {\n                    set_link(&mut n.left, index, value)\n                } else if index == left_size {\n                    n.value = value;\n                    Ok(())\n                } else {\n                    set_link(&mut n.right, index - left_size - 1, value)\n                }\n            }\n        }\n    }"
  },
  {
    "id": 48,
    "function": "push_inorder",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "452-458",
    "spec_strength": "",
    "snippet": "    fn push_inorder<T: StT + Clone>(link: &Link<T>, out: &mut Vec<T>) {\n        if let Some(n) = link {\n            push_inorder(&n.left, out);\n            out.push(n.value.clone());\n            push_inorder(&n.right, out);\n        }\n    }"
  },
  {
    "id": 49,
    "function": "default",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "461",
    "spec_strength": "",
    "snippet": "        fn default() -> Self { Self::new() }"
  },
  {
    "id": 50,
    "function": "height",
    "file": "Chap37/AVLTreeSeqMtPer.rs",
    "lines": "22",
    "spec_strength": "",
    "snippet": "    fn height<T: StTInMtT>(n: &Link<T>) -> N { n.as_ref().map_or(0, |r| r.height) }"
  },
  {
    "id": 51,
    "function": "size",
    "file": "Chap37/AVLTreeSeqMtPer.rs",
    "lines": "23",
    "spec_strength": "",
    "snippet": "    fn size<T: StTInMtT>(n: &Link<T>) -> N { n.as_ref().map_or(0, |r| r.size) }"
  },
  {
    "id": 52,
    "function": "mk",
    "file": "Chap37/AVLTreeSeqMtPer.rs",
    "lines": "25-36",
    "spec_strength": "",
    "snippet": "    fn mk<T: StTInMtT>(value: T, left: Link<T>, right: Link<T>) -> Arc<Node<T>> {\n        let hl = height(&left);\n        let hr = height(&right);\n        let sz = 1 + size(&left) + size(&right);\n        Arc::new(Node {\n            value,\n            height: 1 + hl.max(hr),\n            size: sz,\n            left,\n            right,\n        })\n    }"
  },
  {
    "id": 53,
    "function": "rotate_right",
    "file": "Chap37/AVLTreeSeqMtPer.rs",
    "lines": "38-43",
    "spec_strength": "",
    "snippet": "    fn rotate_right<T: StTInMtT>(y: Arc<Node<T>>) -> Arc<Node<T>> {\n        let x = y.left.as_ref().expect(\"rotate_right requires left\").clone();\n        let t2 = x.right.clone();\n        let new_y = mk(y.value.clone(), t2.clone(), y.right.clone());\n        mk(x.value.clone(), x.left.clone(), Some(new_y))\n    }"
  },
  {
    "id": 54,
    "function": "rotate_left",
    "file": "Chap37/AVLTreeSeqMtPer.rs",
    "lines": "45-50",
    "spec_strength": "",
    "snippet": "    fn rotate_left<T: StTInMtT>(x: Arc<Node<T>>) -> Arc<Node<T>> {\n        let y = x.right.as_ref().expect(\"rotate_left requires right\").clone();\n        let t2 = y.left.clone();\n        let new_x = mk(x.value.clone(), x.left.clone(), t2.clone());\n        mk(y.value.clone(), Some(new_x), y.right.clone())\n    }"
  },
  {
    "id": 55,
    "function": "rebalance",
    "file": "Chap37/AVLTreeSeqMtPer.rs",
    "lines": "52-72",
    "spec_strength": "",
    "snippet": "    fn rebalance<T: StTInMtT>(n: Arc<Node<T>>) -> Arc<Node<T>> {\n        let hl = height(&n.left);\n        let hr = height(&n.right);\n        if hl > hr.saturating_add(1) {\n            let left = n.left.as_ref().unwrap().clone();\n            if height(&left.right) > height(&left.left) {\n                let rotated = rotate_left(left);\n                return rotate_right(mk(n.value.clone(), Some(rotated), n.right.clone()));\n            }\n            return rotate_right(n);\n        }\n        if hr > hl.saturating_add(1) {\n            let right = n.right.as_ref().unwrap().clone();\n            if height(&right.left) > height(&right.right) {\n                let rotated = rotate_right(right);\n                return rotate_left(mk(n.value.clone(), n.left.clone(), Some(rotated)));\n            }\n            return rotate_left(n);\n        }\n        n\n    }"
  },
  {
    "id": 56,
    "function": "nth_ref",
    "file": "Chap37/AVLTreeSeqMtPer.rs",
    "lines": "74-87",
    "spec_strength": "",
    "snippet": "    fn nth_ref<T: StTInMtT>(mut cur: &Link<T>, mut index: N) -> &T {\n        loop {\n            let node = cur.as_ref().expect(\"index out of bounds\");\n            let ls = size(&node.left);\n            if index < ls {\n                cur = &node.left;\n            } else if index == ls {\n                return &node.value;\n            } else {\n                index -= ls + 1;\n                cur = &node.right;\n            }\n        }\n    }"
  },
  {
    "id": 57,
    "function": "set_rec",
    "file": "Chap37/AVLTreeSeqMtPer.rs",
    "lines": "89-111",
    "spec_strength": "",
    "snippet": "    fn set_rec<T: StTInMtT>(cur: &Link<T>, index: N, value: T) -> Result<Link<T>, &'static str> {\n        match cur {\n            | None => {\n                if index == 0 {\n                    Ok(Some(mk(value, None, None)))\n                } else {\n                    Err(\"Index out of bounds\")\n                }\n            }\n            | Some(n) => {\n                let ls = size(&n.left);\n                if index < ls {\n                    let new_left = set_rec(&n.left, index, value)?;\n                    Ok(Some(rebalance(mk(n.value.clone(), new_left, n.right.clone()))))\n                } else if index == ls {\n                    Ok(Some(mk(value, n.left.clone(), n.right.clone())))\n                } else {\n                    let new_right = set_rec(&n.right, index - ls - 1, value)?;\n                    Ok(Some(rebalance(mk(n.value.clone(), n.left.clone(), new_right))))\n                }\n            }\n        }\n    }"
  },
  {
    "id": 58,
    "function": "inorder_collect",
    "file": "Chap37/AVLTreeSeqMtPer.rs",
    "lines": "113-119",
    "spec_strength": "",
    "snippet": "    fn inorder_collect<T: StTInMtT>(cur: &Link<T>, out: &mut Vec<T>) {\n        if let Some(n) = cur {\n            inorder_collect(&n.left, out);\n            out.push(n.value.clone());\n            inorder_collect(&n.right, out);\n        }\n    }"
  },
  {
    "id": 59,
    "function": "build_balanced_from_slice",
    "file": "Chap37/AVLTreeSeqMtPer.rs",
    "lines": "121-137",
    "spec_strength": "",
    "snippet": "    fn build_balanced_from_slice<T: StTInMtT>(a: &[T]) -> Link<T> {\n        fn rec<T: StTInMtT>(a: &[T]) -> Link<T> {\n            if a.is_empty() {\n                return None;\n            }\n            let mid = a.len() / 2;\n            \n            // Parallel construction of left and right subtrees\n            let Pair(left, right) = crate::ParaPair!(\n                move || rec(&a[..mid]),\n                move || rec(&a[mid + 1..])\n            );\n            \n            Some(mk(a[mid].clone(), left, right))\n        }\n        rec(a)\n    }"
  },
  {
    "id": 60,
    "function": "rec",
    "file": "Chap37/AVLTreeSeqMtPer.rs",
    "lines": "122-135",
    "spec_strength": "",
    "snippet": "        fn rec<T: StTInMtT>(a: &[T]) -> Link<T> {\n            if a.is_empty() {\n                return None;\n            }\n            let mid = a.len() / 2;\n            \n            // Parallel construction of left and right subtrees\n            let Pair(left, right) = crate::ParaPair!(\n                move || rec(&a[..mid]),\n                move || rec(&a[mid + 1..])\n            );\n            \n            Some(mk(a[mid].clone(), left, right))\n        }"
  },
  {
    "id": 61,
    "function": "empty",
    "file": "Chap37/AVLTreeSeqMtPer.rs",
    "lines": "144-146",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(1), Span Θ(1)\n        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn empty()                                 -> Self;"
  },
  {
    "id": 62,
    "function": "new",
    "file": "Chap37/AVLTreeSeqMtPer.rs",
    "lines": "147-148",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(1), Span Θ(1)\n        fn new()                                   -> Self;"
  },
  {
    "id": 63,
    "function": "length",
    "file": "Chap37/AVLTreeSeqMtPer.rs",
    "lines": "149-150",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(1), Span Θ(1)\n        fn length(&self)                           -> N;"
  },
  {
    "id": 64,
    "function": "nth",
    "file": "Chap37/AVLTreeSeqMtPer.rs",
    "lines": "151-152",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(lg(n)), Span Θ(lg(n))\n        fn nth(&self, index: N)                    -> &T;"
  },
  {
    "id": 65,
    "function": "set",
    "file": "Chap37/AVLTreeSeqMtPer.rs",
    "lines": "153-156",
    "spec_strength": "",
    "snippet": "        /// APAS (ephemeral set Θ(lg n)); MtPer path-copy Θ(lg n) allocations. Work Θ(lg n), Span Θ(lg n)\n        fn set(&self, index: N, item: T)           -> Result<Self, &'static str>\n        where\n            Self: Sized;"
  },
  {
    "id": 66,
    "function": "singleton",
    "file": "Chap37/AVLTreeSeqMtPer.rs",
    "lines": "157-158",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(1), Span Θ(1)\n        fn singleton(item: T)                      -> Self;"
  },
  {
    "id": 67,
    "function": "isEmpty",
    "file": "Chap37/AVLTreeSeqMtPer.rs",
    "lines": "159-160",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(1), Span Θ(1)\n        fn isEmpty(&self)                          -> B;"
  },
  {
    "id": 68,
    "function": "isSingleton",
    "file": "Chap37/AVLTreeSeqMtPer.rs",
    "lines": "161-162",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(1), Span Θ(1)\n        fn isSingleton(&self)                      -> B;"
  },
  {
    "id": 69,
    "function": "subseq_copy",
    "file": "Chap37/AVLTreeSeqMtPer.rs",
    "lines": "163-164",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(1 + lg|a|), Span Θ(1 + lg|a|)\n        fn subseq_copy(&self, start: N, length: N) -> Self;"
  },
  {
    "id": 70,
    "function": "from_vec",
    "file": "Chap37/AVLTreeSeqMtPer.rs",
    "lines": "165-166",
    "spec_strength": "",
    "snippet": "        /// Build balanced tree from values in in-order order.\n        fn from_vec(values: Vec<T>)                -> Self;"
  },
  {
    "id": 71,
    "function": "values_in_order",
    "file": "Chap37/AVLTreeSeqMtPer.rs",
    "lines": "167-168",
    "spec_strength": "",
    "snippet": "        /// Collect in-order values to Vec.\n        fn values_in_order(&self)                  -> Vec<T>;"
  },
  {
    "id": 72,
    "function": "default",
    "file": "Chap37/AVLTreeSeqMtPer.rs",
    "lines": "248",
    "spec_strength": "",
    "snippet": "        fn default() -> Self { Self::empty() }"
  },
  {
    "id": 73,
    "function": "next",
    "file": "Chap37/AVLTreeSeqMtPer.rs",
    "lines": "260-268",
    "spec_strength": "",
    "snippet": "        fn next(&mut self) -> Option<Self::Item> {\n            if self.index < self.values.len() {\n                let val = self.values[self.index].clone();\n                self.index += 1;\n                Some(val)\n            } else {\n                None\n            }\n        }"
  },
  {
    "id": 74,
    "function": "eq",
    "file": "Chap37/AVLTreeSeqMtPer.rs",
    "lines": "284-294",
    "spec_strength": "",
    "snippet": "        fn eq(&self, other: &Self) -> bool {\n            if self.length() != other.length() {\n                return false;\n            }\n            for i in 0..self.length() {\n                if self.nth(i) != other.nth(i) {\n                    return false;\n                }\n            }\n            true\n        }"
  },
  {
    "id": 75,
    "function": "new`",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "47-48",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(1), Span Θ(1).\n        fn new()                                   -> Self;"
  },
  {
    "id": 76,
    "function": "empty",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "44-46",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(1), Span Θ(1).\n        /// claude-4-sonet: Work Θ(1), Span Θ(1).\n        fn empty()                                 -> Self;"
  },
  {
    "id": 77,
    "function": "length",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "49-50",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(1), Span Θ(1).\n        fn length(&self)                           -> N;"
  },
  {
    "id": 78,
    "function": "nth",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "51-52",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(lg(n)), Span Θ(lg(n)).\n        fn nth(&self, index: N)                    -> &T;"
  },
  {
    "id": 79,
    "function": "set",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "53-54",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(lg(n)), Span Θ(lg(n)).\n        fn set(&mut self, index: N, item: T)       -> Result<&mut Self, &'static str>;"
  },
  {
    "id": 80,
    "function": "singleton",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "55-56",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(1), Span Θ(1).\n        fn singleton(item: T)                      -> Self;"
  },
  {
    "id": 81,
    "function": "isEmpty",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "57-58",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(1), Span Θ(1).\n        fn isEmpty(&self)                          -> B;"
  },
  {
    "id": 82,
    "function": "isSingleton",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "59-60",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(1), Span Θ(1).\n        fn isSingleton(&self)                      -> B;"
  },
  {
    "id": 83,
    "function": "subseq_copy",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "61-62",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(1 + lg(|a|)), Span Θ(1 + lg(|a|)).\n        fn subseq_copy(&self, start: N, length: N) -> Self;"
  },
  {
    "id": 84,
    "function": "new_root",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "63",
    "spec_strength": "",
    "snippet": "        fn new_root()                              -> Self;"
  },
  {
    "id": 85,
    "function": "update",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "64",
    "spec_strength": "",
    "snippet": "        fn update(&mut self, item_at: (N, T))      -> &mut AVLTreeSeqStEphS<T>;"
  },
  {
    "id": 86,
    "function": "from_vec",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "65",
    "spec_strength": "",
    "snippet": "        fn from_vec(values: Vec<T>)                -> AVLTreeSeqStEphS<T>;"
  },
  {
    "id": 87,
    "function": "to_arrayseq",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "66",
    "spec_strength": "",
    "snippet": "        fn to_arrayseq(&self)                      -> ArraySeqStEphS<T>;"
  },
  {
    "id": 88,
    "function": "iter",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "67",
    "spec_strength": "",
    "snippet": "        fn iter<'a>(&'a self)                      -> AVLTreeSeqIterStEph<'a, T>;"
  },
  {
    "id": 89,
    "function": "push_back",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "68",
    "spec_strength": "",
    "snippet": "        fn push_back(&mut self, value: T);"
  },
  {
    "id": 90,
    "function": "contains_value",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "69",
    "spec_strength": "",
    "snippet": "        fn contains_value(&self, target: &T)       -> B;"
  },
  {
    "id": 91,
    "function": "insert_value",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "70",
    "spec_strength": "",
    "snippet": "        fn insert_value(&mut self, value: T);"
  },
  {
    "id": 92,
    "function": "delete_value",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "71",
    "spec_strength": "",
    "snippet": "        fn delete_value(&mut self, target: &T)     -> bool;"
  },
  {
    "id": 93,
    "function": "push_left",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "209-215",
    "spec_strength": "",
    "snippet": "        fn push_left(&mut self, link: &'a Link<T>) {\n            let mut cursor = link;\n            while let Some(node) = cursor.as_ref() {\n                self.stack.push(node);\n                cursor = &node.left;\n            }\n        }"
  },
  {
    "id": 94,
    "function": "next",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "220-225",
    "spec_strength": "",
    "snippet": "        fn next(&mut self) -> Option<Self::Item> {\n            let node = self.stack.pop()?;\n            let value_ref: &T = &node.value;\n            self.push_left(&node.right);\n            Some(value_ref)\n        }"
  },
  {
    "id": 95,
    "function": "h",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "228",
    "spec_strength": "",
    "snippet": "    fn h<T: StT>(n: &Link<T>) -> N { n.as_ref().map_or(0, |b| b.height) }"
  },
  {
    "id": 96,
    "function": "size_link",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "230-236",
    "spec_strength": "",
    "snippet": "    fn size_link<T: StT>(n: &Link<T>) -> N {\n        if let Some(b) = n {\n            1 + b.left_size + b.right_size\n        } else {\n            0\n        }\n    }"
  },
  {
    "id": 97,
    "function": "update_meta",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "238-244",
    "spec_strength": "",
    "snippet": "    fn update_meta<T: StT>(n: &mut Box<AVLTreeNode<T>>) {\n        n.left_size = size_link(&n.left);\n        n.right_size = size_link(&n.right);\n        let hl = h(&n.left);\n        let hr = h(&n.right);\n        n.height = 1 + hl.max(hr);\n    }"
  },
  {
    "id": 98,
    "function": "rotate_right",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "246-255",
    "spec_strength": "",
    "snippet": "    fn rotate_right<T: StT>(mut y: Box<AVLTreeNode<T>>) -> Box<AVLTreeNode<T>> {\n        let mut x = y.left.take().expect(\"rotate_right requires left child\");\n        let t2 = x.right.take();\n        y.left = t2;\n        update_meta(&mut y);\n        x.right = Some(y);\n        update_meta(x.right.as_mut().unwrap());\n        update_meta(&mut x);\n        x\n    }"
  },
  {
    "id": 99,
    "function": "rotate_left",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "257-266",
    "spec_strength": "",
    "snippet": "    fn rotate_left<T: StT>(mut x: Box<AVLTreeNode<T>>) -> Box<AVLTreeNode<T>> {\n        let mut y = x.right.take().expect(\"rotate_left requires right child\");\n        let t2 = y.left.take();\n        x.right = t2;\n        update_meta(&mut x);\n        y.left = Some(x);\n        update_meta(y.left.as_mut().unwrap());\n        update_meta(&mut y);\n        y\n    }"
  },
  {
    "id": 100,
    "function": "rebalance",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "268-287",
    "spec_strength": "",
    "snippet": "    fn rebalance<T: StT>(mut n: Box<AVLTreeNode<T>>) -> Box<AVLTreeNode<T>> {\n        update_meta(&mut n);\n        let hl = h(&n.left);\n        let hr = h(&n.right);\n        if hl > hr.saturating_add(1) {\n            if h(&n.left.as_ref().unwrap().right) > h(&n.left.as_ref().unwrap().left) {\n                let left = n.left.take().unwrap();\n                n.left = Some(rotate_left(left));\n            }\n            return rotate_right(n);\n        }\n        if hr > hl.saturating_add(1) {\n            if h(&n.right.as_ref().unwrap().left) > h(&n.right.as_ref().unwrap().right) {\n                let right = n.right.take().unwrap();\n                n.right = Some(rotate_right(right));\n            }\n            return rotate_left(n);\n        }\n        n\n    }"
  },
  {
    "id": 101,
    "function": "insert_at_link",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "289-307",
    "spec_strength": "",
    "snippet": "    pub(crate) fn insert_at_link<T: StT>(node: Link<T>, index: N, value: T, next_key: &mut N) -> Link<T> {\n        match node {\n            | None => {\n                debug_assert!(index == 0, \"insert_at_link reached None with index > 0\");\n                let key = *next_key;\n                *next_key += 1;\n                Some(Box::new(AVLTreeNode::new(value, key)))\n            }\n            | Some(mut n) => {\n                let left_size = n.left_size;\n                if index <= left_size {\n                    n.left = insert_at_link(n.left.take(), index, value, next_key);\n                } else {\n                    n.right = insert_at_link(n.right.take(), index - left_size - 1, value, next_key);\n                }\n                Some(rebalance(n))\n            }\n        }\n    }"
  },
  {
    "id": 102,
    "function": "nth_link",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "309-319",
    "spec_strength": "",
    "snippet": "    fn nth_link<T: StT>(node: &Link<T>, index: N) -> &T {\n        let n = node.as_ref().expect(\"index out of bounds\");\n        let left_size = n.left_size;\n        if index < left_size {\n            return nth_link(&n.left, index);\n        }\n        if index == left_size {\n            return &n.value;\n        }\n        nth_link(&n.right, index - left_size - 1)\n    }"
  },
  {
    "id": 103,
    "function": "set_link",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "321-336",
    "spec_strength": "",
    "snippet": "    fn set_link<T: StT>(node: &mut Link<T>, index: N, value: T) -> Result<(), &'static str> {\n        match node {\n            | None => Err(\"Index out of bounds\"),\n            | Some(n) => {\n                let left_size = n.left_size;\n                if index < left_size {\n                    set_link(&mut n.left, index, value)\n                } else if index == left_size {\n                    n.value = value;\n                    Ok(())\n                } else {\n                    set_link(&mut n.right, index - left_size - 1, value)\n                }\n            }\n        }\n    }"
  },
  {
    "id": 104,
    "function": "default",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "339",
    "spec_strength": "",
    "snippet": "        fn default() -> Self { Self::new() }"
  },
  {
    "id": 105,
    "function": "eq",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "358-368",
    "spec_strength": "",
    "snippet": "        fn eq(&self, other: &Self) -> bool {\n            if self.length() != other.length() {\n                return false;\n            }\n            for i in 0..self.length() {\n                if self.nth(i) != other.nth(i) {\n                    return false;\n                }\n            }\n            true\n        }"
  },
  {
    "id": 106,
    "function": "height",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "22",
    "spec_strength": "",
    "snippet": "    fn height<T: StT>(n: &Link<T>) -> N { n.as_ref().map_or(0, |r| r.height) }"
  },
  {
    "id": 107,
    "function": "size",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "23",
    "spec_strength": "",
    "snippet": "    fn size<T: StT>(n: &Link<T>) -> N { n.as_ref().map_or(0, |r| r.size) }"
  },
  {
    "id": 108,
    "function": "mk",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "25-36",
    "spec_strength": "",
    "snippet": "    fn mk<T: StT>(value: T, left: Link<T>, right: Link<T>) -> Rc<Node<T>> {\n        let hl = height(&left);\n        let hr = height(&right);\n        let sz = 1 + size(&left) + size(&right);\n        Rc::new(Node {\n            value,\n            height: 1 + hl.max(hr),\n            size: sz,\n            left,\n            right,\n        })\n    }"
  },
  {
    "id": 109,
    "function": "rotate_right",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "38-43",
    "spec_strength": "",
    "snippet": "    fn rotate_right<T: StT>(y: Rc<Node<T>>) -> Rc<Node<T>> {\n        let x = y.left.as_ref().expect(\"rotate_right requires left\").clone();\n        let t2 = x.right.clone();\n        let new_y = mk(y.value.clone(), t2.clone(), y.right.clone());\n        mk(x.value.clone(), x.left.clone(), Some(new_y))\n    }"
  },
  {
    "id": 110,
    "function": "rotate_left",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "45-50",
    "spec_strength": "",
    "snippet": "    fn rotate_left<T: StT>(x: Rc<Node<T>>) -> Rc<Node<T>> {\n        let y = x.right.as_ref().expect(\"rotate_left requires right\").clone();\n        let t2 = y.left.clone();\n        let new_x = mk(x.value.clone(), x.left.clone(), t2.clone());\n        mk(y.value.clone(), Some(new_x), y.right.clone())\n    }"
  },
  {
    "id": 111,
    "function": "rebalance",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "52-72",
    "spec_strength": "",
    "snippet": "    fn rebalance<T: StT>(n: Rc<Node<T>>) -> Rc<Node<T>> {\n        let hl = height(&n.left);\n        let hr = height(&n.right);\n        if hl > hr.saturating_add(1) {\n            let left = n.left.as_ref().unwrap().clone();\n            if height(&left.right) > height(&left.left) {\n                let rotated = rotate_left(left);\n                return rotate_right(mk(n.value.clone(), Some(rotated), n.right.clone()));\n            }\n            return rotate_right(n);\n        }\n        if hr > hl.saturating_add(1) {\n            let right = n.right.as_ref().unwrap().clone();\n            if height(&right.left) > height(&right.right) {\n                let rotated = rotate_right(right);\n                return rotate_left(mk(n.value.clone(), n.left.clone(), Some(rotated)));\n            }\n            return rotate_left(n);\n        }\n        n\n    }"
  },
  {
    "id": 112,
    "function": "nth_ref",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "74-87",
    "spec_strength": "",
    "snippet": "    fn nth_ref<T: StT>(mut cur: &Link<T>, mut index: N) -> &T {\n        loop {\n            let node = cur.as_ref().expect(\"index out of bounds\");\n            let ls = size(&node.left);\n            if index < ls {\n                cur = &node.left;\n            } else if index == ls {\n                return &node.value;\n            } else {\n                index -= ls + 1;\n                cur = &node.right;\n            }\n        }\n    }"
  },
  {
    "id": 113,
    "function": "set_rec",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "89-112",
    "spec_strength": "",
    "snippet": "    fn set_rec<T: StT>(cur: &Link<T>, index: N, value: T) -> Result<Link<T>, &'static str> {\n        match cur {\n            | None => {\n                // Allow setting at index 0 on empty tree (append to empty)\n                if index == 0 {\n                    Ok(Some(mk(value, None, None)))\n                } else {\n                    Err(\"Index out of bounds\")\n                }\n            }\n            | Some(n) => {\n                let ls = size(&n.left);\n                if index < ls {\n                    let new_left = set_rec(&n.left, index, value)?;\n                    Ok(Some(rebalance(mk(n.value.clone(), new_left, n.right.clone()))))\n                } else if index == ls {\n                    Ok(Some(mk(value, n.left.clone(), n.right.clone())))\n                } else {\n                    let new_right = set_rec(&n.right, index - ls - 1, value)?;\n                    Ok(Some(rebalance(mk(n.value.clone(), n.left.clone(), new_right))))\n                }\n            }\n        }\n    }"
  },
  {
    "id": 114,
    "function": "inorder_collect",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "114-120",
    "spec_strength": "",
    "snippet": "    fn inorder_collect<T: StT>(cur: &Link<T>, out: &mut Vec<T>) {\n        if let Some(n) = cur {\n            inorder_collect(&n.left, out);\n            out.push(n.value.clone());\n            inorder_collect(&n.right, out);\n        }\n    }"
  },
  {
    "id": 115,
    "function": "build_balanced_from_slice",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "122-133",
    "spec_strength": "",
    "snippet": "    fn build_balanced_from_slice<T: StT>(a: &[T]) -> Link<T> {\n        fn rec<T: StT>(a: &[T]) -> Link<T> {\n            if a.is_empty() {\n                return None;\n            }\n            let mid = a.len() / 2;\n            let left = rec(&a[..mid]);\n            let right = rec(&a[mid + 1..]);\n            Some(mk(a[mid].clone(), left, right))\n        }\n        rec(a)\n    }"
  },
  {
    "id": 116,
    "function": "rec",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "123-131",
    "spec_strength": "",
    "snippet": "        fn rec<T: StT>(a: &[T]) -> Link<T> {\n            if a.is_empty() {\n                return None;\n            }\n            let mid = a.len() / 2;\n            let left = rec(&a[..mid]);\n            let right = rec(&a[mid + 1..]);\n            Some(mk(a[mid].clone(), left, right))\n        }"
  },
  {
    "id": 117,
    "function": "empty",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "140-142",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(1), Span Θ(1)\n        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn empty()                                 -> Self;"
  },
  {
    "id": 118,
    "function": "new",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "143-144",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(1), Span Θ(1)\n        fn new()                                   -> Self;"
  },
  {
    "id": 119,
    "function": "length",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "145-146",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(1), Span Θ(1)\n        fn length(&self)                           -> N;"
  },
  {
    "id": 120,
    "function": "nth",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "147-148",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(lg(n)), Span Θ(lg(n))\n        fn nth(&self, index: N)                    -> &T;"
  },
  {
    "id": 121,
    "function": "set",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "149-152",
    "spec_strength": "",
    "snippet": "        /// APAS (ephemeral set Θ(lg n)); StPer path-copy Θ(lg n) allocations. Work Θ(lg n), Span Θ(lg n)\n        fn set(&self, index: N, item: T)           -> Result<Self, &'static str>\n        where\n            Self: Sized;"
  },
  {
    "id": 122,
    "function": "singleton",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "153-154",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(1), Span Θ(1)\n        fn singleton(item: T)                      -> Self;"
  },
  {
    "id": 123,
    "function": "isEmpty",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "155-156",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(1), Span Θ(1)\n        fn isEmpty(&self)                          -> B;"
  },
  {
    "id": 124,
    "function": "isSingleton",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "157-158",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(1), Span Θ(1)\n        fn isSingleton(&self)                      -> B;"
  },
  {
    "id": 125,
    "function": "subseq_copy",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "159-160",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(1 + lg|a|), Span Θ(1 + lg|a|)\n        fn subseq_copy(&self, start: N, length: N) -> Self;"
  },
  {
    "id": 126,
    "function": "from_vec",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "161-162",
    "spec_strength": "",
    "snippet": "        /// Build balanced tree from values in in-order order.\n        fn from_vec(values: Vec<T>)                -> Self;"
  },
  {
    "id": 127,
    "function": "values_in_order",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "163-164",
    "spec_strength": "",
    "snippet": "        /// Collect in-order values to Vec.\n        fn values_in_order(&self)                  -> Vec<T>;"
  },
  {
    "id": 128,
    "function": "to_arrayseq",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "165",
    "spec_strength": "",
    "snippet": "        fn to_arrayseq(&self)                      -> ArraySeqStPerS<T>;"
  },
  {
    "id": 129,
    "function": "iter",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "166",
    "spec_strength": "",
    "snippet": "        fn iter<'a>(&'a self)                      -> AVLTreeSeqStPerIter<'a, T>;"
  },
  {
    "id": 130,
    "function": "eq",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "223-233",
    "spec_strength": "",
    "snippet": "        fn eq(&self, other: &Self) -> bool {\n            if self.length() != other.length() {\n                return false;\n            }\n            for i in 0..self.length() {\n                if self.nth(i) != other.nth(i) {\n                    return false;\n                }\n            }\n            true\n        }"
  },
  {
    "id": 131,
    "function": "push_left",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "258-263",
    "spec_strength": "",
    "snippet": "        fn push_left(&mut self, mut cur: Option<&'a Node<T>>) {\n            while let Some(n) = cur {\n                self.stack.push(n);\n                cur = n.left.as_deref();\n            }\n        }"
  },
  {
    "id": 132,
    "function": "next",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "268-277",
    "spec_strength": "",
    "snippet": "        fn next(&mut self) -> Option<Self::Item> {\n            if self.current.is_some() {\n                let cur = self.current.take();\n                self.push_left(cur);\n            }\n            let node = self.stack.pop()?;\n            let value_ref: &T = &node.value;\n            self.push_left(node.right.as_deref());\n            Some(value_ref)\n        }"
  },
  {
    "id": 133,
    "function": "lemma_bst_deep",
    "file": "Chap37/BSTAVLMtEph.rs",
    "lines": "39-71",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_bst_deep<T: TotalOrder>(tree: BalBinTree<T>)\n        requires tree_is_bst::<T>(tree),\n        ensures\n            match tree {\n                BalBinTree::Leaf => true,\n                BalBinTree::Node(node) =>\n                    tree_is_bst::<T>(node.left)\n                    && tree_is_bst::<T>(node.right)\n                    && (forall|x: T| #![auto] tree_contains(node.left, x) ==>\n                        T::le(x, node.value) && x != node.value)\n                    && (forall|x: T| #![auto] tree_contains(node.right, x) ==>\n                        T::le(node.value, x) && x != node.value)\n                    && match node.left {\n                        BalBinTree::Leaf => true,\n                        BalBinTree::Node(lnode) =>\n                            tree_is_bst::<T>(lnode.left)\n                            && tree_is_bst::<T>(lnode.right)\n                            && (forall|x: T| #![auto] tree_contains(lnode.left, x) ==>\n                                T::le(x, lnode.value) && x != lnode.value)\n                            && (forall|x: T| #![auto] tree_contains(lnode.right, x) ==>\n                                T::le(lnode.value, x) && x != lnode.value)\n                    }\n                    && match node.right {\n                        BalBinTree::Leaf => true,\n                        BalBinTree::Node(rnode) =>\n                            tree_is_bst::<T>(rnode.left)\n                            && tree_is_bst::<T>(rnode.right)\n                            && (forall|x: T| #![auto] tree_contains(rnode.left, x) ==>\n                                T::le(x, rnode.value) && x != rnode.value)\n                            && (forall|x: T| #![auto] tree_contains(rnode.right, x) ==>\n                                T::le(rnode.value, x) && x != rnode.value)\n                    }\n            }"
  },
  {
    "id": 134,
    "function": "rotate_right",
    "file": "Chap37/BSTAVLMtEph.rs",
    "lines": "86-90",
    "spec_strength": "unknown",
    "snippet": "    fn rotate_right<T: TotalOrder>(tree: BalBinTree<T>) -> (result: BalBinTree<T>)\n        requires tree_is_bst::<T>(tree), !(tree is Leaf),\n        ensures\n            tree_is_bst::<T>(result),\n            forall|x: T| #![auto] tree_contains(result, x) == tree_contains(tree, x),"
  },
  {
    "id": 135,
    "function": "rotate_left",
    "file": "Chap37/BSTAVLMtEph.rs",
    "lines": "152-156",
    "spec_strength": "unknown",
    "snippet": "    fn rotate_left<T: TotalOrder>(tree: BalBinTree<T>) -> (result: BalBinTree<T>)\n        requires tree_is_bst::<T>(tree), !(tree is Leaf),\n        ensures\n            tree_is_bst::<T>(result),\n            forall|x: T| #![auto] tree_contains(result, x) == tree_contains(tree, x),"
  },
  {
    "id": 136,
    "function": "insert_node",
    "file": "Chap37/BSTAVLMtEph.rs",
    "lines": "219-226",
    "spec_strength": "unknown",
    "snippet": "    fn insert_node<T: TotalOrder>(node: BalBinTree<T>, value: T) -> (result: BalBinTree<T>)\n        requires tree_is_bst::<T>(node),\n        ensures\n            tree_is_bst::<T>(result),\n            tree_contains(result, value),\n            forall|x: T| #![auto] tree_contains(result, x) <==>\n                (tree_contains(node, x) || x == value),\n        decreases node.spec_size(),"
  },
  {
    "id": 137,
    "function": "contains_node",
    "file": "Chap37/BSTAVLMtEph.rs",
    "lines": "309-312",
    "spec_strength": "unknown",
    "snippet": "    fn contains_node<T: TotalOrder>(node: &BalBinTree<T>, target: &T) -> (result: bool)\n        requires tree_is_bst::<T>(*node),\n        ensures result == tree_contains(*node, *target),\n        decreases node.spec_size(),"
  },
  {
    "id": 138,
    "function": "find_node",
    "file": "Chap37/BSTAVLMtEph.rs",
    "lines": "334-339",
    "spec_strength": "unknown",
    "snippet": "    fn find_node<'a, T: TotalOrder>(node: &'a BalBinTree<T>, target: &T) -> (result: Option<&'a T>)\n        requires tree_is_bst::<T>(*node),\n        ensures\n            result.is_some() == tree_contains(*node, *target),\n            result.is_some() ==> *result.unwrap() == *target,\n        decreases node.spec_size(),"
  },
  {
    "id": 139,
    "function": "min_node",
    "file": "Chap37/BSTAVLMtEph.rs",
    "lines": "361-362",
    "spec_strength": "",
    "snippet": "    fn min_node<T: TotalOrder>(node: &BalBinTree<T>) -> (result: Option<&T>)\n        decreases node.spec_size(),"
  },
  {
    "id": 140,
    "function": "max_node",
    "file": "Chap37/BSTAVLMtEph.rs",
    "lines": "373-374",
    "spec_strength": "",
    "snippet": "    fn max_node<T: TotalOrder>(node: &BalBinTree<T>) -> (result: Option<&T>)\n        decreases node.spec_size(),"
  },
  {
    "id": 141,
    "function": "new",
    "file": "Chap37/BSTAVLMtEph.rs",
    "lines": "388",
    "spec_strength": "",
    "snippet": "        pub fn new() -> (tree: Self)"
  },
  {
    "id": 142,
    "function": "insert",
    "file": "Chap37/BSTAVLMtEph.rs",
    "lines": "396",
    "spec_strength": "hole",
    "snippet": "        pub fn insert(&self, value: T)"
  },
  {
    "id": 143,
    "function": "contains",
    "file": "Chap37/BSTAVLMtEph.rs",
    "lines": "404",
    "spec_strength": "hole",
    "snippet": "        pub fn contains(&self, target: &T) -> (result: bool)"
  },
  {
    "id": 144,
    "function": "size",
    "file": "Chap37/BSTAVLMtEph.rs",
    "lines": "411",
    "spec_strength": "hole",
    "snippet": "        pub fn size(&self) -> (n: usize)"
  },
  {
    "id": 145,
    "function": "is_empty",
    "file": "Chap37/BSTAVLMtEph.rs",
    "lines": "418",
    "spec_strength": "hole",
    "snippet": "        pub fn is_empty(&self) -> (b: bool)"
  },
  {
    "id": 146,
    "function": "height",
    "file": "Chap37/BSTAVLMtEph.rs",
    "lines": "425",
    "spec_strength": "hole",
    "snippet": "        pub fn height(&self) -> (h: usize)"
  },
  {
    "id": 147,
    "function": "lemma_bst_deep",
    "file": "Chap37/BSTAVLStEph.rs",
    "lines": "54-86",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_bst_deep<T: TotalOrder>(tree: BalBinTree<T>)\n        requires tree_is_bst::<T>(tree),\n        ensures\n            match tree {\n                BalBinTree::Leaf => true,\n                BalBinTree::Node(node) =>\n                    tree_is_bst::<T>(node.left)\n                    && tree_is_bst::<T>(node.right)\n                    && (forall|x: T| #![auto] tree_contains(node.left, x) ==>\n                        T::le(x, node.value) && x != node.value)\n                    && (forall|x: T| #![auto] tree_contains(node.right, x) ==>\n                        T::le(node.value, x) && x != node.value)\n                    && match node.left {\n                        BalBinTree::Leaf => true,\n                        BalBinTree::Node(lnode) =>\n                            tree_is_bst::<T>(lnode.left)\n                            && tree_is_bst::<T>(lnode.right)\n                            && (forall|x: T| #![auto] tree_contains(lnode.left, x) ==>\n                                T::le(x, lnode.value) && x != lnode.value)\n                            && (forall|x: T| #![auto] tree_contains(lnode.right, x) ==>\n                                T::le(lnode.value, x) && x != lnode.value)\n                    }\n                    && match node.right {\n                        BalBinTree::Leaf => true,\n                        BalBinTree::Node(rnode) =>\n                            tree_is_bst::<T>(rnode.left)\n                            && tree_is_bst::<T>(rnode.right)\n                            && (forall|x: T| #![auto] tree_contains(rnode.left, x) ==>\n                                T::le(x, rnode.value) && x != rnode.value)\n                            && (forall|x: T| #![auto] tree_contains(rnode.right, x) ==>\n                                T::le(rnode.value, x) && x != rnode.value)\n                    }\n            }"
  },
  {
    "id": 148,
    "function": "rotate_right",
    "file": "Chap37/BSTAVLStEph.rs",
    "lines": "99-105",
    "spec_strength": "unknown",
    "snippet": "    fn rotate_right<T: TotalOrder>(tree: BalBinTree<T>) -> (result: BalBinTree<T>)\n        requires\n            tree_is_bst::<T>(tree),\n            !(tree is Leaf),\n        ensures\n            tree_is_bst::<T>(result),\n            forall|x: T| #![auto] tree_contains(result, x) == tree_contains(tree, x),"
  },
  {
    "id": 149,
    "function": "rotate_left",
    "file": "Chap37/BSTAVLStEph.rs",
    "lines": "196-202",
    "spec_strength": "unknown",
    "snippet": "    fn rotate_left<T: TotalOrder>(tree: BalBinTree<T>) -> (result: BalBinTree<T>)\n        requires\n            tree_is_bst::<T>(tree),\n            !(tree is Leaf),\n        ensures\n            tree_is_bst::<T>(result),\n            forall|x: T| #![auto] tree_contains(result, x) == tree_contains(tree, x),"
  },
  {
    "id": 150,
    "function": "insert_node",
    "file": "Chap37/BSTAVLStEph.rs",
    "lines": "293-300",
    "spec_strength": "unknown",
    "snippet": "    fn insert_node<T: TotalOrder>(node: BalBinTree<T>, value: T) -> (result: BalBinTree<T>)\n        requires tree_is_bst::<T>(node),\n        ensures\n            tree_is_bst::<T>(result),\n            tree_contains(result, value),\n            forall|x: T| #![auto] tree_contains(result, x) <==>\n                (tree_contains(node, x) || x == value),\n        decreases node.spec_size(),"
  },
  {
    "id": 151,
    "function": "contains_node",
    "file": "Chap37/BSTAVLStEph.rs",
    "lines": "422-425",
    "spec_strength": "unknown",
    "snippet": "    fn contains_node<T: TotalOrder>(node: &BalBinTree<T>, target: &T) -> (result: bool)\n        requires tree_is_bst::<T>(*node),\n        ensures result == tree_contains(*node, *target),\n        decreases node.spec_size(),"
  },
  {
    "id": 152,
    "function": "find_node",
    "file": "Chap37/BSTAVLStEph.rs",
    "lines": "455-460",
    "spec_strength": "unknown",
    "snippet": "    fn find_node<'a, T: TotalOrder>(node: &'a BalBinTree<T>, target: &T) -> (result: Option<&'a T>)\n        requires tree_is_bst::<T>(*node),\n        ensures\n            result.is_some() == tree_contains(*node, *target),\n            result.is_some() ==> *result.unwrap() == *target,\n        decreases node.spec_size(),"
  },
  {
    "id": 153,
    "function": "min_node",
    "file": "Chap37/BSTAVLStEph.rs",
    "lines": "490-491",
    "spec_strength": "",
    "snippet": "    fn min_node<T: TotalOrder>(node: &BalBinTree<T>) -> (result: Option<&T>)\n        decreases node.spec_size(),"
  },
  {
    "id": 154,
    "function": "max_node",
    "file": "Chap37/BSTAVLStEph.rs",
    "lines": "505-506",
    "spec_strength": "",
    "snippet": "    fn max_node<T: TotalOrder>(node: &BalBinTree<T>) -> (result: Option<&T>)\n        decreases node.spec_size(),"
  },
  {
    "id": 155,
    "function": "avl_new",
    "file": "Chap37/BSTAVLStEph.rs",
    "lines": "520-523",
    "spec_strength": "unknown",
    "snippet": "    pub fn avl_new<T: TotalOrder>() -> (tree: BSTAVLStEph<T>)\n        ensures\n            tree_is_avl::<T>(tree.root),\n            forall|x: T| !tree_contains(tree.root, x),"
  },
  {
    "id": 156,
    "function": "avl_size",
    "file": "Chap37/BSTAVLStEph.rs",
    "lines": "528-530",
    "spec_strength": "unknown",
    "snippet": "    pub fn avl_size<T: TotalOrder>(tree: &BSTAVLStEph<T>) -> (n: usize)\n        requires tree.root.spec_size() <= usize::MAX,\n        ensures n == tree.root.spec_size(),"
  },
  {
    "id": 157,
    "function": "avl_is_empty",
    "file": "Chap37/BSTAVLStEph.rs",
    "lines": "535-536",
    "spec_strength": "unknown",
    "snippet": "    pub fn avl_is_empty<T: TotalOrder>(tree: &BSTAVLStEph<T>) -> (b: bool)\n        ensures b == (tree.root.spec_size() == 0),"
  },
  {
    "id": 158,
    "function": "avl_height",
    "file": "Chap37/BSTAVLStEph.rs",
    "lines": "541-543",
    "spec_strength": "unknown",
    "snippet": "    pub fn avl_height<T: TotalOrder>(tree: &BSTAVLStEph<T>) -> (h: usize)\n        requires tree.root.spec_height() <= usize::MAX,\n        ensures h == tree.root.spec_height(),"
  },
  {
    "id": 159,
    "function": "avl_insert",
    "file": "Chap37/BSTAVLStEph.rs",
    "lines": "548-554",
    "spec_strength": "unknown",
    "snippet": "    pub fn avl_insert<T: TotalOrder>(tree: BSTAVLStEph<T>, value: T) -> (result: BSTAVLStEph<T>)\n        requires tree_is_bst::<T>(tree.root),\n        ensures\n            tree_is_bst::<T>(result.root),\n            tree_contains(result.root, value),\n            forall|x: T| #![auto] tree_contains(result.root, x) <==>\n                (tree_contains(tree.root, x) || x == value),"
  },
  {
    "id": 160,
    "function": "avl_contains",
    "file": "Chap37/BSTAVLStEph.rs",
    "lines": "559-561",
    "spec_strength": "unknown",
    "snippet": "    pub fn avl_contains<T: TotalOrder>(tree: &BSTAVLStEph<T>, target: &T) -> (result: bool)\n        requires tree_is_bst::<T>(tree.root),\n        ensures result == tree_contains(tree.root, *target),"
  },
  {
    "id": 161,
    "function": "avl_find",
    "file": "Chap37/BSTAVLStEph.rs",
    "lines": "566-570",
    "spec_strength": "unknown",
    "snippet": "    pub fn avl_find<'a, T: TotalOrder>(tree: &'a BSTAVLStEph<T>, target: &T) -> (result: Option<&'a T>)\n        requires tree_is_bst::<T>(tree.root),\n        ensures\n            result.is_some() == tree_contains(tree.root, *target),\n            result.is_some() ==> *result.unwrap() == *target,"
  },
  {
    "id": 162,
    "function": "insert_node",
    "file": "Chap37/BSTBBAlphaMtEph.rs",
    "lines": "44-51",
    "spec_strength": "unknown",
    "snippet": "    fn insert_node<T: TotalOrder>(node: BalBinTree<T>, value: T) -> (result: BalBinTree<T>)\n        requires tree_is_bst::<T>(node),\n        ensures\n            tree_is_bst::<T>(result),\n            tree_contains(result, value),\n            forall|x: T| #![auto] tree_contains(result, x) <==>\n                (tree_contains(node, x) || x == value),\n        decreases node.spec_size(),"
  },
  {
    "id": 163,
    "function": "contains_node",
    "file": "Chap37/BSTBBAlphaMtEph.rs",
    "lines": "134-137",
    "spec_strength": "unknown",
    "snippet": "    fn contains_node<T: TotalOrder>(node: &BalBinTree<T>, target: &T) -> (result: bool)\n        requires tree_is_bst::<T>(*node),\n        ensures result == tree_contains(*node, *target),\n        decreases node.spec_size(),"
  },
  {
    "id": 164,
    "function": "find_node",
    "file": "Chap37/BSTBBAlphaMtEph.rs",
    "lines": "159-164",
    "spec_strength": "unknown",
    "snippet": "    fn find_node<'a, T: TotalOrder>(node: &'a BalBinTree<T>, target: &T) -> (result: Option<&'a T>)\n        requires tree_is_bst::<T>(*node),\n        ensures\n            result.is_some() == tree_contains(*node, *target),\n            result.is_some() ==> *result.unwrap() == *target,\n        decreases node.spec_size(),"
  },
  {
    "id": 165,
    "function": "min_node",
    "file": "Chap37/BSTBBAlphaMtEph.rs",
    "lines": "186-187",
    "spec_strength": "",
    "snippet": "    fn min_node<T: TotalOrder>(node: &BalBinTree<T>) -> (result: Option<&T>)\n        decreases node.spec_size(),"
  },
  {
    "id": 166,
    "function": "max_node",
    "file": "Chap37/BSTBBAlphaMtEph.rs",
    "lines": "198-199",
    "spec_strength": "",
    "snippet": "    fn max_node<T: TotalOrder>(node: &BalBinTree<T>) -> (result: Option<&T>)\n        decreases node.spec_size(),"
  },
  {
    "id": 167,
    "function": "new",
    "file": "Chap37/BSTBBAlphaMtEph.rs",
    "lines": "213",
    "spec_strength": "",
    "snippet": "        pub fn new() -> (tree: Self)"
  },
  {
    "id": 168,
    "function": "insert",
    "file": "Chap37/BSTBBAlphaMtEph.rs",
    "lines": "221",
    "spec_strength": "hole",
    "snippet": "        pub fn insert(&self, value: T)"
  },
  {
    "id": 169,
    "function": "contains",
    "file": "Chap37/BSTBBAlphaMtEph.rs",
    "lines": "229",
    "spec_strength": "hole",
    "snippet": "        pub fn contains(&self, target: &T) -> (result: bool)"
  },
  {
    "id": 170,
    "function": "size",
    "file": "Chap37/BSTBBAlphaMtEph.rs",
    "lines": "236",
    "spec_strength": "hole",
    "snippet": "        pub fn size(&self) -> (n: usize)"
  },
  {
    "id": 171,
    "function": "is_empty",
    "file": "Chap37/BSTBBAlphaMtEph.rs",
    "lines": "243",
    "spec_strength": "hole",
    "snippet": "        pub fn is_empty(&self) -> (b: bool)"
  },
  {
    "id": 172,
    "function": "height",
    "file": "Chap37/BSTBBAlphaMtEph.rs",
    "lines": "250",
    "spec_strength": "hole",
    "snippet": "        pub fn height(&self) -> (h: usize)"
  },
  {
    "id": 173,
    "function": "insert_node",
    "file": "Chap37/BSTBBAlphaStEph.rs",
    "lines": "58-65",
    "spec_strength": "unknown",
    "snippet": "    fn insert_node<T: TotalOrder>(node: BalBinTree<T>, value: T) -> (result: BalBinTree<T>)\n        requires tree_is_bst::<T>(node),\n        ensures\n            tree_is_bst::<T>(result),\n            tree_contains(result, value),\n            forall|x: T| #![auto] tree_contains(result, x) <==>\n                (tree_contains(node, x) || x == value),\n        decreases node.spec_size(),"
  },
  {
    "id": 174,
    "function": "contains_node",
    "file": "Chap37/BSTBBAlphaStEph.rs",
    "lines": "187-190",
    "spec_strength": "unknown",
    "snippet": "    fn contains_node<T: TotalOrder>(node: &BalBinTree<T>, target: &T) -> (result: bool)\n        requires tree_is_bst::<T>(*node),\n        ensures result == tree_contains(*node, *target),\n        decreases node.spec_size(),"
  },
  {
    "id": 175,
    "function": "find_node",
    "file": "Chap37/BSTBBAlphaStEph.rs",
    "lines": "220-225",
    "spec_strength": "unknown",
    "snippet": "    fn find_node<'a, T: TotalOrder>(node: &'a BalBinTree<T>, target: &T) -> (result: Option<&'a T>)\n        requires tree_is_bst::<T>(*node),\n        ensures\n            result.is_some() == tree_contains(*node, *target),\n            result.is_some() ==> *result.unwrap() == *target,\n        decreases node.spec_size(),"
  },
  {
    "id": 176,
    "function": "min_node",
    "file": "Chap37/BSTBBAlphaStEph.rs",
    "lines": "255-256",
    "spec_strength": "",
    "snippet": "    fn min_node<T: TotalOrder>(node: &BalBinTree<T>) -> (result: Option<&T>)\n        decreases node.spec_size(),"
  },
  {
    "id": 177,
    "function": "max_node",
    "file": "Chap37/BSTBBAlphaStEph.rs",
    "lines": "270-271",
    "spec_strength": "",
    "snippet": "    fn max_node<T: TotalOrder>(node: &BalBinTree<T>) -> (result: Option<&T>)\n        decreases node.spec_size(),"
  },
  {
    "id": 178,
    "function": "bb_new",
    "file": "Chap37/BSTBBAlphaStEph.rs",
    "lines": "285-288",
    "spec_strength": "unknown",
    "snippet": "    pub fn bb_new<T: TotalOrder>() -> (tree: BSTBBAlphaStEph<T>)\n        ensures\n            tree_is_bst::<T>(tree.root),\n            forall|x: T| !tree_contains(tree.root, x),"
  },
  {
    "id": 179,
    "function": "bb_size",
    "file": "Chap37/BSTBBAlphaStEph.rs",
    "lines": "293-295",
    "spec_strength": "unknown",
    "snippet": "    pub fn bb_size<T: TotalOrder>(tree: &BSTBBAlphaStEph<T>) -> (n: usize)\n        requires tree.root.spec_size() <= usize::MAX,\n        ensures n == tree.root.spec_size(),"
  },
  {
    "id": 180,
    "function": "bb_is_empty",
    "file": "Chap37/BSTBBAlphaStEph.rs",
    "lines": "300-301",
    "spec_strength": "unknown",
    "snippet": "    pub fn bb_is_empty<T: TotalOrder>(tree: &BSTBBAlphaStEph<T>) -> (b: bool)\n        ensures b == (tree.root.spec_size() == 0),"
  },
  {
    "id": 181,
    "function": "bb_height",
    "file": "Chap37/BSTBBAlphaStEph.rs",
    "lines": "306-308",
    "spec_strength": "unknown",
    "snippet": "    pub fn bb_height<T: TotalOrder>(tree: &BSTBBAlphaStEph<T>) -> (h: usize)\n        requires tree.root.spec_height() <= usize::MAX,\n        ensures h == tree.root.spec_height(),"
  },
  {
    "id": 182,
    "function": "bb_insert",
    "file": "Chap37/BSTBBAlphaStEph.rs",
    "lines": "313-319",
    "spec_strength": "unknown",
    "snippet": "    pub fn bb_insert<T: TotalOrder>(tree: BSTBBAlphaStEph<T>, value: T) -> (result: BSTBBAlphaStEph<T>)\n        requires tree_is_bst::<T>(tree.root),\n        ensures\n            tree_is_bst::<T>(result.root),\n            tree_contains(result.root, value),\n            forall|x: T| #![auto] tree_contains(result.root, x) <==>\n                (tree_contains(tree.root, x) || x == value),"
  },
  {
    "id": 183,
    "function": "bb_contains",
    "file": "Chap37/BSTBBAlphaStEph.rs",
    "lines": "324-326",
    "spec_strength": "unknown",
    "snippet": "    pub fn bb_contains<T: TotalOrder>(tree: &BSTBBAlphaStEph<T>, target: &T) -> (result: bool)\n        requires tree_is_bst::<T>(tree.root),\n        ensures result == tree_contains(tree.root, *target),"
  },
  {
    "id": 184,
    "function": "bb_find",
    "file": "Chap37/BSTBBAlphaStEph.rs",
    "lines": "331-335",
    "spec_strength": "unknown",
    "snippet": "    pub fn bb_find<'a, T: TotalOrder>(tree: &'a BSTBBAlphaStEph<T>, target: &T) -> (result: Option<&'a T>)\n        requires tree_is_bst::<T>(tree.root),\n        ensures\n            result.is_some() == tree_contains(tree.root, *target),\n            result.is_some() ==> *result.unwrap() == *target,"
  },
  {
    "id": 185,
    "function": "insert_node",
    "file": "Chap37/BSTPlainMtEph.rs",
    "lines": "55-62",
    "spec_strength": "unknown",
    "snippet": "    fn insert_node<T: TotalOrder>(node: BalBinTree<T>, value: T) -> (result: BalBinTree<T>)\n        requires tree_is_bst::<T>(node),\n        ensures\n            tree_is_bst::<T>(result),\n            tree_contains(result, value),\n            forall|x: T| #![auto] tree_contains(result, x) <==>\n                (tree_contains(node, x) || x == value),\n        decreases node.spec_size(),"
  },
  {
    "id": 186,
    "function": "contains_node",
    "file": "Chap37/BSTPlainMtEph.rs",
    "lines": "145-148",
    "spec_strength": "unknown",
    "snippet": "    fn contains_node<T: TotalOrder>(node: &BalBinTree<T>, target: &T) -> (result: bool)\n        requires tree_is_bst::<T>(*node),\n        ensures result == tree_contains(*node, *target),\n        decreases node.spec_size(),"
  },
  {
    "id": 187,
    "function": "find_node",
    "file": "Chap37/BSTPlainMtEph.rs",
    "lines": "170-175",
    "spec_strength": "unknown",
    "snippet": "    fn find_node<'a, T: TotalOrder>(node: &'a BalBinTree<T>, target: &T) -> (result: Option<&'a T>)\n        requires tree_is_bst::<T>(*node),\n        ensures\n            result.is_some() == tree_contains(*node, *target),\n            result.is_some() ==> *result.unwrap() == *target,\n        decreases node.spec_size(),"
  },
  {
    "id": 188,
    "function": "min_node",
    "file": "Chap37/BSTPlainMtEph.rs",
    "lines": "197-198",
    "spec_strength": "",
    "snippet": "    fn min_node<T: TotalOrder>(node: &BalBinTree<T>) -> (result: Option<&T>)\n        decreases node.spec_size(),"
  },
  {
    "id": 189,
    "function": "max_node",
    "file": "Chap37/BSTPlainMtEph.rs",
    "lines": "209-210",
    "spec_strength": "",
    "snippet": "    fn max_node<T: TotalOrder>(node: &BalBinTree<T>) -> (result: Option<&T>)\n        decreases node.spec_size(),"
  },
  {
    "id": 190,
    "function": "new",
    "file": "Chap37/BSTPlainMtEph.rs",
    "lines": "224",
    "spec_strength": "",
    "snippet": "        pub fn new() -> (tree: Self)"
  },
  {
    "id": 191,
    "function": "insert",
    "file": "Chap37/BSTPlainMtEph.rs",
    "lines": "234",
    "spec_strength": "",
    "snippet": "        pub fn insert(&self, value: T)"
  },
  {
    "id": 192,
    "function": "contains",
    "file": "Chap37/BSTPlainMtEph.rs",
    "lines": "241",
    "spec_strength": "",
    "snippet": "        pub fn contains(&self, target: &T) -> (result: bool)"
  },
  {
    "id": 193,
    "function": "is_empty",
    "file": "Chap37/BSTPlainMtEph.rs",
    "lines": "250",
    "spec_strength": "",
    "snippet": "        pub fn is_empty(&self) -> (b: bool)"
  },
  {
    "id": 194,
    "function": "size",
    "file": "Chap37/BSTPlainMtEph.rs",
    "lines": "259",
    "spec_strength": "hole",
    "snippet": "        pub fn size(&self) -> (n: usize)"
  },
  {
    "id": 195,
    "function": "height",
    "file": "Chap37/BSTPlainMtEph.rs",
    "lines": "269",
    "spec_strength": "hole",
    "snippet": "        pub fn height(&self) -> (h: usize)"
  },
  {
    "id": 196,
    "function": "insert_node",
    "file": "Chap37/BSTPlainStEph.rs",
    "lines": "63-70",
    "spec_strength": "unknown",
    "snippet": "    fn insert_node<T: TotalOrder>(node: BalBinTree<T>, value: T) -> (result: BalBinTree<T>)\n        requires tree_is_bst::<T>(node),\n        ensures\n            tree_is_bst::<T>(result),\n            tree_contains(result, value),\n            forall|x: T| #![auto] tree_contains(result, x) <==>\n                (tree_contains(node, x) || x == value),\n        decreases node.spec_size(),"
  },
  {
    "id": 197,
    "function": "contains_node",
    "file": "Chap37/BSTPlainStEph.rs",
    "lines": "192-195",
    "spec_strength": "unknown",
    "snippet": "    fn contains_node<T: TotalOrder>(node: &BalBinTree<T>, target: &T) -> (result: bool)\n        requires tree_is_bst::<T>(*node),\n        ensures result == tree_contains(*node, *target),\n        decreases node.spec_size(),"
  },
  {
    "id": 198,
    "function": "find_node",
    "file": "Chap37/BSTPlainStEph.rs",
    "lines": "225-230",
    "spec_strength": "unknown",
    "snippet": "    fn find_node<'a, T: TotalOrder>(node: &'a BalBinTree<T>, target: &T) -> (result: Option<&'a T>)\n        requires tree_is_bst::<T>(*node),\n        ensures\n            result.is_some() == tree_contains(*node, *target),\n            result.is_some() ==> *result.unwrap() == *target,\n        decreases node.spec_size(),"
  },
  {
    "id": 199,
    "function": "min_node",
    "file": "Chap37/BSTPlainStEph.rs",
    "lines": "260-261",
    "spec_strength": "",
    "snippet": "    fn min_node<T: TotalOrder>(node: &BalBinTree<T>) -> (result: Option<&T>)\n        decreases node.spec_size(),"
  },
  {
    "id": 200,
    "function": "max_node",
    "file": "Chap37/BSTPlainStEph.rs",
    "lines": "275-276",
    "spec_strength": "",
    "snippet": "    fn max_node<T: TotalOrder>(node: &BalBinTree<T>) -> (result: Option<&T>)\n        decreases node.spec_size(),"
  },
  {
    "id": 201,
    "function": "bst_new",
    "file": "Chap37/BSTPlainStEph.rs",
    "lines": "290-293",
    "spec_strength": "unknown",
    "snippet": "    pub fn bst_new<T: TotalOrder>() -> (tree: BSTPlainStEph<T>)\n        ensures\n            tree_is_bst::<T>(tree.root),\n            forall|x: T| !tree_contains(tree.root, x),"
  },
  {
    "id": 202,
    "function": "bst_size",
    "file": "Chap37/BSTPlainStEph.rs",
    "lines": "298-300",
    "spec_strength": "unknown",
    "snippet": "    pub fn bst_size<T: TotalOrder>(tree: &BSTPlainStEph<T>) -> (n: usize)\n        requires tree.root.spec_size() <= usize::MAX,\n        ensures n == tree.root.spec_size(),"
  },
  {
    "id": 203,
    "function": "bst_is_empty",
    "file": "Chap37/BSTPlainStEph.rs",
    "lines": "305-306",
    "spec_strength": "unknown",
    "snippet": "    pub fn bst_is_empty<T: TotalOrder>(tree: &BSTPlainStEph<T>) -> (b: bool)\n        ensures b == (tree.root.spec_size() == 0),"
  },
  {
    "id": 204,
    "function": "bst_height",
    "file": "Chap37/BSTPlainStEph.rs",
    "lines": "311-313",
    "spec_strength": "unknown",
    "snippet": "    pub fn bst_height<T: TotalOrder>(tree: &BSTPlainStEph<T>) -> (h: usize)\n        requires tree.root.spec_height() <= usize::MAX,\n        ensures h == tree.root.spec_height(),"
  },
  {
    "id": 205,
    "function": "bst_insert",
    "file": "Chap37/BSTPlainStEph.rs",
    "lines": "318-324",
    "spec_strength": "unknown",
    "snippet": "    pub fn bst_insert<T: TotalOrder>(tree: BSTPlainStEph<T>, value: T) -> (result: BSTPlainStEph<T>)\n        requires tree_is_bst::<T>(tree.root),\n        ensures\n            tree_is_bst::<T>(result.root),\n            tree_contains(result.root, value),\n            forall|x: T| #![auto] tree_contains(result.root, x) <==>\n                (tree_contains(tree.root, x) || x == value),"
  },
  {
    "id": 206,
    "function": "bst_contains",
    "file": "Chap37/BSTPlainStEph.rs",
    "lines": "329-331",
    "spec_strength": "unknown",
    "snippet": "    pub fn bst_contains<T: TotalOrder>(tree: &BSTPlainStEph<T>, target: &T) -> (result: bool)\n        requires tree_is_bst::<T>(tree.root),\n        ensures result == tree_contains(tree.root, *target),"
  },
  {
    "id": 207,
    "function": "bst_find",
    "file": "Chap37/BSTPlainStEph.rs",
    "lines": "336-340",
    "spec_strength": "unknown",
    "snippet": "    pub fn bst_find<'a, T: TotalOrder>(tree: &'a BSTPlainStEph<T>, target: &T) -> (result: Option<&'a T>)\n        requires tree_is_bst::<T>(tree.root),\n        ensures\n            result.is_some() == tree_contains(tree.root, *target),\n            result.is_some() ==> *result.unwrap() == *target,"
  },
  {
    "id": 208,
    "function": "new_node",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "29-37",
    "spec_strength": "",
    "snippet": "    fn new_node<T: StTInMtT + Ord>(key: T) -> Node<T> {\n        Node {\n            key,\n            color: Color::Red,\n            size: 1,\n            left: None,\n            right: None,\n        }\n    }"
  },
  {
    "id": 209,
    "function": "is_red",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "39",
    "spec_strength": "",
    "snippet": "    fn is_red<T: StTInMtT + Ord>(link: &Link<T>) -> bool { matches!(link, Some(node) if node.color == Color::Red) }"
  },
  {
    "id": 210,
    "function": "size_link",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "41",
    "spec_strength": "",
    "snippet": "    fn size_link<T: StTInMtT + Ord>(link: &Link<T>) -> N { link.as_ref().map_or(0, |n| n.size) }"
  },
  {
    "id": 211,
    "function": "update",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "43",
    "spec_strength": "",
    "snippet": "    fn update<T: StTInMtT + Ord>(node: &mut Node<T>) { node.size = 1 + size_link(&node.left) + size_link(&node.right); }"
  },
  {
    "id": 212,
    "function": "rotate_left",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "45-62",
    "spec_strength": "",
    "snippet": "    fn rotate_left<T: StTInMtT + Ord>(link: &mut Link<T>) {\n        if let Some(mut h) = link.take() {\n            if let Some(mut x) = h.right.take() {\n                h.right = x.left.take();\n                update(&mut h);\n                x.color = h.color;\n                h.color = Color::Red;\n                x.left = Some(h);\n                if let Some(left) = x.left.as_mut() {\n                    update(left);\n                }\n                update(&mut x);\n                *link = Some(x);\n            } else {\n                *link = Some(h);\n            }\n        }\n    }"
  },
  {
    "id": 213,
    "function": "rotate_right",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "64-81",
    "spec_strength": "",
    "snippet": "    fn rotate_right<T: StTInMtT + Ord>(link: &mut Link<T>) {\n        if let Some(mut h) = link.take() {\n            if let Some(mut x) = h.left.take() {\n                h.left = x.right.take();\n                update(&mut h);\n                x.color = h.color;\n                h.color = Color::Red;\n                x.right = Some(h);\n                if let Some(right) = x.right.as_mut() {\n                    update(right);\n                }\n                update(&mut x);\n                *link = Some(x);\n            } else {\n                *link = Some(h);\n            }\n        }\n    }"
  },
  {
    "id": 214,
    "function": "flip_colors",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "83-102",
    "spec_strength": "",
    "snippet": "    fn flip_colors<T: StTInMtT + Ord>(link: &mut Link<T>) {\n        if let Some(node) = link.as_mut() {\n            node.color = match node.color {\n                | Color::Red => Color::Black,\n                | Color::Black => Color::Red,\n            };\n            if let Some(left) = node.left.as_mut() {\n                left.color = match left.color {\n                    | Color::Red => Color::Black,\n                    | Color::Black => Color::Red,\n                };\n            }\n            if let Some(right) = node.right.as_mut() {\n                right.color = match right.color {\n                    | Color::Red => Color::Black,\n                    | Color::Black => Color::Red,\n                };\n            }\n        }\n    }"
  },
  {
    "id": 215,
    "function": "fix_up",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "104-138",
    "spec_strength": "",
    "snippet": "    fn fix_up<T: StTInMtT + Ord>(link: &mut Link<T>) {\n        let rotate_left_needed = match link {\n            | Some(node) => is_red(&node.right) && !is_red(&node.left),\n            | None => false,\n        };\n        if rotate_left_needed {\n            rotate_left(link);\n        }\n\n        let rotate_right_needed = match link {\n            | Some(node) => {\n                if let Some(left) = node.left.as_ref() {\n                    is_red(&node.left) && is_red(&left.left)\n                } else {\n                    false\n                }\n            }\n            | None => false,\n        };\n        if rotate_right_needed {\n            rotate_right(link);\n        }\n\n        let flip_needed = match link {\n            | Some(node) => is_red(&node.left) && is_red(&node.right),\n            | None => false,\n        };\n        if flip_needed {\n            flip_colors(link);\n        }\n\n        if let Some(node) = link.as_mut() {\n            update(node);\n        }\n    }"
  },
  {
    "id": 216,
    "function": "insert_link",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "140-154",
    "spec_strength": "",
    "snippet": "    fn insert_link<T: StTInMtT + Ord>(link: &mut Link<T>, value: T) {\n        if let Some(node) = link.as_mut() {\n            if value < node.key {\n                insert_link(&mut node.left, value);\n            } else if value > node.key {\n                insert_link(&mut node.right, value);\n            } else {\n                return;\n            }\n        } else {\n            *link = Some(Box::new(new_node(value)));\n            return;\n        }\n        fix_up(link);\n    }"
  },
  {
    "id": 217,
    "function": "find_link",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "156-169",
    "spec_strength": "",
    "snippet": "    fn find_link<'a, T: StTInMtT + Ord>(link: &'a Link<T>, target: &T) -> Option<&'a T> {\n        match link {\n            | None => None,\n            | Some(node) => {\n                if target == &node.key {\n                    Some(&node.key)\n                } else if target < &node.key {\n                    find_link(&node.left, target)\n                } else {\n                    find_link(&node.right, target)\n                }\n            }\n        }\n    }"
  },
  {
    "id": 218,
    "function": "min_link",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "171-179",
    "spec_strength": "",
    "snippet": "    fn min_link<T: StTInMtT + Ord>(link: &Link<T>) -> Option<&T> {\n        match link {\n            | None => None,\n            | Some(node) => match node.left {\n                | None => Some(&node.key),\n                | Some(_) => min_link(&node.left),\n            },\n        }\n    }"
  },
  {
    "id": 219,
    "function": "max_link",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "181-189",
    "spec_strength": "",
    "snippet": "    fn max_link<T: StTInMtT + Ord>(link: &Link<T>) -> Option<&T> {\n        match link {\n            | None => None,\n            | Some(node) => match node.right {\n                | None => Some(&node.key),\n                | Some(_) => max_link(&node.right),\n            },\n        }\n    }"
  },
  {
    "id": 220,
    "function": "in_order_collect",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "191-197",
    "spec_strength": "",
    "snippet": "    fn in_order_collect<T: StTInMtT + Ord>(link: &Link<T>, out: &mut Vec<T>) {\n        if let Some(node) = link {\n            in_order_collect(&node.left, out);\n            out.push(node.key.clone());\n            in_order_collect(&node.right, out);\n        }\n    }"
  },
  {
    "id": 221,
    "function": "pre_order_collect",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "199-205",
    "spec_strength": "",
    "snippet": "    fn pre_order_collect<T: StTInMtT + Ord>(link: &Link<T>, out: &mut Vec<T>) {\n        if let Some(node) = link {\n            out.push(node.key.clone());\n            pre_order_collect(&node.left, out);\n            pre_order_collect(&node.right, out);\n        }\n    }"
  },
  {
    "id": 222,
    "function": "in_order_parallel",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "209-224",
    "spec_strength": "",
    "snippet": "    fn in_order_parallel<T: StTInMtT + Ord>(link: &Link<T>) -> Vec<T> {\n        match link {\n            | None => Vec::new(),\n            | Some(node) => {\n                use crate::Types::Types::Pair;\n                let Pair(left_vec, right_vec) = crate::ParaPair!(\n                    move || in_order_parallel(&node.left),\n                    move || in_order_parallel(&node.right)\n                );\n                let mut result = left_vec;\n                result.push(node.key.clone());\n                result.extend(right_vec);\n                result\n            }\n        }\n    }"
  },
  {
    "id": 223,
    "function": "pre_order_parallel",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "226-241",
    "spec_strength": "",
    "snippet": "    fn pre_order_parallel<T: StTInMtT + Ord>(link: &Link<T>) -> Vec<T> {\n        match link {\n            | None => Vec::new(),\n            | Some(node) => {\n                use crate::Types::Types::Pair;\n                let Pair(left_vec, right_vec) = crate::ParaPair!(\n                    move || pre_order_parallel(&node.left),\n                    move || pre_order_parallel(&node.right)\n                );\n                let mut result = vec![node.key.clone()];\n                result.extend(left_vec);\n                result.extend(right_vec);\n                result\n            }\n        }\n    }"
  },
  {
    "id": 224,
    "function": "build_balanced",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "243-263",
    "spec_strength": "",
    "snippet": "    // Parallel construction from sorted slice\n    fn build_balanced<T: StTInMtT + Ord>(values: &[T]) -> Link<T> {\n        if values.is_empty() {\n            return None;\n        }\n        let mid = values.len() / 2;\n        \n        // Parallel construction of left and right subtrees\n        use crate::Types::Types::Pair;\n        let Pair(left, right) = crate::ParaPair!(\n            move || build_balanced(&values[..mid]),\n            move || build_balanced(&values[mid + 1..])\n        );\n        \n        let mut node = Box::new(new_node(values[mid].clone()));\n        node.left = left;\n        node.right = right;\n        node.color = Color::Black; // Root and internal nodes are black in balanced construction\n        update(&mut node);\n        Some(node)\n    }"
  },
  {
    "id": 225,
    "function": "filter_parallel",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "265-290",
    "spec_strength": "",
    "snippet": "    // Parallel filter\n    fn filter_parallel<T: StTInMtT + Ord, F>(link: &Link<T>, predicate: &std::sync::Arc<F>) -> Vec<T>\n    where\n        F: Fn(&T) -> bool + Send + Sync,\n    {\n        match link {\n            | None => Vec::new(),\n            | Some(node) => {\n                let pred_left = std::sync::Arc::clone(predicate);\n                let pred_right = std::sync::Arc::clone(predicate);\n                \n                use crate::Types::Types::Pair;\n                let Pair(left_vals, right_vals) = crate::ParaPair!(\n                    move || filter_parallel(&node.left, &pred_left),\n                    move || filter_parallel(&node.right, &pred_right)\n                );\n                \n                let mut result = left_vals;\n                if predicate(&node.key) {\n                    result.push(node.key.clone());\n                }\n                result.extend(right_vals);\n                result\n            }\n        }\n    }"
  },
  {
    "id": 226,
    "function": "reduce_parallel",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "292-314",
    "spec_strength": "",
    "snippet": "    // Parallel reduce\n    fn reduce_parallel<T: StTInMtT + Ord, F>(link: &Link<T>, op: &std::sync::Arc<F>, identity: T) -> T\n    where\n        F: Fn(T, T) -> T + Send + Sync,\n    {\n        match link {\n            | None => identity,\n            | Some(node) => {\n                let op_left = std::sync::Arc::clone(op);\n                let op_right = std::sync::Arc::clone(op);\n                let id_left = identity.clone();\n                \n                use crate::Types::Types::Pair;\n                let Pair(left_acc, right_acc) = crate::ParaPair!(\n                    move || reduce_parallel(&node.left, &op_left, id_left),\n                    move || reduce_parallel(&node.right, &op_right, identity)\n                );\n                \n                let with_key = op(left_acc, node.key.clone());\n                op(with_key, right_acc)\n            }\n        }\n    }"
  },
  {
    "id": 227,
    "function": "new",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "324-325",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn new()                       -> Self;"
  },
  {
    "id": 228,
    "function": "from_sorted_slice",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "326-327",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(log n) - Parallel construction from sorted slice\n        fn from_sorted_slice(values: &[T]) -> Self;"
  },
  {
    "id": 229,
    "function": "insert",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "328-329",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n) with locking\n        fn insert(&self, value: T);"
  },
  {
    "id": 230,
    "function": "find",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "330-331",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n) with locking\n        fn find(&self, target: &T)     -> Option<T>;"
  },
  {
    "id": 231,
    "function": "contains",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "332",
    "spec_strength": "",
    "snippet": "        fn contains(&self, target: &T) -> B;"
  },
  {
    "id": 232,
    "function": "size",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "333",
    "spec_strength": "",
    "snippet": "        fn size(&self)                 -> N;"
  },
  {
    "id": 233,
    "function": "is_empty",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "334",
    "spec_strength": "",
    "snippet": "        fn is_empty(&self)             -> B;"
  },
  {
    "id": 234,
    "function": "height",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "335",
    "spec_strength": "",
    "snippet": "        fn height(&self)               -> N;"
  },
  {
    "id": 235,
    "function": "minimum",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "336",
    "spec_strength": "",
    "snippet": "        fn minimum(&self)              -> Option<T>;"
  },
  {
    "id": 236,
    "function": "maximum",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "337",
    "spec_strength": "",
    "snippet": "        fn maximum(&self)              -> Option<T>;"
  },
  {
    "id": 237,
    "function": "in_order",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "338-339",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(log n) - Parallel traversal\n        fn in_order(&self)             -> ArraySeqStPerS<T>;"
  },
  {
    "id": 238,
    "function": "pre_order",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "340-341",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(log n) - Parallel traversal\n        fn pre_order(&self)            -> ArraySeqStPerS<T>;"
  },
  {
    "id": 239,
    "function": "filter",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "342-345",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(log n) - Parallel filter\n        fn filter<F>(&self, predicate: F) -> ArraySeqStPerS<T>\n        where\n            F: Fn(&T) -> bool + Send + Sync;"
  },
  {
    "id": 240,
    "function": "reduce",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "346-349",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(log n) - Parallel reduce\n        fn reduce<F>(&self, op: F, identity: T) -> T\n        where\n            F: Fn(T, T) -> T + Send + Sync;"
  },
  {
    "id": 241,
    "function": "height_rec",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "382-387",
    "spec_strength": "",
    "snippet": "            fn height_rec<T: StTInMtT + Ord>(link: &Link<T>) -> N {\n                match link {\n                    | None => 0,\n                    | Some(node) => 1 + height_rec(&node.left).max(height_rec(&node.right)),\n                }\n            }"
  },
  {
    "id": 242,
    "function": "default",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "441",
    "spec_strength": "",
    "snippet": "        fn default() -> Self { Self::new() }"
  },
  {
    "id": 243,
    "function": "lemma_bst_deep",
    "file": "Chap37/BSTRBStEph.rs",
    "lines": "38-70",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_bst_deep<T: TotalOrder>(tree: BalBinTree<T>)\n        requires tree_is_bst::<T>(tree),\n        ensures\n            match tree {\n                BalBinTree::Leaf => true,\n                BalBinTree::Node(node) =>\n                    tree_is_bst::<T>(node.left)\n                    && tree_is_bst::<T>(node.right)\n                    && (forall|x: T| #![auto] tree_contains(node.left, x) ==>\n                        T::le(x, node.value) && x != node.value)\n                    && (forall|x: T| #![auto] tree_contains(node.right, x) ==>\n                        T::le(node.value, x) && x != node.value)\n                    && match node.left {\n                        BalBinTree::Leaf => true,\n                        BalBinTree::Node(lnode) =>\n                            tree_is_bst::<T>(lnode.left)\n                            && tree_is_bst::<T>(lnode.right)\n                            && (forall|x: T| #![auto] tree_contains(lnode.left, x) ==>\n                                T::le(x, lnode.value) && x != lnode.value)\n                            && (forall|x: T| #![auto] tree_contains(lnode.right, x) ==>\n                                T::le(lnode.value, x) && x != lnode.value)\n                    }\n                    && match node.right {\n                        BalBinTree::Leaf => true,\n                        BalBinTree::Node(rnode) =>\n                            tree_is_bst::<T>(rnode.left)\n                            && tree_is_bst::<T>(rnode.right)\n                            && (forall|x: T| #![auto] tree_contains(rnode.left, x) ==>\n                                T::le(x, rnode.value) && x != rnode.value)\n                            && (forall|x: T| #![auto] tree_contains(rnode.right, x) ==>\n                                T::le(rnode.value, x) && x != rnode.value)\n                    }\n            }"
  },
  {
    "id": 244,
    "function": "rotate_right",
    "file": "Chap37/BSTRBStEph.rs",
    "lines": "84-90",
    "spec_strength": "unknown",
    "snippet": "    fn rotate_right<T: TotalOrder>(tree: BalBinTree<T>) -> (result: BalBinTree<T>)\n        requires\n            tree_is_bst::<T>(tree),\n            !(tree is Leaf),\n        ensures\n            tree_is_bst::<T>(result),\n            forall|x: T| #![auto] tree_contains(result, x) == tree_contains(tree, x),"
  },
  {
    "id": 245,
    "function": "rotate_left",
    "file": "Chap37/BSTRBStEph.rs",
    "lines": "182-188",
    "spec_strength": "unknown",
    "snippet": "    fn rotate_left<T: TotalOrder>(tree: BalBinTree<T>) -> (result: BalBinTree<T>)\n        requires\n            tree_is_bst::<T>(tree),\n            !(tree is Leaf),\n        ensures\n            tree_is_bst::<T>(result),\n            forall|x: T| #![auto] tree_contains(result, x) == tree_contains(tree, x),"
  },
  {
    "id": 246,
    "function": "insert_node",
    "file": "Chap37/BSTRBStEph.rs",
    "lines": "279-286",
    "spec_strength": "unknown",
    "snippet": "    fn insert_node<T: TotalOrder>(node: BalBinTree<T>, value: T) -> (result: BalBinTree<T>)\n        requires tree_is_bst::<T>(node),\n        ensures\n            tree_is_bst::<T>(result),\n            tree_contains(result, value),\n            forall|x: T| #![auto] tree_contains(result, x) <==>\n                (tree_contains(node, x) || x == value),\n        decreases node.spec_size(),"
  },
  {
    "id": 247,
    "function": "contains_node",
    "file": "Chap37/BSTRBStEph.rs",
    "lines": "408-411",
    "spec_strength": "unknown",
    "snippet": "    fn contains_node<T: TotalOrder>(node: &BalBinTree<T>, target: &T) -> (result: bool)\n        requires tree_is_bst::<T>(*node),\n        ensures result == tree_contains(*node, *target),\n        decreases node.spec_size(),"
  },
  {
    "id": 248,
    "function": "find_node",
    "file": "Chap37/BSTRBStEph.rs",
    "lines": "441-446",
    "spec_strength": "unknown",
    "snippet": "    fn find_node<'a, T: TotalOrder>(node: &'a BalBinTree<T>, target: &T) -> (result: Option<&'a T>)\n        requires tree_is_bst::<T>(*node),\n        ensures\n            result.is_some() == tree_contains(*node, *target),\n            result.is_some() ==> *result.unwrap() == *target,\n        decreases node.spec_size(),"
  },
  {
    "id": 249,
    "function": "min_node",
    "file": "Chap37/BSTRBStEph.rs",
    "lines": "476-477",
    "spec_strength": "",
    "snippet": "    fn min_node<T: TotalOrder>(node: &BalBinTree<T>) -> (result: Option<&T>)\n        decreases node.spec_size(),"
  },
  {
    "id": 250,
    "function": "max_node",
    "file": "Chap37/BSTRBStEph.rs",
    "lines": "491-492",
    "spec_strength": "",
    "snippet": "    fn max_node<T: TotalOrder>(node: &BalBinTree<T>) -> (result: Option<&T>)\n        decreases node.spec_size(),"
  },
  {
    "id": 251,
    "function": "rb_new",
    "file": "Chap37/BSTRBStEph.rs",
    "lines": "506-509",
    "spec_strength": "unknown",
    "snippet": "    pub fn rb_new<T: TotalOrder>() -> (tree: BSTRBStEph<T>)\n        ensures\n            tree_is_bst::<T>(tree.root),\n            forall|x: T| !tree_contains(tree.root, x),"
  },
  {
    "id": 252,
    "function": "rb_size",
    "file": "Chap37/BSTRBStEph.rs",
    "lines": "514-516",
    "spec_strength": "unknown",
    "snippet": "    pub fn rb_size<T: TotalOrder>(tree: &BSTRBStEph<T>) -> (n: usize)\n        requires tree.root.spec_size() <= usize::MAX,\n        ensures n == tree.root.spec_size(),"
  },
  {
    "id": 253,
    "function": "rb_is_empty",
    "file": "Chap37/BSTRBStEph.rs",
    "lines": "521-522",
    "spec_strength": "unknown",
    "snippet": "    pub fn rb_is_empty<T: TotalOrder>(tree: &BSTRBStEph<T>) -> (b: bool)\n        ensures b == (tree.root.spec_size() == 0),"
  },
  {
    "id": 254,
    "function": "rb_height",
    "file": "Chap37/BSTRBStEph.rs",
    "lines": "527-529",
    "spec_strength": "unknown",
    "snippet": "    pub fn rb_height<T: TotalOrder>(tree: &BSTRBStEph<T>) -> (h: usize)\n        requires tree.root.spec_height() <= usize::MAX,\n        ensures h == tree.root.spec_height(),"
  },
  {
    "id": 255,
    "function": "rb_insert",
    "file": "Chap37/BSTRBStEph.rs",
    "lines": "534-540",
    "spec_strength": "unknown",
    "snippet": "    pub fn rb_insert<T: TotalOrder>(tree: BSTRBStEph<T>, value: T) -> (result: BSTRBStEph<T>)\n        requires tree_is_bst::<T>(tree.root),\n        ensures\n            tree_is_bst::<T>(result.root),\n            tree_contains(result.root, value),\n            forall|x: T| #![auto] tree_contains(result.root, x) <==>\n                (tree_contains(tree.root, x) || x == value),"
  },
  {
    "id": 256,
    "function": "rb_contains",
    "file": "Chap37/BSTRBStEph.rs",
    "lines": "545-547",
    "spec_strength": "unknown",
    "snippet": "    pub fn rb_contains<T: TotalOrder>(tree: &BSTRBStEph<T>, target: &T) -> (result: bool)\n        requires tree_is_bst::<T>(tree.root),\n        ensures result == tree_contains(tree.root, *target),"
  },
  {
    "id": 257,
    "function": "rb_find",
    "file": "Chap37/BSTRBStEph.rs",
    "lines": "552-556",
    "spec_strength": "unknown",
    "snippet": "    pub fn rb_find<'a, T: TotalOrder>(tree: &'a BSTRBStEph<T>, target: &T) -> (result: Option<&'a T>)\n        requires tree_is_bst::<T>(tree.root),\n        ensures\n            result.is_some() == tree_contains(tree.root, *target),\n            result.is_some() ==> *result.unwrap() == *target,"
  },
  {
    "id": 258,
    "function": "values_vec",
    "file": "Chap37/BSTSetAVLMtEph.rs",
    "lines": "19",
    "spec_strength": "",
    "snippet": "    fn values_vec<T: StTInMtT + Ord>(tree: &BSTAVLMtEph<T>) -> Vec<T> { tree.in_order().iter().cloned().collect() }"
  },
  {
    "id": 259,
    "function": "rebuild_from_vec",
    "file": "Chap37/BSTSetAVLMtEph.rs",
    "lines": "21-27",
    "spec_strength": "",
    "snippet": "    fn rebuild_from_vec<T: StTInMtT + Ord>(values: Vec<T>) -> BSTAVLMtEph<T> {\n        let tree = BSTAVLMtEph::new();\n        for value in values {\n            tree.insert(value);\n        }\n        tree\n    }"
  },
  {
    "id": 260,
    "function": "from_sorted_iter",
    "file": "Chap37/BSTSetAVLMtEph.rs",
    "lines": "29-38",
    "spec_strength": "",
    "snippet": "    fn from_sorted_iter<T: StTInMtT + Ord, I>(values: I) -> BSTSetAVLMtEph<T>\n    where\n        I: IntoIterator<Item = T>,\n    {\n        let tree = BSTAVLMtEph::new();\n        for value in values {\n            tree.insert(value);\n        }\n        BSTSetAVLMtEph { tree }\n    }"
  },
  {
    "id": 261,
    "function": "empty",
    "file": "Chap37/BSTSetAVLMtEph.rs",
    "lines": "41-42",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn empty()                                   -> Self;"
  },
  {
    "id": 262,
    "function": "singleton",
    "file": "Chap37/BSTSetAVLMtEph.rs",
    "lines": "43-44",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn singleton(value: T)                       -> Self;"
  },
  {
    "id": 263,
    "function": "size",
    "file": "Chap37/BSTSetAVLMtEph.rs",
    "lines": "45-46",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn size(&self)                               -> N;"
  },
  {
    "id": 264,
    "function": "is_empty",
    "file": "Chap37/BSTSetAVLMtEph.rs",
    "lines": "47-48",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn is_empty(&self)                           -> B;"
  },
  {
    "id": 265,
    "function": "find",
    "file": "Chap37/BSTSetAVLMtEph.rs",
    "lines": "49-50",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n) with locking\n        fn find(&self, value: &T)                    -> Option<T>;"
  },
  {
    "id": 266,
    "function": "contains",
    "file": "Chap37/BSTSetAVLMtEph.rs",
    "lines": "51-52",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n) with locking\n        fn contains(&self, value: &T)                -> B;"
  },
  {
    "id": 267,
    "function": "minimum",
    "file": "Chap37/BSTSetAVLMtEph.rs",
    "lines": "53-54",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n) with locking\n        fn minimum(&self)                            -> Option<T>;"
  },
  {
    "id": 268,
    "function": "maximum",
    "file": "Chap37/BSTSetAVLMtEph.rs",
    "lines": "55-56",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n) with locking\n        fn maximum(&self)                            -> Option<T>;"
  },
  {
    "id": 269,
    "function": "insert",
    "file": "Chap37/BSTSetAVLMtEph.rs",
    "lines": "57-58",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n) with locking\n        fn insert(&mut self, value: T);"
  },
  {
    "id": 270,
    "function": "delete",
    "file": "Chap37/BSTSetAVLMtEph.rs",
    "lines": "59-60",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n) with locking\n        fn delete(&mut self, target: &T);"
  },
  {
    "id": 271,
    "function": "union",
    "file": "Chap37/BSTSetAVLMtEph.rs",
    "lines": "61-62",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)\n        fn union(&self, other: &Self)                -> Self;"
  },
  {
    "id": 272,
    "function": "intersection",
    "file": "Chap37/BSTSetAVLMtEph.rs",
    "lines": "63-64",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)\n        fn intersection(&self, other: &Self)         -> Self;"
  },
  {
    "id": 273,
    "function": "difference",
    "file": "Chap37/BSTSetAVLMtEph.rs",
    "lines": "65-66",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)\n        fn difference(&self, other: &Self)           -> Self;"
  },
  {
    "id": 274,
    "function": "split",
    "file": "Chap37/BSTSetAVLMtEph.rs",
    "lines": "67-68",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n)\n        fn split(&self, pivot: &T)                   -> (Self, B, Self);"
  },
  {
    "id": 275,
    "function": "join_pair",
    "file": "Chap37/BSTSetAVLMtEph.rs",
    "lines": "69-70",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log(|left| + |right|)), Span Θ(log(|left| + |right|))\n        fn join_pair(left: Self, right: Self)        -> Self;"
  },
  {
    "id": 276,
    "function": "join_m",
    "file": "Chap37/BSTSetAVLMtEph.rs",
    "lines": "71-72",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log(|left| + |right|)), Span Θ(log(|left| + |right|))\n        fn join_m(left: Self, pivot: T, right: Self) -> Self;"
  },
  {
    "id": 277,
    "function": "filter",
    "file": "Chap37/BSTSetAVLMtEph.rs",
    "lines": "73-74",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(log n) [parallelized]\n        fn filter<F: FnMut(&T) -> bool + Send>(&self, predicate: F) -> Self;"
  },
  {
    "id": 278,
    "function": "reduce",
    "file": "Chap37/BSTSetAVLMtEph.rs",
    "lines": "75-76",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(log n) [parallelized]\n        fn reduce<F: FnMut(T, T) -> T + Send>(&self, op: F, base: T) -> T;"
  },
  {
    "id": 279,
    "function": "iter_in_order",
    "file": "Chap37/BSTSetAVLMtEph.rs",
    "lines": "77-78",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(n)\n        fn iter_in_order(&self)                      -> ArraySeqStPerS<T>;"
  },
  {
    "id": 280,
    "function": "as_tree",
    "file": "Chap37/BSTSetAVLMtEph.rs",
    "lines": "79-80",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn as_tree(&self)                            -> &BSTAVLMtEph<T>;"
  },
  {
    "id": 281,
    "function": "empty",
    "file": "Chap37/BSTSetBBAlphaMtEph.rs",
    "lines": "20-21",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn empty()                                   -> Self;"
  },
  {
    "id": 282,
    "function": "singleton",
    "file": "Chap37/BSTSetBBAlphaMtEph.rs",
    "lines": "22-23",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn singleton(value: T)                       -> Self;"
  },
  {
    "id": 283,
    "function": "size",
    "file": "Chap37/BSTSetBBAlphaMtEph.rs",
    "lines": "24-25",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn size(&self)                               -> N;"
  },
  {
    "id": 284,
    "function": "is_empty",
    "file": "Chap37/BSTSetBBAlphaMtEph.rs",
    "lines": "26-27",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn is_empty(&self)                           -> B;"
  },
  {
    "id": 285,
    "function": "find",
    "file": "Chap37/BSTSetBBAlphaMtEph.rs",
    "lines": "28-29",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n) with locking\n        fn find(&self, value: &T)                    -> Option<T>;"
  },
  {
    "id": 286,
    "function": "contains",
    "file": "Chap37/BSTSetBBAlphaMtEph.rs",
    "lines": "30-31",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n) with locking\n        fn contains(&self, value: &T)                -> B;"
  },
  {
    "id": 287,
    "function": "minimum",
    "file": "Chap37/BSTSetBBAlphaMtEph.rs",
    "lines": "32-33",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n) with locking\n        fn minimum(&self)                            -> Option<T>;"
  },
  {
    "id": 288,
    "function": "maximum",
    "file": "Chap37/BSTSetBBAlphaMtEph.rs",
    "lines": "34-35",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n) with locking\n        fn maximum(&self)                            -> Option<T>;"
  },
  {
    "id": 289,
    "function": "insert",
    "file": "Chap37/BSTSetBBAlphaMtEph.rs",
    "lines": "36-37",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n) with locking\n        fn insert(&mut self, value: T);"
  },
  {
    "id": 290,
    "function": "delete",
    "file": "Chap37/BSTSetBBAlphaMtEph.rs",
    "lines": "38-39",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n) with locking\n        fn delete(&mut self, target: &T);"
  },
  {
    "id": 291,
    "function": "union",
    "file": "Chap37/BSTSetBBAlphaMtEph.rs",
    "lines": "40-41",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)\n        fn union(&self, other: &Self)                -> Self;"
  },
  {
    "id": 292,
    "function": "intersection",
    "file": "Chap37/BSTSetBBAlphaMtEph.rs",
    "lines": "42-43",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)\n        fn intersection(&self, other: &Self)         -> Self;"
  },
  {
    "id": 293,
    "function": "difference",
    "file": "Chap37/BSTSetBBAlphaMtEph.rs",
    "lines": "44-45",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)\n        fn difference(&self, other: &Self)           -> Self;"
  },
  {
    "id": 294,
    "function": "split",
    "file": "Chap37/BSTSetBBAlphaMtEph.rs",
    "lines": "46-47",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n)\n        fn split(&self, pivot: &T)                   -> (Self, B, Self);"
  },
  {
    "id": 295,
    "function": "join_pair",
    "file": "Chap37/BSTSetBBAlphaMtEph.rs",
    "lines": "48-49",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log(|left| + |right|)), Span Θ(log(|left| + |right|))\n        fn join_pair(left: Self, right: Self)        -> Self;"
  },
  {
    "id": 296,
    "function": "join_m",
    "file": "Chap37/BSTSetBBAlphaMtEph.rs",
    "lines": "50-51",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log(|left| + |right|)), Span Θ(log(|left| + |right|))\n        fn join_m(left: Self, pivot: T, right: Self) -> Self;"
  },
  {
    "id": 297,
    "function": "filter",
    "file": "Chap37/BSTSetBBAlphaMtEph.rs",
    "lines": "52-53",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(n)\n        fn filter<F: FnMut(&T) -> bool + Send>(&self, predicate: F) -> Self;"
  },
  {
    "id": 298,
    "function": "reduce",
    "file": "Chap37/BSTSetBBAlphaMtEph.rs",
    "lines": "54-55",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(n)\n        fn reduce<F: FnMut(T, T) -> T + Send>(&self, op: F, base: T) -> T;"
  },
  {
    "id": 299,
    "function": "iter_in_order",
    "file": "Chap37/BSTSetBBAlphaMtEph.rs",
    "lines": "56-57",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(n)\n        fn iter_in_order(&self)                      -> ArraySeqStPerS<T>;"
  },
  {
    "id": 300,
    "function": "as_tree",
    "file": "Chap37/BSTSetBBAlphaMtEph.rs",
    "lines": "58-59",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn as_tree(&self)                            -> &BSTBBAlphaMtEph<T>;"
  },
  {
    "id": 301,
    "function": "values_vec",
    "file": "Chap37/BSTSetBBAlphaMtEph.rs",
    "lines": "63",
    "spec_strength": "",
    "snippet": "        fn values_vec(&self) -> Vec<T> { self.tree.in_order().iter().cloned().collect() }"
  },
  {
    "id": 302,
    "function": "rebuild_from_vec",
    "file": "Chap37/BSTSetBBAlphaMtEph.rs",
    "lines": "64-70",
    "spec_strength": "",
    "snippet": "        fn rebuild_from_vec(values: Vec<T>) -> BSTBBAlphaMtEph<T> {\n            let tree = BSTBBAlphaMtEph::new();\n            for value in values {\n                tree.insert(value);\n            }\n            tree\n        }"
  },
  {
    "id": 303,
    "function": "from_sorted_iter",
    "file": "Chap37/BSTSetBBAlphaMtEph.rs",
    "lines": "71-80",
    "spec_strength": "",
    "snippet": "        fn from_sorted_iter<I>(values: I) -> Self\n        where\n            I: IntoIterator<Item = T>,\n        {\n            let tree = BSTBBAlphaMtEph::new();\n            for value in values {\n                tree.insert(value);\n            }\n            Self { tree }\n        }"
  },
  {
    "id": 304,
    "function": "empty",
    "file": "Chap37/BSTSetPlainMtEph.rs",
    "lines": "20-21",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn empty()                                   -> Self;"
  },
  {
    "id": 305,
    "function": "singleton",
    "file": "Chap37/BSTSetPlainMtEph.rs",
    "lines": "22-23",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn singleton(value: T)                       -> Self;"
  },
  {
    "id": 306,
    "function": "size",
    "file": "Chap37/BSTSetPlainMtEph.rs",
    "lines": "24-25",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn size(&self)                               -> N;"
  },
  {
    "id": 307,
    "function": "is_empty",
    "file": "Chap37/BSTSetPlainMtEph.rs",
    "lines": "26-27",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn is_empty(&self)                           -> B;"
  },
  {
    "id": 308,
    "function": "find",
    "file": "Chap37/BSTSetPlainMtEph.rs",
    "lines": "28-29",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n) average, Θ(n) worst case; Span Θ(log n) average with locking\n        fn find(&self, value: &T)                    -> Option<T>;"
  },
  {
    "id": 309,
    "function": "contains",
    "file": "Chap37/BSTSetPlainMtEph.rs",
    "lines": "30-31",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n) average, Θ(n) worst case; Span Θ(log n) average with locking\n        fn contains(&self, value: &T)                -> B;"
  },
  {
    "id": 310,
    "function": "minimum",
    "file": "Chap37/BSTSetPlainMtEph.rs",
    "lines": "32-33",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n) average, Θ(n) worst case; Span Θ(log n) average with locking\n        fn minimum(&self)                            -> Option<T>;"
  },
  {
    "id": 311,
    "function": "maximum",
    "file": "Chap37/BSTSetPlainMtEph.rs",
    "lines": "34-35",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n) average, Θ(n) worst case; Span Θ(log n) average with locking\n        fn maximum(&self)                            -> Option<T>;"
  },
  {
    "id": 312,
    "function": "insert",
    "file": "Chap37/BSTSetPlainMtEph.rs",
    "lines": "36-37",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n) average, Θ(n) worst case; Span Θ(log n) average with locking\n        fn insert(&mut self, value: T);"
  },
  {
    "id": 313,
    "function": "delete",
    "file": "Chap37/BSTSetPlainMtEph.rs",
    "lines": "38-39",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n) average, Θ(n) worst case; Span Θ(log n) average with locking\n        fn delete(&mut self, target: &T);"
  },
  {
    "id": 314,
    "function": "union",
    "file": "Chap37/BSTSetPlainMtEph.rs",
    "lines": "40-41",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)\n        fn union(&self, other: &Self)                -> Self;"
  },
  {
    "id": 315,
    "function": "intersection",
    "file": "Chap37/BSTSetPlainMtEph.rs",
    "lines": "42-43",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)\n        fn intersection(&self, other: &Self)         -> Self;"
  },
  {
    "id": 316,
    "function": "difference",
    "file": "Chap37/BSTSetPlainMtEph.rs",
    "lines": "44-45",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)\n        fn difference(&self, other: &Self)           -> Self;"
  },
  {
    "id": 317,
    "function": "split",
    "file": "Chap37/BSTSetPlainMtEph.rs",
    "lines": "46-47",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n) average, Span Θ(log n)\n        fn split(&self, pivot: &T)                   -> (Self, B, Self);"
  },
  {
    "id": 318,
    "function": "join_pair",
    "file": "Chap37/BSTSetPlainMtEph.rs",
    "lines": "48-49",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log(|left| + |right|)), Span Θ(log(|left| + |right|))\n        fn join_pair(left: Self, right: Self)        -> Self;"
  },
  {
    "id": 319,
    "function": "join_m",
    "file": "Chap37/BSTSetPlainMtEph.rs",
    "lines": "50-51",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log(|left| + |right|)), Span Θ(log(|left| + |right|))\n        fn join_m(left: Self, pivot: T, right: Self) -> Self;"
  },
  {
    "id": 320,
    "function": "filter",
    "file": "Chap37/BSTSetPlainMtEph.rs",
    "lines": "52-53",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(n)\n        fn filter<F: FnMut(&T) -> bool + Send>(&self, predicate: F) -> Self;"
  },
  {
    "id": 321,
    "function": "reduce",
    "file": "Chap37/BSTSetPlainMtEph.rs",
    "lines": "54-55",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(n)\n        fn reduce<F: FnMut(T, T) -> T + Send>(&self, op: F, base: T) -> T;"
  },
  {
    "id": 322,
    "function": "iter_in_order",
    "file": "Chap37/BSTSetPlainMtEph.rs",
    "lines": "56-57",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(n)\n        fn iter_in_order(&self)                      -> ArraySeqStPerS<T>;"
  },
  {
    "id": 323,
    "function": "as_tree",
    "file": "Chap37/BSTSetPlainMtEph.rs",
    "lines": "58-59",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn as_tree(&self)                            -> &BSTPlainMtEph<T>;"
  },
  {
    "id": 324,
    "function": "values_vec",
    "file": "Chap37/BSTSetPlainMtEph.rs",
    "lines": "63",
    "spec_strength": "",
    "snippet": "        fn values_vec(&self) -> Vec<T> { self.tree.in_order().iter().cloned().collect() }"
  },
  {
    "id": 325,
    "function": "rebuild_from_vec",
    "file": "Chap37/BSTSetPlainMtEph.rs",
    "lines": "64-70",
    "spec_strength": "",
    "snippet": "        fn rebuild_from_vec(values: Vec<T>) -> BSTPlainMtEph<T> {\n            let tree = BSTPlainMtEph::new();\n            for value in values {\n                tree.insert(value);\n            }\n            tree\n        }"
  },
  {
    "id": 326,
    "function": "from_sorted_iter",
    "file": "Chap37/BSTSetPlainMtEph.rs",
    "lines": "71-80",
    "spec_strength": "",
    "snippet": "        fn from_sorted_iter<I>(values: I) -> Self\n        where\n            I: IntoIterator<Item = T>,\n        {\n            let tree = BSTPlainMtEph::new();\n            for value in values {\n                tree.insert(value);\n            }\n            Self { tree }\n        }"
  },
  {
    "id": 327,
    "function": "empty",
    "file": "Chap37/BSTSetRBMtEph.rs",
    "lines": "20-21",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn empty()                                   -> Self;"
  },
  {
    "id": 328,
    "function": "singleton",
    "file": "Chap37/BSTSetRBMtEph.rs",
    "lines": "22-23",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn singleton(value: T)                       -> Self;"
  },
  {
    "id": 329,
    "function": "size",
    "file": "Chap37/BSTSetRBMtEph.rs",
    "lines": "24-25",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn size(&self)                               -> N;"
  },
  {
    "id": 330,
    "function": "is_empty",
    "file": "Chap37/BSTSetRBMtEph.rs",
    "lines": "26-27",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn is_empty(&self)                           -> B;"
  },
  {
    "id": 331,
    "function": "find",
    "file": "Chap37/BSTSetRBMtEph.rs",
    "lines": "28-29",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n) with locking\n        fn find(&self, value: &T)                    -> Option<T>;"
  },
  {
    "id": 332,
    "function": "contains",
    "file": "Chap37/BSTSetRBMtEph.rs",
    "lines": "30-31",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n) with locking\n        fn contains(&self, value: &T)                -> B;"
  },
  {
    "id": 333,
    "function": "minimum",
    "file": "Chap37/BSTSetRBMtEph.rs",
    "lines": "32-33",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n) with locking\n        fn minimum(&self)                            -> Option<T>;"
  },
  {
    "id": 334,
    "function": "maximum",
    "file": "Chap37/BSTSetRBMtEph.rs",
    "lines": "34-35",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n) with locking\n        fn maximum(&self)                            -> Option<T>;"
  },
  {
    "id": 335,
    "function": "insert",
    "file": "Chap37/BSTSetRBMtEph.rs",
    "lines": "36-37",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n) with locking\n        fn insert(&mut self, value: T);"
  },
  {
    "id": 336,
    "function": "delete",
    "file": "Chap37/BSTSetRBMtEph.rs",
    "lines": "38-39",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n) with locking\n        fn delete(&mut self, target: &T);"
  },
  {
    "id": 337,
    "function": "union",
    "file": "Chap37/BSTSetRBMtEph.rs",
    "lines": "40-41",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)\n        fn union(&self, other: &Self)                -> Self;"
  },
  {
    "id": 338,
    "function": "intersection",
    "file": "Chap37/BSTSetRBMtEph.rs",
    "lines": "42-43",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)\n        fn intersection(&self, other: &Self)         -> Self;"
  },
  {
    "id": 339,
    "function": "difference",
    "file": "Chap37/BSTSetRBMtEph.rs",
    "lines": "44-45",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)\n        fn difference(&self, other: &Self)           -> Self;"
  },
  {
    "id": 340,
    "function": "split",
    "file": "Chap37/BSTSetRBMtEph.rs",
    "lines": "46-47",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n)\n        fn split(&self, pivot: &T)                   -> (Self, B, Self);"
  },
  {
    "id": 341,
    "function": "join_pair",
    "file": "Chap37/BSTSetRBMtEph.rs",
    "lines": "48-49",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log(|left| + |right|)), Span Θ(log(|left| + |right|))\n        fn join_pair(left: Self, right: Self)        -> Self;"
  },
  {
    "id": 342,
    "function": "join_m",
    "file": "Chap37/BSTSetRBMtEph.rs",
    "lines": "50-51",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log(|left| + |right|)), Span Θ(log(|left| + |right|))\n        fn join_m(left: Self, pivot: T, right: Self) -> Self;"
  },
  {
    "id": 343,
    "function": "filter",
    "file": "Chap37/BSTSetRBMtEph.rs",
    "lines": "52-53",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(n) [sequential due to FnMut]\n        fn filter<F: FnMut(&T) -> bool + Send>(&self, predicate: F) -> Self;"
  },
  {
    "id": 344,
    "function": "reduce",
    "file": "Chap37/BSTSetRBMtEph.rs",
    "lines": "54-55",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(n) [sequential due to FnMut]\n        fn reduce<F: FnMut(T, T) -> T + Send>(&self, op: F, base: T) -> T;"
  },
  {
    "id": 345,
    "function": "iter_in_order",
    "file": "Chap37/BSTSetRBMtEph.rs",
    "lines": "56-57",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(n)\n        fn iter_in_order(&self)                      -> ArraySeqStPerS<T>;"
  },
  {
    "id": 346,
    "function": "as_tree",
    "file": "Chap37/BSTSetRBMtEph.rs",
    "lines": "58-59",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn as_tree(&self)                            -> &BSTRBMtEph<T>;"
  },
  {
    "id": 347,
    "function": "values_vec",
    "file": "Chap37/BSTSetRBMtEph.rs",
    "lines": "63",
    "spec_strength": "",
    "snippet": "        fn values_vec(&self) -> Vec<T> { self.tree.in_order().iter().cloned().collect() }"
  },
  {
    "id": 348,
    "function": "rebuild_from_vec",
    "file": "Chap37/BSTSetRBMtEph.rs",
    "lines": "64-70",
    "spec_strength": "",
    "snippet": "        fn rebuild_from_vec(values: Vec<T>) -> BSTRBMtEph<T> {\n            let tree = BSTRBMtEph::new();\n            for value in values {\n                tree.insert(value);\n            }\n            tree\n        }"
  },
  {
    "id": 349,
    "function": "from_sorted_iter",
    "file": "Chap37/BSTSetRBMtEph.rs",
    "lines": "71-80",
    "spec_strength": "",
    "snippet": "        fn from_sorted_iter<I>(values: I) -> Self\n        where\n            I: IntoIterator<Item = T>,\n        {\n            let tree = BSTRBMtEph::new();\n            for value in values {\n                tree.insert(value);\n            }\n            Self { tree }\n        }"
  },
  {
    "id": 350,
    "function": "empty",
    "file": "Chap37/BSTSetSplayMtEph.rs",
    "lines": "20-21",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn empty()                                   -> Self;"
  },
  {
    "id": 351,
    "function": "singleton",
    "file": "Chap37/BSTSetSplayMtEph.rs",
    "lines": "22-23",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn singleton(value: T)                       -> Self;"
  },
  {
    "id": 352,
    "function": "size",
    "file": "Chap37/BSTSetSplayMtEph.rs",
    "lines": "24-25",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn size(&self)                               -> N;"
  },
  {
    "id": 353,
    "function": "is_empty",
    "file": "Chap37/BSTSetSplayMtEph.rs",
    "lines": "26-27",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn is_empty(&self)                           -> B;"
  },
  {
    "id": 354,
    "function": "find",
    "file": "Chap37/BSTSetSplayMtEph.rs",
    "lines": "28-29",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n) amortized, Θ(n) worst case; Span Θ(log n) amortized with locking\n        fn find(&self, value: &T)                    -> Option<T>;"
  },
  {
    "id": 355,
    "function": "contains",
    "file": "Chap37/BSTSetSplayMtEph.rs",
    "lines": "30-31",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n) amortized, Θ(n) worst case; Span Θ(log n) amortized with locking\n        fn contains(&self, value: &T)                -> B;"
  },
  {
    "id": 356,
    "function": "minimum",
    "file": "Chap37/BSTSetSplayMtEph.rs",
    "lines": "32-33",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n) amortized, Θ(n) worst case; Span Θ(log n) amortized with locking\n        fn minimum(&self)                            -> Option<T>;"
  },
  {
    "id": 357,
    "function": "maximum",
    "file": "Chap37/BSTSetSplayMtEph.rs",
    "lines": "34-35",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n) amortized, Θ(n) worst case; Span Θ(log n) amortized with locking\n        fn maximum(&self)                            -> Option<T>;"
  },
  {
    "id": 358,
    "function": "insert",
    "file": "Chap37/BSTSetSplayMtEph.rs",
    "lines": "36-37",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n) amortized, Θ(n) worst case; Span Θ(log n) amortized with locking\n        fn insert(&mut self, value: T);"
  },
  {
    "id": 359,
    "function": "delete",
    "file": "Chap37/BSTSetSplayMtEph.rs",
    "lines": "38-39",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n) amortized, Θ(n) worst case; Span Θ(log n) amortized with locking\n        fn delete(&mut self, target: &T);"
  },
  {
    "id": 360,
    "function": "union",
    "file": "Chap37/BSTSetSplayMtEph.rs",
    "lines": "40-41",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m) [parallelized]\n        fn union(&self, other: &Self)                -> Self;"
  },
  {
    "id": 361,
    "function": "intersection",
    "file": "Chap37/BSTSetSplayMtEph.rs",
    "lines": "42-43",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m) [parallelized]\n        fn intersection(&self, other: &Self)         -> Self;"
  },
  {
    "id": 362,
    "function": "difference",
    "file": "Chap37/BSTSetSplayMtEph.rs",
    "lines": "44-45",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m) [parallelized]\n        fn difference(&self, other: &Self)           -> Self;"
  },
  {
    "id": 363,
    "function": "split",
    "file": "Chap37/BSTSetSplayMtEph.rs",
    "lines": "46-47",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n) amortized, Span Θ(log n)\n        fn split(&self, pivot: &T)                   -> (Self, B, Self);"
  },
  {
    "id": 364,
    "function": "join_pair",
    "file": "Chap37/BSTSetSplayMtEph.rs",
    "lines": "48-49",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log(|left| + |right|)), Span Θ(log(|left| + |right|))\n        fn join_pair(left: Self, right: Self)        -> Self;"
  },
  {
    "id": 365,
    "function": "join_m",
    "file": "Chap37/BSTSetSplayMtEph.rs",
    "lines": "50-51",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log(|left| + |right|)), Span Θ(log(|left| + |right|))\n        fn join_m(left: Self, pivot: T, right: Self) -> Self;"
  },
  {
    "id": 366,
    "function": "filter",
    "file": "Chap37/BSTSetSplayMtEph.rs",
    "lines": "52-53",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(n) [sequential due to FnMut]\n        fn filter<F: FnMut(&T) -> bool + Send>(&self, predicate: F) -> Self;"
  },
  {
    "id": 367,
    "function": "reduce",
    "file": "Chap37/BSTSetSplayMtEph.rs",
    "lines": "54-55",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(n) [sequential due to FnMut]\n        fn reduce<F: FnMut(T, T) -> T + Send>(&self, op: F, base: T) -> T;"
  },
  {
    "id": 368,
    "function": "iter_in_order",
    "file": "Chap37/BSTSetSplayMtEph.rs",
    "lines": "56-57",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(n)\n        fn iter_in_order(&self)                      -> ArraySeqStPerS<T>;"
  },
  {
    "id": 369,
    "function": "as_tree",
    "file": "Chap37/BSTSetSplayMtEph.rs",
    "lines": "58-59",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn as_tree(&self)                            -> &BSTSplayMtEph<T>;"
  },
  {
    "id": 370,
    "function": "values_vec",
    "file": "Chap37/BSTSetSplayMtEph.rs",
    "lines": "63",
    "spec_strength": "",
    "snippet": "        fn values_vec(&self) -> Vec<T> { self.tree.in_order().iter().cloned().collect() }"
  },
  {
    "id": 371,
    "function": "rebuild_from_vec",
    "file": "Chap37/BSTSetSplayMtEph.rs",
    "lines": "64-70",
    "spec_strength": "",
    "snippet": "        fn rebuild_from_vec(values: Vec<T>) -> BSTSplayMtEph<T> {\n            let tree = BSTSplayMtEph::new();\n            for value in values {\n                tree.insert(value);\n            }\n            tree\n        }"
  },
  {
    "id": 372,
    "function": "from_sorted_iter",
    "file": "Chap37/BSTSetSplayMtEph.rs",
    "lines": "71-80",
    "spec_strength": "",
    "snippet": "        fn from_sorted_iter<I>(values: I) -> Self\n        where\n            I: IntoIterator<Item = T>,\n        {\n            let tree = BSTSplayMtEph::new();\n            for value in values {\n                tree.insert(value);\n            }\n            Self { tree }\n        }"
  },
  {
    "id": 373,
    "function": "new_node",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "22-29",
    "spec_strength": "",
    "snippet": "    fn new_node<T: StTInMtT + Ord>(key: T) -> Node<T> {\n        Node {\n            key,\n            size: 1,\n            left: None,\n            right: None,\n        }\n    }"
  },
  {
    "id": 374,
    "function": "size_link",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "31",
    "spec_strength": "",
    "snippet": "    fn size_link<T: StTInMtT + Ord>(link: &Link<T>) -> N { link.as_ref().map_or(0, |n| n.size) }"
  },
  {
    "id": 375,
    "function": "update",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "33",
    "spec_strength": "",
    "snippet": "    fn update<T: StTInMtT + Ord>(node: &mut Node<T>) { node.size = 1 + size_link(&node.left) + size_link(&node.right); }"
  },
  {
    "id": 376,
    "function": "insert_link",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "35-55",
    "spec_strength": "",
    "snippet": "    fn insert_link<T: StTInMtT + Ord>(link: &mut Link<T>, value: T) -> bool {\n        match link {\n            | Some(node) => {\n                let inserted = if value < node.key {\n                    insert_link(&mut node.left, value)\n                } else if value > node.key {\n                    insert_link(&mut node.right, value)\n                } else {\n                    false\n                };\n                if inserted {\n                    update(node);\n                }\n                inserted\n            }\n            | None => {\n                *link = Some(Box::new(new_node(value)));\n                true\n            }\n        }\n    }"
  },
  {
    "id": 377,
    "function": "find_link",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "57-70",
    "spec_strength": "",
    "snippet": "    fn find_link<'a, T: StTInMtT + Ord>(link: &'a Link<T>, target: &T) -> Option<&'a T> {\n        match link {\n            | None => None,\n            | Some(node) => {\n                if target == &node.key {\n                    Some(&node.key)\n                } else if target < &node.key {\n                    find_link(&node.left, target)\n                } else {\n                    find_link(&node.right, target)\n                }\n            }\n        }\n    }"
  },
  {
    "id": 378,
    "function": "min_link",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "72-80",
    "spec_strength": "",
    "snippet": "    fn min_link<T: StTInMtT + Ord>(link: &Link<T>) -> Option<&T> {\n        match link {\n            | None => None,\n            | Some(node) => match node.left {\n                | None => Some(&node.key),\n                | Some(_) => min_link(&node.left),\n            },\n        }\n    }"
  },
  {
    "id": 379,
    "function": "max_link",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "82-90",
    "spec_strength": "",
    "snippet": "    fn max_link<T: StTInMtT + Ord>(link: &Link<T>) -> Option<&T> {\n        match link {\n            | None => None,\n            | Some(node) => match node.right {\n                | None => Some(&node.key),\n                | Some(_) => max_link(&node.right),\n            },\n        }\n    }"
  },
  {
    "id": 380,
    "function": "in_order_collect",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "92-98",
    "spec_strength": "",
    "snippet": "    fn in_order_collect<T: StTInMtT + Ord>(link: &Link<T>, out: &mut Vec<T>) {\n        if let Some(node) = link {\n            in_order_collect(&node.left, out);\n            out.push(node.key.clone());\n            in_order_collect(&node.right, out);\n        }\n    }"
  },
  {
    "id": 381,
    "function": "pre_order_collect",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "100-106",
    "spec_strength": "",
    "snippet": "    fn pre_order_collect<T: StTInMtT + Ord>(link: &Link<T>, out: &mut Vec<T>) {\n        if let Some(node) = link {\n            out.push(node.key.clone());\n            pre_order_collect(&node.left, out);\n            pre_order_collect(&node.right, out);\n        }\n    }"
  },
  {
    "id": 382,
    "function": "in_order_parallel",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "110-125",
    "spec_strength": "",
    "snippet": "    fn in_order_parallel<T: StTInMtT + Ord>(link: &Link<T>) -> Vec<T> {\n        match link {\n            | None => Vec::new(),\n            | Some(node) => {\n                use crate::Types::Types::Pair;\n                let Pair(left_vec, right_vec) = crate::ParaPair!(\n                    move || in_order_parallel(&node.left),\n                    move || in_order_parallel(&node.right)\n                );\n                let mut result = left_vec;\n                result.push(node.key.clone());\n                result.extend(right_vec);\n                result\n            }\n        }\n    }"
  },
  {
    "id": 383,
    "function": "pre_order_parallel",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "127-142",
    "spec_strength": "",
    "snippet": "    fn pre_order_parallel<T: StTInMtT + Ord>(link: &Link<T>) -> Vec<T> {\n        match link {\n            | None => Vec::new(),\n            | Some(node) => {\n                use crate::Types::Types::Pair;\n                let Pair(left_vec, right_vec) = crate::ParaPair!(\n                    move || pre_order_parallel(&node.left),\n                    move || pre_order_parallel(&node.right)\n                );\n                let mut result = vec![node.key.clone()];\n                result.extend(left_vec);\n                result.extend(right_vec);\n                result\n            }\n        }\n    }"
  },
  {
    "id": 384,
    "function": "build_balanced",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "144-163",
    "spec_strength": "",
    "snippet": "    // Parallel construction from sorted slice\n    fn build_balanced<T: StTInMtT + Ord>(values: &[T]) -> Link<T> {\n        if values.is_empty() {\n            return None;\n        }\n        let mid = values.len() / 2;\n        \n        // Parallel construction of left and right subtrees\n        use crate::Types::Types::Pair;\n        let Pair(left, right) = crate::ParaPair!(\n            move || build_balanced(&values[..mid]),\n            move || build_balanced(&values[mid + 1..])\n        );\n        \n        let mut node = Box::new(new_node(values[mid].clone()));\n        node.left = left;\n        node.right = right;\n        update(&mut node);\n        Some(node)\n    }"
  },
  {
    "id": 385,
    "function": "filter_parallel",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "165-190",
    "spec_strength": "",
    "snippet": "    // Parallel filter\n    fn filter_parallel<T: StTInMtT + Ord, F>(link: &Link<T>, predicate: &std::sync::Arc<F>) -> Vec<T>\n    where\n        F: Fn(&T) -> bool + Send + Sync,\n    {\n        match link {\n            | None => Vec::new(),\n            | Some(node) => {\n                let pred_left = std::sync::Arc::clone(predicate);\n                let pred_right = std::sync::Arc::clone(predicate);\n                \n                use crate::Types::Types::Pair;\n                let Pair(left_vals, right_vals) = crate::ParaPair!(\n                    move || filter_parallel(&node.left, &pred_left),\n                    move || filter_parallel(&node.right, &pred_right)\n                );\n                \n                let mut result = left_vals;\n                if predicate(&node.key) {\n                    result.push(node.key.clone());\n                }\n                result.extend(right_vals);\n                result\n            }\n        }\n    }"
  },
  {
    "id": 386,
    "function": "reduce_parallel",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "192-214",
    "spec_strength": "",
    "snippet": "    // Parallel reduce\n    fn reduce_parallel<T: StTInMtT + Ord, F>(link: &Link<T>, op: &std::sync::Arc<F>, identity: T) -> T\n    where\n        F: Fn(T, T) -> T + Send + Sync,\n    {\n        match link {\n            | None => identity,\n            | Some(node) => {\n                let op_left = std::sync::Arc::clone(op);\n                let op_right = std::sync::Arc::clone(op);\n                let id_left = identity.clone();\n                \n                use crate::Types::Types::Pair;\n                let Pair(left_acc, right_acc) = crate::ParaPair!(\n                    move || reduce_parallel(&node.left, &op_left, id_left),\n                    move || reduce_parallel(&node.right, &op_right, identity)\n                );\n                \n                let with_key = op(left_acc, node.key.clone());\n                op(with_key, right_acc)\n            }\n        }\n    }"
  },
  {
    "id": 387,
    "function": "new",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "224-225",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn new()                       -> Self;"
  },
  {
    "id": 388,
    "function": "from_sorted_slice",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "226-227",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(log n) - Parallel construction from sorted slice\n        fn from_sorted_slice(values: &[T]) -> Self;"
  },
  {
    "id": 389,
    "function": "insert",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "228-229",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n) amortized, Θ(n) worst case; Span Θ(log n) amortized with locking\n        fn insert(&self, value: T);"
  },
  {
    "id": 390,
    "function": "find",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "230-231",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n) amortized, Θ(n) worst case; Span Θ(log n) amortized with locking\n        fn find(&self, target: &T)     -> Option<T>;"
  },
  {
    "id": 391,
    "function": "contains",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "232-233",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n) amortized, Θ(n) worst case; Span Θ(log n) amortized with locking\n        fn contains(&self, target: &T) -> B;"
  },
  {
    "id": 392,
    "function": "size",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "234-235",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn size(&self)                 -> N;"
  },
  {
    "id": 393,
    "function": "is_empty",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "236-237",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn is_empty(&self)             -> B;"
  },
  {
    "id": 394,
    "function": "height",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "238-239",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(n)\n        fn height(&self)               -> N;"
  },
  {
    "id": 395,
    "function": "minimum",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "240-241",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n) amortized, Θ(n) worst case; Span Θ(log n) amortized with locking\n        fn minimum(&self)              -> Option<T>;"
  },
  {
    "id": 396,
    "function": "maximum",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "242-243",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n) amortized, Θ(n) worst case; Span Θ(log n) amortized with locking\n        fn maximum(&self)              -> Option<T>;"
  },
  {
    "id": 397,
    "function": "in_order",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "244-245",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(log n) - Parallel traversal\n        fn in_order(&self)             -> ArraySeqStPerS<T>;"
  },
  {
    "id": 398,
    "function": "pre_order",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "246-247",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(log n) - Parallel traversal\n        fn pre_order(&self)            -> ArraySeqStPerS<T>;"
  },
  {
    "id": 399,
    "function": "filter",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "248-251",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(log n) - Parallel filter\n        fn filter<F>(&self, predicate: F) -> ArraySeqStPerS<T>\n        where\n            F: Fn(&T) -> bool + Send + Sync;"
  },
  {
    "id": 400,
    "function": "reduce",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "252-255",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(log n) - Parallel reduce\n        fn reduce<F>(&self, op: F, identity: T) -> T\n        where\n            F: Fn(T, T) -> T + Send + Sync;"
  },
  {
    "id": 401,
    "function": "height_rec",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "285-290",
    "spec_strength": "",
    "snippet": "            fn height_rec<T: StTInMtT + Ord>(link: &Link<T>) -> N {\n                match link {\n                    | None => 0,\n                    | Some(node) => 1 + height_rec(&node.left).max(height_rec(&node.right)),\n                }\n            }"
  },
  {
    "id": 402,
    "function": "default",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "344",
    "spec_strength": "",
    "snippet": "        fn default() -> Self { Self::new() }"
  },
  {
    "id": 403,
    "function": "new_node",
    "file": "Chap37/BSTSplayStEph.rs",
    "lines": "20-27",
    "spec_strength": "",
    "snippet": "    fn new_node<T: StT + Ord>(key: T) -> Node<T> {\n        Node {\n            key,\n            size: 1,\n            left: None,\n            right: None,\n        }\n    }"
  },
  {
    "id": 404,
    "function": "size_link",
    "file": "Chap37/BSTSplayStEph.rs",
    "lines": "29",
    "spec_strength": "",
    "snippet": "    fn size_link<T: StT + Ord>(link: &Link<T>) -> N { link.as_ref().map_or(0, |n| n.size) }"
  },
  {
    "id": 405,
    "function": "update",
    "file": "Chap37/BSTSplayStEph.rs",
    "lines": "31",
    "spec_strength": "",
    "snippet": "    fn update<T: StT + Ord>(node: &mut Node<T>) { node.size = 1 + size_link(&node.left) + size_link(&node.right); }"
  },
  {
    "id": 406,
    "function": "insert_link",
    "file": "Chap37/BSTSplayStEph.rs",
    "lines": "33-53",
    "spec_strength": "",
    "snippet": "    fn insert_link<T: StT + Ord>(link: &mut Link<T>, value: T) -> bool {\n        match link {\n            | Some(node) => {\n                let inserted = if value < node.key {\n                    insert_link(&mut node.left, value)\n                } else if value > node.key {\n                    insert_link(&mut node.right, value)\n                } else {\n                    false\n                };\n                if inserted {\n                    update(node);\n                }\n                inserted\n            }\n            | None => {\n                *link = Some(Box::new(new_node(value)));\n                true\n            }\n        }\n    }"
  },
  {
    "id": 407,
    "function": "find_link",
    "file": "Chap37/BSTSplayStEph.rs",
    "lines": "55-68",
    "spec_strength": "",
    "snippet": "    fn find_link<'a, T: StT + Ord>(link: &'a Link<T>, target: &T) -> Option<&'a T> {\n        match link {\n            | None => None,\n            | Some(node) => {\n                if target == &node.key {\n                    Some(&node.key)\n                } else if target < &node.key {\n                    find_link(&node.left, target)\n                } else {\n                    find_link(&node.right, target)\n                }\n            }\n        }\n    }"
  },
  {
    "id": 408,
    "function": "min_link",
    "file": "Chap37/BSTSplayStEph.rs",
    "lines": "70-78",
    "spec_strength": "",
    "snippet": "    fn min_link<T: StT + Ord>(link: &Link<T>) -> Option<&T> {\n        match link {\n            | None => None,\n            | Some(node) => match node.left {\n                | None => Some(&node.key),\n                | Some(_) => min_link(&node.left),\n            },\n        }\n    }"
  },
  {
    "id": 409,
    "function": "max_link",
    "file": "Chap37/BSTSplayStEph.rs",
    "lines": "80-88",
    "spec_strength": "",
    "snippet": "    fn max_link<T: StT + Ord>(link: &Link<T>) -> Option<&T> {\n        match link {\n            | None => None,\n            | Some(node) => match node.right {\n                | None => Some(&node.key),\n                | Some(_) => max_link(&node.right),\n            },\n        }\n    }"
  },
  {
    "id": 410,
    "function": "in_order_collect",
    "file": "Chap37/BSTSplayStEph.rs",
    "lines": "90-96",
    "spec_strength": "",
    "snippet": "    fn in_order_collect<T: StT + Ord>(link: &Link<T>, out: &mut Vec<T>) {\n        if let Some(node) = link {\n            in_order_collect(&node.left, out);\n            out.push(node.key.clone());\n            in_order_collect(&node.right, out);\n        }\n    }"
  },
  {
    "id": 411,
    "function": "pre_order_collect",
    "file": "Chap37/BSTSplayStEph.rs",
    "lines": "98-104",
    "spec_strength": "",
    "snippet": "    fn pre_order_collect<T: StT + Ord>(link: &Link<T>, out: &mut Vec<T>) {\n        if let Some(node) = link {\n            out.push(node.key.clone());\n            pre_order_collect(&node.left, out);\n            pre_order_collect(&node.right, out);\n        }\n    }"
  },
  {
    "id": 412,
    "function": "new",
    "file": "Chap37/BSTSplayStEph.rs",
    "lines": "114-115",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn new()                       -> Self;"
  },
  {
    "id": 413,
    "function": "size",
    "file": "Chap37/BSTSplayStEph.rs",
    "lines": "116-117",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn size(&self)                 -> N;"
  },
  {
    "id": 414,
    "function": "is_empty",
    "file": "Chap37/BSTSplayStEph.rs",
    "lines": "118-119",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn is_empty(&self)             -> B;"
  },
  {
    "id": 415,
    "function": "height",
    "file": "Chap37/BSTSplayStEph.rs",
    "lines": "120-121",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(n)\n        fn height(&self)               -> N;"
  },
  {
    "id": 416,
    "function": "insert",
    "file": "Chap37/BSTSplayStEph.rs",
    "lines": "122-123",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n) amortized, Θ(n) worst case; Span Θ(log n) amortized, Parallelism Θ(1)\n        fn insert(&mut self, value: T);"
  },
  {
    "id": 417,
    "function": "find",
    "file": "Chap37/BSTSplayStEph.rs",
    "lines": "124-125",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n) amortized, Θ(n) worst case; Span Θ(log n) amortized, Parallelism Θ(1)\n        fn find(&self, target: &T)     -> Option<&T>;"
  },
  {
    "id": 418,
    "function": "contains",
    "file": "Chap37/BSTSplayStEph.rs",
    "lines": "126-127",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n) amortized, Θ(n) worst case; Span Θ(log n) amortized, Parallelism Θ(1)\n        fn contains(&self, target: &T) -> B;"
  },
  {
    "id": 419,
    "function": "minimum",
    "file": "Chap37/BSTSplayStEph.rs",
    "lines": "128-129",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n) amortized, Θ(n) worst case; Span Θ(log n) amortized, Parallelism Θ(1)\n        fn minimum(&self)              -> Option<&T>;"
  },
  {
    "id": 420,
    "function": "maximum",
    "file": "Chap37/BSTSplayStEph.rs",
    "lines": "130-131",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n) amortized, Θ(n) worst case; Span Θ(log n) amortized, Parallelism Θ(1)\n        fn maximum(&self)              -> Option<&T>;"
  },
  {
    "id": 421,
    "function": "in_order",
    "file": "Chap37/BSTSplayStEph.rs",
    "lines": "132-133",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)\n        fn in_order(&self)             -> ArraySeqStPerS<T>;"
  },
  {
    "id": 422,
    "function": "pre_order",
    "file": "Chap37/BSTSplayStEph.rs",
    "lines": "134-135",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)\n        fn pre_order(&self)            -> ArraySeqStPerS<T>;"
  },
  {
    "id": 423,
    "function": "height_rec",
    "file": "Chap37/BSTSplayStEph.rs",
    "lines": "146-151",
    "spec_strength": "",
    "snippet": "            fn height_rec<T: StT + Ord>(link: &Link<T>) -> N {\n                match link {\n                    | None => 0,\n                    | Some(node) => 1 + height_rec(&node.left).max(height_rec(&node.right)),\n                }\n            }"
  },
  {
    "id": 424,
    "function": "default",
    "file": "Chap37/BSTSplayStEph.rs",
    "lines": "179",
    "spec_strength": "",
    "snippet": "        fn default() -> Self { Self::new() }"
  },
  {
    "id": 425,
    "function": "new",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "32-34",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1), Span O(1)\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        fn new()                           -> Self;"
  },
  {
    "id": 426,
    "function": "expose",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "35-37",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1), Span O(1)\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        fn expose(&self)                   -> Exposed<T>;"
  },
  {
    "id": 427,
    "function": "join_mid",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "38-40",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1), Span O(1)\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        fn join_mid(exposed: Exposed<T>)   -> Self;"
  },
  {
    "id": 428,
    "function": "size",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "41-43",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1), Span O(1)\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        fn size(&self)                     -> N;"
  },
  {
    "id": 429,
    "function": "is_empty",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "44-46",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1), Span O(1)\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        fn is_empty(&self)                 -> B;"
  },
  {
    "id": 430,
    "function": "insert",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "47-49",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(lg |t|), Span O(lg |t|)\n        /// - Claude-Opus-4.6: Work Θ(log n), Span Θ(log n)\n        fn insert(&self, key: T);"
  },
  {
    "id": 431,
    "function": "delete",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "50-52",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(lg |t|), Span O(lg |t|)\n        /// - Claude-Opus-4.6: Work Θ(log n), Span Θ(log n)\n        fn delete(&self, key: &T);"
  },
  {
    "id": 432,
    "function": "find",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "53-55",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(lg |t|), Span O(lg |t|)\n        /// - Claude-Opus-4.6: Work Θ(log n), Span Θ(log n)\n        fn find(&self, key: &T)            -> Option<T>;"
  },
  {
    "id": 433,
    "function": "split",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "56-58",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(lg |t|), Span O(lg |t|)\n        /// - Claude-Opus-4.6: Work Θ(log n), Span Θ(log n)\n        fn split(&self, key: &T)           -> (Self, B, Self);"
  },
  {
    "id": 434,
    "function": "join_pair",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "59-61",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(lg(|t1| + |t2|)), Span O(lg(|t1| + |t2|))\n        /// - Claude-Opus-4.6: Work Θ(log(|t1| + |t2|)), Span Θ(log(|t1| + |t2|))\n        fn join_pair(&self, other: Self)   -> Self;"
  },
  {
    "id": 435,
    "function": "union",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "62-64",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(m · lg(n/m)), Span O(lg n)\n        /// - Claude-Opus-4.6: Work Θ(m · lg(n/m)), Span Θ(lg n)\n        fn union(&self, other: &Self)      -> Self;"
  },
  {
    "id": 436,
    "function": "intersect",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "65-67",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(m · lg(n/m)), Span O(lg n)\n        /// - Claude-Opus-4.6: Work Θ(m · lg(n/m)), Span Θ(lg n)\n        fn intersect(&self, other: &Self)  -> Self;"
  },
  {
    "id": 437,
    "function": "difference",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "68-70",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(m · lg(n/m)), Span O(lg n)\n        /// - Claude-Opus-4.6: Work Θ(m · lg(n/m)), Span Θ(lg n)\n        fn difference(&self, other: &Self) -> Self;"
  },
  {
    "id": 438,
    "function": "filter",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "71-73",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(|t|), Span O(lg |t|)\n        /// - Claude-Opus-4.6: Work Θ(n), Span Θ(lg n)\n        fn filter<F: Fn(&T) -> bool + Send + Sync + 'static>(&self, predicate: F) -> Self;"
  },
  {
    "id": 439,
    "function": "reduce",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "74-76",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(|t|), Span O(lg |t|)\n        /// - Claude-Opus-4.6: Work Θ(n), Span Θ(lg n)\n        fn reduce<F: Fn(T, T) -> T + Send + Sync + 'static>(&self, op: F, base: T) -> T;"
  },
  {
    "id": 440,
    "function": "in_order",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "77-79",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(|t|), Span O(|t|)\n        /// - Claude-Opus-4.6: Work Θ(n), Span Θ(n)\n        fn in_order(&self)                 -> ArraySeqStPerS<T>;"
  },
  {
    "id": 441,
    "function": "expose_internal",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "82-90",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work O(1), Span O(1)\n    /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n    fn expose_internal<T: MtKey + 'static>(tree: &ParamBST<T>) -> Exposed<T> {\n        let guard = tree.root.read().unwrap();\n        match &*guard {\n            | None => Exposed::Leaf,\n            | Some(node) => Exposed::Node(node.left.clone(), node.key.clone(), node.right.clone()),\n        }\n    }"
  },
  {
    "id": 442,
    "function": "split_inner",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "108-135",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work O(lg |t|), Span O(lg |t|)\n    /// - Claude-Opus-4.6: Work Θ(log n), Span Θ(log n)\n    fn split_inner<T: MtKey + 'static>(tree: &ParamBST<T>, key: &T) -> (ParamBST<T>, B, ParamBST<T>) {\n        match expose_internal(tree) {\n            | Exposed::Leaf => (\n                ParamBST {\n                    root: Arc::new(RwLock::new(None)),\n                },\n                false,\n                ParamBST {\n                    root: Arc::new(RwLock::new(None)),\n                },\n            ),\n            | Exposed::Node(left, root_key, right) => match key.cmp(&root_key) {\n                | Less => {\n                    let (ll, found, lr) = split_inner(&left, key);\n                    let rebuilt = join_mid(Exposed::Node(lr, root_key, right));\n                    (ll, found, rebuilt)\n                }\n                | Greater => {\n                    let (rl, found, rr) = split_inner(&right, key);\n                    let rebuilt = join_mid(Exposed::Node(left, root_key, rl));\n                    (rebuilt, found, rr)\n                }\n                | Equal => (left, true, right),\n            },\n        }\n    }"
  },
  {
    "id": 443,
    "function": "join_m",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "137-141",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work O(1), Span O(1)\n    /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n    fn join_m<T: MtKey + 'static>(left: ParamBST<T>, key: T, right: ParamBST<T>) -> ParamBST<T> {\n        join_mid(Exposed::Node(left, key, right))\n    }"
  },
  {
    "id": 444,
    "function": "min_key",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "143-153",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work O(lg |t|), Span O(lg |t|)\n    /// - Claude-Opus-4.6: Work Θ(log n), Span Θ(log n)\n    fn min_key<T: MtKey + 'static>(tree: &ParamBST<T>) -> Option<T> {\n        match expose_internal(tree) {\n            | Exposed::Leaf => None,\n            | Exposed::Node(left, key, _) => match min_key(&left) {\n                | Some(rec) => Some(rec),\n                | None => Some(key),\n            },\n        }\n    }"
  },
  {
    "id": 445,
    "function": "join_pair_inner",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "155-166",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work O(lg(|left| + |right|)), Span O(lg(|left| + |right|))\n    /// - Claude-Opus-4.6: Work Θ(log(|left| + |right|)), Span Θ(log(|left| + |right|))\n    fn join_pair_inner<T: MtKey + 'static>(left: ParamBST<T>, right: ParamBST<T>) -> ParamBST<T> {\n        match expose_internal(&right) {\n            | Exposed::Leaf => left,\n            | Exposed::Node(_, key, _) => {\n                let min_k = min_key(&right).unwrap_or(key);\n                let (_, _, reduced_right) = split_inner(&right, &min_k);\n                join_m(left, min_k, reduced_right)\n            }\n        }\n    }"
  },
  {
    "id": 446,
    "function": "union_inner",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "168-180",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work O(m · lg(n/m)), Span O(lg n)\n    /// - Claude-Opus-4.6: Work Θ(m · lg(n/m)), Span Θ(lg n)\n    fn union_inner<T: MtKey + 'static>(a: &ParamBST<T>, b: &ParamBST<T>) -> ParamBST<T> {\n        match expose_internal(a) {\n            | Exposed::Leaf => b.clone(),\n            | Exposed::Node(al, ak, ar) => {\n                let (bl, _, br) = split_inner(b, &ak);\n                let Pair(left_union, right_union) =\n                    crate::ParaPair!(move || union_inner(&al, &bl), move || union_inner(&ar, &br));\n                join_m(left_union, ak, right_union)\n            }\n        }\n    }"
  },
  {
    "id": 447,
    "function": "intersect_inner",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "182-200",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work O(m · lg(n/m)), Span O(lg n)\n    /// - Claude-Opus-4.6: Work Θ(m · lg(n/m)), Span Θ(lg n)\n    fn intersect_inner<T: MtKey + 'static>(a: &ParamBST<T>, b: &ParamBST<T>) -> ParamBST<T> {\n        match (expose_internal(a), expose_internal(b)) {\n            | (Exposed::Leaf, _) | (_, Exposed::Leaf) => ParamBST {\n                root: Arc::new(RwLock::new(None)),\n            },\n            | (Exposed::Node(al, ak, ar), _) => {\n                let (bl, found, br) = split_inner(b, &ak);\n                let Pair(left_res, right_res) =\n                    crate::ParaPair!(move || intersect_inner(&al, &bl), move || { intersect_inner(&ar, &br) });\n                if found {\n                    join_m(left_res, ak, right_res)\n                } else {\n                    join_pair_inner(left_res, right_res)\n                }\n            }\n        }\n    }"
  },
  {
    "id": 448,
    "function": "difference_inner",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "202-222",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work O(m · lg(n/m)), Span O(lg n)\n    /// - Claude-Opus-4.6: Work Θ(m · lg(n/m)), Span Θ(lg n)\n    fn difference_inner<T: MtKey + 'static>(a: &ParamBST<T>, b: &ParamBST<T>) -> ParamBST<T> {\n        match (expose_internal(a), expose_internal(b)) {\n            | (Exposed::Leaf, _) => ParamBST {\n                root: Arc::new(RwLock::new(None)),\n            },\n            | (_, Exposed::Leaf) => a.clone(),\n            | (Exposed::Node(al, ak, ar), _) => {\n                let (bl, found, br) = split_inner(b, &ak);\n                let Pair(left_res, right_res) = crate::ParaPair!(move || difference_inner(&al, &bl), move || {\n                    difference_inner(&ar, &br)\n                });\n                if found {\n                    join_pair_inner(left_res, right_res)\n                } else {\n                    join_m(left_res, ak, right_res)\n                }\n            }\n        }\n    }"
  },
  {
    "id": 449,
    "function": "filter_inner",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "224-248",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work O(|t|), Span O(lg |t|)\n    /// - Claude-Opus-4.6: Work Θ(n), Span Θ(lg n)\n    fn filter_inner<T: MtKey + 'static, F: Fn(&T) -> bool + Send + Sync + 'static>(\n        tree: &ParamBST<T>,\n        predicate: &Arc<F>,\n    ) -> ParamBST<T> {\n        match expose_internal(tree) {\n            | Exposed::Leaf => ParamBST {\n                root: Arc::new(RwLock::new(None)),\n            },\n            | Exposed::Node(left, key, right) => {\n                let pred_left = Arc::clone(predicate);\n                let pred_right = Arc::clone(predicate);\n                let Pair(left_filtered, right_filtered) =\n                    crate::ParaPair!(move || filter_inner(&left, &pred_left), move || {\n                        filter_inner(&right, &pred_right)\n                    });\n                if (**predicate)(&key) {\n                    join_m(left_filtered, key, right_filtered)\n                } else {\n                    join_pair_inner(left_filtered, right_filtered)\n                }\n            }\n        }\n    }"
  },
  {
    "id": 450,
    "function": "filter_parallel",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "250-258",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work O(|t|), Span O(lg |t|)\n    /// - Claude-Opus-4.6: Work Θ(n), Span Θ(lg n)\n    fn filter_parallel<T: MtKey + 'static, F: Fn(&T) -> bool + Send + Sync + 'static>(\n        tree: &ParamBST<T>,\n        predicate: F,\n    ) -> ParamBST<T> {\n        let predicate = Arc::new(predicate);\n        filter_inner(tree, &predicate)\n    }"
  },
  {
    "id": 451,
    "function": "reduce_inner",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "260-283",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work O(|t|), Span O(lg |t|)\n    /// - Claude-Opus-4.6: Work Θ(n), Span Θ(lg n)\n    fn reduce_inner<T: MtKey + 'static, F: Fn(T, T) -> T + Send + Sync + 'static>(\n        tree: &ParamBST<T>,\n        op: &Arc<F>,\n        identity: T,\n    ) -> T {\n        match expose_internal(tree) {\n            | Exposed::Leaf => identity,\n            | Exposed::Node(left, key, right) => {\n                let op_left = Arc::clone(op);\n                let op_right = Arc::clone(op);\n                let left_base = identity.clone();\n                let right_base = identity;\n                let Pair(left_acc, right_acc) =\n                    crate::ParaPair!(move || reduce_inner(&left, &op_left, left_base), move || {\n                        reduce_inner(&right, &op_right, right_base)\n                    });\n                let op_ref = op.as_ref();\n                let right_with_key = op_ref(key, right_acc);\n                op_ref(left_acc, right_with_key)\n            }\n        }\n    }"
  },
  {
    "id": 452,
    "function": "reduce_parallel",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "285-294",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work O(|t|), Span O(lg |t|)\n    /// - Claude-Opus-4.6: Work Θ(n), Span Θ(lg n)\n    fn reduce_parallel<T: MtKey + 'static, F: Fn(T, T) -> T + Send + Sync + 'static>(\n        tree: &ParamBST<T>,\n        op: F,\n        base: T,\n    ) -> T {\n        let op = Arc::new(op);\n        reduce_inner(tree, &op, base)\n    }"
  },
  {
    "id": 453,
    "function": "collect_in_order",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "296-307",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work O(|t|), Span O(|t|)\n    /// - Claude-Opus-4.6: Work Θ(n), Span Θ(n)\n    fn collect_in_order<T: MtKey + 'static>(tree: &ParamBST<T>, out: &mut Vec<T>) {\n        match expose_internal(tree) {\n            | Exposed::Leaf => {}\n            | Exposed::Node(left, key, right) => {\n                collect_in_order(&left, out);\n                out.push(key);\n                collect_in_order(&right, out);\n            }\n        }\n    }"
  },
  {
    "id": 454,
    "function": "new",
    "file": "Chap38/BSTParaStEph.rs",
    "lines": "34-36",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1), Span O(1)\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        fn new()                         -> Self;"
  },
  {
    "id": 455,
    "function": "expose",
    "file": "Chap38/BSTParaStEph.rs",
    "lines": "37-39",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1), Span O(1)\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        fn expose(&self)                 -> Exposed<T>;"
  },
  {
    "id": 456,
    "function": "join_mid",
    "file": "Chap38/BSTParaStEph.rs",
    "lines": "40-42",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1), Span O(1)\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        fn join_mid(exposed: Exposed<T>) -> Self;"
  },
  {
    "id": 457,
    "function": "size",
    "file": "Chap38/BSTParaStEph.rs",
    "lines": "43-45",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1), Span O(1)\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        fn size(&self)                   -> N;"
  },
  {
    "id": 458,
    "function": "is_empty",
    "file": "Chap38/BSTParaStEph.rs",
    "lines": "46-48",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1), Span O(1)\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        fn is_empty(&self)               -> B;"
  },
  {
    "id": 459,
    "function": "insert",
    "file": "Chap38/BSTParaStEph.rs",
    "lines": "49-51",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(lg |t|), Span O(lg |t|)\n        /// - Claude-Opus-4.6: Work Θ(log n), Span Θ(log n)\n        fn insert(&self, key: T);"
  },
  {
    "id": 460,
    "function": "delete",
    "file": "Chap38/BSTParaStEph.rs",
    "lines": "52-54",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(lg |t|), Span O(lg |t|)\n        /// - Claude-Opus-4.6: Work Θ(log n), Span Θ(log n)\n        fn delete(&self, key: &T);"
  },
  {
    "id": 461,
    "function": "find",
    "file": "Chap38/BSTParaStEph.rs",
    "lines": "55-57",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(lg |t|), Span O(lg |t|)\n        /// - Claude-Opus-4.6: Work Θ(log n), Span Θ(log n)\n        fn find(&self, key: &T)          -> Option<T>;"
  },
  {
    "id": 462,
    "function": "split",
    "file": "Chap38/BSTParaStEph.rs",
    "lines": "58-60",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(lg |t|), Span O(lg |t|)\n        /// - Claude-Opus-4.6: Work Θ(log n), Span Θ(log n)\n        fn split(&self, key: &T)         -> (Self, B, Self);"
  },
  {
    "id": 463,
    "function": "join_pair",
    "file": "Chap38/BSTParaStEph.rs",
    "lines": "61-63",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(lg(|t1| + |t2|)), Span O(lg(|t1| + |t2|))\n        /// - Claude-Opus-4.6: Work Θ(log(|t1| + |t2|)), Span Θ(log(|t1| + |t2|))\n        fn join_pair(&self, other: Self) -> Self;"
  },
  {
    "id": 464,
    "function": "union",
    "file": "Chap38/BSTParaStEph.rs",
    "lines": "64-66",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(m · lg(n/m)), Span O(m · lg(n/m)) — sequential, no parallelism\n        /// - Claude-Opus-4.6: Work Θ(m · lg(n/m)), Span Θ(m · lg(n/m)) — sequential variant\n        fn union(&self, other: &Self)    -> Self;"
  },
  {
    "id": 465,
    "function": "in_order",
    "file": "Chap38/BSTParaStEph.rs",
    "lines": "67-69",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(|t|), Span O(|t|)\n        /// - Claude-Opus-4.6: Work Θ(n), Span Θ(n)\n        fn in_order(&self)               -> ArraySeqStPerS<T>;"
  },
  {
    "id": 466,
    "function": "expose_internal",
    "file": "Chap38/BSTParaStEph.rs",
    "lines": "72-80",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work O(1), Span O(1)\n    /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n    fn expose_internal<T: StT + Ord>(tree: &ParamBST<T>) -> Exposed<T> {\n        let guard = tree.root.borrow();\n        match &*guard {\n            | None => Exposed::Leaf,\n            | Some(node) => Exposed::Node(node.left.clone(), node.key.clone(), node.right.clone()),\n        }\n    }"
  },
  {
    "id": 467,
    "function": "split_inner",
    "file": "Chap38/BSTParaStEph.rs",
    "lines": "98-125",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work O(lg |t|), Span O(lg |t|)\n    /// - Claude-Opus-4.6: Work Θ(log n), Span Θ(log n)\n    fn split_inner<T: StT + Ord>(tree: &ParamBST<T>, key: &T) -> (ParamBST<T>, B, ParamBST<T>) {\n        match expose_internal(tree) {\n            | Exposed::Leaf => (\n                ParamBST {\n                    root: Rc::new(RefCell::new(None)),\n                },\n                false,\n                ParamBST {\n                    root: Rc::new(RefCell::new(None)),\n                },\n            ),\n            | Exposed::Node(left, root_key, right) => match key.cmp(&root_key) {\n                | Less => {\n                    let (ll, found, lr) = split_inner(&left, key);\n                    let rebuilt = join_mid(Exposed::Node(lr, root_key, right));\n                    (ll, found, rebuilt)\n                }\n                | Greater => {\n                    let (rl, found, rr) = split_inner(&right, key);\n                    let rebuilt = join_mid(Exposed::Node(left, root_key, rl));\n                    (rebuilt, found, rr)\n                }\n                | Equal => (left, true, right),\n            },\n        }\n    }"
  },
  {
    "id": 468,
    "function": "join_m",
    "file": "Chap38/BSTParaStEph.rs",
    "lines": "127-131",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work O(1), Span O(1)\n    /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n    fn join_m<T: StT + Ord>(left: ParamBST<T>, key: T, right: ParamBST<T>) -> ParamBST<T> {\n        join_mid(Exposed::Node(left, key, right))\n    }"
  },
  {
    "id": 469,
    "function": "min_key",
    "file": "Chap38/BSTParaStEph.rs",
    "lines": "133-143",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work O(lg |t|), Span O(lg |t|)\n    /// - Claude-Opus-4.6: Work Θ(log n), Span Θ(log n)\n    fn min_key<T: StT + Ord>(tree: &ParamBST<T>) -> Option<T> {\n        match expose_internal(tree) {\n            | Exposed::Leaf => None,\n            | Exposed::Node(left, key, _) => match min_key(&left) {\n                | Some(rec) => Some(rec),\n                | None => Some(key),\n            },\n        }\n    }"
  },
  {
    "id": 470,
    "function": "join_pair_inner",
    "file": "Chap38/BSTParaStEph.rs",
    "lines": "145-156",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work O(lg(|left| + |right|)), Span O(lg(|left| + |right|))\n    /// - Claude-Opus-4.6: Work Θ(log(|left| + |right|)), Span Θ(log(|left| + |right|))\n    fn join_pair_inner<T: StT + Ord>(left: ParamBST<T>, right: ParamBST<T>) -> ParamBST<T> {\n        match expose_internal(&right) {\n            | Exposed::Leaf => left,\n            | Exposed::Node(_, key, _) => {\n                let min_k = min_key(&right).unwrap_or(key);\n                let (_, _, reduced_right) = split_inner(&right, &min_k);\n                join_m(left, min_k, reduced_right)\n            }\n        }\n    }"
  },
  {
    "id": 471,
    "function": "union_inner",
    "file": "Chap38/BSTParaStEph.rs",
    "lines": "158-170",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work O(m · lg(n/m)), Span O(m · lg(n/m)) — sequential, no parallelism\n    /// - Claude-Opus-4.6: Work Θ(m · lg(n/m)), Span Θ(m · lg(n/m)) — sequential variant\n    fn union_inner<T: StT + Ord>(a: &ParamBST<T>, b: &ParamBST<T>) -> ParamBST<T> {\n        match expose_internal(a) {\n            | Exposed::Leaf => b.clone(),\n            | Exposed::Node(al, ak, ar) => {\n                let (bl, _, br) = split_inner(b, &ak);\n                let left_union = union_inner(&al, &bl);\n                let right_union = union_inner(&ar, &br);\n                join_m(left_union, ak, right_union)\n            }\n        }\n    }"
  },
  {
    "id": 472,
    "function": "collect_in_order",
    "file": "Chap38/BSTParaStEph.rs",
    "lines": "172-183",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work O(|t|), Span O(|t|)\n    /// - Claude-Opus-4.6: Work Θ(n), Span Θ(n)\n    fn collect_in_order<T: StT + Ord>(tree: &ParamBST<T>, out: &mut Vec<T>) {\n        match expose_internal(tree) {\n            | Exposed::Leaf => {}\n            | Exposed::Node(left, key, right) => {\n                collect_in_order(&left, out);\n                out.push(key);\n                collect_in_order(&right, out);\n            }\n        }\n    }"
  },
  {
    "id": 473,
    "function": "priority_for",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "34-42",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work Θ(1), Span Θ(1)\n    /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n    fn priority_for<T: MtKey>(key: &T) -> i64 {\n        let mut hasher = std::collections::hash_map::DefaultHasher::new();\n        let mut buf = String::new();\n        let _ = write!(&mut buf, \"{key:?}\");\n        Hash::hash(&buf, &mut hasher);\n        hasher.finish() as i64\n    }"
  },
  {
    "id": 474,
    "function": "tree_priority",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "44-49",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work Θ(1), Span Θ(1)\n    /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n    fn tree_priority<T: MtKey>(tree: &ParamTreap<T>) -> i64 {\n        let guard = tree.root.read().unwrap();\n        guard.as_ref().map_or(i64::MIN, |node| node.priority)\n    }"
  },
  {
    "id": 475,
    "function": "tree_size",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "51-56",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work Θ(1), Span Θ(1)\n    /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n    fn tree_size<T: MtKey>(tree: &ParamTreap<T>) -> N {\n        let guard = tree.root.read().unwrap();\n        guard.as_ref().map_or(0, |node| node.size)\n    }"
  },
  {
    "id": 476,
    "function": "make_node",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "58-71",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work Θ(1), Span Θ(1)\n    /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n    fn make_node<T: MtKey>(left: ParamTreap<T>, key: T, priority: i64, right: ParamTreap<T>) -> ParamTreap<T> {\n        let size = 1 + tree_size(&left) + tree_size(&right);\n        ParamTreap {\n            root: Arc::new(RwLock::new(Some(Box::new(NodeInner {\n                key,\n                priority,\n                size,\n                left,\n                right,\n            })))),\n        }\n    }"
  },
  {
    "id": 477,
    "function": "new",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "74-76",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1), Span O(1)\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        fn new()                                   -> Self;"
  },
  {
    "id": 478,
    "function": "expose",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "77-79",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1), Span O(1)\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        fn expose(&self)                           -> Exposed<T>;"
  },
  {
    "id": 479,
    "function": "join_mid",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "80-82",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(log(|left| + |right|)), Span O(log(|left| + |right|))\n        /// - Claude-Opus-4.6: Work O(log(|left| + |right|)), Span O(log(|left| + |right|)) — delegates to join_with_priority\n        fn join_mid(exposed: Exposed<T>)           -> Self;"
  },
  {
    "id": 480,
    "function": "size",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "83-85",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1), Span O(1)\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        fn size(&self)                             -> N;"
  },
  {
    "id": 481,
    "function": "is_empty",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "86-88",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1), Span O(1)\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        fn is_empty(&self)                         -> B;"
  },
  {
    "id": 482,
    "function": "insert",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "89-91",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(lg |t|), Span O(lg |t|)\n        /// - Claude-Opus-4.6: Work O(lg |t|), Span O(lg |t|)\n        fn insert(&self, key: T);"
  },
  {
    "id": 483,
    "function": "delete",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "92-94",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(lg |t|), Span O(lg |t|)\n        /// - Claude-Opus-4.6: Work O(lg |t|), Span O(lg |t|)\n        fn delete(&self, key: &T);"
  },
  {
    "id": 484,
    "function": "find",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "95-97",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(lg |t|), Span O(lg |t|)\n        /// - Claude-Opus-4.6: Work O(lg |t|), Span O(lg |t|)\n        fn find(&self, key: &T)                    -> Option<T>;"
  },
  {
    "id": 485,
    "function": "split",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "98-100",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(lg |t|), Span O(lg |t|)\n        /// - Claude-Opus-4.6: Work O(lg |t|), Span O(lg |t|)\n        fn split(&self, key: &T)                   -> (Self, B, Self);"
  },
  {
    "id": 486,
    "function": "join_pair",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "101-103",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(lg(|t_1| + |t_2|)), Span O(lg(|t_1| + |t_2|))\n        /// - Claude-Opus-4.6: Work O(lg(|t_1| + |t_2|)), Span O(lg(|t_1| + |t_2|))\n        fn join_pair(&self, other: Self)           -> Self;"
  },
  {
    "id": 487,
    "function": "union",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "104-106",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(m · lg(n/m)), Span O(lg n)\n        /// - Claude-Opus-4.6: Work O(m · lg(n/m)), Span O(lg n)\n        fn union(&self, other: &Self)              -> Self;"
  },
  {
    "id": 488,
    "function": "intersect",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "107-109",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(m · lg(n/m)), Span O(lg n)\n        /// - Claude-Opus-4.6: Work O(m · lg(n/m)), Span O(lg n)\n        fn intersect(&self, other: &Self)          -> Self;"
  },
  {
    "id": 489,
    "function": "difference",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "110-112",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(m · lg(n/m)), Span O(lg n)\n        /// - Claude-Opus-4.6: Work O(m · lg(n/m)), Span O(lg n)\n        fn difference(&self, other: &Self)         -> Self;"
  },
  {
    "id": 490,
    "function": "filter",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "113-115",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(|t|), Span O(lg |t|)\n        /// - Claude-Opus-4.6: Work O(|t|), Span O(lg |t|)\n        fn filter<F: Pred<T>>(&self, predicate: F) -> Self;"
  },
  {
    "id": 491,
    "function": "reduce",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "116-120",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(|t|), Span O(lg |t|)\n        /// - Claude-Opus-4.6: Work O(|t|), Span O(lg |t|)\n        fn reduce<F>(&self, op: F, base: T)        -> T\n        where\n            F: Fn(T, T) -> T + Send + Sync + 'static;"
  },
  {
    "id": 492,
    "function": "in_order",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "121-123",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(|t|), Span O(|t|)\n        /// - Claude-Opus-4.6: Work O(|t|), Span O(|t|)\n        fn in_order(&self)                         -> ArraySeqStPerS<T>;"
  },
  {
    "id": 493,
    "function": "expose_internal",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "127-135",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1), Span O(1)\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        fn expose_internal(&self) -> Exposed<T> {\n            let guard = self.root.read().unwrap();\n            match &*guard {\n                | None => Exposed::Leaf,\n                | Some(node) => Exposed::Node(node.left.clone(), node.key.clone(), node.right.clone()),\n            }\n        }"
  },
  {
    "id": 494,
    "function": "expose_with_priority",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "137-144",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1), Span O(1)\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        pub fn expose_with_priority(&self) -> Option<(ParamTreap<T>, T, i64, ParamTreap<T>)> {\n            let guard = self.root.read().unwrap();\n            guard\n                .as_ref()\n                .map(|node| (node.left.clone(), node.key.clone(), node.priority, node.right.clone()))\n        }"
  },
  {
    "id": 495,
    "function": "join_with_priority",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "146-167",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(lg(|left| + |right|)), Span O(lg(|left| + |right|))\n        /// - Claude-Opus-4.6: Work O(lg(|left| + |right|)), Span O(lg(|left| + |right|))\n        fn join_with_priority(left: ParamTreap<T>, key: T, priority: i64, right: ParamTreap<T>) -> ParamTreap<T> {\n            let left_priority = tree_priority(&left);\n            let right_priority = tree_priority(&right);\n            if priority > left_priority && priority > right_priority {\n                return make_node(left, key, priority, right);\n            }\n            if left_priority > right_priority {\n                if let Some((ll, lk, lp, lr)) = left.expose_with_priority() {\n                    let merged_right = ParamTreap::join_with_priority(lr, key, priority, right);\n                    return make_node(ll, lk, lp, merged_right);\n                }\n                make_node(left, key, priority, right)\n            } else {\n                if let Some((rl, rk, rp, rr)) = right.expose_with_priority() {\n                    let merged_left = ParamTreap::join_with_priority(left, key, priority, rl);\n                    return make_node(merged_left, rk, rp, rr);\n                }\n                make_node(left, key, priority, right)\n            }\n        }"
  },
  {
    "id": 496,
    "function": "split_inner",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "169-188",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(lg |t|), Span O(lg |t|)\n        /// - Claude-Opus-4.6: Work O(lg |t|), Span O(lg |t|)\n        fn split_inner(tree: &Self, key: &T) -> (Self, B, Self) {\n            match tree.expose_with_priority() {\n                | None => (ParamTreap::new(), false, ParamTreap::new()),\n                | Some((left, root_key, priority, right)) => match key.cmp(&root_key) {\n                    | Less => {\n                        let (ll, found, lr) = ParamTreap::split_inner(&left, key);\n                        let rebuilt = ParamTreap::join_with_priority(lr, root_key, priority, right);\n                        (ll, found, rebuilt)\n                    }\n                    | Greater => {\n                        let (rl, found, rr) = ParamTreap::split_inner(&right, key);\n                        let rebuilt = ParamTreap::join_with_priority(left, root_key, priority, rl);\n                        (rebuilt, found, rr)\n                    }\n                    | Equal => (left, true, right),\n                },\n            }\n        }"
  },
  {
    "id": 497,
    "function": "join_pair_inner",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "190-202",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(m · lg(n/m)), Span O(lg n)\n        /// - Claude-Opus-4.6: Work O(m · lg(n/m)), Span O(lg n)\n        fn join_pair_inner(left: Self, right: Self) -> Self {\n            match right.expose_with_priority() {\n                | None => left,\n                | Some((r_left, r_key, r_priority, r_right)) => {\n                    let (split_left, _, split_right) = ParamTreap::split_inner(&left, &r_key);\n                    let combined_left = ParamTreap::join_pair_inner(split_left, r_left);\n                    let combined_right = ParamTreap::join_pair_inner(split_right, r_right);\n                    ParamTreap::join_with_priority(combined_left, r_key, r_priority, combined_right)\n                }\n            }\n        }"
  },
  {
    "id": 498,
    "function": "union_inner",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "204-218",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(m · lg(n/m)), Span O(lg n)\n        /// - Claude-Opus-4.6: Work O(m · lg(n/m)), Span O(lg n)\n        fn union_inner(a: &Self, b: &Self) -> Self {\n            match a.expose_with_priority() {\n                | None => b.clone(),\n                | Some((al, ak, ap, ar)) => {\n                    let (bl, _, br) = ParamTreap::split_inner(b, &ak);\n                    let Pair(left_union, right_union) =\n                        crate::ParaPair!(move || ParamTreap::union_inner(&al, &bl), move || {\n                            ParamTreap::union_inner(&ar, &br)\n                        });\n                    ParamTreap::join_with_priority(left_union, ak, ap, right_union)\n                }\n            }\n        }"
  },
  {
    "id": 499,
    "function": "intersect_inner",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "220-238",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(m · lg(n/m)), Span O(lg n)\n        /// - Claude-Opus-4.6: Work O(m · lg(n/m)), Span O(lg n)\n        fn intersect_inner(a: &Self, b: &Self) -> Self {\n            match a.expose_with_priority() {\n                | None => ParamTreap::new(),\n                | Some((al, ak, ap, ar)) => {\n                    let (bl, found, br) = ParamTreap::split_inner(b, &ak);\n                    let Pair(left_res, right_res) =\n                        crate::ParaPair!(move || ParamTreap::intersect_inner(&al, &bl), move || {\n                            ParamTreap::intersect_inner(&ar, &br)\n                        });\n                    if found {\n                        ParamTreap::join_with_priority(left_res, ak, ap, right_res)\n                    } else {\n                        ParamTreap::join_pair_inner(left_res, right_res)\n                    }\n                }\n            }\n        }"
  },
  {
    "id": 500,
    "function": "difference_inner",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "240-258",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(m · lg(n/m)), Span O(lg n)\n        /// - Claude-Opus-4.6: Work O(m · lg(n/m)), Span O(lg n)\n        fn difference_inner(a: &Self, b: &Self) -> Self {\n            match a.expose_with_priority() {\n                | None => ParamTreap::new(),\n                | Some((al, ak, ap, ar)) => {\n                    let (bl, found, br) = ParamTreap::split_inner(b, &ak);\n                    let Pair(left_res, right_res) =\n                        crate::ParaPair!(move || ParamTreap::difference_inner(&al, &bl), move || {\n                            ParamTreap::difference_inner(&ar, &br)\n                        });\n                    if found {\n                        ParamTreap::join_pair_inner(left_res, right_res)\n                    } else {\n                        ParamTreap::join_with_priority(left_res, ak, ap, right_res)\n                    }\n                }\n            }\n        }"
  },
  {
    "id": 501,
    "function": "filter_inner",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "260-279",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(|t|), Span O(lg |t|)\n        /// - Claude-Opus-4.6: Work O(|t|), Span O(lg |t|)\n        fn filter_inner<F: Pred<T>>(tree: &Self, predicate: &Arc<F>) -> Self {\n            match tree.expose_with_priority() {\n                | None => ParamTreap::new(),\n                | Some((left, key, priority, right)) => {\n                    let pred_left = Arc::clone(predicate);\n                    let pred_right = Arc::clone(predicate);\n                    let Pair(left_filtered, right_filtered) =\n                        crate::ParaPair!(move || ParamTreap::filter_inner(&left, &pred_left), move || {\n                            ParamTreap::filter_inner(&right, &pred_right)\n                        });\n                    if (**predicate)(&key) {\n                        ParamTreap::join_with_priority(left_filtered, key, priority, right_filtered)\n                    } else {\n                        ParamTreap::join_pair_inner(left_filtered, right_filtered)\n                    }\n                }\n            }\n        }"
  },
  {
    "id": 502,
    "function": "filter_parallel",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "281-286",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(|t|), Span O(lg |t|)\n        /// - Claude-Opus-4.6: Work O(|t|), Span O(lg |t|)\n        fn filter_parallel<F: Pred<T>>(tree: &Self, predicate: F) -> Self {\n            let predicate = Arc::new(predicate);\n            ParamTreap::filter_inner(tree, &predicate)\n        }"
  },
  {
    "id": 503,
    "function": "reduce_inner",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "288-310",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(|t|), Span O(lg |t|)\n        /// - Claude-Opus-4.6: Work O(|t|), Span O(lg |t|)\n        fn reduce_inner<F>(tree: &Self, op: &Arc<F>, identity: T) -> T\n        where\n            F: Fn(T, T) -> T + Send + Sync + 'static,\n        {\n            match tree.expose_with_priority() {\n                | None => identity,\n                | Some((left, key, _priority, right)) => {\n                    let op_left = Arc::clone(op);\n                    let op_right = Arc::clone(op);\n                    let left_base = identity.clone();\n                    let right_base = identity;\n                    let Pair(left_acc, right_acc) = crate::ParaPair!(\n                        move || ParamTreap::reduce_inner(&left, &op_left, left_base),\n                        move || ParamTreap::reduce_inner(&right, &op_right, right_base)\n                    );\n                    let op_ref = op.as_ref();\n                    let right_with_key = op_ref(key, right_acc);\n                    op_ref(left_acc, right_with_key)\n                }\n            }\n        }"
  },
  {
    "id": 504,
    "function": "reduce_parallel",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "312-320",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(|t|), Span O(lg |t|)\n        /// - Claude-Opus-4.6: Work O(|t|), Span O(lg |t|)\n        fn reduce_parallel<F>(tree: &Self, op: F, base: T) -> T\n        where\n            F: Fn(T, T) -> T + Send + Sync + 'static,\n        {\n            let op = Arc::new(op);\n            ParamTreap::reduce_inner(tree, &op, base)\n        }"
  },
  {
    "id": 505,
    "function": "collect_in_order",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "322-333",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(|t|), Span O(|t|)\n        /// - Claude-Opus-4.6: Work O(|t|), Span O(|t|)\n        fn collect_in_order(tree: &Self, out: &mut Vec<T>) {\n            match tree.expose_internal() {\n                | Exposed::Leaf => {}\n                | Exposed::Node(left, key, right) => {\n                    ParamTreap::collect_in_order(&left, out);\n                    out.push(key);\n                    ParamTreap::collect_in_order(&right, out);\n                }\n            }\n        }"
  },
  {
    "id": 506,
    "function": "empty",
    "file": "Chap39/BSTSetTreapMtEph.rs",
    "lines": "40-42",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(1), Span Θ(1)\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        fn empty()                                   -> Self;"
  },
  {
    "id": 507,
    "function": "singleton",
    "file": "Chap39/BSTSetTreapMtEph.rs",
    "lines": "43-45",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(log n) expected, Span O(log n) expected\n        /// - Claude-Opus-4.6: Work Θ(log n) expected; Span Θ(log n) expected — singleton inserts one element\n        fn singleton(value: T)                       -> Self;"
  },
  {
    "id": 508,
    "function": "size",
    "file": "Chap39/BSTSetTreapMtEph.rs",
    "lines": "46-48",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(1), Span Θ(1)\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        fn size(&self)                               -> N;"
  },
  {
    "id": 509,
    "function": "is_empty",
    "file": "Chap39/BSTSetTreapMtEph.rs",
    "lines": "49-51",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(1), Span Θ(1)\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        fn is_empty(&self)                           -> B;"
  },
  {
    "id": 510,
    "function": "find",
    "file": "Chap39/BSTSetTreapMtEph.rs",
    "lines": "52-54",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(log n) expected, Span O(log n) expected\n        /// - Claude-Opus-4.6: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected\n        fn find(&self, value: &T)                    -> Option<T>;"
  },
  {
    "id": 511,
    "function": "contains",
    "file": "Chap39/BSTSetTreapMtEph.rs",
    "lines": "55-57",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(log n) expected, Span O(log n) expected\n        /// - Claude-Opus-4.6: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected\n        fn contains(&self, value: &T)                -> B;"
  },
  {
    "id": 512,
    "function": "minimum",
    "file": "Chap39/BSTSetTreapMtEph.rs",
    "lines": "58-60",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(log n) expected, Span O(log n) expected\n        /// - Claude-Opus-4.6: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected\n        fn minimum(&self)                            -> Option<T>;"
  },
  {
    "id": 513,
    "function": "maximum",
    "file": "Chap39/BSTSetTreapMtEph.rs",
    "lines": "61-63",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(log n) expected, Span O(log n) expected\n        /// - Claude-Opus-4.6: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected\n        fn maximum(&self)                            -> Option<T>;"
  },
  {
    "id": 514,
    "function": "insert",
    "file": "Chap39/BSTSetTreapMtEph.rs",
    "lines": "64-66",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(log n) expected, Span O(log n) expected\n        /// - Claude-Opus-4.6: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected\n        fn insert(&mut self, value: T);"
  },
  {
    "id": 515,
    "function": "delete",
    "file": "Chap39/BSTSetTreapMtEph.rs",
    "lines": "67-69",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(log n) expected, Span O(log n) expected\n        /// - Claude-Opus-4.6: Work Θ(n), Span Θ(n) — rebuild-based; not O(log n)\n        fn delete(&mut self, target: &T);"
  },
  {
    "id": 516,
    "function": "union",
    "file": "Chap39/BSTSetTreapMtEph.rs",
    "lines": "70-72",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(m · lg(n/m)), Span O(lg n)\n        /// - Claude-Opus-4.6: Work Θ(n + m), Span Θ(n + m) — sequential BTreeSet rebuild, not parallel\n        fn union(&self, other: &Self)                -> Self;"
  },
  {
    "id": 517,
    "function": "intersection",
    "file": "Chap39/BSTSetTreapMtEph.rs",
    "lines": "73-75",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(m · lg(n/m)), Span O(lg n)\n        /// - Claude-Opus-4.6: Work Θ(n + m), Span Θ(n + m) — sequential filter + rebuild, not parallel\n        fn intersection(&self, other: &Self)         -> Self;"
  },
  {
    "id": 518,
    "function": "difference",
    "file": "Chap39/BSTSetTreapMtEph.rs",
    "lines": "76-78",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(m · lg(n/m)), Span O(lg n)\n        /// - Claude-Opus-4.6: Work Θ(n + m), Span Θ(n + m) — sequential filter + rebuild, not parallel\n        fn difference(&self, other: &Self)           -> Self;"
  },
  {
    "id": 519,
    "function": "split",
    "file": "Chap39/BSTSetTreapMtEph.rs",
    "lines": "79-81",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(log n), Span O(log n)\n        /// - Claude-Opus-4.6: Work Θ(n), Span Θ(n) — sequential scan + rebuild, not O(log n)\n        fn split(&self, pivot: &T)                   -> (Self, B, Self);"
  },
  {
    "id": 520,
    "function": "join_pair",
    "file": "Chap39/BSTSetTreapMtEph.rs",
    "lines": "82-84",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(log(|left| + |right|)), Span O(log(|left| + |right|))\n        /// - Claude-Opus-4.6: Work Θ(n + m), Span Θ(n + m) — BTreeSet rebuild, not O(log n)\n        fn join_pair(left: Self, right: Self)        -> Self;"
  },
  {
    "id": 521,
    "function": "join_m",
    "file": "Chap39/BSTSetTreapMtEph.rs",
    "lines": "85-87",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(log(|left| + |right|)), Span O(log(|left| + |right|))\n        /// - Claude-Opus-4.6: Work Θ(n + m), Span Θ(n + m) — BTreeSet rebuild, not O(log n)\n        fn join_m(left: Self, pivot: T, right: Self) -> Self;"
  },
  {
    "id": 522,
    "function": "filter",
    "file": "Chap39/BSTSetTreapMtEph.rs",
    "lines": "88-90",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(n), Span O(lg n)\n        /// - Claude-Opus-4.6: Work Θ(n), Span Θ(n) — sequential filter + rebuild\n        fn filter<F: FnMut(&T) -> bool>(&self, predicate: F) -> Self;"
  },
  {
    "id": 523,
    "function": "reduce",
    "file": "Chap39/BSTSetTreapMtEph.rs",
    "lines": "91-93",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(n), Span O(lg n)\n        /// - Claude-Opus-4.6: Work Θ(n), Span Θ(n) — sequential fold\n        fn reduce<F: FnMut(T, T) -> T>(&self, op: F, base: T) -> T;"
  },
  {
    "id": 524,
    "function": "iter_in_order",
    "file": "Chap39/BSTSetTreapMtEph.rs",
    "lines": "94-96",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(n), Span Θ(n)\n        /// - Claude-Opus-4.6: Work Θ(n), Span Θ(n)\n        fn iter_in_order(&self)                      -> ArraySeqStPerS<T>;"
  },
  {
    "id": 525,
    "function": "as_tree",
    "file": "Chap39/BSTSetTreapMtEph.rs",
    "lines": "97-99",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(1), Span Θ(1)\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        fn as_tree(&self)                            -> &BSTTreapMtEph<T>;"
  },
  {
    "id": 526,
    "function": "values_vec",
    "file": "Chap39/BSTSetTreapMtEph.rs",
    "lines": "103-105",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(n), Span Θ(n)\n        /// - Claude-Opus-4.6: Work Θ(n), Span Θ(n)\n        fn values_vec(&self) -> Vec<T> { self.tree.in_order().iter().cloned().collect() }"
  },
  {
    "id": 527,
    "function": "rebuild_from_vec",
    "file": "Chap39/BSTSetTreapMtEph.rs",
    "lines": "106-114",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(n log n) expected, Span Θ(n log n) expected\n        /// - Claude-Opus-4.6: Work Θ(n log n) expected, Span Θ(n log n) expected — sequential n inserts\n        fn rebuild_from_vec(values: Vec<T>) -> BSTTreapMtEph<T> {\n            let tree = BSTTreapMtEph::new();\n            for value in values {\n                tree.insert(value);\n            }\n            tree\n        }"
  },
  {
    "id": 528,
    "function": "from_sorted_iter",
    "file": "Chap39/BSTSetTreapMtEph.rs",
    "lines": "115-126",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(n log n) expected, Span Θ(n log n) expected\n        /// - Claude-Opus-4.6: Work Θ(n log n) expected, Span Θ(n log n) expected — sequential n inserts\n        fn from_sorted_iter<I>(values: I) -> Self\n        where\n            I: IntoIterator<Item = T>,\n        {\n            let tree = BSTTreapMtEph::new();\n            for value in values {\n                tree.insert(value);\n            }\n            Self { tree }\n        }"
  },
  {
    "id": 529,
    "function": "new",
    "file": "Chap39/BSTTreapMtEph.rs",
    "lines": "44-46",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(1), Span Θ(1)\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        fn new()                       -> Self;"
  },
  {
    "id": 530,
    "function": "insert",
    "file": "Chap39/BSTTreapMtEph.rs",
    "lines": "47-49",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(log n) expected, Span O(log n) expected\n        /// - Claude-Opus-4.6: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected\n        fn insert(&self, value: T);"
  },
  {
    "id": 531,
    "function": "find",
    "file": "Chap39/BSTTreapMtEph.rs",
    "lines": "50-52",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(log n) expected, Span O(log n) expected\n        /// - Claude-Opus-4.6: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected\n        fn find(&self, target: &T)     -> Option<T>;"
  },
  {
    "id": 532,
    "function": "contains",
    "file": "Chap39/BSTTreapMtEph.rs",
    "lines": "53-55",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(log n) expected, Span O(log n) expected\n        /// - Claude-Opus-4.6: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected\n        fn contains(&self, target: &T) -> B;"
  },
  {
    "id": 533,
    "function": "size",
    "file": "Chap39/BSTTreapMtEph.rs",
    "lines": "56-58",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(1), Span Θ(1)\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        fn size(&self)                 -> N;"
  },
  {
    "id": 534,
    "function": "is_empty",
    "file": "Chap39/BSTTreapMtEph.rs",
    "lines": "59-61",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(1), Span Θ(1)\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        fn is_empty(&self)             -> B;"
  },
  {
    "id": 535,
    "function": "height",
    "file": "Chap39/BSTTreapMtEph.rs",
    "lines": "62-64",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(n), Span Θ(n)\n        /// - Claude-Opus-4.6: Work Θ(n), Span Θ(n)\n        fn height(&self)               -> N;"
  },
  {
    "id": 536,
    "function": "minimum",
    "file": "Chap39/BSTTreapMtEph.rs",
    "lines": "65-67",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(log n) expected, Span O(log n) expected\n        /// - Claude-Opus-4.6: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected\n        fn minimum(&self)              -> Option<T>;"
  },
  {
    "id": 537,
    "function": "maximum",
    "file": "Chap39/BSTTreapMtEph.rs",
    "lines": "68-70",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(log n) expected, Span O(log n) expected\n        /// - Claude-Opus-4.6: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected\n        fn maximum(&self)              -> Option<T>;"
  },
  {
    "id": 538,
    "function": "in_order",
    "file": "Chap39/BSTTreapMtEph.rs",
    "lines": "71-73",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(n), Span Θ(n)\n        /// - Claude-Opus-4.6: Work Θ(n), Span Θ(n)\n        fn in_order(&self)             -> ArraySeqStPerS<T>;"
  },
  {
    "id": 539,
    "function": "pre_order",
    "file": "Chap39/BSTTreapMtEph.rs",
    "lines": "74-76",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(n), Span Θ(n)\n        /// - Claude-Opus-4.6: Work Θ(n), Span Θ(n)\n        fn pre_order(&self)            -> ArraySeqStPerS<T>;"
  },
  {
    "id": 540,
    "function": "size_link",
    "file": "Chap39/BSTTreapMtEph.rs",
    "lines": "81-83",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(1), Span Θ(1)\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        fn size_link(link: &Link<T>) -> N { link.as_ref().map_or(0, |n| n.size) }"
  },
  {
    "id": 541,
    "function": "update",
    "file": "Chap39/BSTTreapMtEph.rs",
    "lines": "85-87",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(1), Span Θ(1)\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        fn update(node: &mut Node<T>) { node.size = 1 + Self::size_link(&node.left) + Self::size_link(&node.right); }"
  },
  {
    "id": 542,
    "function": "rotate_left",
    "file": "Chap39/BSTTreapMtEph.rs",
    "lines": "89-103",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(1), Span Θ(1)\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        fn rotate_left(link: &mut Link<T>) {\n            if let Some(mut x) = link.take() {\n                if let Some(mut y) = x.right.take() {\n                    x.right = y.left.take();\n                    Self::update(&mut x);\n                    Self::update(&mut y);\n                    y.left = Some(x);\n                    *link = Some(y);\n                } else {\n                    *link = Some(x);\n                }\n            }\n        }"
  },
  {
    "id": 543,
    "function": "rotate_right",
    "file": "Chap39/BSTTreapMtEph.rs",
    "lines": "105-119",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(1), Span Θ(1)\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        fn rotate_right(link: &mut Link<T>) {\n            if let Some(mut x) = link.take() {\n                if let Some(mut y) = x.left.take() {\n                    x.left = y.right.take();\n                    Self::update(&mut x);\n                    Self::update(&mut y);\n                    y.right = Some(x);\n                    *link = Some(y);\n                } else {\n                    *link = Some(x);\n                }\n            }\n        }"
  },
  {
    "id": 544,
    "function": "insert_link",
    "file": "Chap39/BSTTreapMtEph.rs",
    "lines": "121-142",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(log n) expected, Span O(log n) expected\n        /// - Claude-Opus-4.6: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected\n        fn insert_link(link: &mut Link<T>, value: T, rng: &mut impl Rng) {\n            if let Some(node) = link.as_mut() {\n                if value < node.key {\n                    Self::insert_link(&mut node.left, value, rng);\n                    if node.left.as_ref().is_some_and(|left| left.priority < node.priority) {\n                        Self::rotate_right(link);\n                    }\n                } else if value > node.key {\n                    Self::insert_link(&mut node.right, value, rng);\n                    if node.right.as_ref().is_some_and(|right| right.priority < node.priority) {\n                        Self::rotate_left(link);\n                    }\n                }\n                if let Some(node) = link.as_mut() {\n                    Self::update(node);\n                }\n            } else {\n                *link = Some(Box::new(Node::new(value, rng.random())));\n            }\n        }"
  },
  {
    "id": 545,
    "function": "find_link",
    "file": "Chap39/BSTTreapMtEph.rs",
    "lines": "144-159",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(log n) expected, Span O(log n) expected\n        /// - Claude-Opus-4.6: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected\n        fn find_link<'a>(link: &'a Link<T>, target: &T) -> Option<&'a T> {\n            match link {\n                | None => None,\n                | Some(node) => {\n                    if target == &node.key {\n                        Some(&node.key)\n                    } else if target < &node.key {\n                        Self::find_link(&node.left, target)\n                    } else {\n                        Self::find_link(&node.right, target)\n                    }\n                }\n            }\n        }"
  },
  {
    "id": 546,
    "function": "min_link",
    "file": "Chap39/BSTTreapMtEph.rs",
    "lines": "161-171",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(log n) expected, Span O(log n) expected\n        /// - Claude-Opus-4.6: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected\n        fn min_link(link: &Link<T>) -> Option<&T> {\n            match link {\n                | None => None,\n                | Some(node) => match node.left {\n                    | None => Some(&node.key),\n                    | Some(_) => Self::min_link(&node.left),\n                },\n            }\n        }"
  },
  {
    "id": 547,
    "function": "max_link",
    "file": "Chap39/BSTTreapMtEph.rs",
    "lines": "173-183",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(log n) expected, Span O(log n) expected\n        /// - Claude-Opus-4.6: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected\n        fn max_link(link: &Link<T>) -> Option<&T> {\n            match link {\n                | None => None,\n                | Some(node) => match node.right {\n                    | None => Some(&node.key),\n                    | Some(_) => Self::max_link(&node.right),\n                },\n            }\n        }"
  },
  {
    "id": 548,
    "function": "in_order_collect",
    "file": "Chap39/BSTTreapMtEph.rs",
    "lines": "185-193",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(n), Span Θ(n)\n        /// - Claude-Opus-4.6: Work Θ(n), Span Θ(n)\n        fn in_order_collect(link: &Link<T>, out: &mut Vec<T>) {\n            if let Some(node) = link {\n                Self::in_order_collect(&node.left, out);\n                out.push(node.key.clone());\n                Self::in_order_collect(&node.right, out);\n            }\n        }"
  },
  {
    "id": 549,
    "function": "pre_order_collect",
    "file": "Chap39/BSTTreapMtEph.rs",
    "lines": "195-203",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(n), Span Θ(n)\n        /// - Claude-Opus-4.6: Work Θ(n), Span Θ(n)\n        fn pre_order_collect(link: &Link<T>, out: &mut Vec<T>) {\n            if let Some(node) = link {\n                out.push(node.key.clone());\n                Self::pre_order_collect(&node.left, out);\n                Self::pre_order_collect(&node.right, out);\n            }\n        }"
  },
  {
    "id": 550,
    "function": "height_rec",
    "file": "Chap39/BSTTreapMtEph.rs",
    "lines": "234-239",
    "spec_strength": "",
    "snippet": "            fn height_rec<T: StTInMtT + Ord>(link: &Link<T>) -> N {\n                match link {\n                    | None => 0,\n                    | Some(node) => 1 + height_rec(&node.left).max(height_rec(&node.right)),\n                }\n            }"
  },
  {
    "id": 551,
    "function": "default",
    "file": "Chap39/BSTTreapMtEph.rs",
    "lines": "271",
    "spec_strength": "",
    "snippet": "        fn default() -> Self { Self::new() }"
  },
  {
    "id": 552,
    "function": "new_node",
    "file": "Chap39/BSTTreapStEph.rs",
    "lines": "22-32",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work Θ(1), Span Θ(1)\n    /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n    fn new_node<T: StT + Ord>(key: T, priority: u64) -> Node<T> {\n        Node {\n            key,\n            priority,\n            size: 1,\n            left: None,\n            right: None,\n        }\n    }"
  },
  {
    "id": 553,
    "function": "new",
    "file": "Chap39/BSTTreapStEph.rs",
    "lines": "42-44",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(1), Span Θ(1)\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        fn new()                       -> Self;"
  },
  {
    "id": 554,
    "function": "size",
    "file": "Chap39/BSTTreapStEph.rs",
    "lines": "45-47",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(1), Span Θ(1)\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        fn size(&self)                 -> N;"
  },
  {
    "id": 555,
    "function": "is_empty",
    "file": "Chap39/BSTTreapStEph.rs",
    "lines": "48-50",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(1), Span Θ(1)\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        fn is_empty(&self)             -> B;"
  },
  {
    "id": 556,
    "function": "height",
    "file": "Chap39/BSTTreapStEph.rs",
    "lines": "51-53",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(n), Span Θ(n)\n        /// - Claude-Opus-4.6: Work Θ(n), Span Θ(n)\n        fn height(&self)               -> N;"
  },
  {
    "id": 557,
    "function": "insert",
    "file": "Chap39/BSTTreapStEph.rs",
    "lines": "54-56",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(log n) expected, Span O(log n) expected\n        /// - Claude-Opus-4.6: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected\n        fn insert(&mut self, value: T);"
  },
  {
    "id": 558,
    "function": "find",
    "file": "Chap39/BSTTreapStEph.rs",
    "lines": "57-59",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(log n) expected, Span O(log n) expected\n        /// - Claude-Opus-4.6: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected\n        fn find(&self, target: &T)     -> Option<&T>;"
  },
  {
    "id": 559,
    "function": "contains",
    "file": "Chap39/BSTTreapStEph.rs",
    "lines": "60-62",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(log n) expected, Span O(log n) expected\n        /// - Claude-Opus-4.6: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected\n        fn contains(&self, target: &T) -> B;"
  },
  {
    "id": 560,
    "function": "minimum",
    "file": "Chap39/BSTTreapStEph.rs",
    "lines": "63-65",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(log n) expected, Span O(log n) expected\n        /// - Claude-Opus-4.6: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected\n        fn minimum(&self)              -> Option<&T>;"
  },
  {
    "id": 561,
    "function": "maximum",
    "file": "Chap39/BSTTreapStEph.rs",
    "lines": "66-68",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(log n) expected, Span O(log n) expected\n        /// - Claude-Opus-4.6: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected\n        fn maximum(&self)              -> Option<&T>;"
  },
  {
    "id": 562,
    "function": "in_order",
    "file": "Chap39/BSTTreapStEph.rs",
    "lines": "69-71",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(n), Span Θ(n)\n        /// - Claude-Opus-4.6: Work Θ(n), Span Θ(n)\n        fn in_order(&self)             -> ArraySeqStPerS<T>;"
  },
  {
    "id": 563,
    "function": "pre_order",
    "file": "Chap39/BSTTreapStEph.rs",
    "lines": "72-74",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(n), Span Θ(n)\n        /// - Claude-Opus-4.6: Work Θ(n), Span Θ(n)\n        fn pre_order(&self)            -> ArraySeqStPerS<T>;"
  },
  {
    "id": 564,
    "function": "size_link",
    "file": "Chap39/BSTTreapStEph.rs",
    "lines": "77-79",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work Θ(1), Span Θ(1)\n    /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n    fn size_link<T: StT + Ord>(link: &Link<T>) -> N { link.as_ref().map_or(0, |n| n.size) }"
  },
  {
    "id": 565,
    "function": "update",
    "file": "Chap39/BSTTreapStEph.rs",
    "lines": "81-83",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work Θ(1), Span Θ(1)\n    /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n    fn update<T: StT + Ord>(node: &mut Node<T>) { node.size = 1 + size_link(&node.left) + size_link(&node.right); }"
  },
  {
    "id": 566,
    "function": "rotate_left",
    "file": "Chap39/BSTTreapStEph.rs",
    "lines": "85-99",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work Θ(1), Span Θ(1)\n    /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n    fn rotate_left<T: StT + Ord>(link: &mut Link<T>) {\n        if let Some(mut x) = link.take() {\n            if let Some(mut y) = x.right.take() {\n                x.right = y.left.take();\n                update(&mut x);\n                update(&mut y);\n                y.left = Some(x);\n                *link = Some(y);\n            } else {\n                *link = Some(x);\n            }\n        }\n    }"
  },
  {
    "id": 567,
    "function": "rotate_right",
    "file": "Chap39/BSTTreapStEph.rs",
    "lines": "101-115",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work Θ(1), Span Θ(1)\n    /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n    fn rotate_right<T: StT + Ord>(link: &mut Link<T>) {\n        if let Some(mut x) = link.take() {\n            if let Some(mut y) = x.left.take() {\n                x.left = y.right.take();\n                update(&mut x);\n                update(&mut y);\n                y.right = Some(x);\n                *link = Some(y);\n            } else {\n                *link = Some(x);\n            }\n        }\n    }"
  },
  {
    "id": 568,
    "function": "insert_link",
    "file": "Chap39/BSTTreapStEph.rs",
    "lines": "117-138",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work O(log n) expected, Span O(log n) expected\n    /// - Claude-Opus-4.6: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected\n    fn insert_link<T: StT + Ord>(link: &mut Link<T>, value: T, rng: &mut impl Rng) {\n        if let Some(node) = link.as_mut() {\n            if value < node.key {\n                insert_link(&mut node.left, value, rng);\n                if node.left.as_ref().is_some_and(|left| left.priority < node.priority) {\n                    rotate_right(link);\n                }\n            } else if value > node.key {\n                insert_link(&mut node.right, value, rng);\n                if node.right.as_ref().is_some_and(|right| right.priority < node.priority) {\n                    rotate_left(link);\n                }\n            }\n            if let Some(node) = link.as_mut() {\n                update(node);\n            }\n        } else {\n            *link = Some(Box::new(new_node(value, rng.random())));\n        }\n    }"
  },
  {
    "id": 569,
    "function": "find_link",
    "file": "Chap39/BSTTreapStEph.rs",
    "lines": "140-155",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work O(log n) expected, Span O(log n) expected\n    /// - Claude-Opus-4.6: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected\n    fn find_link<'a, T: StT + Ord>(link: &'a Link<T>, target: &T) -> Option<&'a T> {\n        match link {\n            | None => None,\n            | Some(node) => {\n                if target == &node.key {\n                    Some(&node.key)\n                } else if target < &node.key {\n                    find_link(&node.left, target)\n                } else {\n                    find_link(&node.right, target)\n                }\n            }\n        }\n    }"
  },
  {
    "id": 570,
    "function": "min_link",
    "file": "Chap39/BSTTreapStEph.rs",
    "lines": "157-167",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work O(log n) expected, Span O(log n) expected\n    /// - Claude-Opus-4.6: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected\n    fn min_link<T: StT + Ord>(link: &Link<T>) -> Option<&T> {\n        match link {\n            | None => None,\n            | Some(node) => match node.left {\n                | None => Some(&node.key),\n                | Some(_) => min_link(&node.left),\n            },\n        }\n    }"
  },
  {
    "id": 571,
    "function": "max_link",
    "file": "Chap39/BSTTreapStEph.rs",
    "lines": "169-179",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work O(log n) expected, Span O(log n) expected\n    /// - Claude-Opus-4.6: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected\n    fn max_link<T: StT + Ord>(link: &Link<T>) -> Option<&T> {\n        match link {\n            | None => None,\n            | Some(node) => match node.right {\n                | None => Some(&node.key),\n                | Some(_) => max_link(&node.right),\n            },\n        }\n    }"
  },
  {
    "id": 572,
    "function": "in_order_collect",
    "file": "Chap39/BSTTreapStEph.rs",
    "lines": "181-189",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work Θ(n), Span Θ(n)\n    /// - Claude-Opus-4.6: Work Θ(n), Span Θ(n)\n    fn in_order_collect<T: StT + Ord>(link: &Link<T>, out: &mut Vec<T>) {\n        if let Some(node) = link {\n            in_order_collect(&node.left, out);\n            out.push(node.key.clone());\n            in_order_collect(&node.right, out);\n        }\n    }"
  },
  {
    "id": 573,
    "function": "pre_order_collect",
    "file": "Chap39/BSTTreapStEph.rs",
    "lines": "191-199",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work Θ(n), Span Θ(n)\n    /// - Claude-Opus-4.6: Work Θ(n), Span Θ(n)\n    fn pre_order_collect<T: StT + Ord>(link: &Link<T>, out: &mut Vec<T>) {\n        if let Some(node) = link {\n            out.push(node.key.clone());\n            pre_order_collect(&node.left, out);\n            pre_order_collect(&node.right, out);\n        }\n    }"
  },
  {
    "id": 574,
    "function": "height_rec",
    "file": "Chap39/BSTTreapStEph.rs",
    "lines": "209-214",
    "spec_strength": "",
    "snippet": "            fn height_rec<T: StT + Ord>(link: &Link<T>) -> N {\n                match link {\n                    | None => 0,\n                    | Some(node) => 1 + height_rec(&node.left).max(height_rec(&node.right)),\n                }\n            }"
  },
  {
    "id": 575,
    "function": "default",
    "file": "Chap39/BSTTreapStEph.rs",
    "lines": "245",
    "spec_strength": "",
    "snippet": "        fn default() -> Self { Self::new() }"
  },
  {
    "id": 576,
    "function": "new_node",
    "file": "Chap40/BSTKeyValueStEph.rs",
    "lines": "22-32",
    "spec_strength": "",
    "snippet": "    /// - APAS: N/A — internal node constructor.\n    /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n    fn new_node<K: StT + Ord, V: StT>(key: K, value: V, priority: u64) -> Node<K, V> {\n        Node {\n            key,\n            value,\n            priority,\n            left: None,\n            right: None,\n        }\n    }"
  },
  {
    "id": 577,
    "function": "new",
    "file": "Chap40/BSTKeyValueStEph.rs",
    "lines": "43-44",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn new()                    -> Self;"
  },
  {
    "id": 578,
    "function": "size",
    "file": "Chap40/BSTKeyValueStEph.rs",
    "lines": "45-46",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn size(&self)              -> N;"
  },
  {
    "id": 579,
    "function": "is_empty",
    "file": "Chap40/BSTKeyValueStEph.rs",
    "lines": "47-48",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn is_empty(&self)          -> B;"
  },
  {
    "id": 580,
    "function": "height",
    "file": "Chap40/BSTKeyValueStEph.rs",
    "lines": "49-50",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(n)\n        fn height(&self)            -> N;"
  },
  {
    "id": 581,
    "function": "insert",
    "file": "Chap40/BSTKeyValueStEph.rs",
    "lines": "51-52",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected, Parallelism Θ(1)\n        fn insert(&mut self, key: K, value: V);"
  },
  {
    "id": 582,
    "function": "find",
    "file": "Chap40/BSTKeyValueStEph.rs",
    "lines": "53-54",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected, Parallelism Θ(1)\n        fn find(&self, key: &K)     -> Option<&V>;"
  },
  {
    "id": 583,
    "function": "contains",
    "file": "Chap40/BSTKeyValueStEph.rs",
    "lines": "55-56",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected, Parallelism Θ(1)\n        fn contains(&self, key: &K) -> B;"
  },
  {
    "id": 584,
    "function": "get",
    "file": "Chap40/BSTKeyValueStEph.rs",
    "lines": "57-58",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected, Parallelism Θ(1)\n        fn get(&self, key: &K)      -> Option<&V>;"
  },
  {
    "id": 585,
    "function": "keys",
    "file": "Chap40/BSTKeyValueStEph.rs",
    "lines": "59-60",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)\n        fn keys(&self)              -> ArraySeqStPerS<K>;"
  },
  {
    "id": 586,
    "function": "values",
    "file": "Chap40/BSTKeyValueStEph.rs",
    "lines": "61-62",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)\n        fn values(&self)            -> ArraySeqStPerS<V>;"
  },
  {
    "id": 587,
    "function": "minimum_key",
    "file": "Chap40/BSTKeyValueStEph.rs",
    "lines": "63-65",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(log n) expected, Span Θ(log n) expected\n        /// - Claude-Opus-4.6: Work Θ(log n) expected, Span Θ(log n) expected\n        fn minimum_key(&self)       -> Option<&K>;"
  },
  {
    "id": 588,
    "function": "maximum_key",
    "file": "Chap40/BSTKeyValueStEph.rs",
    "lines": "66-68",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(log n) expected, Span Θ(log n) expected\n        /// - Claude-Opus-4.6: Work Θ(log n) expected, Span Θ(log n) expected\n        fn maximum_key(&self)       -> Option<&K>;"
  },
  {
    "id": 589,
    "function": "rotate_left",
    "file": "Chap40/BSTKeyValueStEph.rs",
    "lines": "71-83",
    "spec_strength": "",
    "snippet": "    /// - APAS: N/A — internal treap rotation.\n    /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n    fn rotate_left<K: StT + Ord, V: StT>(link: &mut Link<K, V>) {\n        if let Some(mut x) = link.take() {\n            if let Some(mut y) = x.right.take() {\n                x.right = y.left.take();\n                y.left = Some(x);\n                *link = Some(y);\n            } else {\n                *link = Some(x);\n            }\n        }\n    }"
  },
  {
    "id": 590,
    "function": "rotate_right",
    "file": "Chap40/BSTKeyValueStEph.rs",
    "lines": "85-97",
    "spec_strength": "",
    "snippet": "    /// - APAS: N/A — internal treap rotation.\n    /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n    fn rotate_right<K: StT + Ord, V: StT>(link: &mut Link<K, V>) {\n        if let Some(mut x) = link.take() {\n            if let Some(mut y) = x.left.take() {\n                x.left = y.right.take();\n                y.right = Some(x);\n                *link = Some(y);\n            } else {\n                *link = Some(x);\n            }\n        }\n    }"
  },
  {
    "id": 591,
    "function": "insert_link",
    "file": "Chap40/BSTKeyValueStEph.rs",
    "lines": "99-124",
    "spec_strength": "",
    "snippet": "    /// - APAS: N/A — internal recursive insert helper.\n    /// - Claude-Opus-4.6: Work Θ(log n) expected, Span Θ(log n) expected\n    fn insert_link<K: StT + Ord, V: StT>(link: &mut Link<K, V>, key: K, value: V, rng: &mut impl Rng) -> bool {\n        if let Some(node) = link.as_mut() {\n            if key < node.key {\n                let inserted = insert_link(&mut node.left, key, value, rng);\n                if node.left.as_ref().is_some_and(|left| left.priority < node.priority) {\n                    rotate_right(link);\n                }\n                inserted\n            } else if key > node.key {\n                let inserted = insert_link(&mut node.right, key, value, rng);\n                if node.right.as_ref().is_some_and(|right| right.priority < node.priority) {\n                    rotate_left(link);\n                }\n                inserted\n            } else {\n                // Key exists, update value\n                node.value = value;\n                false // No new insertion\n            }\n        } else {\n            *link = Some(Box::new(new_node(key, value, rng.random())));\n            true // New insertion\n        }\n    }"
  },
  {
    "id": 592,
    "function": "find_link",
    "file": "Chap40/BSTKeyValueStEph.rs",
    "lines": "126-141",
    "spec_strength": "",
    "snippet": "    /// - APAS: N/A — internal recursive find helper.\n    /// - Claude-Opus-4.6: Work Θ(log n) expected, Span Θ(log n) expected\n    fn find_link<'a, K: StT + Ord, V: StT>(link: &'a Link<K, V>, key: &K) -> Option<&'a V> {\n        match link {\n            | None => None,\n            | Some(node) => {\n                if key == &node.key {\n                    Some(&node.value)\n                } else if key < &node.key {\n                    find_link(&node.left, key)\n                } else {\n                    find_link(&node.right, key)\n                }\n            }\n        }\n    }"
  },
  {
    "id": 593,
    "function": "min_key_link",
    "file": "Chap40/BSTKeyValueStEph.rs",
    "lines": "143-153",
    "spec_strength": "",
    "snippet": "    /// - APAS: N/A — internal recursive min-key helper.\n    /// - Claude-Opus-4.6: Work Θ(log n) expected, Span Θ(log n) expected\n    fn min_key_link<K: StT + Ord, V: StT>(link: &Link<K, V>) -> Option<&K> {\n        match link {\n            | None => None,\n            | Some(node) => match node.left {\n                | None => Some(&node.key),\n                | Some(_) => min_key_link(&node.left),\n            },\n        }\n    }"
  },
  {
    "id": 594,
    "function": "max_key_link",
    "file": "Chap40/BSTKeyValueStEph.rs",
    "lines": "155-165",
    "spec_strength": "",
    "snippet": "    /// - APAS: N/A — internal recursive max-key helper.\n    /// - Claude-Opus-4.6: Work Θ(log n) expected, Span Θ(log n) expected\n    fn max_key_link<K: StT + Ord, V: StT>(link: &Link<K, V>) -> Option<&K> {\n        match link {\n            | None => None,\n            | Some(node) => match node.right {\n                | None => Some(&node.key),\n                | Some(_) => max_key_link(&node.right),\n            },\n        }\n    }"
  },
  {
    "id": 595,
    "function": "collect_keys",
    "file": "Chap40/BSTKeyValueStEph.rs",
    "lines": "167-175",
    "spec_strength": "",
    "snippet": "    /// - APAS: N/A — internal recursive key collection helper.\n    /// - Claude-Opus-4.6: Work Θ(n), Span Θ(n)\n    fn collect_keys<K: StT + Ord, V: StT>(link: &Link<K, V>, out: &mut Vec<K>) {\n        if let Some(node) = link {\n            collect_keys(&node.left, out);\n            out.push(node.key.clone());\n            collect_keys(&node.right, out);\n        }\n    }"
  },
  {
    "id": 596,
    "function": "collect_values",
    "file": "Chap40/BSTKeyValueStEph.rs",
    "lines": "177-185",
    "spec_strength": "",
    "snippet": "    /// - APAS: N/A — internal recursive value collection helper.\n    /// - Claude-Opus-4.6: Work Θ(n), Span Θ(n)\n    fn collect_values<K: StT + Ord, V: StT>(link: &Link<K, V>, out: &mut Vec<V>) {\n        if let Some(node) = link {\n            collect_values(&node.left, out);\n            out.push(node.value.clone());\n            collect_values(&node.right, out);\n        }\n    }"
  },
  {
    "id": 597,
    "function": "height_rec",
    "file": "Chap40/BSTKeyValueStEph.rs",
    "lines": "195-200",
    "spec_strength": "",
    "snippet": "            fn height_rec<K: StT + Ord, V: StT>(link: &Link<K, V>) -> N {\n                match link {\n                    | None => 0,\n                    | Some(node) => 1 + height_rec(&node.left).max(height_rec(&node.right)),\n                }\n            }"
  },
  {
    "id": 598,
    "function": "default",
    "file": "Chap40/BSTKeyValueStEph.rs",
    "lines": "236",
    "spec_strength": "",
    "snippet": "        fn default() -> Self { Self::new() }"
  },
  {
    "id": 599,
    "function": "identity`",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "28-29",
    "spec_strength": "",
    "snippet": "        /// Identity element for the reduction operation\n        fn identity()          -> R;"
  },
  {
    "id": 600,
    "function": "combine`",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "30-31",
    "spec_strength": "",
    "snippet": "        /// Associative binary operation: f(a, b)\n        fn combine(a: R, b: R) -> R;"
  },
  {
    "id": 601,
    "function": "lift`",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "32-33",
    "spec_strength": "",
    "snippet": "        /// Convert value to reduced form\n        fn lift(value: &V)     -> R;"
  },
  {
    "id": 602,
    "function": "new",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "83-84",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn new()                                  -> Self;"
  },
  {
    "id": 603,
    "function": "size",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "85-86",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn size(&self)                            -> N;"
  },
  {
    "id": 604,
    "function": "is_empty",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "87-88",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn is_empty(&self)                        -> B;"
  },
  {
    "id": 605,
    "function": "height",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "89-90",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(n)\n        fn height(&self)                          -> N;"
  },
  {
    "id": 606,
    "function": "insert",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "91-92",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected, Parallelism Θ(1)\n        fn insert(&mut self, key: K, value: V);"
  },
  {
    "id": 607,
    "function": "find",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "93-94",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected, Parallelism Θ(1)\n        fn find(&self, key: &K)                   -> Option<&V>;"
  },
  {
    "id": 608,
    "function": "contains",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "95-96",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected, Parallelism Θ(1)\n        fn contains(&self, key: &K)               -> B;"
  },
  {
    "id": 609,
    "function": "get",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "97-98",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected, Parallelism Θ(1)\n        fn get(&self, key: &K)                    -> Option<&V>;"
  },
  {
    "id": 610,
    "function": "keys",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "99-100",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)\n        fn keys(&self)                            -> ArraySeqStPerS<K>;"
  },
  {
    "id": 611,
    "function": "values",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "101-102",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)\n        fn values(&self)                          -> ArraySeqStPerS<V>;"
  },
  {
    "id": 612,
    "function": "minimum_key",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "103-105",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(log n) expected, Span Θ(log n) expected\n        /// - Claude-Opus-4.6: Work Θ(log n) expected, Span Θ(log n) expected\n        fn minimum_key(&self)                     -> Option<&K>;"
  },
  {
    "id": 613,
    "function": "maximum_key",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "106-108",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(log n) expected, Span Θ(log n) expected\n        /// - Claude-Opus-4.6: Work Θ(log n) expected, Span Θ(log n) expected\n        fn maximum_key(&self)                     -> Option<&K>;"
  },
  {
    "id": 614,
    "function": "reduced_value",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "109-111",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(1), Span Θ(1) — reads augmented field at root.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        fn reduced_value(&self)                   -> R;"
  },
  {
    "id": 615,
    "function": "range_reduce",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "112-114",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(log n), Span Θ(log n) — range query on augmented BST.\n        /// - Claude-Opus-4.6: Work Θ(log n), Span Θ(log n)\n        fn range_reduce(&self, low: &K, high: &K) -> R;"
  },
  {
    "id": 616,
    "function": "default",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "118",
    "spec_strength": "",
    "snippet": "        fn default() -> Self { Self::new() }"
  },
  {
    "id": 617,
    "function": "size_link",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "122-124",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(1), Span Θ(1) — O(1) via augmented size field.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        fn size_link(link: &Link<K, V, R>) -> N { link.as_ref().map_or(0, |n| n.size) }"
  },
  {
    "id": 618,
    "function": "reduced_value_link",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "126-131",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(1), Span Θ(1) — reads augmented reduced value.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        fn reduced_value_link(link: &Link<K, V, R>) -> R {\n            link.as_ref()\n                .map_or_else(|| Op::identity(), |n| n.reduced_value.clone())\n        }"
  },
  {
    "id": 619,
    "function": "update_node",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "133-144",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(1), Span Θ(1) — recomputes size and reduced value from children.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        fn update_node(node: &mut Node<K, V, R>) {\n            node.size = 1 + Self::size_link(&node.left) + Self::size_link(&node.right);\n\n            // Compute reduced value: f(left_reduced, f(node_value, right_reduced))\n            let left_reduced = Self::reduced_value_link(&node.left);\n            let right_reduced = Self::reduced_value_link(&node.right);\n            let node_reduced = Op::lift(&node.value);\n\n            node.reduced_value = Op::combine(left_reduced, Op::combine(node_reduced, right_reduced));\n        }"
  },
  {
    "id": 620,
    "function": "make_node",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "146-155",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(1), Span Θ(1) — corresponds to APAS makeNode with reduced values.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        fn make_node(key: K, value: V, priority: u64, left: Link<K, V, R>, right: Link<K, V, R>) -> Link<K, V, R> {\n            let node_reduced = Op::lift(&value);\n            let mut node = Node::new(key, value, priority, node_reduced);\n            node.left = left;\n            node.right = right;\n            Self::update_node(&mut node);\n            Some(Box::new(node))\n        }"
  },
  {
    "id": 621,
    "function": "rotate_left",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "157-171",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — internal treap rotation (updates sizes and reduced values).\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        fn rotate_left(link: &mut Link<K, V, R>) {\n            if let Some(mut x) = link.take() {\n                if let Some(mut y) = x.right.take() {\n                    x.right = y.left.take();\n                    Self::update_node(&mut x);\n                    Self::update_node(&mut y);\n                    y.left = Some(x);\n                    *link = Some(y);\n                } else {\n                    *link = Some(x);\n                }\n            }\n        }"
  },
  {
    "id": 622,
    "function": "rotate_right",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "173-187",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — internal treap rotation (updates sizes and reduced values).\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        fn rotate_right(link: &mut Link<K, V, R>) {\n            if let Some(mut x) = link.take() {\n                if let Some(mut y) = x.left.take() {\n                    x.left = y.right.take();\n                    Self::update_node(&mut x);\n                    Self::update_node(&mut y);\n                    y.right = Some(x);\n                    *link = Some(y);\n                } else {\n                    *link = Some(x);\n                }\n            }\n        }"
  },
  {
    "id": 623,
    "function": "insert_link",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "189-214",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — internal recursive insert helper.\n        /// - Claude-Opus-4.6: Work Θ(log n) expected, Span Θ(log n) expected\n        fn insert_link(link: &mut Link<K, V, R>, key: K, value: V, rng: &mut impl Rng) {\n            if let Some(node) = link.as_mut() {\n                if key < node.key {\n                    Self::insert_link(&mut node.left, key, value, rng);\n                    if node.left.as_ref().is_some_and(|left| left.priority < node.priority) {\n                        Self::rotate_right(link);\n                    }\n                } else if key > node.key {\n                    Self::insert_link(&mut node.right, key, value, rng);\n                    if node.right.as_ref().is_some_and(|right| right.priority < node.priority) {\n                        Self::rotate_left(link);\n                    }\n                } else {\n                    // Key exists, update value\n                    node.value = value;\n                }\n                if let Some(node) = link.as_mut() {\n                    Self::update_node(node);\n                }\n            } else {\n                let node_reduced = Op::lift(&value);\n                *link = Some(Box::new(Node::new(key, value, rng.random(), node_reduced)));\n            }\n        }"
  },
  {
    "id": 624,
    "function": "find_link",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "216-231",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — internal recursive find helper.\n        /// - Claude-Opus-4.6: Work Θ(log n) expected, Span Θ(log n) expected\n        fn find_link<'a>(link: &'a Link<K, V, R>, key: &K) -> Option<&'a V> {\n            match link {\n                | None => None,\n                | Some(node) => {\n                    if key == &node.key {\n                        Some(&node.value)\n                    } else if key < &node.key {\n                        Self::find_link(&node.left, key)\n                    } else {\n                        Self::find_link(&node.right, key)\n                    }\n                }\n            }\n        }"
  },
  {
    "id": 625,
    "function": "min_key_link",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "233-243",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — internal recursive min-key helper.\n        /// - Claude-Opus-4.6: Work Θ(log n) expected, Span Θ(log n) expected\n        fn min_key_link(link: &Link<K, V, R>) -> Option<&K> {\n            match link {\n                | None => None,\n                | Some(node) => match node.left {\n                    | None => Some(&node.key),\n                    | Some(_) => Self::min_key_link(&node.left),\n                },\n            }\n        }"
  },
  {
    "id": 626,
    "function": "max_key_link",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "245-255",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — internal recursive max-key helper.\n        /// - Claude-Opus-4.6: Work Θ(log n) expected, Span Θ(log n) expected\n        fn max_key_link(link: &Link<K, V, R>) -> Option<&K> {\n            match link {\n                | None => None,\n                | Some(node) => match node.right {\n                    | None => Some(&node.key),\n                    | Some(_) => Self::max_key_link(&node.right),\n                },\n            }\n        }"
  },
  {
    "id": 627,
    "function": "collect_keys",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "257-265",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — internal recursive key collection helper.\n        /// - Claude-Opus-4.6: Work Θ(n), Span Θ(n)\n        fn collect_keys(link: &Link<K, V, R>, out: &mut Vec<K>) {\n            if let Some(node) = link {\n                Self::collect_keys(&node.left, out);\n                out.push(node.key.clone());\n                Self::collect_keys(&node.right, out);\n            }\n        }"
  },
  {
    "id": 628,
    "function": "collect_values",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "267-275",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — internal recursive value collection helper.\n        /// - Claude-Opus-4.6: Work Θ(n), Span Θ(n)\n        fn collect_values(link: &Link<K, V, R>, out: &mut Vec<V>) {\n            if let Some(node) = link {\n                Self::collect_values(&node.left, out);\n                out.push(node.value.clone());\n                Self::collect_values(&node.right, out);\n            }\n        }"
  },
  {
    "id": 629,
    "function": "range_reduce_link",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "277-303",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(log n), Span Θ(log n) — range query on augmented BST.\n        /// - Claude-Opus-4.6: Work Θ(log n), Span Θ(log n)\n        fn range_reduce_link(link: &Link<K, V, R>, low: &K, high: &K) -> R {\n            match link {\n                | None => Op::identity(),\n                | Some(node) => {\n                    let mut result = Op::identity();\n\n                    // Include left subtree if it might contain keys >= low\n                    if &node.key > low {\n                        result = Op::combine(result, Self::range_reduce_link(&node.left, low, high));\n                    }\n\n                    // Include current node if it's in range\n                    if &node.key >= low && &node.key <= high {\n                        result = Op::combine(result, Op::lift(&node.value));\n                    }\n\n                    // Include right subtree if it might contain keys <= high\n                    if &node.key < high {\n                        result = Op::combine(result, Self::range_reduce_link(&node.right, low, high));\n                    }\n\n                    result\n                }\n            }\n        }"
  },
  {
    "id": 630,
    "function": "height_rec",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "321-326",
    "spec_strength": "",
    "snippet": "            fn height_rec<K: StT + Ord, V: StT, R: StT>(link: &Link<K, V, R>) -> N {\n                match link {\n                    | None => 0,\n                    | Some(node) => 1 + height_rec(&node.left).max(height_rec(&node.right)),\n                }\n            }"
  },
  {
    "id": 631,
    "function": "new",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "42-43",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn new()                       -> Self;"
  },
  {
    "id": 632,
    "function": "size",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "44-45",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn size(&self)                 -> N;"
  },
  {
    "id": 633,
    "function": "is_empty",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "46-47",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn is_empty(&self)             -> B;"
  },
  {
    "id": 634,
    "function": "height",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "48-49",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(n)\n        fn height(&self)               -> N;"
  },
  {
    "id": 635,
    "function": "insert",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "50-51",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected, Parallelism Θ(1)\n        fn insert(&mut self, value: T);"
  },
  {
    "id": 636,
    "function": "find",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "52-53",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected, Parallelism Θ(1)\n        fn find(&self, target: &T)     -> Option<&T>;"
  },
  {
    "id": 637,
    "function": "contains",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "54-55",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected, Parallelism Θ(1)\n        fn contains(&self, target: &T) -> B;"
  },
  {
    "id": 638,
    "function": "minimum",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "56-57",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected, Parallelism Θ(1)\n        fn minimum(&self)              -> Option<&T>;"
  },
  {
    "id": 639,
    "function": "maximum",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "58-59",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n) expected, Θ(n) worst case; Span Θ(log n) expected, Parallelism Θ(1)\n        fn maximum(&self)              -> Option<&T>;"
  },
  {
    "id": 640,
    "function": "in_order",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "60-61",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)\n        fn in_order(&self)             -> ArraySeqStPerS<T>;"
  },
  {
    "id": 641,
    "function": "rank",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "62-63",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn rank(&self, key: &T)        -> N;"
  },
  {
    "id": 642,
    "function": "select",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "64-66",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(log n) with size augmentation, Span Θ(log n)\n        /// - Claude-Opus-4.6: Work Θ(log n), Span Θ(log n)\n        fn select(&self, rank: N)      -> Option<&T>;"
  },
  {
    "id": 643,
    "function": "split_rank",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "67-69",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(log n), Span Θ(log n)\n        /// - Claude-Opus-4.6: Work Θ(log n), Span Θ(log n)\n        fn split_rank(&self, rank: N)  -> (BSTSizeStEph<T>, BSTSizeStEph<T>);"
  },
  {
    "id": 644,
    "function": "size_link",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "73-75",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(1), Span Θ(1) — O(1) size access via augmented field.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        fn size_link(link: &Link<T>) -> N { link.as_ref().map_or(0, |n| n.size) }"
  },
  {
    "id": 645,
    "function": "update_size",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "77-81",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(1), Span Θ(1) — recomputes subtree size from children.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        fn update_size(node: &mut Node<T>) {\n            node.size = 1 + Self::size_link(&node.left) + Self::size_link(&node.right);\n        }"
  },
  {
    "id": 646,
    "function": "make_node",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "83-91",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(1), Span Θ(1) — corresponds to APAS makeNode.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        fn make_node(key: T, priority: u64, left: Link<T>, right: Link<T>) -> Link<T> {\n            let mut node = Node::new(key, priority);\n            node.left = left;\n            node.right = right;\n            Self::update_size(&mut node);\n            Some(Box::new(node))\n        }"
  },
  {
    "id": 647,
    "function": "rotate_left",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "93-107",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — internal treap rotation (updates sizes).\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        fn rotate_left(link: &mut Link<T>) {\n            if let Some(mut x) = link.take() {\n                if let Some(mut y) = x.right.take() {\n                    x.right = y.left.take();\n                    Self::update_size(&mut x);\n                    Self::update_size(&mut y);\n                    y.left = Some(x);\n                    *link = Some(y);\n                } else {\n                    *link = Some(x);\n                }\n            }\n        }"
  },
  {
    "id": 648,
    "function": "rotate_right",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "109-123",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — internal treap rotation (updates sizes).\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        fn rotate_right(link: &mut Link<T>) {\n            if let Some(mut x) = link.take() {\n                if let Some(mut y) = x.left.take() {\n                    x.left = y.right.take();\n                    Self::update_size(&mut x);\n                    Self::update_size(&mut y);\n                    y.right = Some(x);\n                    *link = Some(y);\n                } else {\n                    *link = Some(x);\n                }\n            }\n        }"
  },
  {
    "id": 649,
    "function": "insert_link",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "125-146",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — internal recursive insert helper.\n        /// - Claude-Opus-4.6: Work Θ(log n) expected, Span Θ(log n) expected\n        fn insert_link(link: &mut Link<T>, value: T, rng: &mut impl Rng) {\n            if let Some(node) = link.as_mut() {\n                if value < node.key {\n                    Self::insert_link(&mut node.left, value, rng);\n                    if node.left.as_ref().is_some_and(|left| left.priority < node.priority) {\n                        Self::rotate_right(link);\n                    }\n                } else if value > node.key {\n                    Self::insert_link(&mut node.right, value, rng);\n                    if node.right.as_ref().is_some_and(|right| right.priority < node.priority) {\n                        Self::rotate_left(link);\n                    }\n                }\n                if let Some(node) = link.as_mut() {\n                    Self::update_size(node);\n                }\n            } else {\n                *link = Some(Box::new(Node::new(value, rng.random())));\n            }\n        }"
  },
  {
    "id": 650,
    "function": "find_link",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "148-163",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — internal recursive find helper.\n        /// - Claude-Opus-4.6: Work Θ(log n) expected, Span Θ(log n) expected\n        fn find_link<'a>(link: &'a Link<T>, target: &T) -> Option<&'a T> {\n            match link {\n                | None => None,\n                | Some(node) => {\n                    if target == &node.key {\n                        Some(&node.key)\n                    } else if target < &node.key {\n                        Self::find_link(&node.left, target)\n                    } else {\n                        Self::find_link(&node.right, target)\n                    }\n                }\n            }\n        }"
  },
  {
    "id": 651,
    "function": "min_link",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "165-175",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — internal recursive minimum helper.\n        /// - Claude-Opus-4.6: Work Θ(log n) expected, Span Θ(log n) expected\n        fn min_link(link: &Link<T>) -> Option<&T> {\n            match link {\n                | None => None,\n                | Some(node) => match node.left {\n                    | None => Some(&node.key),\n                    | Some(_) => Self::min_link(&node.left),\n                },\n            }\n        }"
  },
  {
    "id": 652,
    "function": "max_link",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "177-187",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — internal recursive maximum helper.\n        /// - Claude-Opus-4.6: Work Θ(log n) expected, Span Θ(log n) expected\n        fn max_link(link: &Link<T>) -> Option<&T> {\n            match link {\n                | None => None,\n                | Some(node) => match node.right {\n                    | None => Some(&node.key),\n                    | Some(_) => Self::max_link(&node.right),\n                },\n            }\n        }"
  },
  {
    "id": 653,
    "function": "in_order_collect",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "189-197",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — internal recursive in-order traversal helper.\n        /// - Claude-Opus-4.6: Work Θ(n), Span Θ(n)\n        fn in_order_collect(link: &Link<T>, out: &mut Vec<T>) {\n            if let Some(node) = link {\n                Self::in_order_collect(&node.left, out);\n                out.push(node.key.clone());\n                Self::in_order_collect(&node.right, out);\n            }\n        }"
  },
  {
    "id": 654,
    "function": "rank_link",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "199-215",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(log n) with size augmentation, Span Θ(log n) — Algorithm 40.1.\n        /// - Claude-Opus-4.6: Work Θ(log n), Span Θ(log n)\n        fn rank_link(link: &Link<T>, key: &T) -> N {\n            match link {\n                | None => 0,\n                | Some(node) => {\n                    let left_size = Self::size_link(&node.left);\n                    if key < &node.key {\n                        Self::rank_link(&node.left, key)\n                    } else if key == &node.key {\n                        left_size + 1\n                    } else {\n                        left_size + 1 + Self::rank_link(&node.right, key)\n                    }\n                }\n            }\n        }"
  },
  {
    "id": 655,
    "function": "select_link",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "217-233",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(log n) with size augmentation, Span Θ(log n) — Algorithm 40.1.\n        /// - Claude-Opus-4.6: Work Θ(log n), Span Θ(log n)\n        fn select_link(link: &Link<T>, rank: N) -> Option<&T> {\n            match link {\n                | None => None,\n                | Some(node) => {\n                    let left_size = Self::size_link(&node.left);\n                    if rank <= left_size {\n                        Self::select_link(&node.left, rank)\n                    } else if rank == left_size + 1 {\n                        Some(&node.key)\n                    } else {\n                        Self::select_link(&node.right, rank - left_size - 1)\n                    }\n                }\n            }\n        }"
  },
  {
    "id": 656,
    "function": "split_rank_link",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "235-253",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(log n), Span Θ(log n) — Exercise 40.1.\n        /// - Claude-Opus-4.6: Work Θ(log n), Span Θ(log n)\n        fn split_rank_link(link: &Link<T>, rank: N) -> (Link<T>, Link<T>) {\n            match link {\n                | None => (None, None),\n                | Some(node) => {\n                    let left_size = Self::size_link(&node.left);\n                    if rank <= left_size {\n                        let (ll, lr) = Self::split_rank_link(&node.left, rank);\n                        let right_tree = Self::make_node(node.key.clone(), node.priority, lr, node.right.clone());\n                        (ll, right_tree)\n                    } else {\n                        let (rl, rr) = Self::split_rank_link(&node.right, rank - left_size - 1);\n                        let left_tree = Self::make_node(node.key.clone(), node.priority, node.left.clone(), rl);\n                        (left_tree, rr)\n                    }\n                }\n            }\n        }"
  },
  {
    "id": 657,
    "function": "height_rec",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "264-269",
    "spec_strength": "",
    "snippet": "            fn height_rec<T: StT + Ord>(link: &Link<T>) -> N {\n                match link {\n                    | None => 0,\n                    | Some(node) => 1 + height_rec(&node.left).max(height_rec(&node.right)),\n                }\n            }"
  },
  {
    "id": 658,
    "function": "default",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "315",
    "spec_strength": "",
    "snippet": "        fn default() -> Self { Self::new() }"
  },
  {
    "id": 659,
    "function": "size",
    "file": "Chap41/AVLTreeSetMtEph.rs",
    "lines": "33-35",
    "spec_strength": "",
    "snippet": "        /// - APAS Cost Spec 41.4: Work 1, Span 1\n        /// - claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn size(&self)                               -> N;"
  },
  {
    "id": 660,
    "function": "to_seq",
    "file": "Chap41/AVLTreeSetMtEph.rs",
    "lines": "36-38",
    "spec_strength": "",
    "snippet": "        /// - APAS Cost Spec 41.4: Work |a|, Span lg |a|\n        /// - claude-4-sonet: Work Θ(n), Span Θ(n)\n        fn to_seq(&self)                             -> AVLTreeSeqStEphS<T>;"
  },
  {
    "id": 661,
    "function": "empty",
    "file": "Chap41/AVLTreeSetMtEph.rs",
    "lines": "39-41",
    "spec_strength": "",
    "snippet": "        /// - APAS Cost Spec 41.4: Work 1, Span 1\n        /// - claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn empty()                                   -> Self;"
  },
  {
    "id": 662,
    "function": "singleton",
    "file": "Chap41/AVLTreeSetMtEph.rs",
    "lines": "42-44",
    "spec_strength": "",
    "snippet": "        /// - APAS Cost Spec 41.4: Work 1, Span 1\n        /// - claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn singleton(x: T)                           -> Self;"
  },
  {
    "id": 663,
    "function": "from_seq",
    "file": "Chap41/AVLTreeSetMtEph.rs",
    "lines": "45-46",
    "spec_strength": "",
    "snippet": "        /// - claude-4-sonet: Work Θ(n log n), Span Θ(log n), Parallelism Θ(n)\n        fn from_seq(seq: AVLTreeSeqStEphS<T>)        -> Self;"
  },
  {
    "id": 664,
    "function": "filter",
    "file": "Chap41/AVLTreeSetMtEph.rs",
    "lines": "47-49",
    "spec_strength": "",
    "snippet": "        /// - APAS Cost Spec 41.4: Work Σ W(f(x)), Span lg |a| + max S(f(x))\n        /// - claude-4-sonet: Work Θ(n), Span Θ(log n), Parallelism Θ(n/log n)\n        fn filter<F: PredMt<T> + Clone>(&self, f: F) -> Self;"
  },
  {
    "id": 665,
    "function": "intersection",
    "file": "Chap41/AVLTreeSetMtEph.rs",
    "lines": "50-52",
    "spec_strength": "",
    "snippet": "        /// - APAS Cost Spec 41.4: Work m·lg(1+n/m), Span lg(n)\n        /// - claude-4-sonet: Work Θ(m + n), Span Θ(log(m + n)), Parallelism Θ((m+n)/log(m+n))\n        fn intersection(&self, other: &Self)         -> Self;"
  },
  {
    "id": 666,
    "function": "difference",
    "file": "Chap41/AVLTreeSetMtEph.rs",
    "lines": "53-55",
    "spec_strength": "",
    "snippet": "        /// - APAS Cost Spec 41.4: Work m·lg(1+n/m), Span lg(n)\n        /// - claude-4-sonet: Work Θ(m + n), Span Θ(log(m + n)), Parallelism Θ((m+n)/log(m+n))\n        fn difference(&self, other: &Self)           -> Self;"
  },
  {
    "id": 667,
    "function": "union",
    "file": "Chap41/AVLTreeSetMtEph.rs",
    "lines": "56-58",
    "spec_strength": "",
    "snippet": "        /// - APAS Cost Spec 41.4: Work m·lg(1+n/m), Span lg(n)\n        /// - claude-4-sonet: Work Θ(m + n), Span Θ(log(m + n)), Parallelism Θ((m+n)/log(m+n))\n        fn union(&self, other: &Self)                -> Self;"
  },
  {
    "id": 668,
    "function": "find",
    "file": "Chap41/AVLTreeSetMtEph.rs",
    "lines": "59-61",
    "spec_strength": "",
    "snippet": "        /// - APAS Cost Spec 41.4: Work lg |a|, Span lg |a|\n        /// - claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn find(&self, x: &T)                        -> B;"
  },
  {
    "id": 669,
    "function": "delete",
    "file": "Chap41/AVLTreeSetMtEph.rs",
    "lines": "62-64",
    "spec_strength": "",
    "snippet": "        /// - APAS Cost Spec 41.4: Work lg |a|, Span lg |a|\n        /// - claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn delete(&mut self, x: &T);"
  },
  {
    "id": 670,
    "function": "insert",
    "file": "Chap41/AVLTreeSetMtEph.rs",
    "lines": "65-67",
    "spec_strength": "",
    "snippet": "        /// - APAS Cost Spec 41.4: Work lg |a|, Span lg |a|\n        /// - claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn insert(&mut self, x: T);"
  },
  {
    "id": 671,
    "function": "parallel_filter",
    "file": "Chap41/AVLTreeSetMtEph.rs",
    "lines": "114-140",
    "spec_strength": "",
    "snippet": "            // Unconditionally parallel divide-and-conquer using ParaPair!\n            fn parallel_filter<T: StTInMtT + Ord + 'static, F: PredMt<T> + Clone>(vals: Vec<T>, f: F) -> Vec<T> {\n                let n = vals.len();\n                if n == 0 {\n                    return Vec::new();\n                }\n                if n == 1 {\n                    return if f(&vals[0]) { vals } else { Vec::new() };\n                }\n\n                let mid = n / 2;\n                let mut right_vals = vals;\n                let left_vals = right_vals.split_off(mid);\n                let right_vals_final = right_vals;\n\n                let f_left = f.clone();\n                let f_right = f;\n\n                let Pair(left_filtered, right_filtered) = ParaPair!(\n                    move || parallel_filter(left_vals, f_left),\n                    move || parallel_filter(right_vals_final, f_right)\n                );\n\n                let mut result = left_filtered;\n                result.extend(right_filtered);\n                result\n            }"
  },
  {
    "id": 672,
    "function": "parallel_intersect",
    "file": "Chap41/AVLTreeSetMtEph.rs",
    "lines": "171-202",
    "spec_strength": "",
    "snippet": "            // Unconditionally parallel divide-and-conquer using ParaPair!\n            fn parallel_intersect<T: StTInMtT + Ord + 'static>(self_vals: Vec<T>, other_vals: Vec<T>) -> Vec<T> {\n                let n = self_vals.len();\n                if n == 0 {\n                    return Vec::new();\n                }\n                if n == 1 {\n                    let other_set = AVLTreeSetMtEph::from_seq(AVLTreeSeqStEphS::from_vec(other_vals));\n                    return if other_set.find(&self_vals[0]) {\n                        self_vals\n                    } else {\n                        Vec::new()\n                    };\n                }\n\n                let mid = n / 2;\n                let mut right_self = self_vals;\n                let left_self = right_self.split_off(mid);\n                let right_self_final = right_self;\n\n                let other_left = other_vals.clone();\n                let other_right = other_vals;\n\n                let Pair(left_intersect, right_intersect) =\n                    ParaPair!(move || parallel_intersect(left_self, other_left), move || {\n                        parallel_intersect(right_self_final, other_right)\n                    });\n\n                let mut result = left_intersect;\n                result.extend(right_intersect);\n                result\n            }"
  },
  {
    "id": 673,
    "function": "default",
    "file": "Chap41/AVLTreeSetMtEph.rs",
    "lines": "266",
    "spec_strength": "",
    "snippet": "        fn default() -> Self { Self::empty() }"
  },
  {
    "id": 674,
    "function": "partial_cmp",
    "file": "Chap41/AVLTreeSetMtPer.rs",
    "lines": "34-36",
    "spec_strength": "",
    "snippet": "        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n            Some(self.cmp(other))\n        }"
  },
  {
    "id": 675,
    "function": "cmp",
    "file": "Chap41/AVLTreeSetMtPer.rs",
    "lines": "40-58",
    "spec_strength": "",
    "snippet": "        fn cmp(&self, other: &Self) -> Ordering {\n            // Lexicographic ordering: compare element by element (no cloning)\n            let n_self = self.size();\n            let n_other = other.size();\n            let min_n = n_self.min(n_other);\n            \n            // Compare common prefix\n            for i in 0..min_n {\n                let a = self.elements.nth(i);\n                let b = other.elements.nth(i);\n                match a.cmp(b) {\n                    Equal => continue,\n                    non_equal => return non_equal,\n                }\n            }\n            \n            // If all compared elements are equal, compare by size\n            n_self.cmp(&n_other)\n        }"
  },
  {
    "id": 676,
    "function": "size",
    "file": "Chap41/AVLTreeSetMtPer.rs",
    "lines": "62-64",
    "spec_strength": "",
    "snippet": "        /// - APAS Cost Spec 41.4: Work 1, Span 1\n        /// - claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn size(&self)                               -> N;"
  },
  {
    "id": 677,
    "function": "to_seq",
    "file": "Chap41/AVLTreeSetMtPer.rs",
    "lines": "65-67",
    "spec_strength": "",
    "snippet": "        /// - APAS Cost Spec 41.4: Work |a|, Span lg |a|\n        /// - claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn to_seq(&self)                             -> AVLTreeSeqMtPerS<T>;"
  },
  {
    "id": 678,
    "function": "empty",
    "file": "Chap41/AVLTreeSetMtPer.rs",
    "lines": "68-70",
    "spec_strength": "",
    "snippet": "        /// - APAS Cost Spec 41.4: Work 1, Span 1\n        /// - claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn empty()                                   -> Self;"
  },
  {
    "id": 679,
    "function": "singleton",
    "file": "Chap41/AVLTreeSetMtPer.rs",
    "lines": "71-73",
    "spec_strength": "",
    "snippet": "        /// - APAS Cost Spec 41.4: Work 1, Span 1\n        /// - claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn singleton(x: T)                           -> Self;"
  },
  {
    "id": 680,
    "function": "from_seq",
    "file": "Chap41/AVLTreeSetMtPer.rs",
    "lines": "74-75",
    "spec_strength": "",
    "snippet": "        /// - claude-4-sonet: Work Θ(n log n), Span Θ(log n), Parallelism Θ(n)\n        fn from_seq(seq: AVLTreeSeqMtPerS<T>)        -> Self;"
  },
  {
    "id": 681,
    "function": "filter",
    "file": "Chap41/AVLTreeSetMtPer.rs",
    "lines": "76-78",
    "spec_strength": "",
    "snippet": "        /// - APAS Cost Spec 41.4: Work Σ W(f(x)), Span lg |a| + max S(f(x))\n        /// - claude-4-sonet: Work Θ(n), Span Θ(log n), Parallelism Θ(n/log n)\n        fn filter<F: PredMt<T> + Clone>(&self, f: F) -> Self;"
  },
  {
    "id": 682,
    "function": "intersection",
    "file": "Chap41/AVLTreeSetMtPer.rs",
    "lines": "79-81",
    "spec_strength": "",
    "snippet": "        /// - APAS Cost Spec 41.4: Work m·lg(1+n/m), Span lg(n)\n        /// - claude-4-sonet: Work Θ(m + n), Span Θ(log(m + n)), Parallelism Θ((m+n)/log(m+n))\n        fn intersection(&self, other: &Self)         -> Self;"
  },
  {
    "id": 683,
    "function": "difference",
    "file": "Chap41/AVLTreeSetMtPer.rs",
    "lines": "82-84",
    "spec_strength": "",
    "snippet": "        /// - APAS Cost Spec 41.4: Work m·lg(1+n/m), Span lg(n)\n        /// - claude-4-sonet: Work Θ(m + n), Span Θ(log(m + n)), Parallelism Θ((m+n)/log(m+n))\n        fn difference(&self, other: &Self)           -> Self;"
  },
  {
    "id": 684,
    "function": "union",
    "file": "Chap41/AVLTreeSetMtPer.rs",
    "lines": "85-87",
    "spec_strength": "",
    "snippet": "        /// - APAS Cost Spec 41.4: Work m·lg(1+n/m), Span lg(n)\n        /// - claude-4-sonet: Work Θ(m + n), Span Θ(log(m + n)), Parallelism Θ((m+n)/log(m+n))\n        fn union(&self, other: &Self)                -> Self;"
  },
  {
    "id": 685,
    "function": "find",
    "file": "Chap41/AVLTreeSetMtPer.rs",
    "lines": "88-90",
    "spec_strength": "",
    "snippet": "        /// - APAS Cost Spec 41.4: Work lg |a|, Span lg |a|\n        /// - claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn find(&self, x: &T)                        -> B;"
  },
  {
    "id": 686,
    "function": "delete",
    "file": "Chap41/AVLTreeSetMtPer.rs",
    "lines": "91-93",
    "spec_strength": "",
    "snippet": "        /// - APAS Cost Spec 41.4: Work lg |a|, Span lg |a|\n        /// - claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn delete(&self, x: &T)                      -> Self;"
  },
  {
    "id": 687,
    "function": "insert",
    "file": "Chap41/AVLTreeSetMtPer.rs",
    "lines": "94-96",
    "spec_strength": "",
    "snippet": "        /// - APAS Cost Spec 41.4: Work lg |a|, Span lg |a|\n        /// - claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn insert(&self, x: T)                       -> Self;"
  },
  {
    "id": 688,
    "function": "parallel_sort",
    "file": "Chap41/AVLTreeSetMtPer.rs",
    "lines": "119-149",
    "spec_strength": "",
    "snippet": "            // Unconditionally parallel merge sort using ParaPair!\n            fn parallel_sort<T: StTInMtT + Ord + 'static>(mut vals: Vec<T>) -> Vec<T> {\n                let n = vals.len();\n                if n <= 1 {\n                    return vals;\n                }\n\n                let mid = n / 2;\n                let right_vals = vals.split_off(mid);\n                let left_vals = vals;\n\n                let Pair(left_sorted, right_sorted) =\n                    ParaPair!(move || parallel_sort(left_vals), move || parallel_sort(right_vals));\n\n                // Merge sorted halves\n                let mut result = Vec::with_capacity(n);\n                let mut i = 0;\n                let mut j = 0;\n                while i < left_sorted.len() && j < right_sorted.len() {\n                    if left_sorted[i] <= right_sorted[j] {\n                        result.push(left_sorted[i].clone());\n                        i += 1;\n                    } else {\n                        result.push(right_sorted[j].clone());\n                        j += 1;\n                    }\n                }\n                result.extend_from_slice(&left_sorted[i..]);\n                result.extend_from_slice(&right_sorted[j..]);\n                result\n            }"
  },
  {
    "id": 689,
    "function": "default",
    "file": "Chap41/AVLTreeSetMtPer.rs",
    "lines": "327",
    "spec_strength": "",
    "snippet": "        fn default() -> Self { Self::empty() }"
  },
  {
    "id": 690,
    "function": "size",
    "file": "Chap41/AVLTreeSetStEph.rs",
    "lines": "21-23",
    "spec_strength": "",
    "snippet": "        /// - APAS Cost Spec 41.4: Work 1, Span 1\n        /// - claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn size(&self)                        -> N;"
  },
  {
    "id": 691,
    "function": "to_seq",
    "file": "Chap41/AVLTreeSetStEph.rs",
    "lines": "24-26",
    "spec_strength": "",
    "snippet": "        /// - APAS Cost Spec 41.4: Work |a|, Span lg |a|\n        /// - claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)\n        fn to_seq(&self)                      -> AVLTreeSeqStEphS<T>;"
  },
  {
    "id": 692,
    "function": "empty",
    "file": "Chap41/AVLTreeSetStEph.rs",
    "lines": "27-29",
    "spec_strength": "",
    "snippet": "        /// - APAS Cost Spec 41.4: Work 1, Span 1\n        /// - claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn empty()                            -> Self;"
  },
  {
    "id": 693,
    "function": "singleton",
    "file": "Chap41/AVLTreeSetStEph.rs",
    "lines": "30-32",
    "spec_strength": "",
    "snippet": "        /// - APAS Cost Spec 41.4: Work 1, Span 1\n        /// - claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn singleton(x: T)                    -> Self;"
  },
  {
    "id": 694,
    "function": "from_seq",
    "file": "Chap41/AVLTreeSetStEph.rs",
    "lines": "33-34",
    "spec_strength": "",
    "snippet": "        /// - claude-4-sonet: Work Θ(n log n), Span Θ(n log n), Parallelism Θ(1)\n        fn from_seq(seq: AVLTreeSeqStEphS<T>) -> Self;"
  },
  {
    "id": 695,
    "function": "filter",
    "file": "Chap41/AVLTreeSetStEph.rs",
    "lines": "35-37",
    "spec_strength": "",
    "snippet": "        /// - APAS Cost Spec 41.4: Work Σ W(f(x)), Span lg |a| + max S(f(x))\n        /// - claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)\n        fn filter<F: PredSt<T>>(&self, f: F)  -> Self;"
  },
  {
    "id": 696,
    "function": "intersection",
    "file": "Chap41/AVLTreeSetStEph.rs",
    "lines": "38-40",
    "spec_strength": "",
    "snippet": "        /// - APAS Cost Spec 41.4: Work m·lg(1+n/m), Span lg(n)\n        /// - claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)\n        fn intersection(&self, other: &Self)  -> Self;"
  },
  {
    "id": 697,
    "function": "difference",
    "file": "Chap41/AVLTreeSetStEph.rs",
    "lines": "41-43",
    "spec_strength": "",
    "snippet": "        /// - APAS Cost Spec 41.4: Work m·lg(1+n/m), Span lg(n)\n        /// - claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)\n        fn difference(&self, other: &Self)    -> Self;"
  },
  {
    "id": 698,
    "function": "union",
    "file": "Chap41/AVLTreeSetStEph.rs",
    "lines": "44-46",
    "spec_strength": "",
    "snippet": "        /// - APAS Cost Spec 41.4: Work m·lg(1+n/m), Span lg(n)\n        /// - claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)\n        fn union(&self, other: &Self)         -> Self;"
  },
  {
    "id": 699,
    "function": "find",
    "file": "Chap41/AVLTreeSetStEph.rs",
    "lines": "47-49",
    "spec_strength": "",
    "snippet": "        /// - APAS Cost Spec 41.4: Work lg |a|, Span lg |a|\n        /// - claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn find(&self, x: &T)                 -> B;"
  },
  {
    "id": 700,
    "function": "delete",
    "file": "Chap41/AVLTreeSetStEph.rs",
    "lines": "50-52",
    "spec_strength": "",
    "snippet": "        /// - APAS Cost Spec 41.4: Work lg |a|, Span lg |a|\n        /// - claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn delete(&mut self, x: &T);"
  },
  {
    "id": 701,
    "function": "insert",
    "file": "Chap41/AVLTreeSetStEph.rs",
    "lines": "53-55",
    "spec_strength": "",
    "snippet": "        /// - APAS Cost Spec 41.4: Work lg |a|, Span lg |a|\n        /// - claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn insert(&mut self, x: T);"
  },
  {
    "id": 702,
    "function": "default",
    "file": "Chap41/AVLTreeSetStEph.rs",
    "lines": "191",
    "spec_strength": "",
    "snippet": "        fn default() -> Self { Self::empty() }"
  },
  {
    "id": 703,
    "function": "size",
    "file": "Chap41/AVLTreeSetStPer.rs",
    "lines": "21-23",
    "spec_strength": "",
    "snippet": "        /// - APAS Cost Spec 41.4: Work 1, Span 1\n        /// - claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn size(&self)                        -> N;"
  },
  {
    "id": 704,
    "function": "to_seq",
    "file": "Chap41/AVLTreeSetStPer.rs",
    "lines": "24-26",
    "spec_strength": "",
    "snippet": "        /// - APAS Cost Spec 41.4: Work |a|, Span lg |a|\n        /// - claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)\n        fn to_seq(&self)                      -> AVLTreeSeqStPerS<T>;"
  },
  {
    "id": 705,
    "function": "empty",
    "file": "Chap41/AVLTreeSetStPer.rs",
    "lines": "27-29",
    "spec_strength": "",
    "snippet": "        /// - APAS Cost Spec 41.4: Work 1, Span 1\n        /// - claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn empty()                            -> Self;"
  },
  {
    "id": 706,
    "function": "singleton",
    "file": "Chap41/AVLTreeSetStPer.rs",
    "lines": "30-32",
    "spec_strength": "",
    "snippet": "        /// - APAS Cost Spec 41.4: Work 1, Span 1\n        /// - claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn singleton(x: T)                    -> Self;"
  },
  {
    "id": 707,
    "function": "from_seq",
    "file": "Chap41/AVLTreeSetStPer.rs",
    "lines": "33-34",
    "spec_strength": "",
    "snippet": "        /// - claude-4-sonet: Work Θ(n log n), Span Θ(n log n), Parallelism Θ(1)\n        fn from_seq(seq: AVLTreeSeqStPerS<T>) -> Self;"
  },
  {
    "id": 708,
    "function": "filter",
    "file": "Chap41/AVLTreeSetStPer.rs",
    "lines": "35-37",
    "spec_strength": "",
    "snippet": "        /// - APAS Cost Spec 41.4: Work Σ W(f(x)), Span lg |a| + max S(f(x))\n        /// - claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)\n        fn filter<F: PredSt<T>>(&self, f: F)  -> Self;"
  },
  {
    "id": 709,
    "function": "intersection",
    "file": "Chap41/AVLTreeSetStPer.rs",
    "lines": "38-40",
    "spec_strength": "",
    "snippet": "        /// - APAS Cost Spec 41.4: Work m·lg(1+n/m), Span lg(n)\n        /// - claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)\n        fn intersection(&self, other: &Self)  -> Self;"
  },
  {
    "id": 710,
    "function": "difference",
    "file": "Chap41/AVLTreeSetStPer.rs",
    "lines": "41-43",
    "spec_strength": "",
    "snippet": "        /// - APAS Cost Spec 41.4: Work m·lg(1+n/m), Span lg(n)\n        /// - claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)\n        fn difference(&self, other: &Self)    -> Self;"
  },
  {
    "id": 711,
    "function": "union",
    "file": "Chap41/AVLTreeSetStPer.rs",
    "lines": "44-46",
    "spec_strength": "",
    "snippet": "        /// - APAS Cost Spec 41.4: Work m·lg(1+n/m), Span lg(n)\n        /// - claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)\n        fn union(&self, other: &Self)         -> Self;"
  },
  {
    "id": 712,
    "function": "find",
    "file": "Chap41/AVLTreeSetStPer.rs",
    "lines": "47-49",
    "spec_strength": "",
    "snippet": "        /// - APAS Cost Spec 41.4: Work lg |a|, Span lg |a|\n        /// - claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn find(&self, x: &T)                 -> B;"
  },
  {
    "id": 713,
    "function": "delete",
    "file": "Chap41/AVLTreeSetStPer.rs",
    "lines": "50-52",
    "spec_strength": "",
    "snippet": "        /// - APAS Cost Spec 41.4: Work lg |a|, Span lg |a|\n        /// - claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn delete(&self, x: &T)               -> Self;"
  },
  {
    "id": 714,
    "function": "insert",
    "file": "Chap41/AVLTreeSetStPer.rs",
    "lines": "53-55",
    "spec_strength": "",
    "snippet": "        /// - APAS Cost Spec 41.4: Work lg |a|, Span lg |a|\n        /// - claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn insert(&self, x: T)                -> Self;"
  },
  {
    "id": 715,
    "function": "default",
    "file": "Chap41/AVLTreeSetStPer.rs",
    "lines": "201",
    "spec_strength": "",
    "snippet": "        fn default() -> Self { Self::empty() }"
  },
  {
    "id": 716,
    "function": "new",
    "file": "Chap41/ArraySetEnumMtEph.rs",
    "lines": "24-25",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(u), Span Θ(1)\n        fn new(u: N)                                  -> Self;"
  },
  {
    "id": 717,
    "function": "size",
    "file": "Chap41/ArraySetEnumMtEph.rs",
    "lines": "26-28",
    "spec_strength": "",
    "snippet": "        /// - APAS Cost Spec 41.3: Work u, Span 1\n        /// - claude-4-sonet: Work Θ(u/w) where w is word size, Span Θ(u/w)\n        fn size(&self)                                -> N;"
  },
  {
    "id": 718,
    "function": "to_seq",
    "file": "Chap41/ArraySetEnumMtEph.rs",
    "lines": "29-31",
    "spec_strength": "",
    "snippet": "        /// - APAS Cost Spec 41.3: Work u, Span 1\n        /// - claude-4-sonet: Work Θ(|set|), Span Θ(|set|)\n        fn to_seq(&self)                              -> ArraySeqMtEphS<N>;"
  },
  {
    "id": 719,
    "function": "empty",
    "file": "Chap41/ArraySetEnumMtEph.rs",
    "lines": "32-33",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(u), Span Θ(1)\n        fn empty(u: N)                                -> Self;"
  },
  {
    "id": 720,
    "function": "singleton",
    "file": "Chap41/ArraySetEnumMtEph.rs",
    "lines": "34-36",
    "spec_strength": "",
    "snippet": "        /// - APAS Cost Spec 41.3: Work u, Span 1\n        /// - claude-4-sonet: Work Θ(u), Span Θ(1)\n        fn singleton(u: N, x: N)                      -> Self;"
  },
  {
    "id": 721,
    "function": "from_seq",
    "file": "Chap41/ArraySetEnumMtEph.rs",
    "lines": "37-38",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(u + |seq|), Span Θ(1)\n        fn from_seq(u: N, seq: ArraySeqMtEphS<N>)     -> Self;"
  },
  {
    "id": 722,
    "function": "filter",
    "file": "Chap41/ArraySetEnumMtEph.rs",
    "lines": "39-41",
    "spec_strength": "",
    "snippet": "        /// - APAS Cost Spec 41.3: Work u + Σ W(f(x)), Span 1 + max S(f(x))\n        /// - claude-4-sonet: Work Θ(u), Span Θ(log u), Parallelism Θ(u/log u)\n        fn filter<F: PredVal<N> + Clone>(&self, f: F) -> Self;"
  },
  {
    "id": 723,
    "function": "intersection",
    "file": "Chap41/ArraySetEnumMtEph.rs",
    "lines": "42-44",
    "spec_strength": "",
    "snippet": "        /// - APAS Cost Spec 41.3: Work u, Span 1\n        /// - claude-4-sonet: Work Θ(u/w), Span Θ(u/w)\n        fn intersection(&self, other: &Self)          -> Self;"
  },
  {
    "id": 724,
    "function": "difference",
    "file": "Chap41/ArraySetEnumMtEph.rs",
    "lines": "45-47",
    "spec_strength": "",
    "snippet": "        /// - APAS Cost Spec 41.3: Work u, Span 1\n        /// - claude-4-sonet: Work Θ(u/w), Span Θ(u/w)\n        fn difference(&self, other: &Self)            -> Self;"
  },
  {
    "id": 725,
    "function": "union",
    "file": "Chap41/ArraySetEnumMtEph.rs",
    "lines": "48-50",
    "spec_strength": "",
    "snippet": "        /// - APAS Cost Spec 41.3: Work u, Span 1\n        /// - claude-4-sonet: Work Θ(u/w), Span Θ(u/w)\n        fn union(&self, other: &Self)                 -> Self;"
  },
  {
    "id": 726,
    "function": "find",
    "file": "Chap41/ArraySetEnumMtEph.rs",
    "lines": "51-53",
    "spec_strength": "",
    "snippet": "        /// - APAS Cost Spec 41.3: Work 1, Span 1\n        /// - claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn find(&self, x: N)                          -> B;"
  },
  {
    "id": 727,
    "function": "delete",
    "file": "Chap41/ArraySetEnumMtEph.rs",
    "lines": "54-56",
    "spec_strength": "",
    "snippet": "        /// - APAS Cost Spec 41.3: Work u, Span 1\n        /// - claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn delete(&mut self, x: N);"
  },
  {
    "id": 728,
    "function": "insert",
    "file": "Chap41/ArraySetEnumMtEph.rs",
    "lines": "57-59",
    "spec_strength": "",
    "snippet": "        /// - APAS Cost Spec 41.3: Work u, Span 1\n        /// - claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn insert(&mut self, x: N);"
  },
  {
    "id": 729,
    "function": "size",
    "file": "Chap41/ArraySetStEph.rs",
    "lines": "17-18",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn size(&self)                       -> N;"
  },
  {
    "id": 730,
    "function": "to_seq",
    "file": "Chap41/ArraySetStEph.rs",
    "lines": "19-20",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn to_seq(&self)                     -> ArraySeqStEphS<T>;"
  },
  {
    "id": 731,
    "function": "empty",
    "file": "Chap41/ArraySetStEph.rs",
    "lines": "21-22",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn empty()                           -> Self;"
  },
  {
    "id": 732,
    "function": "singleton",
    "file": "Chap41/ArraySetStEph.rs",
    "lines": "23-24",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn singleton(x: T)                   -> Self;"
  },
  {
    "id": 733,
    "function": "from_seq",
    "file": "Chap41/ArraySetStEph.rs",
    "lines": "25-26",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n log n), Span Θ(n log n), Parallelism Θ(1)\n        fn from_seq(seq: ArraySeqStEphS<T>)  -> Self;"
  },
  {
    "id": 734,
    "function": "filter",
    "file": "Chap41/ArraySetStEph.rs",
    "lines": "27-28",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)\n        fn filter<F: PredSt<T>>(&self, f: F) -> Self;"
  },
  {
    "id": 735,
    "function": "intersection",
    "file": "Chap41/ArraySetStEph.rs",
    "lines": "29-30",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(m + n), Span Θ(m + n), Parallelism Θ(1)\n        fn intersection(&self, other: &Self) -> Self;"
  },
  {
    "id": 736,
    "function": "difference",
    "file": "Chap41/ArraySetStEph.rs",
    "lines": "31-32",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(m + n), Span Θ(m + n), Parallelism Θ(1)\n        fn difference(&self, other: &Self)   -> Self;"
  },
  {
    "id": 737,
    "function": "union",
    "file": "Chap41/ArraySetStEph.rs",
    "lines": "33-34",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(m + n), Span Θ(m + n), Parallelism Θ(1)\n        fn union(&self, other: &Self)        -> Self;"
  },
  {
    "id": 738,
    "function": "find",
    "file": "Chap41/ArraySetStEph.rs",
    "lines": "35-36",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn find(&self, x: &T)                -> B;"
  },
  {
    "id": 739,
    "function": "delete",
    "file": "Chap41/ArraySetStEph.rs",
    "lines": "37-38",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)\n        fn delete(&mut self, x: &T);"
  },
  {
    "id": 740,
    "function": "insert",
    "file": "Chap41/ArraySetStEph.rs",
    "lines": "39-40",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)\n        fn insert(&mut self, x: T);"
  },
  {
    "id": 741,
    "function": "default",
    "file": "Chap41/ArraySetStEph.rs",
    "lines": "176",
    "spec_strength": "",
    "snippet": "        fn default() -> Self { Self::empty() }"
  },
  {
    "id": 742,
    "function": "example_41_1_array_set",
    "file": "Chap41/Example41_3.rs",
    "lines": "15-17",
    "spec_strength": "",
    "snippet": "        /// Example 41.1 cases using ArraySetStEph\n        /// APAS: Work Θ(n log n), Span Θ(log n)\n        fn example_41_1_array_set();"
  },
  {
    "id": 743,
    "function": "example_41_1_avl_set",
    "file": "Chap41/Example41_3.rs",
    "lines": "19-21",
    "spec_strength": "",
    "snippet": "        /// Example 41.1 cases using AVLTreeSetStEph\n        /// APAS: Work Θ(n log n), Span Θ(log n)\n        fn example_41_1_avl_set();"
  },
  {
    "id": 744,
    "function": "demonstrate_set_operations",
    "file": "Chap41/Example41_3.rs",
    "lines": "23-25",
    "spec_strength": "",
    "snippet": "        /// Demonstrate set operations with different implementations\n        /// APAS: Work Θ(n log n), Span Θ(log n)\n        fn demonstrate_set_operations();"
  },
  {
    "id": 745,
    "function": "example_41_3_from_seq_demonstration",
    "file": "Chap41/Example41_3.rs",
    "lines": "128-172",
    "spec_strength": "",
    "snippet": "    pub fn example_41_3_from_seq_demonstration() {\n        // Example 41.3: Two implementations of fromSeq\n\n        // Sequential version: fromseq a = Seq.iterate Set.insert ∅ a\n        // (This would be implemented as a simple loop with insert)\n\n        // Parallel version: fromSeq a = Seq.reduce Set.union ∅ ⟨{x} : x ∈ a⟩\n        // This is what our implementation uses\n\n        let seq = ArraySeqStEphSLit![1, 3, 2, 3, 1, 4, 2];\n        let set_result = ArraySetStEph::from_seq(seq);\n\n        // Should contain unique elements: {1, 2, 3, 4}\n        assert_eq!(set_result.size(), 4);\n        assert!(set_result.find(&1));\n        assert!(set_result.find(&2));\n        assert!(set_result.find(&3));\n        assert!(set_result.find(&4));\n\n        // Demonstrate the conceptual steps:\n        // 1. Create singleton sets: ⟨{1}, {3}, {2}, {3}, {1}, {4}, {2}⟩\n        // 2. Reduce with union: {1} ∪ {3} ∪ {2} ∪ {3} ∪ {1} ∪ {4} ∪ {2} = {1, 2, 3, 4}\n\n        let singleton1 = ArraySetStEph::singleton(1);\n        let singleton3 = ArraySetStEph::singleton(3);\n        let singleton2 = ArraySetStEph::singleton(2);\n        let singleton4 = ArraySetStEph::singleton(4);\n\n        let manual_union = singleton1\n            .union(&singleton3)\n            .union(&singleton2)\n            .union(&singleton3) // duplicate, should not change result\n            .union(&singleton1) // duplicate, should not change result\n            .union(&singleton4)\n            .union(&singleton2); // duplicate, should not change result\n\n        assert_eq!(manual_union.size(), 4);\n        assert!(manual_union.find(&1));\n        assert!(manual_union.find(&2));\n        assert!(manual_union.find(&3));\n        assert!(manual_union.find(&4));\n\n        // Both approaches should yield the same result\n        assert_eq!(set_result.size(), manual_union.size());\n    }"
  },
  {
    "id": 746,
    "function": "additional_set_operations",
    "file": "Chap41/Example41_3.rs",
    "lines": "174-215",
    "spec_strength": "",
    "snippet": "    pub fn additional_set_operations() {\n        // Additional set operations testing\n        let set1 = ArraySetStEphLit![1, 2, 3, 4, 5];\n        let set2 = ArraySetStEphLit![4, 5, 6, 7, 8];\n\n        // Intersection: {1, 2, 3, 4, 5} ∩ {4, 5, 6, 7, 8} = {4, 5}\n        let intersection = set1.intersection(&set2);\n        assert_eq!(intersection.size(), 2);\n        assert!(intersection.find(&4));\n        assert!(intersection.find(&5));\n        assert!(!intersection.find(&1));\n        assert!(!intersection.find(&6));\n\n        // Difference: {1, 2, 3, 4, 5} \\ {4, 5, 6, 7, 8} = {1, 2, 3}\n        let difference = set1.difference(&set2);\n        assert_eq!(difference.size(), 3);\n        assert!(difference.find(&1));\n        assert!(difference.find(&2));\n        assert!(difference.find(&3));\n        assert!(!difference.find(&4));\n        assert!(!difference.find(&5));\n\n        // Delete operation\n        let mut set_delete = ArraySetStEphLit![1, 2, 3, 4, 5];\n        set_delete.delete(&3);\n        assert_eq!(set_delete.size(), 4);\n        assert!(!set_delete.find(&3));\n        assert!(set_delete.find(&1));\n        assert!(set_delete.find(&2));\n        assert!(set_delete.find(&4));\n        assert!(set_delete.find(&5));\n\n        // Insert operation\n        let mut set_insert = ArraySetStEphLit![1, 2, 4, 5];\n        set_insert.insert(3);\n        assert_eq!(set_insert.size(), 5);\n        assert!(set_insert.find(&3));\n\n        // Insert duplicate (should not change size)\n        set_insert.insert(3);\n        assert_eq!(set_insert.size(), 5);\n    }"
  },
  {
    "id": 747,
    "function": "example_42_1",
    "file": "Chap42/Example42_1.rs",
    "lines": "15-17",
    "spec_strength": "",
    "snippet": "        /// Example 42.1: Basic table operations demonstration\n        /// APAS: Work Θ(n log n), Span Θ(log n)\n        fn example_42_1();"
  },
  {
    "id": 748,
    "function": "demonstrate_table_operations",
    "file": "Chap42/Example42_1.rs",
    "lines": "19-21",
    "spec_strength": "",
    "snippet": "        /// Demonstrate table operations with different implementations\n        /// APAS: Work Θ(n log n), Span Θ(log n)\n        fn demonstrate_table_operations();"
  },
  {
    "id": 749,
    "function": "performance_comparison",
    "file": "Chap42/Example42_1.rs",
    "lines": "145-196",
    "spec_strength": "",
    "snippet": "    /// Demonstrate performance characteristics of different table implementations\n    pub fn performance_comparison() {\n        println!(\"\\n=== Performance Comparison ===\");\n\n        let size = 1000;\n        println!(\"Building tables with {size} entries...\");\n\n        // Build persistent table\n        let start = std::time::Instant::now();\n        let mut table_per = TableStPer::empty();\n        for i in 0..size {\n            table_per = table_per.insert(i, format!(\"value_{i}\"), |_old, new| new.clone());\n        }\n        let per_time = start.elapsed();\n        println!(\"Persistent table construction: {per_time:?}\");\n\n        // Build ephemeral table\n        let start = std::time::Instant::now();\n        let mut table_eph = TableStEph::empty();\n        for i in 0..size {\n            table_eph.insert(i, format!(\"value_{i}\"), |_old, new| new.clone());\n        }\n        let eph_time = start.elapsed();\n        println!(\"Ephemeral table construction: {eph_time:?}\");\n\n        // Build multi-threaded table\n        let start = std::time::Instant::now();\n        let mut table_mt = TableMtEph::empty();\n        for i in 0..size {\n            table_mt.insert(i, format!(\"value_{i}\"), |_old, new| new.clone());\n        }\n        let mt_time = start.elapsed();\n        println!(\"Multi-threaded table construction: {mt_time:?}\");\n\n        // Test map operation performance\n        println!(\"\\nMap operation performance:\");\n\n        let start = std::time::Instant::now();\n        let _mapped_per = table_per.map(|s| s.to_uppercase());\n        let per_map_time = start.elapsed();\n        println!(\"Persistent map: {per_map_time:?}\");\n\n        let start = std::time::Instant::now();\n        table_eph.map(|s| s.to_uppercase());\n        let eph_map_time = start.elapsed();\n        println!(\"Ephemeral map: {eph_map_time:?}\");\n\n        let start = std::time::Instant::now();\n        table_mt.map(|s| s.to_uppercase());\n        let mt_map_time = start.elapsed();\n        println!(\"Multi-threaded map: {mt_map_time:?}\");\n    }"
  },
  {
    "id": 750,
    "function": "size",
    "file": "Chap42/TableMtEph.rs",
    "lines": "32-34",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(1), Span Θ(1)\n        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn size(&self)                 -> N;"
  },
  {
    "id": 751,
    "function": "empty",
    "file": "Chap42/TableMtEph.rs",
    "lines": "35-37",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(1), Span Θ(1)\n        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn empty()                     -> Self;"
  },
  {
    "id": 752,
    "function": "singleton",
    "file": "Chap42/TableMtEph.rs",
    "lines": "38-40",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(1), Span Θ(1)\n        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn singleton(key: K, value: V) -> Self;"
  },
  {
    "id": 753,
    "function": "domain",
    "file": "Chap42/TableMtEph.rs",
    "lines": "41-43",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(|a|), Span Θ(lg |a|)\n        /// claude-4-sonet: Work Θ(n log n), Span Θ(log n), Parallelism Θ(n)\n        fn domain(&self)               -> ArraySetStEph<K>;"
  },
  {
    "id": 754,
    "function": "tabulate",
    "file": "Chap42/TableMtEph.rs",
    "lines": "44-46",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(|s| * W(f)), Span Θ(lg |s| + S(f))\n        /// claude-4-sonet: Work Θ(|keys| × W(f)), Span Θ(log |keys| + S(f)), Parallelism Θ(|keys|/(log |keys| + S(f)))\n        fn tabulate<F: Fn(&K) -> V + Send + Sync + 'static>(f: F, keys: &ArraySetStEph<K>) -> Self;"
  },
  {
    "id": 755,
    "function": "map",
    "file": "Chap42/TableMtEph.rs",
    "lines": "47-49",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(Σ W(f(v))), Span Θ(lg |a| + max S(f(v)))\n        /// claude-4-sonet: Work Θ(n × W(f)), Span Θ(log n + S(f)), Parallelism Θ(n/(log n + S(f)))\n        fn map<F: Fn(&V) -> V + Send + Sync + 'static>(&mut self, f: F);"
  },
  {
    "id": 756,
    "function": "filter",
    "file": "Chap42/TableMtEph.rs",
    "lines": "50-52",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(Σ W(p(k,v))), Span Θ(lg |a| + max S(p(k,v)))\n        /// claude-4-sonet: Work Θ(n × W(f)), Span Θ(log n + S(f)), Parallelism Θ(n/(log n + S(f)))\n        fn filter<F: Fn(&K, &V) -> B + Send + Sync + 'static>(&mut self, f: F);"
  },
  {
    "id": 757,
    "function": "intersection",
    "file": "Chap42/TableMtEph.rs",
    "lines": "53-55",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(m * lg(1 + n/m)), Span Θ(lg(n + m))\n        /// claude-4-sonet: Work Θ(m + n), Span Θ(log(m + n)), Parallelism Θ((m+n)/log(m+n))\n        fn intersection<F: Fn(&V, &V) -> V + Send + Sync + 'static>(&mut self, other: &Self, combine: F);"
  },
  {
    "id": 758,
    "function": "union",
    "file": "Chap42/TableMtEph.rs",
    "lines": "56-58",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(m * lg(1 + n/m)), Span Θ(lg(n + m))\n        /// claude-4-sonet: Work Θ(m + n), Span Θ(log(m + n)), Parallelism Θ((m+n)/log(m+n))\n        fn union<F: Fn(&V, &V) -> V + Send + Sync + 'static>(&mut self, other: &Self, combine: F);"
  },
  {
    "id": 759,
    "function": "difference",
    "file": "Chap42/TableMtEph.rs",
    "lines": "59-61",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(m * lg(1 + n/m)), Span Θ(lg(n + m))\n        /// claude-4-sonet: Work Θ(m + n), Span Θ(log(m + n)), Parallelism Θ((m+n)/log(m+n))\n        fn difference(&mut self, other: &Self);"
  },
  {
    "id": 760,
    "function": "find",
    "file": "Chap42/TableMtEph.rs",
    "lines": "62-64",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(lg |a|), Span Θ(lg |a|)\n        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn find(&self, key: &K)        -> Option<V>;"
  },
  {
    "id": 761,
    "function": "delete",
    "file": "Chap42/TableMtEph.rs",
    "lines": "65-67",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(lg |a|), Span Θ(lg |a|)\n        /// claude-4-sonet: Work Θ(n), Span Θ(log n), Parallelism Θ(n/log n)\n        fn delete(&mut self, key: &K);"
  },
  {
    "id": 762,
    "function": "insert",
    "file": "Chap42/TableMtEph.rs",
    "lines": "68-70",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(lg |a|), Span Θ(lg |a|)\n        /// claude-4-sonet: Work Θ(n), Span Θ(log n), Parallelism Θ(n/log n)\n        fn insert<F: Fn(&V, &V) -> V + Send + Sync + 'static>(&mut self, key: K, value: V, combine: F);"
  },
  {
    "id": 763,
    "function": "restrict",
    "file": "Chap42/TableMtEph.rs",
    "lines": "71-73",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(m * lg(1 + n/m)), Span Θ(lg(n + m))\n        /// claude-4-sonet: Work Θ(m + n), Span Θ(log(m + n)), Parallelism Θ((m+n)/log(m+n))\n        fn restrict(&mut self, keys: &ArraySetStEph<K>);"
  },
  {
    "id": 764,
    "function": "subtract",
    "file": "Chap42/TableMtEph.rs",
    "lines": "74-76",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(m * lg(1 + n/m)), Span Θ(lg(n + m))\n        /// claude-4-sonet: Work Θ(m + n), Span Θ(log(m + n)), Parallelism Θ((m+n)/log(m+n))\n        fn subtract(&mut self, keys: &ArraySetStEph<K>);"
  },
  {
    "id": 765,
    "function": "collect",
    "file": "Chap42/TableMtEph.rs",
    "lines": "78-80",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(|a|), Span Θ(lg |a|)\n        /// claude-4-sonet: Work Θ(n), Span Θ(log n), Parallelism Θ(n/log n)\n        fn collect(&self)              -> ArraySeqMtEphS<Pair<K, V>>;"
  },
  {
    "id": 766,
    "function": "from_sorted_entries",
    "file": "Chap42/TableMtEph.rs",
    "lines": "669-674",
    "spec_strength": "",
    "snippet": "    /// Create tables from sorted entries\n    pub fn from_sorted_entries<K: MtKey, V: MtVal>(entries: Vec<Pair<K, V>>) -> TableMtEph<K, V> {\n        TableMtEph {\n            entries: ArraySeqMtEphS::from_vec(entries),\n        }\n    }"
  },
  {
    "id": 767,
    "function": "size",
    "file": "Chap42/TableStEph.rs",
    "lines": "21-23",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(1), Span Θ(1)\n        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn size(&self)                 -> N;"
  },
  {
    "id": 768,
    "function": "empty",
    "file": "Chap42/TableStEph.rs",
    "lines": "24-26",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(1), Span Θ(1)\n        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn empty()                     -> Self;"
  },
  {
    "id": 769,
    "function": "singleton",
    "file": "Chap42/TableStEph.rs",
    "lines": "27-29",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(1), Span Θ(1)\n        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn singleton(key: K, value: V) -> Self;"
  },
  {
    "id": 770,
    "function": "domain",
    "file": "Chap42/TableStEph.rs",
    "lines": "30-32",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(|a|), Span Θ(lg |a|)\n        /// claude-4-sonet: Work Θ(n log n), Span Θ(n log n), Parallelism Θ(1)\n        fn domain(&self)               -> ArraySetStEph<K>;"
  },
  {
    "id": 771,
    "function": "tabulate",
    "file": "Chap42/TableStEph.rs",
    "lines": "33-35",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(|s| * W(f)), Span Θ(lg |s| + S(f))\n        /// claude-4-sonet: Work Θ(|keys| × W(f)), Span Θ(|keys| × S(f)), Parallelism Θ(1)\n        fn tabulate<F: Fn(&K) -> V>(f: F, keys: &ArraySetStEph<K>) -> Self;"
  },
  {
    "id": 772,
    "function": "map",
    "file": "Chap42/TableStEph.rs",
    "lines": "36-38",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(Σ W(f(v))), Span Θ(lg |a| + max S(f(v)))\n        /// claude-4-sonet: Work Θ(n × W(f)), Span Θ(n × S(f)), Parallelism Θ(1)\n        fn map<F: Fn(&V) -> V>(&mut self, f: F);"
  },
  {
    "id": 773,
    "function": "filter",
    "file": "Chap42/TableStEph.rs",
    "lines": "39-41",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(Σ W(p(k,v))), Span Θ(lg |a| + max S(p(k,v)))\n        /// claude-4-sonet: Work Θ(n × W(f)), Span Θ(n × S(f)), Parallelism Θ(1)\n        fn filter<F: Fn(&K, &V) -> B>(&mut self, f: F);"
  },
  {
    "id": 774,
    "function": "intersection",
    "file": "Chap42/TableStEph.rs",
    "lines": "42-44",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(m * lg(1 + n/m)), Span Θ(lg(n + m))\n        /// claude-4-sonet: Work Θ(m + n), Span Θ(m + n), Parallelism Θ(1)\n        fn intersection<F: Fn(&V, &V) -> V>(&mut self, other: &Self, combine: F);"
  },
  {
    "id": 775,
    "function": "union",
    "file": "Chap42/TableStEph.rs",
    "lines": "45-47",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(m * lg(1 + n/m)), Span Θ(lg(n + m))\n        /// claude-4-sonet: Work Θ(m + n), Span Θ(m + n), Parallelism Θ(1)\n        fn union<F: Fn(&V, &V) -> V>(&mut self, other: &Self, combine: F);"
  },
  {
    "id": 776,
    "function": "difference",
    "file": "Chap42/TableStEph.rs",
    "lines": "48-50",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(m * lg(1 + n/m)), Span Θ(lg(n + m))\n        /// claude-4-sonet: Work Θ(m + n), Span Θ(m + n), Parallelism Θ(1)\n        fn difference(&mut self, other: &Self);"
  },
  {
    "id": 777,
    "function": "find",
    "file": "Chap42/TableStEph.rs",
    "lines": "51-53",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(lg |a|), Span Θ(lg |a|)\n        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn find(&self, key: &K)        -> Option<V>;"
  },
  {
    "id": 778,
    "function": "delete",
    "file": "Chap42/TableStEph.rs",
    "lines": "54-56",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(lg |a|), Span Θ(lg |a|)\n        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)\n        fn delete(&mut self, key: &K);"
  },
  {
    "id": 779,
    "function": "insert",
    "file": "Chap42/TableStEph.rs",
    "lines": "57-59",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(lg |a|), Span Θ(lg |a|)\n        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)\n        fn insert<F: Fn(&V, &V) -> V>(&mut self, key: K, value: V, combine: F);"
  },
  {
    "id": 780,
    "function": "restrict",
    "file": "Chap42/TableStEph.rs",
    "lines": "60-62",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(m * lg(1 + n/m)), Span Θ(lg(n + m))\n        /// claude-4-sonet: Work Θ(m + n), Span Θ(m + n), Parallelism Θ(1)\n        fn restrict(&mut self, keys: &ArraySetStEph<K>);"
  },
  {
    "id": 781,
    "function": "subtract",
    "file": "Chap42/TableStEph.rs",
    "lines": "63-65",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(m * lg(1 + n/m)), Span Θ(lg(n + m))\n        /// claude-4-sonet: Work Θ(m + n), Span Θ(m + n), Parallelism Θ(1)\n        fn subtract(&mut self, keys: &ArraySetStEph<K>);"
  },
  {
    "id": 782,
    "function": "collect",
    "file": "Chap42/TableStEph.rs",
    "lines": "67-69",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(|a|), Span Θ(lg |a|)\n        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)\n        fn collect(&self)              -> ArraySeqStEphS<Pair<K, V>>;"
  },
  {
    "id": 783,
    "function": "from_sorted_entries",
    "file": "Chap42/TableStEph.rs",
    "lines": "330-335",
    "spec_strength": "",
    "snippet": "    /// Create tables from sorted entries\n    pub fn from_sorted_entries<K: StT + Ord, V: StT>(entries: Vec<Pair<K, V>>) -> TableStEph<K, V> {\n        TableStEph {\n            entries: ArraySeqStEphS::from_vec(entries),\n        }\n    }"
  },
  {
    "id": 784,
    "function": "size",
    "file": "Chap42/TableStPer.rs",
    "lines": "22-24",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(1), Span Θ(1)\n        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn size(&self)                              -> N;"
  },
  {
    "id": 785,
    "function": "empty",
    "file": "Chap42/TableStPer.rs",
    "lines": "26-28",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(1), Span Θ(1)\n        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn empty()                                  -> Self;"
  },
  {
    "id": 786,
    "function": "singleton",
    "file": "Chap42/TableStPer.rs",
    "lines": "30-32",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(1), Span Θ(1)\n        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn singleton(key: K, value: V)              -> Self;"
  },
  {
    "id": 787,
    "function": "domain",
    "file": "Chap42/TableStPer.rs",
    "lines": "34-36",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(|a|), Span Θ(lg |a|)\n        /// claude-4-sonet: Work Θ(n log n), Span Θ(n log n), Parallelism Θ(1)\n        fn domain(&self)                            -> ArraySetStEph<K>;"
  },
  {
    "id": 788,
    "function": "tabulate",
    "file": "Chap42/TableStPer.rs",
    "lines": "38-40",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(|s| * W(f)), Span Θ(lg |s| + S(f))\n        /// claude-4-sonet: Work Θ(|keys| × W(f)), Span Θ(log |keys| + S(f)), Parallelism Θ(|keys|/(log |keys| + S(f)))\n        fn tabulate<F: Fn(&K) -> V>(f: F, keys: &ArraySetStEph<K>) -> Self;"
  },
  {
    "id": 789,
    "function": "map",
    "file": "Chap42/TableStPer.rs",
    "lines": "42-44",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(|a| * W(f)), Span Θ(lg |a| + S(f))\n        /// claude-4-sonet: Work Θ(n × W(f)), Span Θ(log n + S(f)), Parallelism Θ(n/(log n + S(f)))\n        fn map<F: Fn(&V) -> V>(&self, f: F) -> Self;"
  },
  {
    "id": 790,
    "function": "filter",
    "file": "Chap42/TableStPer.rs",
    "lines": "46-48",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(|a| * W(f)), Span Θ(lg |a| + S(f))\n        /// claude-4-sonet: Work Θ(n × W(f)), Span Θ(log n + S(f)), Parallelism Θ(n/(log n + S(f)))\n        fn filter<F: Fn(&K, &V) -> B>(&self, f: F) -> Self;"
  },
  {
    "id": 791,
    "function": "intersection",
    "file": "Chap42/TableStPer.rs",
    "lines": "50-52",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(m * lg(1 + n/m)), Span Θ(lg(n + m))\n        /// claude-4-sonet: Work Θ(m log(1 + n/m)), Span Θ(log(n + m)), Parallelism Θ(m/log(n + m))\n        fn intersection<F: Fn(&V, &V) -> V>(&self, other: &Self, combine: F) -> Self;"
  },
  {
    "id": 792,
    "function": "union",
    "file": "Chap42/TableStPer.rs",
    "lines": "54-56",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(m * lg(1 + n/m)), Span Θ(lg(n + m))\n        /// claude-4-sonet: Work Θ(m log(1 + n/m)), Span Θ(log(n + m)), Parallelism Θ(m/log(n + m))\n        fn union<F: Fn(&V, &V) -> V>(&self, other: &Self, combine: F) -> Self;"
  },
  {
    "id": 793,
    "function": "difference",
    "file": "Chap42/TableStPer.rs",
    "lines": "58-60",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(m * lg(1 + n/m)), Span Θ(lg(n + m))\n        /// claude-4-sonet: Work Θ(m log(1 + n/m)), Span Θ(log(n + m)), Parallelism Θ(m/log(n + m))\n        fn difference(&self, other: &Self)          -> Self;"
  },
  {
    "id": 794,
    "function": "find",
    "file": "Chap42/TableStPer.rs",
    "lines": "62-64",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(lg |a|), Span Θ(lg |a|)\n        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn find(&self, key: &K)                     -> Option<V>;"
  },
  {
    "id": 795,
    "function": "delete",
    "file": "Chap42/TableStPer.rs",
    "lines": "66-68",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(lg |a|), Span Θ(lg |a|)\n        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)\n        fn delete(&self, key: &K)                   -> Self;"
  },
  {
    "id": 796,
    "function": "insert",
    "file": "Chap42/TableStPer.rs",
    "lines": "70-72",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(lg |a|), Span Θ(lg |a|)\n        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)\n        fn insert<F: Fn(&V, &V) -> V>(&self, key: K, value: V, combine: F) -> Self;"
  },
  {
    "id": 797,
    "function": "restrict",
    "file": "Chap42/TableStPer.rs",
    "lines": "74-76",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(m * lg(1 + n/m)), Span Θ(lg(n + m))\n        /// claude-4-sonet: Work Θ(m + n), Span Θ(m + n), Parallelism Θ(1)\n        fn restrict(&self, keys: &ArraySetStEph<K>) -> Self;"
  },
  {
    "id": 798,
    "function": "subtract",
    "file": "Chap42/TableStPer.rs",
    "lines": "78-80",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(m * lg(1 + n/m)), Span Θ(lg(n + m))\n        /// claude-4-sonet: Work Θ(m + n), Span Θ(m + n), Parallelism Θ(1)\n        fn subtract(&self, keys: &ArraySetStEph<K>) -> Self;"
  },
  {
    "id": 799,
    "function": "collect",
    "file": "Chap42/TableStPer.rs",
    "lines": "82-84",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(|a|), Span Θ(lg |a|)\n        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)\n        fn collect(&self)                           -> ArraySeqStPerS<Pair<K, V>>;"
  },
  {
    "id": 800,
    "function": "from_sorted_entries",
    "file": "Chap42/TableStPer.rs",
    "lines": "362-367",
    "spec_strength": "",
    "snippet": "    /// Create tables from sorted entries\n    pub fn from_sorted_entries<K: StT + Ord, V: StT>(entries: Vec<Pair<K, V>>) -> TableStPer<K, V> {\n        TableStPer {\n            entries: ArraySeqStPerS::from_vec(entries),\n        }\n    }"
  },
  {
    "id": 801,
    "function": "size",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "32-33",
    "spec_strength": "",
    "snippet": "        // Base table operations (ADT 42.1) - ephemeral semantics with parallelism\n        fn size(&self)                                    -> N;"
  },
  {
    "id": 802,
    "function": "empty",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "34",
    "spec_strength": "",
    "snippet": "        fn empty(reducer: F, identity: V)                 -> Self;"
  },
  {
    "id": 803,
    "function": "singleton",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "35",
    "spec_strength": "",
    "snippet": "        fn singleton(k: K, v: V, reducer: F, identity: V) -> Self;"
  },
  {
    "id": 804,
    "function": "find",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "36",
    "spec_strength": "",
    "snippet": "        fn find(&self, k: &K)                             -> Option<V>;"
  },
  {
    "id": 805,
    "function": "lookup",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "37",
    "spec_strength": "",
    "snippet": "        fn lookup(&self, k: &K)                           -> Option<V>;"
  },
  {
    "id": 806,
    "function": "is_empty",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "38",
    "spec_strength": "",
    "snippet": "        fn is_empty(&self)                                -> B;"
  },
  {
    "id": 807,
    "function": "insert",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "39",
    "spec_strength": "",
    "snippet": "        fn insert<G: Fn(&V, &V) -> V + Send + Sync + 'static>(&mut self, k: K, v: V, combine: G);"
  },
  {
    "id": 808,
    "function": "delete",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "40",
    "spec_strength": "",
    "snippet": "        fn delete(&mut self, k: &K)                       -> Option<V>;"
  },
  {
    "id": 809,
    "function": "domain",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "41",
    "spec_strength": "",
    "snippet": "        fn domain(&self)                                  -> ArraySetStEph<K>;"
  },
  {
    "id": 810,
    "function": "tabulate",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "42-47",
    "spec_strength": "",
    "snippet": "        fn tabulate<G: Fn(&K) -> V + Send + Sync + 'static>(\n            f: G,\n            keys: &ArraySetStEph<K>,\n            reducer: F,\n            identity: V,\n        ) -> Self;"
  },
  {
    "id": 811,
    "function": "map",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "48",
    "spec_strength": "",
    "snippet": "        fn map<G: Fn(&K, &V) -> V + Send + Sync + 'static>(&self, f: G) -> Self;"
  },
  {
    "id": 812,
    "function": "filter",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "49",
    "spec_strength": "",
    "snippet": "        fn filter<G: Fn(&K, &V) -> B + Send + Sync + 'static>(&self, f: G) -> Self;"
  },
  {
    "id": 813,
    "function": "intersection",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "50",
    "spec_strength": "",
    "snippet": "        fn intersection<G: Fn(&V, &V) -> V + Send + Sync + 'static>(&mut self, other: &Self, f: G);"
  },
  {
    "id": 814,
    "function": "union",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "51",
    "spec_strength": "",
    "snippet": "        fn union<G: Fn(&V, &V) -> V + Send + Sync + 'static>(&mut self, other: &Self, f: G);"
  },
  {
    "id": 815,
    "function": "difference",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "52",
    "spec_strength": "",
    "snippet": "        fn difference(&mut self, other: &Self);"
  },
  {
    "id": 816,
    "function": "restrict",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "53",
    "spec_strength": "",
    "snippet": "        fn restrict(&mut self, keys: &ArraySetStEph<K>);"
  },
  {
    "id": 817,
    "function": "subtract",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "54",
    "spec_strength": "",
    "snippet": "        fn subtract(&mut self, keys: &ArraySetStEph<K>);"
  },
  {
    "id": 818,
    "function": "reduce",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "55",
    "spec_strength": "",
    "snippet": "        fn reduce<R: StTInMtT + 'static, G: Fn(R, &K, &V) -> R + Send + Sync + 'static>(&self, init: R, f: G) -> R;"
  },
  {
    "id": 819,
    "function": "collect",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "56",
    "spec_strength": "",
    "snippet": "        fn collect(&self)                                 -> AVLTreeSeqStPerS<Pair<K, V>>;"
  },
  {
    "id": 820,
    "function": "first_key",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "58-59",
    "spec_strength": "",
    "snippet": "        // Key ordering operations (ADT 43.1 adapted for tables) - sequential (inherently sequential on trees)\n        fn first_key(&self)                               -> Option<K>;"
  },
  {
    "id": 821,
    "function": "last_key",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "60",
    "spec_strength": "",
    "snippet": "        fn last_key(&self)                                -> Option<K>;"
  },
  {
    "id": 822,
    "function": "previous_key",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "61",
    "spec_strength": "",
    "snippet": "        fn previous_key(&self, k: &K)                     -> Option<K>;"
  },
  {
    "id": 823,
    "function": "next_key",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "62",
    "spec_strength": "",
    "snippet": "        fn next_key(&self, k: &K)                         -> Option<K>;"
  },
  {
    "id": 824,
    "function": "split_key",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "63-65",
    "spec_strength": "",
    "snippet": "        fn split_key(&mut self, k: &K)                    -> (Self, Self)\n        where\n            Self: Sized;"
  },
  {
    "id": 825,
    "function": "join_key",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "66",
    "spec_strength": "",
    "snippet": "        fn join_key(&mut self, other: Self);"
  },
  {
    "id": 826,
    "function": "get_key_range",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "67",
    "spec_strength": "",
    "snippet": "        fn get_key_range(&self, k1: &K, k2: &K)           -> Self;"
  },
  {
    "id": 827,
    "function": "rank_key",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "68",
    "spec_strength": "",
    "snippet": "        fn rank_key(&self, k: &K)                         -> N;"
  },
  {
    "id": 828,
    "function": "select_key",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "69",
    "spec_strength": "",
    "snippet": "        fn select_key(&self, i: N)                        -> Option<K>;"
  },
  {
    "id": 829,
    "function": "split_rank_key",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "70-72",
    "spec_strength": "",
    "snippet": "        fn split_rank_key(&mut self, i: N)                -> (Self, Self)\n        where\n            Self: Sized;"
  },
  {
    "id": 830,
    "function": "reduce_val",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "74-77",
    "spec_strength": "",
    "snippet": "        // Augmented operations (ADT 43.3) - the key innovation with parallelism\n        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        /// Returns the cached reduction of all values using the reducer function\n        fn reduce_val(&self)                              -> V;"
  },
  {
    "id": 831,
    "function": "reduce_range",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "79-81",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        /// Efficient range reduction for TRAMLAW/QADSAN scenarios\n        fn reduce_range(&self, k1: &K, k2: &K)            -> V;"
  },
  {
    "id": 832,
    "function": "reduce_range_parallel",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "83-85",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n) with parallel reduce_val, Parallelism Θ(n/log n)\n        /// Parallel range reduction using spawn/join\n        fn reduce_range_parallel(&self, k1: &K, k2: &K)   -> V;"
  },
  {
    "id": 833,
    "function": "recalculate_reduction",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "372-374",
    "spec_strength": "",
    "snippet": "    fn recalculate_reduction<K: MtKey, V: MtVal, F: MtReduceFn<V>>(table: &AugOrderedTableMtEph<K, V, F>) -> V {\n        calculate_reduction(&table.base_table, &table.reducer, &table.identity)\n    }"
  },
  {
    "id": 834,
    "function": "calculate_reduction",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "376-400",
    "spec_strength": "",
    "snippet": "    fn calculate_reduction<K: MtKey, V: MtVal, F: MtReduceFn<V>>(\n        base: &OrderedTableMtEph<K, V>,\n        reducer: &F,\n        identity: &V,\n    ) -> V {\n        if base.size() == 0 {\n            return identity.clone();\n        }\n\n        let pairs = base.collect();\n        let mut result = identity.clone();\n        let mut first = true;\n\n        for i in 0..pairs.length() {\n            let pair = pairs.nth(i);\n            if first {\n                result = pair.1.clone();\n                first = false;\n            } else {\n                result = reducer(&result, &pair.1);\n            }\n        }\n\n        result\n    }"
  },
  {
    "id": 835,
    "function": "size",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "33-34",
    "spec_strength": "",
    "snippet": "        // Base table operations (ADT 42.1) - ephemeral semantics\n        fn size(&self) -> N;"
  },
  {
    "id": 836,
    "function": "empty",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "35",
    "spec_strength": "",
    "snippet": "        fn empty(reducer: F, identity: V) -> Self;"
  },
  {
    "id": 837,
    "function": "singleton",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "36",
    "spec_strength": "",
    "snippet": "        fn singleton(k: K, v: V, reducer: F, identity: V) -> Self;"
  },
  {
    "id": 838,
    "function": "find",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "37",
    "spec_strength": "",
    "snippet": "        fn find(&self, k: &K) -> Option<V>;"
  },
  {
    "id": 839,
    "function": "lookup",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "38",
    "spec_strength": "",
    "snippet": "        fn lookup(&self, k: &K) -> Option<V>;"
  },
  {
    "id": 840,
    "function": "is_empty",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "39",
    "spec_strength": "",
    "snippet": "        fn is_empty(&self) -> B;"
  },
  {
    "id": 841,
    "function": "insert",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "40",
    "spec_strength": "",
    "snippet": "        fn insert<G: Fn(&V, &V) -> V>(&mut self, k: K, v: V, combine: G);"
  },
  {
    "id": 842,
    "function": "delete",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "41",
    "spec_strength": "",
    "snippet": "        fn delete(&mut self, k: &K) -> Option<V>;"
  },
  {
    "id": 843,
    "function": "domain",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "42",
    "spec_strength": "",
    "snippet": "        fn domain(&self) -> ArraySetStEph<K>;"
  },
  {
    "id": 844,
    "function": "tabulate",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "43",
    "spec_strength": "",
    "snippet": "        fn tabulate<G: Fn(&K) -> V>(f: G, keys: &ArraySetStEph<K>, reducer: F, identity: V) -> Self;"
  },
  {
    "id": 845,
    "function": "map",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "44",
    "spec_strength": "",
    "snippet": "        fn map<G: Fn(&K, &V) -> V>(&self, f: G) -> Self;"
  },
  {
    "id": 846,
    "function": "filter",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "45",
    "spec_strength": "",
    "snippet": "        fn filter<G: Fn(&K, &V) -> B>(&self, f: G) -> Self;"
  },
  {
    "id": 847,
    "function": "reduce",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "46",
    "spec_strength": "",
    "snippet": "        fn reduce<R, G: Fn(R, &K, &V) -> R>(&self, init: R, f: G) -> R;"
  },
  {
    "id": 848,
    "function": "intersection",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "47",
    "spec_strength": "",
    "snippet": "        fn intersection<G: Fn(&V, &V) -> V>(&mut self, other: &Self, f: G);"
  },
  {
    "id": 849,
    "function": "union",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "48",
    "spec_strength": "",
    "snippet": "        fn union<G: Fn(&V, &V) -> V>(&mut self, other: &Self, f: G);"
  },
  {
    "id": 850,
    "function": "difference",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "49",
    "spec_strength": "",
    "snippet": "        fn difference(&mut self, other: &Self);"
  },
  {
    "id": 851,
    "function": "restrict",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "50",
    "spec_strength": "",
    "snippet": "        fn restrict(&mut self, keys: &ArraySetStEph<K>);"
  },
  {
    "id": 852,
    "function": "subtract",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "51",
    "spec_strength": "",
    "snippet": "        fn subtract(&mut self, keys: &ArraySetStEph<K>);"
  },
  {
    "id": 853,
    "function": "collect",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "52",
    "spec_strength": "",
    "snippet": "        fn collect(&self) -> AVLTreeSeqStPerS<Pair<K, V>>;"
  },
  {
    "id": 854,
    "function": "first_key",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "54-55",
    "spec_strength": "",
    "snippet": "        // Key ordering operations (ADT 43.1 adapted for tables) - ephemeral semantics\n        fn first_key(&self) -> Option<K>;"
  },
  {
    "id": 855,
    "function": "last_key",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "56",
    "spec_strength": "",
    "snippet": "        fn last_key(&self) -> Option<K>;"
  },
  {
    "id": 856,
    "function": "previous_key",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "57",
    "spec_strength": "",
    "snippet": "        fn previous_key(&self, k: &K) -> Option<K>;"
  },
  {
    "id": 857,
    "function": "next_key",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "58",
    "spec_strength": "",
    "snippet": "        fn next_key(&self, k: &K) -> Option<K>;"
  },
  {
    "id": 858,
    "function": "split_key",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "59-61",
    "spec_strength": "",
    "snippet": "        fn split_key(&mut self, k: &K) -> (Self, Self)\n        where\n            Self: Sized;"
  },
  {
    "id": 859,
    "function": "join_key",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "62",
    "spec_strength": "",
    "snippet": "        fn join_key(&mut self, other: Self);"
  },
  {
    "id": 860,
    "function": "get_key_range",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "63",
    "spec_strength": "",
    "snippet": "        fn get_key_range(&self, k1: &K, k2: &K) -> Self;"
  },
  {
    "id": 861,
    "function": "rank_key",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "64",
    "spec_strength": "",
    "snippet": "        fn rank_key(&self, k: &K) -> N;"
  },
  {
    "id": 862,
    "function": "select_key",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "65",
    "spec_strength": "",
    "snippet": "        fn select_key(&self, i: N) -> Option<K>;"
  },
  {
    "id": 863,
    "function": "split_rank_key",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "66-68",
    "spec_strength": "",
    "snippet": "        fn split_rank_key(&mut self, i: N) -> (Self, Self)\n        where\n            Self: Sized;"
  },
  {
    "id": 864,
    "function": "reduce_val",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "70-73",
    "spec_strength": "",
    "snippet": "        // Augmented operations (ADT 43.3) - the key innovation\n        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        /// Returns the cached reduction of all values using the reducer function\n        fn reduce_val(&self) -> V;"
  },
  {
    "id": 865,
    "function": "reduce_range",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "75-77",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        /// Efficient range reduction: getRange followed by reduceVal\n        fn reduce_range(&self, k1: &K, k2: &K) -> V;"
  },
  {
    "id": 866,
    "function": "recalculate_reduction",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "328-330",
    "spec_strength": "",
    "snippet": "        fn recalculate_reduction(&self) -> V {\n            Self::calculate_reduction(&self.base_table, &self.reducer, &self.identity)\n        }"
  },
  {
    "id": 867,
    "function": "calculate_reduction",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "332-352",
    "spec_strength": "",
    "snippet": "        fn calculate_reduction(base: &OrderedTableStEph<K, V>, reducer: &F, identity: &V) -> V {\n            if base.size() == 0 {\n                return identity.clone();\n            }\n\n            let pairs = base.collect();\n            let mut result = identity.clone();\n            let mut first = true;\n\n            for i in 0..pairs.length() {\n                let pair = pairs.nth(i);\n                if first {\n                    result = pair.1.clone();\n                    first = false;\n                } else {\n                    result = reducer(&result, &pair.1);\n                }\n            }\n\n            result\n        }"
  },
  {
    "id": 868,
    "function": "size",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "33-34",
    "spec_strength": "",
    "snippet": "        // Base table operations (ADT 42.1) - delegated to OrderedTableStPer\n        fn size(&self) -> N;"
  },
  {
    "id": 869,
    "function": "empty",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "35",
    "spec_strength": "",
    "snippet": "        fn empty(reducer: F, identity: V) -> Self;"
  },
  {
    "id": 870,
    "function": "singleton",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "36",
    "spec_strength": "",
    "snippet": "        fn singleton(k: K, v: V, reducer: F, identity: V) -> Self;"
  },
  {
    "id": 871,
    "function": "find",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "37",
    "spec_strength": "",
    "snippet": "        fn find(&self, k: &K) -> Option<V>;"
  },
  {
    "id": 872,
    "function": "insert",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "38",
    "spec_strength": "",
    "snippet": "        fn insert(&self, k: K, v: V) -> Self;"
  },
  {
    "id": 873,
    "function": "delete",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "39",
    "spec_strength": "",
    "snippet": "        fn delete(&self, k: &K) -> Self;"
  },
  {
    "id": 874,
    "function": "domain",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "40",
    "spec_strength": "",
    "snippet": "        fn domain(&self) -> ArraySetStEph<K>;"
  },
  {
    "id": 875,
    "function": "tabulate",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "41",
    "spec_strength": "",
    "snippet": "        fn tabulate<G: Fn(&K) -> V>(f: G, keys: &ArraySetStEph<K>, reducer: F, identity: V) -> Self;"
  },
  {
    "id": 876,
    "function": "map",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "42",
    "spec_strength": "",
    "snippet": "        fn map<G: Fn(&V) -> V>(&self, f: G) -> Self;"
  },
  {
    "id": 877,
    "function": "filter",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "43",
    "spec_strength": "",
    "snippet": "        fn filter<G: Fn(&K, &V) -> B>(&self, f: G) -> Self;"
  },
  {
    "id": 878,
    "function": "intersection",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "44",
    "spec_strength": "",
    "snippet": "        fn intersection<G: Fn(&V, &V) -> V>(&self, other: &Self, f: G) -> Self;"
  },
  {
    "id": 879,
    "function": "union",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "45",
    "spec_strength": "",
    "snippet": "        fn union<G: Fn(&V, &V) -> V>(&self, other: &Self, f: G) -> Self;"
  },
  {
    "id": 880,
    "function": "difference",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "46",
    "spec_strength": "",
    "snippet": "        fn difference(&self, other: &Self) -> Self;"
  },
  {
    "id": 881,
    "function": "restrict",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "47",
    "spec_strength": "",
    "snippet": "        fn restrict(&self, keys: &ArraySetStEph<K>) -> Self;"
  },
  {
    "id": 882,
    "function": "subtract",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "48",
    "spec_strength": "",
    "snippet": "        fn subtract(&self, keys: &ArraySetStEph<K>) -> Self;"
  },
  {
    "id": 883,
    "function": "collect",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "49",
    "spec_strength": "",
    "snippet": "        fn collect(&self) -> AVLTreeSeqStPerS<Pair<K, V>>;"
  },
  {
    "id": 884,
    "function": "first_key",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "51-52",
    "spec_strength": "",
    "snippet": "        // Key ordering operations (ADT 43.1 adapted for tables)\n        fn first_key(&self) -> Option<K>;"
  },
  {
    "id": 885,
    "function": "last_key",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "53",
    "spec_strength": "",
    "snippet": "        fn last_key(&self) -> Option<K>;"
  },
  {
    "id": 886,
    "function": "previous_key",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "54",
    "spec_strength": "",
    "snippet": "        fn previous_key(&self, k: &K) -> Option<K>;"
  },
  {
    "id": 887,
    "function": "next_key",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "55",
    "spec_strength": "",
    "snippet": "        fn next_key(&self, k: &K) -> Option<K>;"
  },
  {
    "id": 888,
    "function": "split_key",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "56-58",
    "spec_strength": "",
    "snippet": "        fn split_key(&self, k: &K) -> (Self, Option<V>, Self)\n        where\n            Self: Sized;"
  },
  {
    "id": 889,
    "function": "join_key",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "59",
    "spec_strength": "",
    "snippet": "        fn join_key(left: &Self, right: &Self) -> Self;"
  },
  {
    "id": 890,
    "function": "get_key_range",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "60",
    "spec_strength": "",
    "snippet": "        fn get_key_range(&self, k1: &K, k2: &K) -> Self;"
  },
  {
    "id": 891,
    "function": "rank_key",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "61",
    "spec_strength": "",
    "snippet": "        fn rank_key(&self, k: &K) -> N;"
  },
  {
    "id": 892,
    "function": "select_key",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "62",
    "spec_strength": "",
    "snippet": "        fn select_key(&self, i: N) -> Option<K>;"
  },
  {
    "id": 893,
    "function": "split_rank_key",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "63-65",
    "spec_strength": "",
    "snippet": "        fn split_rank_key(&self, i: N) -> (Self, Self)\n        where\n            Self: Sized;"
  },
  {
    "id": 894,
    "function": "reduce_val",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "67-70",
    "spec_strength": "",
    "snippet": "        // Augmented operations (ADT 43.3) - the key innovation\n        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        /// Returns the cached reduction of all values using the reducer function\n        fn reduce_val(&self) -> V;"
  },
  {
    "id": 895,
    "function": "reduce_range",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "72-74",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        /// Efficient range reduction: getRange followed by reduceVal\n        fn reduce_range(&self, k1: &K, k2: &K) -> V;"
  },
  {
    "id": 896,
    "function": "recalculate_reduction",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "363-365",
    "spec_strength": "",
    "snippet": "        fn recalculate_reduction(&self, base: &OrderedTableStPer<K, V>) -> V {\n            Self::calculate_reduction(base, &self.reducer, &self.identity)\n        }"
  },
  {
    "id": 897,
    "function": "calculate_reduction",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "367-387",
    "spec_strength": "",
    "snippet": "        fn calculate_reduction(base: &OrderedTableStPer<K, V>, reducer: &F, identity: &V) -> V {\n            if base.size() == 0 {\n                return identity.clone();\n            }\n\n            let pairs = base.collect();\n            let mut result = identity.clone();\n            let mut first = true;\n\n            for i in 0..pairs.length() {\n                let pair = pairs.nth(i);\n                if first {\n                    result = pair.1.clone();\n                    first = false;\n                } else {\n                    result = reducer(&result, &pair.1);\n                }\n            }\n\n            result\n        }"
  },
  {
    "id": 898,
    "function": "run_example43_1",
    "file": "Chap43/Example43_1.rs",
    "lines": "13-15",
    "spec_strength": "",
    "snippet": "        /// Demonstrates Example 43.1 from the textbook with lexicographic ordering\n        /// APAS: Work Θ(n log n), Span Θ(log n)\n        fn run_example43_1();"
  },
  {
    "id": 899,
    "function": "demonstrate_ordered_operations",
    "file": "Chap43/Example43_1.rs",
    "lines": "17-19",
    "spec_strength": "",
    "snippet": "        /// Demonstrate ordered set operations\n        /// APAS: Work Θ(n log n), Span Θ(log n)\n        fn demonstrate_ordered_operations();"
  },
  {
    "id": 900,
    "function": "run_integer_example",
    "file": "Chap43/Example43_1.rs",
    "lines": "168-224",
    "spec_strength": "",
    "snippet": "    /// Demonstrates ordering operations with integer sets for additional clarity\n    pub fn run_integer_example() {\n        println!(\"\\n=== Integer Ordered Set Example ===\");\n\n        // Create an ordered set of integers\n        let int_set: OrderedSetStPer<i32> = OrderedSetStPerLit![1, 3, 5, 7, 9, 11, 13];\n\n        print!(\"Integer Set: [\");\n        let seq = int_set.to_seq();\n        for i in 0..seq.length() {\n            if i > 0 {\n                print!(\", \");\n            }\n            print!(\"{}\", seq.nth(i));\n        }\n        println!(\"]\");\n\n        // Demonstrate all ordering operations\n        println!(\"first() = {:?}\", int_set.first());\n        println!(\"last() = {:?}\", int_set.last());\n        println!(\"previous(7) = {:?}\", int_set.previous(&7));\n        println!(\"next(7) = {:?}\", int_set.next(&7));\n        println!(\"rank(7) = {}\", int_set.rank(&7));\n        println!(\"select(3) = {:?}\", int_set.select(3));\n\n        let range = int_set.get_range(&3, &9);\n        print!(\"getRange(3, 9) = [\");\n        let seq = range.to_seq();\n        for i in 0..seq.length() {\n            if i > 0 {\n                print!(\", \");\n            }\n            print!(\"{}\", seq.nth(i));\n        }\n        println!(\"]\");\n\n        let (left, right) = int_set.split_rank(4);\n        print!(\"splitRank(4) = ([\");\n        let seq = left.to_seq();\n        for i in 0..seq.length() {\n            if i > 0 {\n                print!(\", \");\n            }\n            print!(\"{}\", seq.nth(i));\n        }\n        print!(\"], [\");\n        let seq = right.to_seq();\n        for i in 0..seq.length() {\n            if i > 0 {\n                print!(\", \");\n            }\n            print!(\"{}\", seq.nth(i));\n        }\n        println!(\"])\");\n\n        println!(\"=== Integer Example Complete ===\");\n    }"
  },
  {
    "id": 901,
    "function": "size",
    "file": "Chap43/OrderedSetMtEph.rs",
    "lines": "18-20",
    "spec_strength": "",
    "snippet": "        // Base set operations (ADT 41.1) - ephemeral semantics with parallelism\n        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn size(&self)                        -> N;"
  },
  {
    "id": 902,
    "function": "empty",
    "file": "Chap43/OrderedSetMtEph.rs",
    "lines": "21-22",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn empty()                            -> Self;"
  },
  {
    "id": 903,
    "function": "singleton",
    "file": "Chap43/OrderedSetMtEph.rs",
    "lines": "23-24",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn singleton(x: T)                    -> Self;"
  },
  {
    "id": 904,
    "function": "find",
    "file": "Chap43/OrderedSetMtEph.rs",
    "lines": "25-26",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn find(&self, x: &T)                 -> B;"
  },
  {
    "id": 905,
    "function": "insert",
    "file": "Chap43/OrderedSetMtEph.rs",
    "lines": "27-28",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(log n), Parallelism Θ(n/log n)\n        fn insert(&mut self, x: T);"
  },
  {
    "id": 906,
    "function": "delete",
    "file": "Chap43/OrderedSetMtEph.rs",
    "lines": "29-30",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(log n), Parallelism Θ(n/log n)\n        fn delete(&mut self, x: &T);"
  },
  {
    "id": 907,
    "function": "filter",
    "file": "Chap43/OrderedSetMtEph.rs",
    "lines": "31-32",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(log n), Parallelism Θ(n/log n)\n        fn filter<F: Pred<T>>(&mut self, f: F);"
  },
  {
    "id": 908,
    "function": "intersection",
    "file": "Chap43/OrderedSetMtEph.rs",
    "lines": "33-34",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(m + n), Span Θ(log(m + n)), Parallelism Θ((m+n)/log(m+n))\n        fn intersection(&mut self, other: &Self);"
  },
  {
    "id": 909,
    "function": "union",
    "file": "Chap43/OrderedSetMtEph.rs",
    "lines": "35-36",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(m + n), Span Θ(log(m + n)), Parallelism Θ((m+n)/log(m+n))\n        fn union(&mut self, other: &Self);"
  },
  {
    "id": 910,
    "function": "difference",
    "file": "Chap43/OrderedSetMtEph.rs",
    "lines": "37-38",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(m + n), Span Θ(log(m + n)), Parallelism Θ((m+n)/log(m+n))\n        fn difference(&mut self, other: &Self);"
  },
  {
    "id": 911,
    "function": "to_seq",
    "file": "Chap43/OrderedSetMtEph.rs",
    "lines": "39-40",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)\n        fn to_seq(&self)                      -> ArraySeqStPerS<T>;"
  },
  {
    "id": 912,
    "function": "from_seq",
    "file": "Chap43/OrderedSetMtEph.rs",
    "lines": "41-42",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n lg n), Span Θ(lg n), Parallelism Θ(1)\n        fn from_seq(seq: ArraySeqStPerS<T>) -> Self;"
  },
  {
    "id": 913,
    "function": "first",
    "file": "Chap43/OrderedSetMtEph.rs",
    "lines": "44-46",
    "spec_strength": "",
    "snippet": "        // Ordering operations (ADT 43.1) - sequential (inherently sequential on trees)\n        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn first(&self)                       -> Option<T>;"
  },
  {
    "id": 914,
    "function": "last",
    "file": "Chap43/OrderedSetMtEph.rs",
    "lines": "47-48",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn last(&self)                        -> Option<T>;"
  },
  {
    "id": 915,
    "function": "previous",
    "file": "Chap43/OrderedSetMtEph.rs",
    "lines": "49-50",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn previous(&self, k: &T)             -> Option<T>;"
  },
  {
    "id": 916,
    "function": "next",
    "file": "Chap43/OrderedSetMtEph.rs",
    "lines": "51-52",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn next(&self, k: &T)                 -> Option<T>;"
  },
  {
    "id": 917,
    "function": "split",
    "file": "Chap43/OrderedSetMtEph.rs",
    "lines": "53-56",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(log n), Parallelism Θ(n/log n)\n        fn split(&mut self, k: &T)            -> (Self, B, Self)\n        where\n            Self: Sized;"
  },
  {
    "id": 918,
    "function": "join",
    "file": "Chap43/OrderedSetMtEph.rs",
    "lines": "57-58",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(m + n), Span Θ(log(m + n)), Parallelism Θ((m+n)/log(m+n))\n        fn join(&mut self, other: Self);"
  },
  {
    "id": 919,
    "function": "get_range",
    "file": "Chap43/OrderedSetMtEph.rs",
    "lines": "59-60",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn get_range(&self, k1: &T, k2: &T)   -> Self;"
  },
  {
    "id": 920,
    "function": "rank",
    "file": "Chap43/OrderedSetMtEph.rs",
    "lines": "61-62",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn rank(&self, k: &T)                 -> N;"
  },
  {
    "id": 921,
    "function": "select",
    "file": "Chap43/OrderedSetMtEph.rs",
    "lines": "63-64",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn select(&self, i: N)                -> Option<T>;"
  },
  {
    "id": 922,
    "function": "split_rank",
    "file": "Chap43/OrderedSetMtEph.rs",
    "lines": "65-68",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(log n), Parallelism Θ(n/log n)\n        fn split_rank(&mut self, i: N)        -> (Self, Self)\n        where\n            Self: Sized;"
  },
  {
    "id": 923,
    "function": "size",
    "file": "Chap43/OrderedSetStEph.rs",
    "lines": "21-23",
    "spec_strength": "",
    "snippet": "        // Base set operations (ADT 41.1) - ephemeral semantics\n        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn size(&self)                        -> N;"
  },
  {
    "id": 924,
    "function": "empty",
    "file": "Chap43/OrderedSetStEph.rs",
    "lines": "24-25",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn empty()                            -> Self;"
  },
  {
    "id": 925,
    "function": "singleton",
    "file": "Chap43/OrderedSetStEph.rs",
    "lines": "26-27",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn singleton(x: T)                    -> Self;"
  },
  {
    "id": 926,
    "function": "find",
    "file": "Chap43/OrderedSetStEph.rs",
    "lines": "28-29",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn find(&self, x: &T)                 -> B;"
  },
  {
    "id": 927,
    "function": "insert",
    "file": "Chap43/OrderedSetStEph.rs",
    "lines": "30-31",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn insert(&mut self, x: T);"
  },
  {
    "id": 928,
    "function": "delete",
    "file": "Chap43/OrderedSetStEph.rs",
    "lines": "32-33",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn delete(&mut self, x: &T);"
  },
  {
    "id": 929,
    "function": "filter",
    "file": "Chap43/OrderedSetStEph.rs",
    "lines": "34-35",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)\n        fn filter<F: PredSt<T>>(&mut self, f: F);"
  },
  {
    "id": 930,
    "function": "intersection",
    "file": "Chap43/OrderedSetStEph.rs",
    "lines": "36-37",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)\n        fn intersection(&mut self, other: &Self);"
  },
  {
    "id": 931,
    "function": "union",
    "file": "Chap43/OrderedSetStEph.rs",
    "lines": "38-39",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)\n        fn union(&mut self, other: &Self);"
  },
  {
    "id": 932,
    "function": "difference",
    "file": "Chap43/OrderedSetStEph.rs",
    "lines": "40-41",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)\n        fn difference(&mut self, other: &Self);"
  },
  {
    "id": 933,
    "function": "to_seq",
    "file": "Chap43/OrderedSetStEph.rs",
    "lines": "42-43",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)\n        fn to_seq(&self)                      -> AVLTreeSeqStPerS<T>;"
  },
  {
    "id": 934,
    "function": "from_seq",
    "file": "Chap43/OrderedSetStEph.rs",
    "lines": "44-45",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n log n), Span Θ(n log n), Parallelism Θ(1)\n        fn from_seq(seq: AVLTreeSeqStPerS<T>) -> Self;"
  },
  {
    "id": 935,
    "function": "first",
    "file": "Chap43/OrderedSetStEph.rs",
    "lines": "47-49",
    "spec_strength": "",
    "snippet": "        // Ordering operations (ADT 43.1)\n        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn first(&self)                       -> Option<T>;"
  },
  {
    "id": 936,
    "function": "last",
    "file": "Chap43/OrderedSetStEph.rs",
    "lines": "50-51",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn last(&self)                        -> Option<T>;"
  },
  {
    "id": 937,
    "function": "previous",
    "file": "Chap43/OrderedSetStEph.rs",
    "lines": "52-53",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn previous(&self, k: &T)             -> Option<T>;"
  },
  {
    "id": 938,
    "function": "next",
    "file": "Chap43/OrderedSetStEph.rs",
    "lines": "54-55",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn next(&self, k: &T)                 -> Option<T>;"
  },
  {
    "id": 939,
    "function": "split",
    "file": "Chap43/OrderedSetStEph.rs",
    "lines": "56-59",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn split(&mut self, k: &T)            -> (Self, B, Self)\n        where\n            Self: Sized;"
  },
  {
    "id": 940,
    "function": "join",
    "file": "Chap43/OrderedSetStEph.rs",
    "lines": "60-61",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log(|self| + |other|)), Span Θ(log(|self| + |other|)), Parallelism Θ(1)\n        fn join(&mut self, other: Self);"
  },
  {
    "id": 941,
    "function": "get_range",
    "file": "Chap43/OrderedSetStEph.rs",
    "lines": "62-63",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn get_range(&self, k1: &T, k2: &T)   -> Self;"
  },
  {
    "id": 942,
    "function": "rank",
    "file": "Chap43/OrderedSetStEph.rs",
    "lines": "64-65",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn rank(&self, k: &T)                 -> N;"
  },
  {
    "id": 943,
    "function": "select",
    "file": "Chap43/OrderedSetStEph.rs",
    "lines": "66-67",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn select(&self, i: N)                -> Option<T>;"
  },
  {
    "id": 944,
    "function": "split_rank",
    "file": "Chap43/OrderedSetStEph.rs",
    "lines": "68-71",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn split_rank(&mut self, i: N)        -> (Self, Self)\n        where\n            Self: Sized;"
  },
  {
    "id": 945,
    "function": "from_sorted_elements",
    "file": "Chap43/OrderedSetStEph.rs",
    "lines": "326-329",
    "spec_strength": "",
    "snippet": "    pub fn from_sorted_elements<T: StT + Ord>(elements: Vec<T>) -> OrderedSetStEph<T> {\n        let seq = AVLTreeSeqStPerS::from_vec(elements);\n        OrderedSetStEph::from_seq(seq)\n    }"
  },
  {
    "id": 946,
    "function": "size",
    "file": "Chap43/OrderedSetStPer.rs",
    "lines": "20-22",
    "spec_strength": "",
    "snippet": "        // Base set operations (ADT 41.1) - delegated\n        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn size(&self)                        -> N;"
  },
  {
    "id": 947,
    "function": "empty",
    "file": "Chap43/OrderedSetStPer.rs",
    "lines": "23-24",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn empty()                            -> Self;"
  },
  {
    "id": 948,
    "function": "singleton",
    "file": "Chap43/OrderedSetStPer.rs",
    "lines": "25-26",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn singleton(x: T)                    -> Self;"
  },
  {
    "id": 949,
    "function": "find",
    "file": "Chap43/OrderedSetStPer.rs",
    "lines": "27-28",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn find(&self, x: &T)                 -> B;"
  },
  {
    "id": 950,
    "function": "insert",
    "file": "Chap43/OrderedSetStPer.rs",
    "lines": "29-30",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn insert(&self, x: T)                -> Self;"
  },
  {
    "id": 951,
    "function": "delete",
    "file": "Chap43/OrderedSetStPer.rs",
    "lines": "31-32",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn delete(&self, x: &T)               -> Self;"
  },
  {
    "id": 952,
    "function": "filter",
    "file": "Chap43/OrderedSetStPer.rs",
    "lines": "33-34",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)\n        fn filter<F: PredSt<T>>(&self, f: F)  -> Self;"
  },
  {
    "id": 953,
    "function": "intersection",
    "file": "Chap43/OrderedSetStPer.rs",
    "lines": "35-36",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)\n        fn intersection(&self, other: &Self)  -> Self;"
  },
  {
    "id": 954,
    "function": "union",
    "file": "Chap43/OrderedSetStPer.rs",
    "lines": "37-38",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)\n        fn union(&self, other: &Self)         -> Self;"
  },
  {
    "id": 955,
    "function": "difference",
    "file": "Chap43/OrderedSetStPer.rs",
    "lines": "39-40",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)\n        fn difference(&self, other: &Self)    -> Self;"
  },
  {
    "id": 956,
    "function": "to_seq",
    "file": "Chap43/OrderedSetStPer.rs",
    "lines": "41-42",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)\n        fn to_seq(&self)                      -> AVLTreeSeqStPerS<T>;"
  },
  {
    "id": 957,
    "function": "from_seq",
    "file": "Chap43/OrderedSetStPer.rs",
    "lines": "43-44",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n log n), Span Θ(n log n), Parallelism Θ(1)\n        fn from_seq(seq: AVLTreeSeqStPerS<T>) -> Self;"
  },
  {
    "id": 958,
    "function": "first",
    "file": "Chap43/OrderedSetStPer.rs",
    "lines": "46-48",
    "spec_strength": "",
    "snippet": "        // Ordering operations (ADT 43.1)\n        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn first(&self)                       -> Option<T>;"
  },
  {
    "id": 959,
    "function": "last",
    "file": "Chap43/OrderedSetStPer.rs",
    "lines": "49-50",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn last(&self)                        -> Option<T>;"
  },
  {
    "id": 960,
    "function": "previous",
    "file": "Chap43/OrderedSetStPer.rs",
    "lines": "51-52",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn previous(&self, k: &T)             -> Option<T>;"
  },
  {
    "id": 961,
    "function": "next",
    "file": "Chap43/OrderedSetStPer.rs",
    "lines": "53-54",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn next(&self, k: &T)                 -> Option<T>;"
  },
  {
    "id": 962,
    "function": "split",
    "file": "Chap43/OrderedSetStPer.rs",
    "lines": "55-58",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn split(&self, k: &T)                -> (Self, B, Self)\n        where\n            Self: Sized;"
  },
  {
    "id": 963,
    "function": "join",
    "file": "Chap43/OrderedSetStPer.rs",
    "lines": "59-60",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log(|left| + |right|)), Span Θ(log(|left| + |right|)), Parallelism Θ(1)\n        fn join(left: &Self, right: &Self)    -> Self;"
  },
  {
    "id": 964,
    "function": "get_range",
    "file": "Chap43/OrderedSetStPer.rs",
    "lines": "61-62",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn get_range(&self, k1: &T, k2: &T)   -> Self;"
  },
  {
    "id": 965,
    "function": "rank",
    "file": "Chap43/OrderedSetStPer.rs",
    "lines": "63-64",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn rank(&self, k: &T)                 -> N;"
  },
  {
    "id": 966,
    "function": "select",
    "file": "Chap43/OrderedSetStPer.rs",
    "lines": "65-66",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn select(&self, i: N)                -> Option<T>;"
  },
  {
    "id": 967,
    "function": "split_rank",
    "file": "Chap43/OrderedSetStPer.rs",
    "lines": "67-70",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn split_rank(&self, i: N)            -> (Self, Self)\n        where\n            Self: Sized;"
  },
  {
    "id": 968,
    "function": "from_sorted_elements",
    "file": "Chap43/OrderedSetStPer.rs",
    "lines": "304-307",
    "spec_strength": "",
    "snippet": "    pub fn from_sorted_elements<T: StT + Ord>(elements: Vec<T>) -> OrderedSetStPer<T> {\n        let seq = AVLTreeSeqStPerS::from_vec(elements);\n        OrderedSetStPer::from_seq(seq)\n    }"
  },
  {
    "id": 969,
    "function": "size",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "24-26",
    "spec_strength": "",
    "snippet": "        // Base table operations (ADT 42.1) - ephemeral semantics with parallelism\n        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn size(&self)                          -> N;"
  },
  {
    "id": 970,
    "function": "empty",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "27-28",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn empty()                              -> Self;"
  },
  {
    "id": 971,
    "function": "singleton",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "29-30",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn singleton(k: K, v: V)                -> Self;"
  },
  {
    "id": 972,
    "function": "find",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "31-32",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn find(&self, k: &K)                   -> Option<V>;"
  },
  {
    "id": 973,
    "function": "lookup",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "33-34",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn lookup(&self, k: &K)                 -> Option<V>; // Alias for find"
  },
  {
    "id": 974,
    "function": "is_empty",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "34-36",
    "spec_strength": "",
    "snippet": "        fn lookup(&self, k: &K)                 -> Option<V>; // Alias for find\n        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn is_empty(&self)                      -> B;"
  },
  {
    "id": 975,
    "function": "insert",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "37-38",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(log n), Parallelism Θ(n/log n)\n        fn insert<F: Fn(&V, &V) -> V + Send + Sync + 'static>(&mut self, k: K, v: V, combine: F);"
  },
  {
    "id": 976,
    "function": "delete",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "39-40",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(log n), Parallelism Θ(n/log n)\n        fn delete(&mut self, k: &K)             -> Option<V>;"
  },
  {
    "id": 977,
    "function": "domain",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "41-42",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n log n), Span Θ(log n), Parallelism Θ(n)\n        fn domain(&self)                        -> ArraySetStEph<K>;"
  },
  {
    "id": 978,
    "function": "tabulate",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "43-44",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(|keys| × W(f)), Span Θ(log |keys| + S(f)), Parallelism Θ(|keys|/(log |keys| + S(f)))\n        fn tabulate<F: Fn(&K) -> V + Send + Sync + 'static>(f: F, keys: &ArraySetStEph<K>) -> Self;"
  },
  {
    "id": 979,
    "function": "map",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "45-46",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n × W(f)), Span Θ(log n + S(f)), Parallelism Θ(n/(log n + S(f)))\n        fn map<F: Fn(&K, &V) -> V + Send + Sync + 'static>(&self, f: F) -> Self;"
  },
  {
    "id": 980,
    "function": "filter",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "47-48",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n × W(f)), Span Θ(log n + S(f)), Parallelism Θ(n/(log n + S(f)))\n        fn filter<F: Fn(&K, &V) -> B + Send + Sync + 'static>(&self, f: F) -> Self;"
  },
  {
    "id": 981,
    "function": "intersection",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "49-50",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(m + n), Span Θ(log(m + n)), Parallelism Θ((m+n)/log(m+n))\n        fn intersection<F: Fn(&V, &V) -> V + Send + Sync + 'static>(&mut self, other: &Self, f: F);"
  },
  {
    "id": 982,
    "function": "union",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "51-52",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(m + n), Span Θ(log(m + n)), Parallelism Θ((m+n)/log(m+n))\n        fn union<F: Fn(&V, &V) -> V + Send + Sync + 'static>(&mut self, other: &Self, f: F);"
  },
  {
    "id": 983,
    "function": "difference",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "53-54",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(m + n), Span Θ(log(m + n)), Parallelism Θ((m+n)/log(m+n))\n        fn difference(&mut self, other: &Self);"
  },
  {
    "id": 984,
    "function": "restrict",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "55-56",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(m + n), Span Θ(log(m + n)), Parallelism Θ((m+n)/log(m+n))\n        fn restrict(&mut self, keys: &ArraySetStEph<K>);"
  },
  {
    "id": 985,
    "function": "subtract",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "57-58",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(m + n), Span Θ(log(m + n)), Parallelism Θ((m+n)/log(m+n))\n        fn subtract(&mut self, keys: &ArraySetStEph<K>);"
  },
  {
    "id": 986,
    "function": "reduce",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "59-60",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n × W(f)), Span Θ(log n + S(f)), Parallelism Θ(n/(log n + S(f)))\n        fn reduce<R: StTInMtT + 'static, F: Fn(R, &K, &V) -> R + Send + Sync + 'static>(&self, init: R, f: F) -> R;"
  },
  {
    "id": 987,
    "function": "collect",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "61-62",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(log n), Parallelism Θ(n/log n)\n        fn collect(&self)                       -> AVLTreeSeqStPerS<Pair<K, V>>;"
  },
  {
    "id": 988,
    "function": "first_key",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "64-66",
    "spec_strength": "",
    "snippet": "        // Key ordering operations (ADT 43.1 adapted for tables) - sequential (inherently sequential on trees)\n        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn first_key(&self)                     -> Option<K>;"
  },
  {
    "id": 989,
    "function": "last_key",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "67-68",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn last_key(&self)                      -> Option<K>;"
  },
  {
    "id": 990,
    "function": "previous_key",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "69-70",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn previous_key(&self, k: &K)           -> Option<K>;"
  },
  {
    "id": 991,
    "function": "next_key",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "71-72",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn next_key(&self, k: &K)               -> Option<K>;"
  },
  {
    "id": 992,
    "function": "split_key",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "73-76",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(log n), Parallelism Θ(n/log n)\n        fn split_key(&mut self, k: &K)          -> (Self, Self)\n        where\n            Self: Sized;"
  },
  {
    "id": 993,
    "function": "join_key",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "77",
    "spec_strength": "",
    "snippet": "        fn join_key(&mut self, other: Self);"
  },
  {
    "id": 994,
    "function": "get_key_range",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "78",
    "spec_strength": "",
    "snippet": "        fn get_key_range(&self, k1: &K, k2: &K) -> Self;"
  },
  {
    "id": 995,
    "function": "rank_key",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "79",
    "spec_strength": "",
    "snippet": "        fn rank_key(&self, k: &K)               -> N;"
  },
  {
    "id": 996,
    "function": "select_key",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "80",
    "spec_strength": "",
    "snippet": "        fn select_key(&self, i: N)              -> Option<K>;"
  },
  {
    "id": 997,
    "function": "split_rank_key",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "81-83",
    "spec_strength": "",
    "snippet": "        fn split_rank_key(&mut self, i: N)      -> (Self, Self)\n        where\n            Self: Sized;"
  },
  {
    "id": 998,
    "function": "from_sorted_entries",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "394-403",
    "spec_strength": "",
    "snippet": "    pub fn from_sorted_entries<K: MtKey, V: MtVal>(entries: AVLTreeSeqStPerS<Pair<K, V>>) -> OrderedTableMtEph<K, V> {\n        let len = entries.length();\n        let mut elements = Vec::new();\n        for i in 0..len {\n            elements.push(entries.nth(i).clone());\n        }\n        OrderedTableMtEph {\n            base_table: crate::Chap42::TableMtEph::TableMtEph::from_sorted_entries(elements),\n        }\n    }"
  },
  {
    "id": 999,
    "function": "size",
    "file": "Chap43/OrderedTableMtPer.rs",
    "lines": "22-23",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn size(&self)               -> N;"
  },
  {
    "id": 1000,
    "function": "empty",
    "file": "Chap43/OrderedTableMtPer.rs",
    "lines": "24-25",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn empty()                   -> Self;"
  },
  {
    "id": 1001,
    "function": "singleton",
    "file": "Chap43/OrderedTableMtPer.rs",
    "lines": "26-27",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(lg n), Span Θ(lg n)\n        fn singleton(k: K, v: V)     -> Self;"
  },
  {
    "id": 1002,
    "function": "find",
    "file": "Chap43/OrderedTableMtPer.rs",
    "lines": "28-29",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(lg n), Span Θ(lg n) - binary search on in-order sequence\n        fn find(&self, k: &K)        -> Option<V>;"
  },
  {
    "id": 1003,
    "function": "insert",
    "file": "Chap43/OrderedTableMtPer.rs",
    "lines": "30-31",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(lg n) - parallel filter + insert via ParaPair!\n        fn insert(&self, k: K, v: V) -> Self;"
  },
  {
    "id": 1004,
    "function": "delete",
    "file": "Chap43/OrderedTableMtPer.rs",
    "lines": "32-33",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(lg n) - parallel filter via ParaPair!\n        fn delete(&self, k: &K)      -> Self;"
  },
  {
    "id": 1005,
    "function": "domain",
    "file": "Chap43/OrderedTableMtPer.rs",
    "lines": "34-35",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(lg n) - parallel key extraction with rayon\n        fn domain(&self)             -> OrderedSetMtEph<K>;"
  },
  {
    "id": 1006,
    "function": "map",
    "file": "Chap43/OrderedTableMtPer.rs",
    "lines": "36-37",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(lg n) - parallel filter via ParaPair!\n        fn map<F: Pred<Pair<K, V>>>(&self, f: F) -> Self;"
  },
  {
    "id": 1007,
    "function": "filter",
    "file": "Chap43/OrderedTableMtPer.rs",
    "lines": "38-39",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(lg n) - parallel filter via ParaPair!\n        fn filter<F: Pred<Pair<K, V>>>(&self, f: F) -> Self;"
  },
  {
    "id": 1008,
    "function": "default",
    "file": "Chap43/OrderedTableMtPer.rs",
    "lines": "127",
    "spec_strength": "",
    "snippet": "        fn default() -> Self { Self::empty() }"
  },
  {
    "id": 1009,
    "function": "size",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "21-23",
    "spec_strength": "",
    "snippet": "        // Base table operations (ADT 42.1) - ephemeral semantics\n        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn size(&self)                          -> N;"
  },
  {
    "id": 1010,
    "function": "empty",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "24-25",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn empty()                              -> Self;"
  },
  {
    "id": 1011,
    "function": "singleton",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "26-27",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn singleton(k: K, v: V)                -> Self;"
  },
  {
    "id": 1012,
    "function": "find",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "28-29",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn find(&self, k: &K)                   -> Option<V>;"
  },
  {
    "id": 1013,
    "function": "lookup",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "30-31",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn lookup(&self, k: &K)                 -> Option<V>; // Alias for find"
  },
  {
    "id": 1014,
    "function": "is_empty",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "31-33",
    "spec_strength": "",
    "snippet": "        fn lookup(&self, k: &K)                 -> Option<V>; // Alias for find\n        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn is_empty(&self)                      -> B;"
  },
  {
    "id": 1015,
    "function": "insert",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "34-35",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn insert<F: Fn(&V, &V) -> V>(&mut self, k: K, v: V, combine: F);"
  },
  {
    "id": 1016,
    "function": "delete",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "36-37",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn delete(&mut self, k: &K)             -> Option<V>;"
  },
  {
    "id": 1017,
    "function": "domain",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "38-39",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)\n        fn domain(&self)                        -> ArraySetStEph<K>;"
  },
  {
    "id": 1018,
    "function": "tabulate",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "40-41",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(|keys| × W(f)), Span Θ(|keys| × S(f)), Parallelism Θ(1)\n        fn tabulate<F: Fn(&K) -> V>(f: F, keys: &ArraySetStEph<K>) -> Self;"
  },
  {
    "id": 1019,
    "function": "map",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "42-43",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n × W(f)), Span Θ(n × S(f)), Parallelism Θ(1)\n        fn map<F: Fn(&K, &V) -> V>(&self, f: F) -> Self;"
  },
  {
    "id": 1020,
    "function": "filter",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "44-45",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n × W(f)), Span Θ(n × S(f)), Parallelism Θ(1)\n        fn filter<F: Fn(&K, &V) -> B>(&self, f: F) -> Self;"
  },
  {
    "id": 1021,
    "function": "reduce",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "46-47",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n × W(f)), Span Θ(n × S(f)), Parallelism Θ(1)\n        fn reduce<R, F: Fn(R, &K, &V) -> R>(&self, init: R, f: F) -> R;"
  },
  {
    "id": 1022,
    "function": "intersection",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "48-49",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)\n        fn intersection<F: Fn(&V, &V) -> V>(&mut self, other: &Self, f: F);"
  },
  {
    "id": 1023,
    "function": "union",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "50-51",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)\n        fn union<F: Fn(&V, &V) -> V>(&mut self, other: &Self, f: F);"
  },
  {
    "id": 1024,
    "function": "difference",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "52-53",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)\n        fn difference(&mut self, other: &Self);"
  },
  {
    "id": 1025,
    "function": "restrict",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "54-55",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(m + n), Span Θ(m + n), Parallelism Θ(1)\n        fn restrict(&mut self, keys: &ArraySetStEph<K>);"
  },
  {
    "id": 1026,
    "function": "subtract",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "56-57",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(m + n), Span Θ(m + n), Parallelism Θ(1)\n        fn subtract(&mut self, keys: &ArraySetStEph<K>);"
  },
  {
    "id": 1027,
    "function": "collect",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "58-59",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)\n        fn collect(&self)                       -> AVLTreeSeqStPerS<Pair<K, V>>;"
  },
  {
    "id": 1028,
    "function": "first_key",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "61-63",
    "spec_strength": "",
    "snippet": "        // Key ordering operations (ADT 43.1 adapted for tables)\n        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn first_key(&self)                     -> Option<K>;"
  },
  {
    "id": 1029,
    "function": "last_key",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "64-65",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn last_key(&self)                      -> Option<K>;"
  },
  {
    "id": 1030,
    "function": "previous_key",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "66-67",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn previous_key(&self, k: &K)           -> Option<K>;"
  },
  {
    "id": 1031,
    "function": "next_key",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "68-69",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn next_key(&self, k: &K)               -> Option<K>;"
  },
  {
    "id": 1032,
    "function": "split_key",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "70-73",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn split_key(&mut self, k: &K)          -> (Self, Self)\n        where\n            Self: Sized;"
  },
  {
    "id": 1033,
    "function": "join_key",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "74-75",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log(|self| + |other|)), Span Θ(log(|self| + |other|)), Parallelism Θ(1)\n        fn join_key(&mut self, other: Self);"
  },
  {
    "id": 1034,
    "function": "get_key_range",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "76",
    "spec_strength": "",
    "snippet": "        fn get_key_range(&self, k1: &K, k2: &K) -> Self;"
  },
  {
    "id": 1035,
    "function": "rank_key",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "77",
    "spec_strength": "",
    "snippet": "        fn rank_key(&self, k: &K)               -> N;"
  },
  {
    "id": 1036,
    "function": "select_key",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "78",
    "spec_strength": "",
    "snippet": "        fn select_key(&self, i: N)              -> Option<K>;"
  },
  {
    "id": 1037,
    "function": "split_rank_key",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "79-81",
    "spec_strength": "",
    "snippet": "        fn split_rank_key(&mut self, i: N)      -> (Self, Self)\n        where\n            Self: Sized;"
  },
  {
    "id": 1038,
    "function": "from_sorted_entries",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "366-376",
    "spec_strength": "",
    "snippet": "    // Convert persistent sequence to Vec for TableStEph\n    pub fn from_sorted_entries<K: StT + Ord, V: StT>(entries: AVLTreeSeqStPerS<Pair<K, V>>) -> OrderedTableStEph<K, V> {\n        let len = entries.length();\n        let mut elements = Vec::new();\n        for i in 0..len {\n            elements.push(entries.nth(i).clone());\n        }\n        OrderedTableStEph {\n            base_table: crate::Chap42::TableStEph::TableStEph::from_sorted_entries(elements),\n        }\n    }"
  },
  {
    "id": 1039,
    "function": "size",
    "file": "Chap43/OrderedTableStPer.rs",
    "lines": "21-23",
    "spec_strength": "",
    "snippet": "        // Base table operations (ADT 42.1) - delegated\n        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn size(&self)                              -> N;"
  },
  {
    "id": 1040,
    "function": "empty",
    "file": "Chap43/OrderedTableStPer.rs",
    "lines": "24-25",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn empty()                                  -> Self;"
  },
  {
    "id": 1041,
    "function": "singleton",
    "file": "Chap43/OrderedTableStPer.rs",
    "lines": "26-27",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn singleton(k: K, v: V)                    -> Self;"
  },
  {
    "id": 1042,
    "function": "find",
    "file": "Chap43/OrderedTableStPer.rs",
    "lines": "28-29",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn find(&self, k: &K)                       -> Option<V>;"
  },
  {
    "id": 1043,
    "function": "insert",
    "file": "Chap43/OrderedTableStPer.rs",
    "lines": "30-31",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn insert(&self, k: K, v: V)                -> Self;"
  },
  {
    "id": 1044,
    "function": "delete",
    "file": "Chap43/OrderedTableStPer.rs",
    "lines": "32-33",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn delete(&self, k: &K)                     -> Self;"
  },
  {
    "id": 1045,
    "function": "domain",
    "file": "Chap43/OrderedTableStPer.rs",
    "lines": "34-35",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)\n        fn domain(&self)                            -> ArraySetStEph<K>;"
  },
  {
    "id": 1046,
    "function": "tabulate",
    "file": "Chap43/OrderedTableStPer.rs",
    "lines": "36-37",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(|keys| × W(f)), Span Θ(|keys| × S(f)), Parallelism Θ(1)\n        fn tabulate<F: Fn(&K) -> V>(f: F, keys: &ArraySetStEph<K>) -> Self;"
  },
  {
    "id": 1047,
    "function": "map",
    "file": "Chap43/OrderedTableStPer.rs",
    "lines": "38-39",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n × W(f)), Span Θ(n × S(f)), Parallelism Θ(1)\n        fn map<F: Fn(&V) -> V>(&self, f: F) -> Self;"
  },
  {
    "id": 1048,
    "function": "filter",
    "file": "Chap43/OrderedTableStPer.rs",
    "lines": "40-41",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n × W(f)), Span Θ(n × S(f)), Parallelism Θ(1)\n        fn filter<F: Fn(&K, &V) -> B>(&self, f: F) -> Self;"
  },
  {
    "id": 1049,
    "function": "intersection",
    "file": "Chap43/OrderedTableStPer.rs",
    "lines": "42-43",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)\n        fn intersection<F: Fn(&V, &V) -> V>(&self, other: &Self, f: F) -> Self;"
  },
  {
    "id": 1050,
    "function": "union",
    "file": "Chap43/OrderedTableStPer.rs",
    "lines": "44-45",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)\n        fn union<F: Fn(&V, &V) -> V>(&self, other: &Self, f: F) -> Self;"
  },
  {
    "id": 1051,
    "function": "difference",
    "file": "Chap43/OrderedTableStPer.rs",
    "lines": "46-47",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(m log(n/m)) where m = min(|self|, |other|), Span Θ(log n × log m)\n        fn difference(&self, other: &Self)          -> Self;"
  },
  {
    "id": 1052,
    "function": "restrict",
    "file": "Chap43/OrderedTableStPer.rs",
    "lines": "48-49",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(m + n), Span Θ(m + n), Parallelism Θ(1)\n        fn restrict(&self, keys: &ArraySetStEph<K>) -> Self;"
  },
  {
    "id": 1053,
    "function": "subtract",
    "file": "Chap43/OrderedTableStPer.rs",
    "lines": "50-51",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(m + n), Span Θ(m + n), Parallelism Θ(1)\n        fn subtract(&self, keys: &ArraySetStEph<K>) -> Self;"
  },
  {
    "id": 1054,
    "function": "collect",
    "file": "Chap43/OrderedTableStPer.rs",
    "lines": "52-53",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)\n        fn collect(&self)                           -> AVLTreeSeqStPerS<Pair<K, V>>;"
  },
  {
    "id": 1055,
    "function": "first_key",
    "file": "Chap43/OrderedTableStPer.rs",
    "lines": "55-57",
    "spec_strength": "",
    "snippet": "        // Key ordering operations (ADT 43.1 adapted for tables)\n        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn first_key(&self)                         -> Option<K>;"
  },
  {
    "id": 1056,
    "function": "last_key",
    "file": "Chap43/OrderedTableStPer.rs",
    "lines": "58-59",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn last_key(&self)                          -> Option<K>;"
  },
  {
    "id": 1057,
    "function": "previous_key",
    "file": "Chap43/OrderedTableStPer.rs",
    "lines": "60-61",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn previous_key(&self, k: &K)               -> Option<K>;"
  },
  {
    "id": 1058,
    "function": "next_key",
    "file": "Chap43/OrderedTableStPer.rs",
    "lines": "62-63",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn next_key(&self, k: &K)                   -> Option<K>;"
  },
  {
    "id": 1059,
    "function": "split_key",
    "file": "Chap43/OrderedTableStPer.rs",
    "lines": "64-67",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn split_key(&self, k: &K)                  -> (Self, Option<V>, Self)\n        where\n            Self: Sized;"
  },
  {
    "id": 1060,
    "function": "join_key",
    "file": "Chap43/OrderedTableStPer.rs",
    "lines": "68-69",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log(|left| + |right|)), Span Θ(log(|left| + |right|)), Parallelism Θ(1)\n        fn join_key(left: &Self, right: &Self)      -> Self;"
  },
  {
    "id": 1061,
    "function": "get_key_range",
    "file": "Chap43/OrderedTableStPer.rs",
    "lines": "70-71",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn get_key_range(&self, k1: &K, k2: &K)     -> Self;"
  },
  {
    "id": 1062,
    "function": "rank_key",
    "file": "Chap43/OrderedTableStPer.rs",
    "lines": "72-73",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn rank_key(&self, k: &K)                   -> N;"
  },
  {
    "id": 1063,
    "function": "select_key",
    "file": "Chap43/OrderedTableStPer.rs",
    "lines": "74-75",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        fn select_key(&self, i: N)                  -> Option<K>;"
  },
  {
    "id": 1064,
    "function": "split_rank_key",
    "file": "Chap43/OrderedTableStPer.rs",
    "lines": "76-78",
    "spec_strength": "",
    "snippet": "        fn split_rank_key(&self, i: N)              -> (Self, Self)\n        where\n            Self: Sized;"
  },
  {
    "id": 1065,
    "function": "from_sorted_entries",
    "file": "Chap43/OrderedTableStPer.rs",
    "lines": "350-359",
    "spec_strength": "",
    "snippet": "    pub fn from_sorted_entries<K: StT + Ord, V: StT>(entries: AVLTreeSeqStPerS<Pair<K, V>>) -> OrderedTableStPer<K, V> {\n        let len = entries.length();\n        let mut elements = Vec::new();\n        for i in 0..len {\n            elements.push(entries.nth(i).clone());\n        }\n        OrderedTableStPer {\n            base_table: crate::Chap42::TableStPer::TableStPer::from_sorted_entries(elements),\n        }\n    }"
  },
  {
    "id": 1066,
    "function": "make_index",
    "file": "Chap44/DocumentIndex.rs",
    "lines": "30-32",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(n log n), Span Θ(log² n)\n        /// - Claude-Opus-4.6: Work Θ(n²), Span Θ(n²) — sequential nested loops over all_pairs; no Table.collect sort used\n        fn make_index(docs: &DocumentCollection)                     -> Self;"
  },
  {
    "id": 1067,
    "function": "find`",
    "file": "Chap44/DocumentIndex.rs",
    "lines": "288-290",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — delegates to DocumentIndex::find.\n        /// - Claude-Opus-4.6: Work Θ(log n), Span Θ(log n)\n        fn find(&self, word: &Word)                                                     -> DocumentSet;"
  },
  {
    "id": 1068,
    "function": "query_and",
    "file": "Chap44/DocumentIndex.rs",
    "lines": "38-40",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(m log(1 + n/m)), Span Θ(log n + log m)\n        /// - Claude-Opus-4.6: Work Θ(m log(1 + n/m)), Span Θ(m log(1 + n/m)) — delegates to AVLTreeSetStPer.intersection (sequential)\n        fn query_and(docs_a: &DocumentSet, docs_b: &DocumentSet)     -> DocumentSet;"
  },
  {
    "id": 1069,
    "function": "query_or",
    "file": "Chap44/DocumentIndex.rs",
    "lines": "42-44",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(m log(1 + n/m)), Span Θ(log n + log m)\n        /// - Claude-Opus-4.6: Work Θ(m log(1 + n/m)), Span Θ(m log(1 + n/m)) — delegates to AVLTreeSetStPer.union (sequential)\n        fn query_or(docs_a: &DocumentSet, docs_b: &DocumentSet)      -> DocumentSet;"
  },
  {
    "id": 1070,
    "function": "query_and_not",
    "file": "Chap44/DocumentIndex.rs",
    "lines": "46-48",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(m log(1 + n/m)), Span Θ(log n + log m)\n        /// - Claude-Opus-4.6: Work Θ(m log(1 + n/m)), Span Θ(m log(1 + n/m)) — delegates to AVLTreeSetStPer.difference (sequential)\n        fn query_and_not(docs_a: &DocumentSet, docs_b: &DocumentSet) -> DocumentSet;"
  },
  {
    "id": 1071,
    "function": "size",
    "file": "Chap44/DocumentIndex.rs",
    "lines": "50-52",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(1), Span Θ(1)\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1) — agrees with APAS\n        fn size(docs: &DocumentSet)                                  -> N;"
  },
  {
    "id": 1072,
    "function": "to_seq",
    "file": "Chap44/DocumentIndex.rs",
    "lines": "54-56",
    "spec_strength": "",
    "snippet": "        /// - APAS: (no cost stated)\n        /// - Claude-Opus-4.6: Work Θ(n), Span Θ(n) — sequential iteration over AVL tree sequence\n        fn to_seq(docs: &DocumentSet)                                -> ArraySeqStPerS<DocumentId>;"
  },
  {
    "id": 1073,
    "function": "empty",
    "file": "Chap44/DocumentIndex.rs",
    "lines": "58-60",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — Verus-specific scaffolding.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        fn empty()                                                   -> Self;"
  },
  {
    "id": 1074,
    "function": "get_all_words",
    "file": "Chap44/DocumentIndex.rs",
    "lines": "62-64",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — Verus-specific scaffolding.\n        /// - Claude-Opus-4.6: Work Θ(n), Span Θ(n) — collects table keys into sequence\n        fn get_all_words(&self)                                      -> ArraySeqStPerS<Word>;"
  },
  {
    "id": 1075,
    "function": "word_count",
    "file": "Chap44/DocumentIndex.rs",
    "lines": "66-68",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — Verus-specific scaffolding.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1) — delegates to Table.size\n        fn word_count(&self)                                         -> N;"
  },
  {
    "id": 1076,
    "function": "tokens",
    "file": "Chap44/DocumentIndex.rs",
    "lines": "200-227",
    "spec_strength": "",
    "snippet": "    /// Tokenization function: splits content into words.\n    /// - APAS: (no cost stated — tokens is a helper assumed O(m) where m = string length)\n    /// - Claude-Opus-4.6: Work Θ(m), Span Θ(m) — sequential character iteration\n    pub fn tokens(content: &Contents) -> ArraySeqStPerS<Word> {\n        let mut words = ArraySeqStPerS::empty();\n        let content_lower = content.to_lowercase();\n\n        // Simple tokenization: split on whitespace and punctuation\n        let mut current_word = String::new();\n\n        for ch in content_lower.chars() {\n            if ch.is_alphabetic() {\n                current_word.push(ch);\n            } else if !current_word.is_empty() {\n                let single_seq = ArraySeqStPerS::singleton(current_word.clone());\n                words = ArraySeqStPerS::append(&words, &single_seq);\n                current_word = String::new();\n            }\n        }\n\n        // Don't forget the last word\n        if !current_word.is_empty() {\n            let single_seq = ArraySeqStPerS::singleton(current_word);\n            words = ArraySeqStPerS::append(&words, &single_seq);\n        }\n\n        words\n    }"
  },
  {
    "id": 1077,
    "function": "create_finder",
    "file": "Chap44/DocumentIndex.rs",
    "lines": "229-234",
    "spec_strength": "",
    "snippet": "    /// Convenience function for staged computation pattern (Example 44.2).\n    /// - APAS: N/A — Verus-specific scaffolding.\n    /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1) — closure capture only\n    pub fn create_finder(index: &DocumentIndex) -> impl Fn(&Word) -> DocumentSet + '_ {\n        move |word: &Word| index.find(word)\n    }"
  },
  {
    "id": 1078,
    "function": "new",
    "file": "Chap44/DocumentIndex.rs",
    "lines": "284-286",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — Verus-specific scaffolding.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        fn new(index: &'a DocumentIndex)                                                -> Self;"
  },
  {
    "id": 1079,
    "function": "and",
    "file": "Chap44/DocumentIndex.rs",
    "lines": "292-294",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — delegates to DocumentIndex::query_and.\n        /// - Claude-Opus-4.6: Work Θ(m log(1 + n/m)), Span Θ(m log(1 + n/m))\n        fn and(&self, docs_a: DocumentSet, docs_b: DocumentSet)                         -> DocumentSet;"
  },
  {
    "id": 1080,
    "function": "or",
    "file": "Chap44/DocumentIndex.rs",
    "lines": "296-298",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — delegates to DocumentIndex::query_or.\n        /// - Claude-Opus-4.6: Work Θ(m log(1 + n/m)), Span Θ(m log(1 + n/m))\n        fn or(&self, docs_a: DocumentSet, docs_b: DocumentSet)                          -> DocumentSet;"
  },
  {
    "id": 1081,
    "function": "and_not",
    "file": "Chap44/DocumentIndex.rs",
    "lines": "300-302",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — delegates to DocumentIndex::query_and_not.\n        /// - Claude-Opus-4.6: Work Θ(m log(1 + n/m)), Span Θ(m log(1 + n/m))\n        fn and_not(&self, docs_a: DocumentSet, docs_b: DocumentSet)                     -> DocumentSet;"
  },
  {
    "id": 1082,
    "function": "complex_query",
    "file": "Chap44/DocumentIndex.rs",
    "lines": "304-306",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — Verus-specific scaffolding.\n        /// - Claude-Opus-4.6: Work dominated by 4 finds + 3 set operations\n        fn complex_query(&self, word1: &Word, word2: &Word, word3: &Word, word4: &Word) -> DocumentSet;"
  },
  {
    "id": 1083,
    "function": "create_tweet_collection",
    "file": "Chap44/Example44_1.rs",
    "lines": "11-21",
    "spec_strength": "",
    "snippet": "    /// - APAS: N/A — Example scaffolding.\n    /// - Claude-Opus-4.6: Work Θ(n), Span Θ(n) — builds 5-element sequence via macro\n    pub fn create_tweet_collection() -> DocumentCollection {\n        DocumentCollectionLit![\n            \"jack\" => \"chess is fun\",\n            \"mary\" => \"I had fun in dance club today\",\n            \"nick\" => \"food at the cafeteria sucks\",\n            \"josefa\" => \"rock climbing was a blast\",\n            \"peter\" => \"I had fun at the party, food was great\"\n        ]\n    }"
  },
  {
    "id": 1084,
    "function": "create_tweet_index",
    "file": "Chap44/Example44_1.rs",
    "lines": "23-29",
    "spec_strength": "",
    "snippet": "    /// Creates the document index for the tweet collection.\n    /// - APAS: N/A — Example scaffolding (cost dominated by make_index).\n    /// - Claude-Opus-4.6: Work Θ(n²), Span Θ(n²) — delegates to make_index\n    pub fn create_tweet_index() -> DocumentIndex {\n        let tweets = create_tweet_collection();\n        DocumentIndex::make_index(&tweets)\n    }"
  },
  {
    "id": 1085,
    "function": "create_tweet_finder",
    "file": "Chap44/Example44_1.rs",
    "lines": "31-38",
    "spec_strength": "",
    "snippet": "    /// Example 44.2: Staged computation pattern.\n    /// fw : word -> docs = find (makeIndex T)\n    /// - APAS: N/A — Example scaffolding (cost dominated by make_index).\n    /// - Claude-Opus-4.6: Work Θ(n²), Span Θ(n²) — builds index then returns closure\n    pub fn create_tweet_finder() -> impl Fn(&Word) -> DocumentSet {\n        let index = create_tweet_index();\n        move |word: &Word| index.find(word)\n    }"
  },
  {
    "id": 1086,
    "function": "default",
    "file": "Chap44/Example44_1.rs",
    "lines": "47",
    "spec_strength": "",
    "snippet": "        fn default() -> Self { Self::new() }"
  },
  {
    "id": 1087,
    "function": "new",
    "file": "Chap44/Example44_1.rs",
    "lines": "51-59",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — Example scaffolding.\n        /// - Claude-Opus-4.6: Work Θ(n²), Span Θ(n²) — builds index via create_tweet_index\n        pub fn new() -> Self {\n            let index = create_tweet_index();\n            let index_clone = index.clone();\n            let fw = Box::new(move |word: &Word| index_clone.find(word));\n\n            TweetQueryExamples { index, fw }\n        }"
  },
  {
    "id": 1088,
    "function": "search_fun",
    "file": "Chap44/Example44_1.rs",
    "lines": "61-64",
    "spec_strength": "",
    "snippet": "        /// Example query: searching for 'fun' should return {\"jack\", \"mary\", \"peter\"}.\n        /// - APAS: N/A — Example scaffolding.\n        /// - Claude-Opus-4.6: Work Θ(log n), Span Θ(log n) — single find\n        pub fn search_fun(&self) -> DocumentSet { (self.fw)(&\"fun\".to_string()) }"
  },
  {
    "id": 1089,
    "function": "search_club",
    "file": "Chap44/Example44_1.rs",
    "lines": "66-69",
    "spec_strength": "",
    "snippet": "        /// Example query: searching for 'club' should return {\"mary\"}.\n        /// - APAS: N/A — Example scaffolding.\n        /// - Claude-Opus-4.6: Work Θ(log n), Span Θ(log n) — single find\n        pub fn search_club(&self) -> DocumentSet { (self.fw)(&\"club\".to_string()) }"
  },
  {
    "id": 1090,
    "function": "search_food",
    "file": "Chap44/Example44_1.rs",
    "lines": "71-74",
    "spec_strength": "",
    "snippet": "        /// Example query: searching for 'food' should return {\"nick\", \"peter\"}.\n        /// - APAS: N/A — Example scaffolding.\n        /// - Claude-Opus-4.6: Work Θ(log n), Span Θ(log n) — single find\n        pub fn search_food(&self) -> DocumentSet { (self.fw)(&\"food\".to_string()) }"
  },
  {
    "id": 1091,
    "function": "search_chess",
    "file": "Chap44/Example44_1.rs",
    "lines": "76-79",
    "spec_strength": "",
    "snippet": "        /// Example query: searching for 'chess' should return {\"jack\"}.\n        /// - APAS: N/A — Example scaffolding.\n        /// - Claude-Opus-4.6: Work Θ(log n), Span Θ(log n) — single find\n        pub fn search_chess(&self) -> DocumentSet { (self.fw)(&\"chess\".to_string()) }"
  },
  {
    "id": 1092,
    "function": "complex_query_fun_and_food_or_chess",
    "file": "Chap44/Example44_1.rs",
    "lines": "81-95",
    "spec_strength": "",
    "snippet": "        /// Complex query from textbook:\n        /// toSeq (queryAnd ((fw 'fun'), queryOr ((fw 'food'), (fw 'chess'))))\n        /// Expected result: ⟨'jack', 'peter'⟩\n        /// - APAS: N/A — Example scaffolding; cost is 3 finds + 2 set operations + toSeq.\n        /// - Claude-Opus-4.6: Work Θ(m log(1+n/m)), Span Θ(m log(1+n/m)) — dominated by set operations\n        pub fn complex_query_fun_and_food_or_chess(&self) -> ArraySeqStPerS<DocumentId> {\n            let fun_docs = (self.fw)(&\"fun\".to_string());\n            let food_docs = (self.fw)(&\"food\".to_string());\n            let chess_docs = (self.fw)(&\"chess\".to_string());\n\n            let food_or_chess = DocumentIndex::query_or(&food_docs, &chess_docs);\n            let result = DocumentIndex::query_and(&fun_docs, &food_or_chess);\n\n            DocumentIndex::to_seq(&result)\n        }"
  },
  {
    "id": 1093,
    "function": "count_fun_but_not_chess",
    "file": "Chap44/Example44_1.rs",
    "lines": "97-108",
    "spec_strength": "",
    "snippet": "        /// Complex query from textbook:\n        /// size (queryAndNot ((fw 'fun'), (fw 'chess')))\n        /// Expected result: 2 (mary and peter).\n        /// - APAS: N/A — Example scaffolding; cost is 2 finds + queryAndNot + size.\n        /// - Claude-Opus-4.6: Work Θ(m log(1+n/m)), Span Θ(m log(1+n/m)) — dominated by set difference\n        pub fn count_fun_but_not_chess(&self) -> N {\n            let fun_docs = (self.fw)(&\"fun\".to_string());\n            let chess_docs = (self.fw)(&\"chess\".to_string());\n\n            let result = DocumentIndex::query_and_not(&fun_docs, &chess_docs);\n            DocumentIndex::size(&result)\n        }"
  },
  {
    "id": 1094,
    "function": "search_food_or_fun",
    "file": "Chap44/Example44_1.rs",
    "lines": "110-118",
    "spec_strength": "",
    "snippet": "        /// Additional example: documents with 'food' OR 'fun'.\n        /// - APAS: N/A — Example scaffolding.\n        /// - Claude-Opus-4.6: Work Θ(m log(1+n/m)), Span Θ(m log(1+n/m))\n        pub fn search_food_or_fun(&self) -> DocumentSet {\n            let food_docs = (self.fw)(&\"food\".to_string());\n            let fun_docs = (self.fw)(&\"fun\".to_string());\n\n            DocumentIndex::query_or(&food_docs, &fun_docs)\n        }"
  },
  {
    "id": 1095,
    "function": "search_party_and_food",
    "file": "Chap44/Example44_1.rs",
    "lines": "120-128",
    "spec_strength": "",
    "snippet": "        /// Additional example: documents with 'party' AND 'food'.\n        /// - APAS: N/A — Example scaffolding.\n        /// - Claude-Opus-4.6: Work Θ(m log(1+n/m)), Span Θ(m log(1+n/m))\n        pub fn search_party_and_food(&self) -> DocumentSet {\n            let party_docs = (self.fw)(&\"party\".to_string());\n            let food_docs = (self.fw)(&\"food\".to_string());\n\n            DocumentIndex::query_and(&party_docs, &food_docs)\n        }"
  },
  {
    "id": 1096,
    "function": "get_all_words",
    "file": "Chap44/Example44_1.rs",
    "lines": "130-133",
    "spec_strength": "",
    "snippet": "        /// Get all unique words in the tweet collection.\n        /// - APAS: N/A — Example scaffolding.\n        /// - Claude-Opus-4.6: Work Θ(n), Span Θ(n)\n        pub fn get_all_words(&self) -> ArraySeqStPerS<Word> { self.index.get_all_words() }"
  },
  {
    "id": 1097,
    "function": "get_word_count",
    "file": "Chap44/Example44_1.rs",
    "lines": "135-138",
    "spec_strength": "",
    "snippet": "        /// Get word count statistics.\n        /// - APAS: N/A — Example scaffolding.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        pub fn get_word_count(&self) -> N { self.index.word_count() }"
  },
  {
    "id": 1098,
    "function": "query_builder_example",
    "file": "Chap44/Example44_1.rs",
    "lines": "140-153",
    "spec_strength": "",
    "snippet": "        /// Demonstrate query builder pattern.\n        /// - APAS: N/A — Example scaffolding.\n        /// - Claude-Opus-4.6: Work dominated by 4 finds + 3 set operations\n        pub fn query_builder_example(&self) -> DocumentSet {\n            let builder = QueryBuilder::new(&self.index);\n\n            // Complex query: (fun AND party) OR (chess AND NOT food)\n            builder.complex_query(\n                &\"fun\".to_string(),\n                &\"party\".to_string(),\n                &\"chess\".to_string(),\n                &\"food\".to_string(),\n            )\n        }"
  },
  {
    "id": 1099,
    "function": "doc_set_to_sorted_vec",
    "file": "Chap44/Example44_1.rs",
    "lines": "156-169",
    "spec_strength": "",
    "snippet": "    /// - APAS: N/A — Test helper.\n    /// - Claude-Opus-4.6: Work Θ(n log n), Span Θ(n log n) — to_seq + sort\n    pub fn doc_set_to_sorted_vec(docs: &DocumentSet) -> Vec<DocumentId> {\n        let seq = DocumentIndex::to_seq(docs);\n        let mut result = Vec::new();\n\n        for i in 0..seq.length() {\n            let doc_id = seq.nth(i);\n            result.push(doc_id.clone());\n        }\n\n        result.sort();\n        result\n    }"
  },
  {
    "id": 1100,
    "function": "verify_textbook_examples",
    "file": "Chap44/Example44_1.rs",
    "lines": "171-211",
    "spec_strength": "",
    "snippet": "    /// Verify the expected results from the textbook examples.\n    /// - APAS: N/A — Test verification helper.\n    /// - Claude-Opus-4.6: Work Θ(n²), Span Θ(n²) — builds index, runs queries, compares results\n    pub fn verify_textbook_examples() -> bool {\n        let examples = TweetQueryExamples::new();\n\n        // Test 1: searching for 'fun' should return {\"jack\", \"mary\", \"peter\"}\n        let fun_results = doc_set_to_sorted_vec(&examples.search_fun());\n        let expected_fun = vec![\"jack\".to_string(), \"mary\".to_string(), \"peter\".to_string()];\n        if fun_results != expected_fun {\n            return false;\n        }\n\n        // Test 2: searching for 'club' should return {\"mary\"}\n        let club_results = doc_set_to_sorted_vec(&examples.search_club());\n        let expected_club = vec![\"mary\".to_string()];\n        if club_results != expected_club {\n            return false;\n        }\n\n        // Test 3: complex query should return ⟨'jack', 'peter'⟩\n        let complex_results = examples.complex_query_fun_and_food_or_chess();\n        let mut complex_vec = Vec::new();\n        for i in 0..complex_results.length() {\n            let doc_id = complex_results.nth(i);\n            complex_vec.push(doc_id.clone());\n        }\n        complex_vec.sort();\n        let expected_complex = vec![\"jack\".to_string(), \"peter\".to_string()];\n        if complex_vec != expected_complex {\n            return false;\n        }\n\n        // Test 4: count query should return 2\n        let count_result = examples.count_fun_but_not_chess();\n        if count_result != 2 {\n            return false;\n        }\n\n        true\n    }"
  },
  {
    "id": 1101,
    "function": "performance_comparison_demo",
    "file": "Chap44/Example44_1.rs",
    "lines": "213-227",
    "spec_strength": "",
    "snippet": "    /// Performance demonstration: compare indexed search vs brute force.\n    /// - APAS: N/A — Example scaffolding.\n    /// - Claude-Opus-4.6: Work Θ(n²), Span Θ(n²) — dominated by index construction\n    pub fn performance_comparison_demo() -> (N, N) {\n        let tweets = create_tweet_collection();\n        let _index = create_tweet_index();\n\n        // Indexed search work: O(log n) for find\n        let indexed_work = 1; // Represents O(log n) complexity\n\n        // Brute force work: O(n * m) where n is documents, m is average content length\n        let brute_force_work = tweets.length(); // Represents O(n) complexity\n\n        (indexed_work, brute_force_work)\n    }"
  },
  {
    "id": 1102,
    "function": "tokenization_demo",
    "file": "Chap44/Example44_1.rs",
    "lines": "229-235",
    "spec_strength": "",
    "snippet": "    /// Demonstrate the tokenization process.\n    /// - APAS: N/A — Example scaffolding.\n    /// - Claude-Opus-4.6: Work Θ(m), Span Θ(m) — delegates to tokens()\n    pub fn tokenization_demo() -> ArraySeqStPerS<Word> {\n        let sample_content = \"I had fun in dance club today!\";\n        tokens(&sample_content.to_string())\n    }"
  },
  {
    "id": 1103,
    "function": "index_statistics",
    "file": "Chap44/Example44_1.rs",
    "lines": "237-256",
    "spec_strength": "",
    "snippet": "    /// Show index statistics for the tweet collection.\n    /// - APAS: N/A — Example scaffolding.\n    /// - Claude-Opus-4.6: Work Θ(n²), Span Θ(n²) — builds index + iterates documents\n    pub fn index_statistics() -> (N, N, N) {\n        let tweets = create_tweet_collection();\n        let index = create_tweet_index();\n\n        let document_count = tweets.length();\n        let unique_word_count = index.word_count();\n\n        // Calculate total words across all documents\n        let mut total_words = 0;\n        for i in 0..tweets.length() {\n            let doc = tweets.nth(i);\n            let word_tokens = tokens(&doc.1);\n            total_words += word_tokens.length();\n        }\n\n        (document_count, unique_word_count, total_words)\n    }"
  },
  {
    "id": 1104,
    "function": "empty",
    "file": "Chap45/BalancedTreePQ.rs",
    "lines": "18-19",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn empty()                                           -> Self;"
  },
  {
    "id": 1105,
    "function": "singleton",
    "file": "Chap45/BalancedTreePQ.rs",
    "lines": "21-22",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn singleton(element: T)                             -> Self;"
  },
  {
    "id": 1106,
    "function": "find_min",
    "file": "Chap45/BalancedTreePQ.rs",
    "lines": "24-26",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        /// Returns the minimum element (leftmost in balanced tree), or None if empty\n        fn find_min(&self)                                   -> Option<&T>;"
  },
  {
    "id": 1107,
    "function": "insert",
    "file": "Chap45/BalancedTreePQ.rs",
    "lines": "28-30",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        /// Inserts element into balanced tree maintaining order\n        fn insert(&self, element: T)                         -> Self;"
  },
  {
    "id": 1108,
    "function": "delete_min",
    "file": "Chap45/BalancedTreePQ.rs",
    "lines": "32-36",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        /// Removes minimum element (leftmost) from balanced tree\n        fn delete_min(&self)                                 -> (Self, Option<T>)\n        where\n            Self: Sized;"
  },
  {
    "id": 1109,
    "function": "meld",
    "file": "Chap45/BalancedTreePQ.rs",
    "lines": "38-40",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(m log(1 + n/m)), Span Θ(log n + log m)\n        /// Melds two balanced trees using union operation\n        fn meld(&self, other: &Self)                         -> Self;"
  },
  {
    "id": 1110,
    "function": "from_seq",
    "file": "Chap45/BalancedTreePQ.rs",
    "lines": "42-44",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n log n), Span Θ(log² n), Parallelism Θ(n/log² n)\n        /// Creates priority queue from sequence using balanced tree construction\n        fn from_seq(seq: &AVLTreeSeqStPerS<T>)               -> Self;"
  },
  {
    "id": 1111,
    "function": "size",
    "file": "Chap45/BalancedTreePQ.rs",
    "lines": "46",
    "spec_strength": "",
    "snippet": "        fn size(&self)                                       -> N;"
  },
  {
    "id": 1112,
    "function": "is_empty",
    "file": "Chap45/BalancedTreePQ.rs",
    "lines": "47",
    "spec_strength": "",
    "snippet": "        fn is_empty(&self)                                   -> bool;"
  },
  {
    "id": 1113,
    "function": "to_seq",
    "file": "Chap45/BalancedTreePQ.rs",
    "lines": "48",
    "spec_strength": "",
    "snippet": "        fn to_seq(&self)                                     -> AVLTreeSeqStPerS<T>;"
  },
  {
    "id": 1114,
    "function": "find_max",
    "file": "Chap45/BalancedTreePQ.rs",
    "lines": "49",
    "spec_strength": "",
    "snippet": "        fn find_max(&self)                                   -> Option<&T>;"
  },
  {
    "id": 1115,
    "function": "delete_max",
    "file": "Chap45/BalancedTreePQ.rs",
    "lines": "50-52",
    "spec_strength": "",
    "snippet": "        fn delete_max(&self)                                 -> (Self, Option<T>)\n        where\n            Self: Sized;"
  },
  {
    "id": 1116,
    "function": "insert_all",
    "file": "Chap45/BalancedTreePQ.rs",
    "lines": "53",
    "spec_strength": "",
    "snippet": "        fn insert_all(&self, elements: &AVLTreeSeqStPerS<T>) -> Self;"
  },
  {
    "id": 1117,
    "function": "extract_all_sorted",
    "file": "Chap45/BalancedTreePQ.rs",
    "lines": "54",
    "spec_strength": "",
    "snippet": "        fn extract_all_sorted(&self)                         -> AVLTreeSeqStPerS<T>;"
  },
  {
    "id": 1118,
    "function": "contains",
    "file": "Chap45/BalancedTreePQ.rs",
    "lines": "55",
    "spec_strength": "",
    "snippet": "        fn contains(&self, element: &T)                      -> bool;"
  },
  {
    "id": 1119,
    "function": "remove",
    "file": "Chap45/BalancedTreePQ.rs",
    "lines": "56-58",
    "spec_strength": "",
    "snippet": "        fn remove(&self, element: &T)                        -> (Self, bool)\n        where\n            Self: Sized;"
  },
  {
    "id": 1120,
    "function": "range",
    "file": "Chap45/BalancedTreePQ.rs",
    "lines": "59",
    "spec_strength": "",
    "snippet": "        fn range(&self, min_val: &T, max_val: &T)            -> AVLTreeSeqStPerS<T>;"
  },
  {
    "id": 1121,
    "function": "from_vec",
    "file": "Chap45/BalancedTreePQ.rs",
    "lines": "60",
    "spec_strength": "",
    "snippet": "        fn from_vec(elements: Vec<T>)                        -> Self;"
  },
  {
    "id": 1122,
    "function": "to_vec",
    "file": "Chap45/BalancedTreePQ.rs",
    "lines": "61",
    "spec_strength": "",
    "snippet": "        fn to_vec(&self)                                     -> Vec<T>;"
  },
  {
    "id": 1123,
    "function": "to_sorted_vec",
    "file": "Chap45/BalancedTreePQ.rs",
    "lines": "62",
    "spec_strength": "",
    "snippet": "        fn to_sorted_vec(&self)                              -> Vec<T>;"
  },
  {
    "id": 1124,
    "function": "default",
    "file": "Chap45/BalancedTreePQ.rs",
    "lines": "306",
    "spec_strength": "",
    "snippet": "        fn default() -> Self { Self::empty() }"
  },
  {
    "id": 1125,
    "function": "is_sorted",
    "file": "Chap45/BalancedTreePQ.rs",
    "lines": "339-349",
    "spec_strength": "",
    "snippet": "        /// Check if the tree maintains sorted order (for testing)\n        pub fn is_sorted(&self) -> bool {\n            for i in 1..self.elements.length() {\n                let prev = self.elements.nth(i - 1);\n                let curr = self.elements.nth(i);\n                if prev > curr {\n                    return false;\n                }\n            }\n            true\n        }"
  },
  {
    "id": 1126,
    "function": "height",
    "file": "Chap45/BalancedTreePQ.rs",
    "lines": "350-359",
    "spec_strength": "",
    "snippet": "        /// Get height of the underlying AVL tree (for testing)\n        pub fn height(&self) -> N {\n            // This would require access to internal tree structure\n            // For now, return log(n) as expected height\n            if self.elements.length() == 0 {\n                0\n            } else {\n                ((self.elements.length() as f64).log2().ceil() as N).max(1)\n            }\n        }"
  },
  {
    "id": 1127,
    "function": "split",
    "file": "Chap45/BalancedTreePQ.rs",
    "lines": "364-384",
    "spec_strength": "",
    "snippet": "        /// Split the priority queue at a given element\n        /// Returns (left, found, right) where left < element <= right\n        pub fn split(&self, element: &T) -> (Self, bool, Self) {\n            let mut left = Self::empty();\n            let mut right = Self::empty();\n            let mut found = false;\n\n            for i in 0..self.elements.length() {\n                let current = self.elements.nth(i);\n                if current < element {\n                    left = left.insert(current.clone());\n                } else if current == element {\n                    found = true;\n                    right = right.insert(current.clone());\n                } else {\n                    right = right.insert(current.clone());\n                }\n            }\n\n            (left, found, right)\n        }"
  },
  {
    "id": 1128,
    "function": "join",
    "file": "Chap45/BalancedTreePQ.rs",
    "lines": "386-387",
    "spec_strength": "",
    "snippet": "        /// Join two priority queues where all elements in left <= all elements in right\n        pub fn join(left: &Self, right: &Self) -> Self { left.meld(right) }"
  },
  {
    "id": 1129,
    "function": "filter",
    "file": "Chap45/BalancedTreePQ.rs",
    "lines": "389-404",
    "spec_strength": "",
    "snippet": "        /// Filter elements based on a predicate\n        pub fn filter<F>(&self, predicate: F) -> Self\n        where\n            F: Fn(&T) -> bool,\n        {\n            let mut result = Self::empty();\n\n            for i in 0..self.elements.length() {\n                let current = self.elements.nth(i);\n                if predicate(current) {\n                    result = result.insert(current.clone());\n                }\n            }\n\n            result\n        }"
  },
  {
    "id": 1130,
    "function": "map",
    "file": "Chap45/BalancedTreePQ.rs",
    "lines": "406-421",
    "spec_strength": "",
    "snippet": "        /// Map elements to a new type (maintaining order)\n        pub fn map<U, F>(&self, f: F) -> BalancedTreePQ<U>\n        where\n            U: StT + Ord,\n            F: Fn(&T) -> U,\n        {\n            let mut result = BalancedTreePQ::<U>::empty();\n\n            for i in 0..self.elements.length() {\n                let current = self.elements.nth(i);\n                let mapped = f(current);\n                result = result.insert(mapped);\n            }\n\n            result\n        }"
  },
  {
    "id": 1131,
    "function": "empty",
    "file": "Chap45/BinaryHeapPQ.rs",
    "lines": "18-19",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn empty()                           -> Self;"
  },
  {
    "id": 1132,
    "function": "singleton",
    "file": "Chap45/BinaryHeapPQ.rs",
    "lines": "21-22",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn singleton(element: T)             -> Self;"
  },
  {
    "id": 1133,
    "function": "find_min",
    "file": "Chap45/BinaryHeapPQ.rs",
    "lines": "24-26",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        /// Returns the minimum element (root of min-heap), or None if empty\n        fn find_min(&self)                   -> Option<&T>;"
  },
  {
    "id": 1134,
    "function": "insert",
    "file": "Chap45/BinaryHeapPQ.rs",
    "lines": "28-30",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        /// Inserts element and bubbles up to maintain heap property\n        fn insert(&self, element: T)         -> Self;"
  },
  {
    "id": 1135,
    "function": "delete_min",
    "file": "Chap45/BinaryHeapPQ.rs",
    "lines": "32-36",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        /// Removes root (minimum) and bubbles down to maintain heap property\n        fn delete_min(&self)                 -> (Self, Option<T>)\n        where\n            Self: Sized;"
  },
  {
    "id": 1136,
    "function": "meld",
    "file": "Chap45/BinaryHeapPQ.rs",
    "lines": "38-40",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(m + n), Span Θ(m + n), Parallelism Θ(1)\n        /// Melds two heaps by concatenating and re-heapifying\n        fn meld(&self, other: &Self)         -> Self;"
  },
  {
    "id": 1137,
    "function": "from_seq",
    "file": "Chap45/BinaryHeapPQ.rs",
    "lines": "42-44",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)\n        /// Creates heap from sequence using bottom-up heapify\n        fn from_seq(seq: &ArraySeqStPerS<T>) -> Self;"
  },
  {
    "id": 1138,
    "function": "size",
    "file": "Chap45/BinaryHeapPQ.rs",
    "lines": "46",
    "spec_strength": "",
    "snippet": "        fn size(&self)                       -> N;"
  },
  {
    "id": 1139,
    "function": "is_empty",
    "file": "Chap45/BinaryHeapPQ.rs",
    "lines": "47",
    "spec_strength": "",
    "snippet": "        fn is_empty(&self)                   -> bool;"
  },
  {
    "id": 1140,
    "function": "to_seq",
    "file": "Chap45/BinaryHeapPQ.rs",
    "lines": "48",
    "spec_strength": "",
    "snippet": "        fn to_seq(&self)                     -> ArraySeqStPerS<T>;"
  },
  {
    "id": 1141,
    "function": "left_child",
    "file": "Chap45/BinaryHeapPQ.rs",
    "lines": "52",
    "spec_strength": "",
    "snippet": "        fn left_child(i: N) -> N { 2 * i + 1 }"
  },
  {
    "id": 1142,
    "function": "right_child",
    "file": "Chap45/BinaryHeapPQ.rs",
    "lines": "53",
    "spec_strength": "",
    "snippet": "        fn right_child(i: N) -> N { 2 * i + 2 }"
  },
  {
    "id": 1143,
    "function": "parent",
    "file": "Chap45/BinaryHeapPQ.rs",
    "lines": "54",
    "spec_strength": "",
    "snippet": "        fn parent(i: N) -> N { if i == 0 { 0 } else { (i - 1) / 2 } }"
  },
  {
    "id": 1144,
    "function": "is_heap",
    "file": "Chap45/BinaryHeapPQ.rs",
    "lines": "56-70",
    "spec_strength": "",
    "snippet": "        fn is_heap(&self) -> bool {\n            for i in 0..self.elements.length() {\n                let left = Self::left_child(i);\n                let right = Self::right_child(i);\n\n                if left < self.elements.length() && self.elements.nth(i) > self.elements.nth(left) {\n                    return false;\n                }\n\n                if right < self.elements.length() && self.elements.nth(i) > self.elements.nth(right) {\n                    return false;\n                }\n            }\n            true\n        }"
  },
  {
    "id": 1145,
    "function": "bubble_up",
    "file": "Chap45/BinaryHeapPQ.rs",
    "lines": "72-91",
    "spec_strength": "",
    "snippet": "        /// Bubble up element at index i to maintain heap property\n        fn bubble_up(&self, mut i: N) -> ArraySeqStPerS<T> {\n            let mut result = self.elements.clone();\n\n            while i > 0 {\n                let parent_idx = Self::parent(i);\n                let current = result.nth(i);\n                let parent = result.nth(parent_idx);\n\n                if current >= parent {\n                    break;\n                }\n\n                // Swap current with parent\n                result = self.swap_elements(&result, i, parent_idx);\n                i = parent_idx;\n            }\n\n            result\n        }"
  },
  {
    "id": 1146,
    "function": "bubble_down",
    "file": "Chap45/BinaryHeapPQ.rs",
    "lines": "93-121",
    "spec_strength": "",
    "snippet": "        /// Bubble down element at index i to maintain heap property\n        fn bubble_down(&self, mut i: N, heap: &ArraySeqStPerS<T>) -> ArraySeqStPerS<T> {\n            let mut result = heap.clone();\n\n            loop {\n                let left = Self::left_child(i);\n                let right = Self::right_child(i);\n                let mut smallest = i;\n\n                // Find smallest among current, left child, right child\n                if left < result.length() && result.nth(left) < result.nth(smallest) {\n                    smallest = left;\n                }\n\n                if right < result.length() && result.nth(right) < result.nth(smallest) {\n                    smallest = right;\n                }\n\n                if smallest == i {\n                    break; // Heap property satisfied\n                }\n\n                // Swap current with smallest child\n                result = self.swap_elements(&result, i, smallest);\n                i = smallest;\n            }\n\n            result\n        }"
  },
  {
    "id": 1147,
    "function": "swap_elements",
    "file": "Chap45/BinaryHeapPQ.rs",
    "lines": "123-141",
    "spec_strength": "",
    "snippet": "        /// Swap elements at indices i and j\n        fn swap_elements(&self, seq: &ArraySeqStPerS<T>, i: N, j: N) -> ArraySeqStPerS<T> {\n            let mut result = ArraySeqStPerS::empty();\n\n            for k in 0..seq.length() {\n                let element = if k == i {\n                    seq.nth(j).clone()\n                } else if k == j {\n                    seq.nth(i).clone()\n                } else {\n                    seq.nth(k).clone()\n                };\n\n                let single_seq = ArraySeqStPerS::singleton(element);\n                result = ArraySeqStPerS::append(&result, &single_seq);\n            }\n\n            result\n        }"
  },
  {
    "id": 1148,
    "function": "heapify",
    "file": "Chap45/BinaryHeapPQ.rs",
    "lines": "143-159",
    "spec_strength": "",
    "snippet": "        /// Build heap from arbitrary sequence (bottom-up heapify)\n        fn heapify(&self, seq: &ArraySeqStPerS<T>) -> ArraySeqStPerS<T> {\n            if seq.length() <= 1 {\n                return seq.clone();\n            }\n\n            let mut result = seq.clone();\n\n            // Start from last non-leaf node and bubble down\n            let last_non_leaf = if seq.length() >= 2 { (seq.length() - 2) / 2 } else { 0 };\n\n            for i in (0..=last_non_leaf).rev() {\n                result = self.bubble_down(i, &result);\n            }\n\n            result\n        }"
  },
  {
    "id": 1149,
    "function": "insert_all",
    "file": "Chap45/BinaryHeapPQ.rs",
    "lines": "267-275",
    "spec_strength": "",
    "snippet": "        /// Insert multiple elements from a sequence\n        pub fn insert_all(&self, elements: &ArraySeqStPerS<T>) -> Self {\n            let mut result = self.clone();\n            for i in 0..elements.length() {\n                let element = elements.nth(i);\n                result = result.insert(element.clone());\n            }\n            result\n        }"
  },
  {
    "id": 1150,
    "function": "extract_all_sorted",
    "file": "Chap45/BinaryHeapPQ.rs",
    "lines": "277-292",
    "spec_strength": "",
    "snippet": "        /// Extract all elements in sorted order (heapsort)\n        pub fn extract_all_sorted(&self) -> ArraySeqStPerS<T> {\n            let mut result = ArraySeqStPerS::empty();\n            let mut current_heap = self.clone();\n\n            while !current_heap.is_empty() {\n                let (new_heap, min_element) = current_heap.delete_min();\n                if let Some(element) = min_element {\n                    let single_seq = ArraySeqStPerS::singleton(element);\n                    result = ArraySeqStPerS::append(&result, &single_seq);\n                }\n                current_heap = new_heap;\n            }\n\n            result\n        }"
  },
  {
    "id": 1151,
    "function": "is_valid_heap",
    "file": "Chap45/BinaryHeapPQ.rs",
    "lines": "294-295",
    "spec_strength": "",
    "snippet": "        /// Check if the heap property is maintained (for testing)\n        pub fn is_valid_heap(&self) -> bool { self.is_heap() }"
  },
  {
    "id": 1152,
    "function": "height",
    "file": "Chap45/BinaryHeapPQ.rs",
    "lines": "297-304",
    "spec_strength": "",
    "snippet": "        /// Get the height of the heap (for testing)\n        pub fn height(&self) -> N {\n            if self.elements.length() == 0 {\n                0\n            } else {\n                ((self.elements.length() as f64).log2().floor() as N) + 1\n            }\n        }"
  },
  {
    "id": 1153,
    "function": "level_elements",
    "file": "Chap45/BinaryHeapPQ.rs",
    "lines": "306-321",
    "spec_strength": "",
    "snippet": "        /// Get elements at a specific level (for testing)\n        pub fn level_elements(&self, level: N) -> ArraySeqStPerS<T> {\n            let mut result = ArraySeqStPerS::empty();\n            let start_idx = (1 << level) - 1; // 2^level - 1\n            let end_idx = ((1 << (level + 1)) - 1).min(self.elements.length()); // 2^(level+1) - 1\n\n            for i in start_idx..end_idx {\n                if i < self.elements.length() {\n                    let elem = self.elements.nth(i);\n                    let single_seq = ArraySeqStPerS::singleton(elem.clone());\n                    result = ArraySeqStPerS::append(&result, &single_seq);\n                }\n            }\n\n            result\n        }"
  },
  {
    "id": 1154,
    "function": "default",
    "file": "Chap45/BinaryHeapPQ.rs",
    "lines": "325",
    "spec_strength": "",
    "snippet": "        fn default() -> Self { Self::empty() }"
  },
  {
    "id": 1155,
    "function": "from_vec",
    "file": "Chap45/BinaryHeapPQ.rs",
    "lines": "358-366",
    "spec_strength": "",
    "snippet": "        /// Create priority queue from vector (for testing)\n        pub fn from_vec(vec: Vec<T>) -> Self {\n            let mut seq = ArraySeqStPerS::empty();\n            for element in vec {\n                let single_seq = ArraySeqStPerS::singleton(element);\n                seq = ArraySeqStPerS::append(&seq, &single_seq);\n            }\n            Self::from_seq(&seq)\n        }"
  },
  {
    "id": 1156,
    "function": "to_vec",
    "file": "Chap45/BinaryHeapPQ.rs",
    "lines": "368-375",
    "spec_strength": "",
    "snippet": "        /// Convert to vector (for testing)\n        pub fn to_vec(&self) -> Vec<T> {\n            let mut result = Vec::new();\n            for i in 0..self.elements.length() {\n                result.push(self.elements.nth(i).clone());\n            }\n            result\n        }"
  },
  {
    "id": 1157,
    "function": "to_sorted_vec",
    "file": "Chap45/BinaryHeapPQ.rs",
    "lines": "377-385",
    "spec_strength": "",
    "snippet": "        /// Get elements in sorted order as vector (for testing)\n        pub fn to_sorted_vec(&self) -> Vec<T> {\n            let sorted_seq = self.extract_all_sorted();\n            let mut result = Vec::new();\n            for i in 0..sorted_seq.length() {\n                result.push(sorted_seq.nth(i).clone());\n            }\n            result\n        }"
  },
  {
    "id": 1158,
    "function": "example_45_2_textbook_example",
    "file": "Chap45/Example45_2.rs",
    "lines": "12-14",
    "spec_strength": "",
    "snippet": "        /// Example 45.2: Textbook heapsort demonstration\n        /// APAS: Work Θ(n log n), Span Θ(n log n)\n        fn example_45_2_textbook_example()         -> HeapsortComparison<i32>;"
  },
  {
    "id": 1159,
    "function": "example_45_2_reverse_sorted",
    "file": "Chap45/Example45_2.rs",
    "lines": "16-18",
    "spec_strength": "",
    "snippet": "        /// Example 45.2: Reverse-sorted input demonstration\n        /// APAS: Work Θ(n log n), Span Θ(n log n)\n        fn example_45_2_reverse_sorted()           -> HeapsortComparison<i32>;"
  },
  {
    "id": 1160,
    "function": "example_45_2_already_sorted",
    "file": "Chap45/Example45_2.rs",
    "lines": "20-22",
    "spec_strength": "",
    "snippet": "        /// Example 45.2: Already-sorted input demonstration\n        /// APAS: Work Θ(n log n), Span Θ(n log n)\n        fn example_45_2_already_sorted()           -> HeapsortComparison<i32>;"
  },
  {
    "id": 1161,
    "function": "example_45_2_duplicates",
    "file": "Chap45/Example45_2.rs",
    "lines": "24-26",
    "spec_strength": "",
    "snippet": "        /// Example 45.2: Input with duplicates demonstration\n        /// APAS: Work Θ(n log n), Span Θ(n log n)\n        fn example_45_2_duplicates()               -> HeapsortComparison<i32>;"
  },
  {
    "id": 1162,
    "function": "example_45_2_single_element",
    "file": "Chap45/Example45_2.rs",
    "lines": "28-30",
    "spec_strength": "",
    "snippet": "        /// Example 45.2: Single element demonstration\n        /// APAS: Work Θ(1), Span Θ(1)\n        fn example_45_2_single_element()           -> HeapsortComparison<i32>;"
  },
  {
    "id": 1163,
    "function": "example_45_2_empty",
    "file": "Chap45/Example45_2.rs",
    "lines": "32-34",
    "spec_strength": "",
    "snippet": "        /// Example 45.2: Empty input demonstration\n        /// APAS: Work Θ(1), Span Θ(1)\n        fn example_45_2_empty()                    -> HeapsortComparison<i32>;"
  },
  {
    "id": 1164,
    "function": "example_45_2_efficiency_demonstration",
    "file": "Chap45/Example45_2.rs",
    "lines": "36-38",
    "spec_strength": "",
    "snippet": "        /// Example 45.2: Efficiency comparison demonstration\n        /// APAS: Work Θ(n²), Span Θ(n²) - dominated by worst implementation\n        fn example_45_2_efficiency_demonstration() -> Vec<(String, Vec<i32>)>;"
  },
  {
    "id": 1165,
    "function": "run_example_45_2",
    "file": "Chap45/Example45_2.rs",
    "lines": "40-42",
    "spec_strength": "",
    "snippet": "        /// Run comprehensive demonstration of Example 45.2\n        /// APAS: Work Θ(n²), Span Θ(n²) - dominated by worst implementation\n        fn run_example_45_2()                      -> String;"
  },
  {
    "id": 1166,
    "function": "heapsort_unsorted_list",
    "file": "Chap45/HeapsortExample.rs",
    "lines": "19-21",
    "spec_strength": "",
    "snippet": "        /// Heapsort using UnsortedListPQ\n        /// Claude Work: Θ(n²), Span: Θ(n²) - inefficient due to O(n) deleteMin\n        fn heapsort_unsorted_list<T: StT + Ord>(sequence: &[T]) -> Vec<T>;"
  },
  {
    "id": 1167,
    "function": "heapsort_sorted_list",
    "file": "Chap45/HeapsortExample.rs",
    "lines": "23-25",
    "spec_strength": "",
    "snippet": "        /// Heapsort using SortedListPQ  \n        /// Claude Work: Θ(n²), Span: Θ(n²) - inefficient due to O(n) insert\n        fn heapsort_sorted_list<T: StT + Ord>(sequence: &[T])   -> Vec<T>;"
  },
  {
    "id": 1168,
    "function": "heapsort_balanced_tree",
    "file": "Chap45/HeapsortExample.rs",
    "lines": "27-29",
    "spec_strength": "",
    "snippet": "        /// Heapsort using BalancedTreePQ\n        /// Claude Work: Θ(n log n), Span: Θ(n log n) - optimal complexity\n        fn heapsort_balanced_tree<T: StT + Ord>(sequence: &[T]) -> Vec<T>;"
  },
  {
    "id": 1169,
    "function": "heapsort_binary_heap",
    "file": "Chap45/HeapsortExample.rs",
    "lines": "31-33",
    "spec_strength": "",
    "snippet": "        /// Heapsort using BinaryHeapPQ\n        /// Claude Work: Θ(n log n), Span: Θ(n log n) - optimal complexity\n        fn heapsort_binary_heap<T: StT + Ord>(sequence: &[T])   -> Vec<T>;"
  },
  {
    "id": 1170,
    "function": "heapsort_leftist_heap",
    "file": "Chap45/HeapsortExample.rs",
    "lines": "35-37",
    "spec_strength": "",
    "snippet": "        /// Heapsort using LeftistHeapPQ\n        /// Claude Work: Θ(n log n), Span: Θ(n log n) - optimal complexity\n        fn heapsort_leftist_heap<T: StT + Ord>(sequence: &[T])  -> Vec<T>;"
  },
  {
    "id": 1171,
    "function": "compare_all_heapsorts",
    "file": "Chap45/HeapsortExample.rs",
    "lines": "39-41",
    "spec_strength": "",
    "snippet": "        /// Compare all heapsort implementations on the same input\n        /// Claude Work: Θ(n²), Span: Θ(n²) - dominated by worst implementation\n        fn compare_all_heapsorts<T: StT + Ord>(sequence: &[T])  -> HeapsortComparison<T>;"
  },
  {
    "id": 1172,
    "function": "textbook_example",
    "file": "Chap45/HeapsortExample.rs",
    "lines": "158-159",
    "spec_strength": "",
    "snippet": "        /// Example from textbook - demonstrate heapsort on a small dataset\n        fn textbook_example()         -> HeapsortComparison<i32>;"
  },
  {
    "id": 1173,
    "function": "reverse_sorted_example",
    "file": "Chap45/HeapsortExample.rs",
    "lines": "160-161",
    "spec_strength": "",
    "snippet": "        /// Demonstrate heapsort on reverse-sorted input (worst case for some algorithms)\n        fn reverse_sorted_example()   -> HeapsortComparison<i32>;"
  },
  {
    "id": 1174,
    "function": "already_sorted_example",
    "file": "Chap45/HeapsortExample.rs",
    "lines": "162-163",
    "spec_strength": "",
    "snippet": "        /// Demonstrate heapsort on already-sorted input\n        fn already_sorted_example()   -> HeapsortComparison<i32>;"
  },
  {
    "id": 1175,
    "function": "duplicates_example",
    "file": "Chap45/HeapsortExample.rs",
    "lines": "164-165",
    "spec_strength": "",
    "snippet": "        /// Demonstrate heapsort on input with duplicates\n        fn duplicates_example()       -> HeapsortComparison<i32>;"
  },
  {
    "id": 1176,
    "function": "single_element_example",
    "file": "Chap45/HeapsortExample.rs",
    "lines": "166-167",
    "spec_strength": "",
    "snippet": "        /// Demonstrate heapsort on single element\n        fn single_element_example()   -> HeapsortComparison<i32>;"
  },
  {
    "id": 1177,
    "function": "empty_example",
    "file": "Chap45/HeapsortExample.rs",
    "lines": "168-169",
    "spec_strength": "",
    "snippet": "        /// Demonstrate heapsort on empty input\n        fn empty_example()            -> HeapsortComparison<i32>;"
  },
  {
    "id": 1178,
    "function": "large_example",
    "file": "Chap45/HeapsortExample.rs",
    "lines": "170-171",
    "spec_strength": "",
    "snippet": "        /// Generate large example for performance testing\n        fn large_example(size: usize) -> Vec<i32>;"
  },
  {
    "id": 1179,
    "function": "efficiency_demonstration",
    "file": "Chap45/HeapsortExample.rs",
    "lines": "172-173",
    "spec_strength": "",
    "snippet": "        /// Demonstrate the efficiency difference between implementations\n        fn efficiency_demonstration() -> Vec<(String, Vec<i32>)>;"
  },
  {
    "id": 1180,
    "function": "complexity_analysis",
    "file": "Chap45/HeapsortExample.rs",
    "lines": "177-178",
    "spec_strength": "",
    "snippet": "        /// Analyze the theoretical complexity of each heapsort variant\n        fn complexity_analysis()      -> Vec<(String, String, String)>;"
  },
  {
    "id": 1181,
    "function": "correctness_verification",
    "file": "Chap45/HeapsortExample.rs",
    "lines": "179-180",
    "spec_strength": "",
    "snippet": "        /// Verify that all heapsort implementations produce correct results\n        fn correctness_verification() -> bool;"
  },
  {
    "id": 1182,
    "function": "vec_to_array_seq",
    "file": "Chap45/HeapsortExample.rs",
    "lines": "184-185",
    "spec_strength": "",
    "snippet": "        /// Convert Vec to ArraySeqStPerS for use with APAS sequence types\n        fn vec_to_array_seq<T: StT>(vec: &[T])  -> ArraySeqStPerS<T>;"
  },
  {
    "id": 1183,
    "function": "vec_to_avl_seq",
    "file": "Chap45/HeapsortExample.rs",
    "lines": "186-187",
    "spec_strength": "",
    "snippet": "        /// Convert Vec to AVLTreeSeqStPerS for use with balanced tree operations\n        fn vec_to_avl_seq<T: StT>(vec: &[T])    -> AVLTreeSeqStPerS<T>;"
  },
  {
    "id": 1184,
    "function": "is_sorted",
    "file": "Chap45/HeapsortExample.rs",
    "lines": "188-189",
    "spec_strength": "",
    "snippet": "        /// Check if a sequence is sorted\n        fn is_sorted<T: Ord>(vec: &[T])         -> bool;"
  },
  {
    "id": 1185,
    "function": "generate_test_sequences",
    "file": "Chap45/HeapsortExample.rs",
    "lines": "190-191",
    "spec_strength": "",
    "snippet": "        /// Generate test sequences of various patterns\n        fn generate_test_sequences(size: usize) -> Vec<(String, Vec<i32>)>;"
  },
  {
    "id": 1186,
    "function": "all_results_match",
    "file": "Chap45/HeapsortExample.rs",
    "lines": "195-202",
    "spec_strength": "",
    "snippet": "        /// Verify that all implementations produce the same sorted result\n        pub fn all_results_match(&self) -> bool {\n            let expected = &self.binary_heap_result; // Use binary heap as reference\n            self.unsorted_list_result == *expected\n                && self.sorted_list_result == *expected\n                && self.balanced_tree_result == *expected\n                && self.leftist_heap_result == *expected\n        }"
  },
  {
    "id": 1187,
    "function": "all_results_sorted",
    "file": "Chap45/HeapsortExample.rs",
    "lines": "204-213",
    "spec_strength": "",
    "snippet": "        /// Check if all results are properly sorted\n        pub fn all_results_sorted(&self) -> bool {\n            fn is_sorted<T: Ord>(vec: &[T]) -> bool { vec.windows(2).all(|w| w[0] <= w[1]) }\n\n            is_sorted(&self.unsorted_list_result)\n                && is_sorted(&self.sorted_list_result)\n                && is_sorted(&self.balanced_tree_result)\n                && is_sorted(&self.binary_heap_result)\n                && is_sorted(&self.leftist_heap_result)\n        }"
  },
  {
    "id": 1188,
    "function": "empty",
    "file": "Chap45/LeftistHeapPQ.rs",
    "lines": "30-31",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn empty()                       -> Self;"
  },
  {
    "id": 1189,
    "function": "singleton",
    "file": "Chap45/LeftistHeapPQ.rs",
    "lines": "33-34",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn singleton(element: T)         -> Self;"
  },
  {
    "id": 1190,
    "function": "find_min",
    "file": "Chap45/LeftistHeapPQ.rs",
    "lines": "36-38",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        /// Returns the minimum element (root of heap), or None if empty\n        fn find_min(&self)               -> Option<&T>;"
  },
  {
    "id": 1191,
    "function": "insert",
    "file": "Chap45/LeftistHeapPQ.rs",
    "lines": "40-42",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        /// Inserts element by creating singleton and melding\n        fn insert(&self, element: T)     -> Self;"
  },
  {
    "id": 1192,
    "function": "delete_min",
    "file": "Chap45/LeftistHeapPQ.rs",
    "lines": "44-48",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(log n), Span Θ(log n), Parallelism Θ(1)\n        /// Removes root and melds left and right subtrees\n        fn delete_min(&self)             -> (Self, Option<T>)\n        where\n            Self: Sized;"
  },
  {
    "id": 1193,
    "function": "meld",
    "file": "Chap45/LeftistHeapPQ.rs",
    "lines": "50-52",
    "spec_strength": "",
    "snippet": "        /// Claude Work: Θ(log m + log n), Span: Θ(log m + log n)\n        /// KEY ADVANTAGE: Efficient meld following right spines\n        fn meld(&self, other: &Self)     -> Self;"
  },
  {
    "id": 1194,
    "function": "from_seq",
    "file": "Chap45/LeftistHeapPQ.rs",
    "lines": "54-56",
    "spec_strength": "",
    "snippet": "        /// Claude Work: Θ(n), Span: Θ(n)\n        /// Creates heap from sequence using reduce with meld\n        fn from_seq(seq: &[T])           -> Self;"
  },
  {
    "id": 1195,
    "function": "size",
    "file": "Chap45/LeftistHeapPQ.rs",
    "lines": "58",
    "spec_strength": "",
    "snippet": "        fn size(&self)                   -> N;"
  },
  {
    "id": 1196,
    "function": "is_empty",
    "file": "Chap45/LeftistHeapPQ.rs",
    "lines": "59",
    "spec_strength": "",
    "snippet": "        fn is_empty(&self)               -> bool;"
  },
  {
    "id": 1197,
    "function": "extract_all_sorted",
    "file": "Chap45/LeftistHeapPQ.rs",
    "lines": "60",
    "spec_strength": "",
    "snippet": "        fn extract_all_sorted(&self)     -> Vec<T>;"
  },
  {
    "id": 1198,
    "function": "height",
    "file": "Chap45/LeftistHeapPQ.rs",
    "lines": "61",
    "spec_strength": "",
    "snippet": "        fn height(&self)                 -> N;"
  },
  {
    "id": 1199,
    "function": "root_rank",
    "file": "Chap45/LeftistHeapPQ.rs",
    "lines": "62",
    "spec_strength": "",
    "snippet": "        fn root_rank(&self)              -> N;"
  },
  {
    "id": 1200,
    "function": "is_valid_leftist_heap",
    "file": "Chap45/LeftistHeapPQ.rs",
    "lines": "63",
    "spec_strength": "",
    "snippet": "        fn is_valid_leftist_heap(&self)  -> bool;"
  },
  {
    "id": 1201,
    "function": "from_vec",
    "file": "Chap45/LeftistHeapPQ.rs",
    "lines": "64",
    "spec_strength": "",
    "snippet": "        fn from_vec(vec: Vec<T>)         -> Self;"
  },
  {
    "id": 1202,
    "function": "to_vec",
    "file": "Chap45/LeftistHeapPQ.rs",
    "lines": "65",
    "spec_strength": "",
    "snippet": "        fn to_vec(&self)                 -> Vec<T>;"
  },
  {
    "id": 1203,
    "function": "to_sorted_vec",
    "file": "Chap45/LeftistHeapPQ.rs",
    "lines": "66",
    "spec_strength": "",
    "snippet": "        fn to_sorted_vec(&self)          -> Vec<T>;"
  },
  {
    "id": 1204,
    "function": "meld_multiple",
    "file": "Chap45/LeftistHeapPQ.rs",
    "lines": "67-69",
    "spec_strength": "",
    "snippet": "        fn meld_multiple(heaps: &[Self]) -> Self\n        where\n            Self: Sized;"
  },
  {
    "id": 1205,
    "function": "split",
    "file": "Chap45/LeftistHeapPQ.rs",
    "lines": "70-72",
    "spec_strength": "",
    "snippet": "        fn split(&self, key: &T)         -> (Self, Self)\n        where\n            Self: Sized;"
  },
  {
    "id": 1206,
    "function": "efficient_multi_way_merge",
    "file": "Chap45/LeftistHeapPQ.rs",
    "lines": "76-78",
    "spec_strength": "",
    "snippet": "        /// Demonstrate the power of O(log n) meld operations\n        /// This would be much slower with other priority queue implementations!\n        fn efficient_multi_way_merge<T: StT + Ord>(sequences: Vec<Vec<T>>) -> Vec<T>;"
  },
  {
    "id": 1207,
    "function": "parallel_heap_construction",
    "file": "Chap45/LeftistHeapPQ.rs",
    "lines": "79-80",
    "spec_strength": "",
    "snippet": "        /// Demonstrate parallel heap construction\n        fn parallel_heap_construction<T: StT + Ord>(elements: Vec<T>)      -> LeftistHeapPQ<T>;"
  },
  {
    "id": 1208,
    "function": "rank",
    "file": "Chap45/LeftistHeapPQ.rs",
    "lines": "84-90",
    "spec_strength": "",
    "snippet": "        /// Get the rank (distance to nearest leaf) of a node\n        fn rank(&self) -> N {\n            match self {\n                | LeftistHeapNode::Leaf => 0,\n                | LeftistHeapNode::Node { rank, .. } => *rank,\n            }\n        }"
  },
  {
    "id": 1209,
    "function": "make_node",
    "file": "Chap45/LeftistHeapPQ.rs",
    "lines": "92-112",
    "spec_strength": "",
    "snippet": "        /// Create a new node with correct rank and leftist property\n        fn make_node(key: T, left: LeftistHeapNode<T>, right: LeftistHeapNode<T>) -> Self {\n            let left_rank = left.rank();\n            let right_rank = right.rank();\n\n            // Ensure leftist property: left subtree has >= rank than right subtree\n            let (final_left, final_right) = if left_rank >= right_rank {\n                (left, right)\n            } else {\n                (right, left)\n            };\n\n            let node_rank = final_right.rank() + 1;\n\n            LeftistHeapNode::Node {\n                key,\n                left: Box::new(final_left),\n                right: Box::new(final_right),\n                rank: node_rank,\n            }\n        }"
  },
  {
    "id": 1210,
    "function": "meld_nodes",
    "file": "Chap45/LeftistHeapPQ.rs",
    "lines": "114-163",
    "spec_strength": "",
    "snippet": "        /// Core meld operation - follows right spines (Data Structure 45.3 algorithm)\n        /// This is the key innovation that makes meld O(log n)!\n        fn meld_nodes(a: LeftistHeapNode<T>, b: LeftistHeapNode<T>) -> LeftistHeapNode<T> {\n            match (a, b) {\n                | (LeftistHeapNode::Leaf, other) => other,\n                | (other, LeftistHeapNode::Leaf) => other,\n                | (\n                    LeftistHeapNode::Node {\n                        key: ka,\n                        left: la,\n                        right: ra,\n                        ..\n                    },\n                    LeftistHeapNode::Node {\n                        key: kb,\n                        left: lb,\n                        right: rb,\n                        ..\n                    },\n                ) => {\n                    if ka <= kb {\n                        // ka is smaller, so it becomes the root\n                        // Meld ra (right subtree of a) with entire b\n                        let melded_right = Self::meld_nodes(\n                            *ra,\n                            LeftistHeapNode::Node {\n                                key: kb,\n                                left: lb,\n                                right: rb,\n                                rank: 0, // rank will be recalculated\n                            },\n                        );\n                        Self::make_node(ka, *la, melded_right)\n                    } else {\n                        // kb is smaller, so it becomes the root\n                        // Meld entire a with rb (right subtree of b)\n                        let melded_right = Self::meld_nodes(\n                            LeftistHeapNode::Node {\n                                key: ka,\n                                left: la,\n                                right: ra,\n                                rank: 0, // rank will be recalculated\n                            },\n                            *rb,\n                        );\n                        Self::make_node(kb, *lb, melded_right)\n                    }\n                }\n            }\n        }"
  },
  {
    "id": 1211,
    "function": "is_leftist",
    "file": "Chap45/LeftistHeapPQ.rs",
    "lines": "181-189",
    "spec_strength": "",
    "snippet": "        /// Check if leftist property is maintained\n        fn is_leftist(&self) -> bool {\n            match self {\n                | LeftistHeapNode::Leaf => true,\n                | LeftistHeapNode::Node { left, right, .. } => {\n                    left.rank() >= right.rank() && left.is_leftist() && right.is_leftist()\n                }\n            }\n        }"
  },
  {
    "id": 1212,
    "function": "is_heap",
    "file": "Chap45/LeftistHeapPQ.rs",
    "lines": "191-207",
    "spec_strength": "",
    "snippet": "        /// Check if heap property is maintained\n        fn is_heap(&self) -> bool {\n            match self {\n                | LeftistHeapNode::Leaf => true,\n                | LeftistHeapNode::Node { key, left, right, .. } => {\n                    let left_ok = match left.as_ref() {\n                        | LeftistHeapNode::Leaf => true,\n                        | LeftistHeapNode::Node { key: left_key, .. } => key <= left_key,\n                    };\n                    let right_ok = match right.as_ref() {\n                        | LeftistHeapNode::Leaf => true,\n                        | LeftistHeapNode::Node { key: right_key, .. } => key <= right_key,\n                    };\n                    left_ok && right_ok && left.is_heap() && right.is_heap()\n                }\n            }\n        }"
  },
  {
    "id": 1213,
    "function": "default",
    "file": "Chap45/LeftistHeapPQ.rs",
    "lines": "377",
    "spec_strength": "",
    "snippet": "        fn default() -> Self { Self::empty() }"
  },
  {
    "id": 1214,
    "function": "format_node",
    "file": "Chap45/LeftistHeapPQ.rs",
    "lines": "382-393",
    "spec_strength": "",
    "snippet": "            fn format_node<T: StT + Ord>(node: &LeftistHeapNode<T>, f: &mut Formatter<'_>, depth: usize) -> Result {\n                match node {\n                    | LeftistHeapNode::Leaf => Ok(()),\n                    | LeftistHeapNode::Node { key, left, right, rank } => {\n                        let indent = \"  \".repeat(depth);\n                        writeln!(f, \"{indent}{key}(rank:{rank})\")?;\n                        format_node(left, f, depth + 1)?;\n                        format_node(right, f, depth + 1)?;\n                        Ok(())\n                    }\n                }\n            }"
  },
  {
    "id": 1215,
    "function": "empty",
    "file": "Chap45/SortedListPQ.rs",
    "lines": "18-19",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn empty()                                         -> Self;"
  },
  {
    "id": 1216,
    "function": "singleton",
    "file": "Chap45/SortedListPQ.rs",
    "lines": "21-22",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn singleton(element: T)                           -> Self;"
  },
  {
    "id": 1217,
    "function": "find_min",
    "file": "Chap45/SortedListPQ.rs",
    "lines": "24-26",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        /// Returns the minimum element (first in sorted list), or None if empty\n        fn find_min(&self)                                 -> Option<&T>;"
  },
  {
    "id": 1218,
    "function": "insert",
    "file": "Chap45/SortedListPQ.rs",
    "lines": "28-30",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)\n        /// Inserts element in correct sorted position\n        fn insert(&self, element: T)                       -> Self;"
  },
  {
    "id": 1219,
    "function": "delete_min",
    "file": "Chap45/SortedListPQ.rs",
    "lines": "32-36",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        /// Removes first element (minimum) from sorted list\n        fn delete_min(&self)                               -> (Self, Option<T>)\n        where\n            Self: Sized;"
  },
  {
    "id": 1220,
    "function": "meld",
    "file": "Chap45/SortedListPQ.rs",
    "lines": "38-40",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(m + n), Span Θ(m + n), Parallelism Θ(1)\n        /// Melds two sorted priority queues by merging sorted lists\n        fn meld(&self, other: &Self)                       -> Self;"
  },
  {
    "id": 1221,
    "function": "from_seq",
    "file": "Chap45/SortedListPQ.rs",
    "lines": "42-44",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n log n), Span Θ(n log n), Parallelism Θ(1)\n        /// Creates priority queue from sequence by sorting\n        fn from_seq(seq: &ArraySeqStPerS<T>)               -> Self;"
  },
  {
    "id": 1222,
    "function": "size",
    "file": "Chap45/SortedListPQ.rs",
    "lines": "46",
    "spec_strength": "",
    "snippet": "        fn size(&self)                                     -> N;"
  },
  {
    "id": 1223,
    "function": "is_empty",
    "file": "Chap45/SortedListPQ.rs",
    "lines": "47",
    "spec_strength": "",
    "snippet": "        fn is_empty(&self)                                 -> bool;"
  },
  {
    "id": 1224,
    "function": "to_seq",
    "file": "Chap45/SortedListPQ.rs",
    "lines": "48",
    "spec_strength": "",
    "snippet": "        fn to_seq(&self)                                   -> ArraySeqStPerS<T>;"
  },
  {
    "id": 1225,
    "function": "insert_all",
    "file": "Chap45/SortedListPQ.rs",
    "lines": "49",
    "spec_strength": "",
    "snippet": "        fn insert_all(&self, elements: &ArraySeqStPerS<T>) -> Self;"
  },
  {
    "id": 1226,
    "function": "extract_all_sorted",
    "file": "Chap45/SortedListPQ.rs",
    "lines": "50",
    "spec_strength": "",
    "snippet": "        fn extract_all_sorted(&self)                       -> ArraySeqStPerS<T>;"
  },
  {
    "id": 1227,
    "function": "find_max",
    "file": "Chap45/SortedListPQ.rs",
    "lines": "51",
    "spec_strength": "",
    "snippet": "        fn find_max(&self)                                 -> Option<&T>;"
  },
  {
    "id": 1228,
    "function": "delete_max",
    "file": "Chap45/SortedListPQ.rs",
    "lines": "52-54",
    "spec_strength": "",
    "snippet": "        fn delete_max(&self)                               -> (Self, Option<T>)\n        where\n            Self: Sized;"
  },
  {
    "id": 1229,
    "function": "from_vec",
    "file": "Chap45/SortedListPQ.rs",
    "lines": "55",
    "spec_strength": "",
    "snippet": "        fn from_vec(vec: Vec<T>)                           -> Self;"
  },
  {
    "id": 1230,
    "function": "to_vec",
    "file": "Chap45/SortedListPQ.rs",
    "lines": "56",
    "spec_strength": "",
    "snippet": "        fn to_vec(&self)                                   -> Vec<T>;"
  },
  {
    "id": 1231,
    "function": "to_sorted_vec",
    "file": "Chap45/SortedListPQ.rs",
    "lines": "57",
    "spec_strength": "",
    "snippet": "        fn to_sorted_vec(&self)                            -> Vec<T>;"
  },
  {
    "id": 1232,
    "function": "is_sorted",
    "file": "Chap45/SortedListPQ.rs",
    "lines": "58",
    "spec_strength": "",
    "snippet": "        fn is_sorted(&self)                                -> bool;"
  },
  {
    "id": 1233,
    "function": "default",
    "file": "Chap45/SortedListPQ.rs",
    "lines": "285",
    "spec_strength": "",
    "snippet": "        fn default() -> Self { Self::empty() }"
  },
  {
    "id": 1234,
    "function": "empty",
    "file": "Chap45/UnsortedListPQ.rs",
    "lines": "18-19",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn empty()                                         -> Self;"
  },
  {
    "id": 1235,
    "function": "singleton",
    "file": "Chap45/UnsortedListPQ.rs",
    "lines": "21-22",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        fn singleton(element: T)                           -> Self;"
  },
  {
    "id": 1236,
    "function": "find_min",
    "file": "Chap45/UnsortedListPQ.rs",
    "lines": "24-26",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)\n        /// Returns the minimum element, or None if empty\n        fn find_min(&self)                                 -> Option<&T>;"
  },
  {
    "id": 1237,
    "function": "insert",
    "file": "Chap45/UnsortedListPQ.rs",
    "lines": "28-30",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(1), Span Θ(1)\n        /// Inserts element into unsorted list\n        fn insert(&self, element: T)                       -> Self;"
  },
  {
    "id": 1238,
    "function": "delete_min",
    "file": "Chap45/UnsortedListPQ.rs",
    "lines": "32-36",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)\n        /// Removes and returns minimum element with new queue\n        fn delete_min(&self)                               -> (Self, Option<T>)\n        where\n            Self: Sized;"
  },
  {
    "id": 1239,
    "function": "meld",
    "file": "Chap45/UnsortedListPQ.rs",
    "lines": "38-40",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(m + n), Span Θ(m + n), Parallelism Θ(1)\n        /// Melds two priority queues by concatenating lists\n        fn meld(&self, other: &Self)                       -> Self;"
  },
  {
    "id": 1240,
    "function": "from_seq",
    "file": "Chap45/UnsortedListPQ.rs",
    "lines": "42-44",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work Θ(n), Span Θ(n), Parallelism Θ(1)\n        /// Creates priority queue from sequence\n        fn from_seq(seq: &ArraySeqStPerS<T>)               -> Self;"
  },
  {
    "id": 1241,
    "function": "size",
    "file": "Chap45/UnsortedListPQ.rs",
    "lines": "46",
    "spec_strength": "",
    "snippet": "        fn size(&self)                                     -> N;"
  },
  {
    "id": 1242,
    "function": "is_empty",
    "file": "Chap45/UnsortedListPQ.rs",
    "lines": "47",
    "spec_strength": "",
    "snippet": "        fn is_empty(&self)                                 -> bool;"
  },
  {
    "id": 1243,
    "function": "to_seq",
    "file": "Chap45/UnsortedListPQ.rs",
    "lines": "48",
    "spec_strength": "",
    "snippet": "        fn to_seq(&self)                                   -> ArraySeqStPerS<T>;"
  },
  {
    "id": 1244,
    "function": "insert_all",
    "file": "Chap45/UnsortedListPQ.rs",
    "lines": "49",
    "spec_strength": "",
    "snippet": "        fn insert_all(&self, elements: &ArraySeqStPerS<T>) -> Self;"
  },
  {
    "id": 1245,
    "function": "extract_all_sorted",
    "file": "Chap45/UnsortedListPQ.rs",
    "lines": "50",
    "spec_strength": "",
    "snippet": "        fn extract_all_sorted(&self)                       -> ArraySeqStPerS<T>;"
  },
  {
    "id": 1246,
    "function": "from_vec",
    "file": "Chap45/UnsortedListPQ.rs",
    "lines": "51",
    "spec_strength": "",
    "snippet": "        fn from_vec(vec: Vec<T>)                           -> Self;"
  },
  {
    "id": 1247,
    "function": "to_vec",
    "file": "Chap45/UnsortedListPQ.rs",
    "lines": "52",
    "spec_strength": "",
    "snippet": "        fn to_vec(&self)                                   -> Vec<T>;"
  },
  {
    "id": 1248,
    "function": "to_sorted_vec",
    "file": "Chap45/UnsortedListPQ.rs",
    "lines": "53",
    "spec_strength": "",
    "snippet": "        fn to_sorted_vec(&self)                            -> Vec<T>;"
  },
  {
    "id": 1249,
    "function": "default",
    "file": "Chap45/UnsortedListPQ.rs",
    "lines": "209",
    "spec_strength": "",
    "snippet": "        fn default() -> Self { Self::empty() }"
  },
  {
    "id": 1250,
    "function": "hash_index",
    "file": "Chap47/ChainedHashTable.rs",
    "lines": "26-29",
    "spec_strength": "",
    "snippet": "        /// Computes the hash index for a key.\n        /// - APAS: Work O(1), Span O(1).\n        /// - Claude-Opus-4.6: N/A — abstract trait method; cost depends on hash function.\n        fn hash_index(table: &HashTable<Key, Value, Entry, Metrics>, key: &Key) -> N;"
  },
  {
    "id": 1251,
    "function": "insert_chained",
    "file": "Chap47/ChainedHashTable.rs",
    "lines": "31-39",
    "spec_strength": "",
    "snippet": "        /// Inserts into the chain at the hashed bucket.\n        /// - APAS: Work O(1) expected, Span O(1).\n        /// - Claude-Opus-4.6: Work O(1) expected, Span O(1) — agrees with APAS; hashes then delegates to EntryTrait::insert.\n        fn insert_chained(table: &mut HashTable<Key, Value, Entry, Metrics>, key: Key, value: Value) {\n            let index = Self::hash_index(table, &key);\n            if index < table.table.len() {\n                table.table[index].insert(key, value);\n            }\n        }"
  },
  {
    "id": 1252,
    "function": "lookup_chained",
    "file": "Chap47/ChainedHashTable.rs",
    "lines": "41-51",
    "spec_strength": "",
    "snippet": "        /// Looks up in the chain at the hashed bucket.\n        /// - APAS: Work O(1+α) expected, Span O(1+α).\n        /// - Claude-Opus-4.6: Work O(1+α) expected, Span O(1+α) — agrees with APAS; hashes then linear scan of chain.\n        fn lookup_chained(table: &HashTable<Key, Value, Entry, Metrics>, key: &Key) -> Option<Value> {\n            let index = Self::hash_index(table, key);\n            if index < table.table.len() {\n                table.table[index].lookup(key)\n            } else {\n                None\n            }\n        }"
  },
  {
    "id": 1253,
    "function": "delete_chained",
    "file": "Chap47/ChainedHashTable.rs",
    "lines": "53-63",
    "spec_strength": "",
    "snippet": "        /// Deletes from the chain at the hashed bucket.\n        /// - APAS: Work O(1+α) expected, Span O(1+α).\n        /// - Claude-Opus-4.6: Work O(1+α) expected, Span O(1+α) — agrees with APAS; hashes then linear scan of chain.\n        fn delete_chained(table: &mut HashTable<Key, Value, Entry, Metrics>, key: &Key) -> B {\n            let index = Self::hash_index(table, key);\n            if index < table.table.len() {\n                table.table[index].delete(key)\n            } else {\n                false\n            }\n        }"
  },
  {
    "id": 1254,
    "function": "second_hash",
    "file": "Chap47/DoubleHashFlatHashTableStEph.rs",
    "lines": "18-56",
    "spec_strength": "",
    "snippet": "        /// Compute second hash value for double hashing.\n        /// APAS: hh(k) must be relatively prime to m.\n        /// - APAS: Work O(1), Span O(1).\n        /// - Claude-Opus-4.6: Work O(sizeof(Key)), Span O(sizeof(Key)) — iterates over key bytes with FNV-1a.\n        /// Strategy: Always return an odd number (works for power-of-2 sizes),\n        /// and for prime sizes, ensure < m and non-zero.\n        pub fn second_hash<Key: StT>(key: &Key, table_size: N) -> N {\n            // APAS: hh(k) must be non-zero and coprime to m\n            // Use key bytes directly instead of memory address\n\n            if table_size <= 2 {\n                return 1;\n            }\n\n            // Compute hash from key bytes using FNV-1a algorithm\n            let key_ptr = key as *const Key as *const u8;\n            let key_size = std::mem::size_of::<Key>();\n            let mut hash: u64 = 0xcbf29ce484222325; // FNV offset basis\n\n            unsafe {\n                for i in 0..key_size {\n                    let byte = *key_ptr.add(i);\n                    hash ^= byte as u64;\n                    hash = hash.wrapping_mul(0x100000001b3); // FNV prime\n                }\n            }\n\n            // For prime table sizes, use: step = 1 + (hash % (m-1))\n            // This ensures 1 <= step < m and step != 0\n            let base = (table_size - 1) as u64;\n            let mut step = ((hash % base) + 1) as N;\n\n            // Ensure odd for power-of-2 coprimality\n            if step % 2 == 0 && step < table_size - 1 {\n                step += 1;\n            }\n\n            step\n        }"
  },
  {
    "id": 1255,
    "function": "insert",
    "file": "Chap47/DoubleHashFlatHashTableStEph.rs",
    "lines": "62-79",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1/(1−α)) expected, Span O(1/(1−α)).\n        /// - Claude-Opus-4.6: Work O(1/(1−α)) expected, Span O(1/(1−α)) — double hash find_slot then O(1) write.\n        fn insert(table: &mut HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: Key, value: Value) {\n            let slot = Self::find_slot(table, &key);\n            match &table.table[slot] {\n                | FlatEntry::Occupied(k, _) if k == &key => {\n                    table.table[slot] = FlatEntry::Occupied(key, value);\n                }\n                | FlatEntry::Empty | FlatEntry::Deleted => {\n                    table.table[slot] = FlatEntry::Occupied(key, value);\n                    table.num_elements += 1;\n                }\n                | _ => {\n                    table.table[slot] = FlatEntry::Occupied(key, value);\n                    table.num_elements += 1;\n                }\n            }\n        }"
  },
  {
    "id": 1256,
    "function": "lookup",
    "file": "Chap47/DoubleHashFlatHashTableStEph.rs",
    "lines": "81-96",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1/(1−α)) expected, Span O(1/(1−α)).\n        /// - Claude-Opus-4.6: Work O(1/(1−α)) expected, Span O(1/(1−α)) — double hash probe until found or empty.\n        fn lookup(table: &HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: &Key) -> Option<Value> {\n            let mut attempt = 0;\n            while attempt < table.current_size {\n                let slot = Self::probe(table, key, attempt);\n                match &table.table[slot] {\n                    | FlatEntry::Occupied(k, v) if k == key => return Some(v.clone()),\n                    | FlatEntry::Empty => return None,\n                    | FlatEntry::Deleted | FlatEntry::Occupied(_, _) => {\n                        attempt += 1;\n                    }\n                }\n            }\n            None\n        }"
  },
  {
    "id": 1257,
    "function": "delete",
    "file": "Chap47/DoubleHashFlatHashTableStEph.rs",
    "lines": "98-117",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1/(1−α)) expected, Span O(1/(1−α)).\n        /// - Claude-Opus-4.6: Work O(1/(1−α)) expected, Span O(1/(1−α)) — double hash probe until found or empty, then tombstone.\n        fn delete(table: &mut HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: &Key) -> B {\n            let mut attempt = 0;\n            while attempt < table.current_size {\n                let slot = Self::probe(table, key, attempt);\n                match &table.table[slot] {\n                    | FlatEntry::Occupied(k, _) if k == key => {\n                        table.table[slot] = FlatEntry::Deleted;\n                        table.num_elements -= 1;\n                        return true;\n                    }\n                    | FlatEntry::Empty => return false,\n                    | FlatEntry::Deleted | FlatEntry::Occupied(_, _) => {\n                        attempt += 1;\n                    }\n                }\n            }\n            false\n        }"
  },
  {
    "id": 1258,
    "function": "resize",
    "file": "Chap47/DoubleHashFlatHashTableStEph.rs",
    "lines": "119-153",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(n + m + m'), Span O(n + m + m').\n        /// - Claude-Opus-4.6: Work O(n + m + m'), Span O(n + m + m') — collects n pairs, creates m' slots, reinserts.\n        fn resize(\n            table: &HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>,\n            new_size: N,\n        ) -> HashTable<Key, Value, FlatEntry<Key, Value>, Metrics> {\n            // Collect all key-value pairs from old table\n            let mut pairs = Vec::new();\n            for entry in &table.table {\n                if let FlatEntry::Occupied(k, v) = entry {\n                    pairs.push((k.clone(), v.clone()));\n                }\n            }\n\n            // Create new table with new size using the stored generator\n            let new_table_vec = (0..new_size).map(|_| FlatEntry::new()).collect();\n            let new_hash_fn = (table.hash_fn_gen)(new_size);\n            let mut new_table = HashTable {\n                table: new_table_vec,\n                hash_fn_gen: table.hash_fn_gen.clone(),\n                hash_fn: new_hash_fn,\n                initial_size: table.initial_size,\n                current_size: new_size,\n                num_elements: 0,\n                metrics: Metrics::default(),\n                _phantom: PhantomData,\n            };\n\n            // Reinsert all pairs into new table\n            for (key, value) in pairs {\n                Self::insert(&mut new_table, key, value);\n            }\n\n            new_table\n        }"
  },
  {
    "id": 1259,
    "function": "probe",
    "file": "Chap47/DoubleHashFlatHashTableStEph.rs",
    "lines": "159-167",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1), Span O(1).\n        /// - Claude-Opus-4.6: Work O(1), Span O(1) — two hash values + arithmetic + modulo.\n        fn probe(table: &HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: &Key, attempt: N) -> N {\n            let hash1 = (table.hash_fn)(key);\n            let step = Self::second_hash(key, table.current_size);\n\n            // Double hashing: (h1(key) + i·h2(key)) mod size\n            (hash1 + (attempt * step)) % table.current_size\n        }"
  },
  {
    "id": 1260,
    "function": "find_slot",
    "file": "Chap47/DoubleHashFlatHashTableStEph.rs",
    "lines": "169-182",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1/(1−α)) expected, Span O(1/(1−α)).\n        /// - Claude-Opus-4.6: Work O(1/(1−α)) expected, Span O(1/(1−α)) — double hash probe until empty/deleted/matching.\n        fn find_slot(table: &HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: &Key) -> N {\n            let mut attempt = 0;\n            while attempt < table.current_size {\n                let slot = Self::probe(table, key, attempt);\n                match &table.table[slot] {\n                    | FlatEntry::Empty | FlatEntry::Deleted => return slot,\n                    | FlatEntry::Occupied(k, _) if k == key => return slot,\n                    | _ => attempt += 1,\n                }\n            }\n            Self::probe(table, key, 0)\n        }"
  },
  {
    "id": 1261,
    "function": "new",
    "file": "Chap47/FlatHashTable.rs",
    "lines": "23-25",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1), Span O(1).\n        /// - Claude-Opus-4.6: Work O(1), Span O(1) — constant-time enum construction.\n        fn new() -> Self { FlatEntry::Empty }"
  },
  {
    "id": 1262,
    "function": "insert",
    "file": "Chap47/FlatHashTable.rs",
    "lines": "26-28",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1), Span O(1).\n        /// - Claude-Opus-4.6: Work O(1), Span O(1) — constant-time enum assignment.\n        fn insert(&mut self, key: Key, value: Value) { *self = FlatEntry::Occupied(key, value); }"
  },
  {
    "id": 1263,
    "function": "lookup",
    "file": "Chap47/FlatHashTable.rs",
    "lines": "30-37",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1), Span O(1).\n        /// - Claude-Opus-4.6: Work O(1), Span O(1) — single match + key comparison.\n        fn lookup(&self, key: &Key) -> Option<Value> {\n            match self {\n                | FlatEntry::Occupied(k, v) if k == key => Some(v.clone()),\n                | _ => None,\n            }\n        }"
  },
  {
    "id": 1264,
    "function": "delete",
    "file": "Chap47/FlatHashTable.rs",
    "lines": "39-49",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1), Span O(1).\n        /// - Claude-Opus-4.6: Work O(1), Span O(1) — single match + enum assignment.\n        fn delete(&mut self, key: &Key) -> B {\n            match self {\n                | FlatEntry::Occupied(k, _) if k == key => {\n                    *self = FlatEntry::Deleted;\n                    true\n                }\n                | _ => false,\n            }\n        }"
  },
  {
    "id": 1265,
    "function": "probe",
    "file": "Chap47/FlatHashTable.rs",
    "lines": "58-61",
    "spec_strength": "",
    "snippet": "        /// Probes for the next slot in the sequence.\n        /// - APAS: Work O(1), Span O(1).\n        /// - Claude-Opus-4.6: N/A — abstract trait method; cost depends on probing strategy.\n        fn probe(table: &HashTable<Key, Value, Entry, Metrics>, key: &Key, attempt: N) -> N;"
  },
  {
    "id": 1266,
    "function": "find_slot",
    "file": "Chap47/FlatHashTable.rs",
    "lines": "63-66",
    "spec_strength": "",
    "snippet": "        /// Finds the first available slot (Empty or Deleted) for insertion.\n        /// - APAS: Work O(1/(1−α)) expected, Span O(1/(1−α)).\n        /// - Claude-Opus-4.6: N/A — abstract trait method; cost depends on probing strategy.\n        fn find_slot(table: &HashTable<Key, Value, Entry, Metrics>, key: &Key) -> N;"
  },
  {
    "id": 1267,
    "function": "insert_with_probe",
    "file": "Chap47/FlatHashTable.rs",
    "lines": "68-76",
    "spec_strength": "",
    "snippet": "        /// Inserts using linear probing as default.\n        /// - APAS: Work O(1/(1−α)) expected, Span O(1/(1−α)).\n        /// - Claude-Opus-4.6: Work O(1/(1−α)) expected, Span O(1/(1−α)) — delegates to find_slot then O(1) write.\n        fn insert_with_probe(table: &mut HashTable<Key, Value, Entry, Metrics>, key: Key, value: Value) {\n            let slot = Self::find_slot(table, &key);\n            if slot < table.table.len() {\n                table.table[slot].insert(key, value);\n            }\n        }"
  },
  {
    "id": 1268,
    "function": "lookup_with_probe",
    "file": "Chap47/FlatHashTable.rs",
    "lines": "78-91",
    "spec_strength": "",
    "snippet": "        /// Looks up using probe sequence.\n        /// - APAS: Work O(1/(1−α)) expected, Span O(1/(1−α)).\n        /// - Claude-Opus-4.6: Work O(1/(1−α)) expected, Span O(1/(1−α)) — iterates probe sequence until found or empty.\n        fn lookup_with_probe(table: &HashTable<Key, Value, Entry, Metrics>, key: &Key) -> Option<Value> {\n            for attempt in 0..table.current_size {\n                let slot = Self::probe(table, key, attempt);\n                if slot < table.table.len() {\n                    if let Some(val) = table.table[slot].lookup(key) {\n                        return Some(val);\n                    }\n                }\n            }\n            None\n        }"
  },
  {
    "id": 1269,
    "function": "insert",
    "file": "Chap47/LinProbFlatHashTableStEph.rs",
    "lines": "18-38",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1/(1−α)) expected, Span O(1/(1−α)).\n        /// - Claude-Opus-4.6: Work O(1/(1−α)) expected, Span O(1/(1−α)) — linear probe find_slot then O(1) write.\n        fn insert(table: &mut HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: Key, value: Value) {\n            let slot = Self::find_slot(table, &key);\n            match &table.table[slot] {\n                | FlatEntry::Occupied(k, _) if k == &key => {\n                    // Update existing\n                    table.table[slot] = FlatEntry::Occupied(key, value);\n                }\n                | FlatEntry::Empty | FlatEntry::Deleted => {\n                    // Insert new\n                    table.table[slot] = FlatEntry::Occupied(key, value);\n                    table.num_elements += 1;\n                }\n                | _ => {\n                    // This shouldn't happen if find_slot works correctly\n                    table.table[slot] = FlatEntry::Occupied(key, value);\n                    table.num_elements += 1;\n                }\n            }\n        }"
  },
  {
    "id": 1270,
    "function": "lookup",
    "file": "Chap47/LinProbFlatHashTableStEph.rs",
    "lines": "40-56",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1/(1−α)) expected, Span O(1/(1−α)).\n        /// - Claude-Opus-4.6: Work O(1/(1−α)) expected, Span O(1/(1−α)) — linear probe sequence until found or empty.\n        fn lookup(table: &HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: &Key) -> Option<Value> {\n            let mut attempt = 0;\n            while attempt < table.current_size {\n                let slot = Self::probe(table, key, attempt);\n                match &table.table[slot] {\n                    | FlatEntry::Occupied(k, v) if k == key => return Some(v.clone()),\n                    | FlatEntry::Empty => return None, // Stop at Empty - key not in table\n                    | FlatEntry::Deleted | FlatEntry::Occupied(_, _) => {\n                        // Continue probing past Deleted or non-matching Occupied\n                        attempt += 1;\n                    }\n                }\n            }\n            None\n        }"
  },
  {
    "id": 1271,
    "function": "delete",
    "file": "Chap47/LinProbFlatHashTableStEph.rs",
    "lines": "58-79",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1/(1−α)) expected, Span O(1/(1−α)).\n        /// - Claude-Opus-4.6: Work O(1/(1−α)) expected, Span O(1/(1−α)) — linear probe until found or empty, then tombstone.\n        fn delete(table: &mut HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: &Key) -> B {\n            let mut attempt = 0;\n            while attempt < table.current_size {\n                let slot = Self::probe(table, key, attempt);\n                match &table.table[slot] {\n                    | FlatEntry::Occupied(k, _) if k == key => {\n                        // Mark as Deleted (tombstone) to maintain probe chain integrity\n                        table.table[slot] = FlatEntry::Deleted;\n                        table.num_elements -= 1;\n                        return true;\n                    }\n                    | FlatEntry::Empty => return false, // Key not found, stop at Empty\n                    | FlatEntry::Deleted | FlatEntry::Occupied(_, _) => {\n                        // Continue probing\n                        attempt += 1;\n                    }\n                }\n            }\n            false\n        }"
  },
  {
    "id": 1272,
    "function": "resize",
    "file": "Chap47/LinProbFlatHashTableStEph.rs",
    "lines": "81-115",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(n + m + m'), Span O(n + m + m').\n        /// - Claude-Opus-4.6: Work O(n + m + m'), Span O(n + m + m') — collects n pairs from m slots, creates m' new slots, reinserts n pairs.\n        fn resize(\n            table: &HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>,\n            new_size: N,\n        ) -> HashTable<Key, Value, FlatEntry<Key, Value>, Metrics> {\n            // Collect all key-value pairs from old table\n            let mut pairs = Vec::new();\n            for entry in &table.table {\n                if let FlatEntry::Occupied(k, v) = entry {\n                    pairs.push((k.clone(), v.clone()));\n                }\n            }\n\n            // Create new table with new size using the stored generator\n            let new_table_vec = (0..new_size).map(|_| FlatEntry::new()).collect();\n            let new_hash_fn = (table.hash_fn_gen)(new_size);\n            let mut new_table = HashTable {\n                table: new_table_vec,\n                hash_fn_gen: table.hash_fn_gen.clone(),\n                hash_fn: new_hash_fn,\n                initial_size: table.initial_size,\n                current_size: new_size,\n                num_elements: 0,\n                metrics: Metrics::default(),\n                _phantom: PhantomData,\n            };\n\n            // Reinsert all pairs into new table\n            for (key, value) in pairs {\n                Self::insert(&mut new_table, key, value);\n            }\n\n            new_table\n        }"
  },
  {
    "id": 1273,
    "function": "probe",
    "file": "Chap47/LinProbFlatHashTableStEph.rs",
    "lines": "121-128",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1), Span O(1).\n        /// - Claude-Opus-4.6: Work O(1), Span O(1) — hash + addition + modulo.\n        fn probe(table: &HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: &Key, attempt: N) -> N {\n            let hash_val = (table.hash_fn)(key);\n\n            // Linear probing: (hash(key) + attempt) mod size\n            (hash_val + attempt) % table.current_size\n        }"
  },
  {
    "id": 1274,
    "function": "find_slot",
    "file": "Chap47/LinProbFlatHashTableStEph.rs",
    "lines": "130-145",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1/(1−α)) expected, Span O(1/(1−α)).\n        /// - Claude-Opus-4.6: Work O(1/(1−α)) expected, Span O(1/(1−α)) — linear probe until empty/deleted/matching slot.\n        fn find_slot(table: &HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: &Key) -> N {\n            // Find first Empty or Deleted slot (can reuse Deleted slots for insertion)\n            let mut attempt = 0;\n            while attempt < table.current_size {\n                let slot = Self::probe(table, key, attempt);\n                match &table.table[slot] {\n                    | FlatEntry::Empty | FlatEntry::Deleted => return slot,\n                    | FlatEntry::Occupied(k, _) if k == key => return slot, // Update existing key\n                    | _ => attempt += 1,\n                }\n            }\n            // Table full - return first slot as fallback (shouldn't happen with proper load factor)\n            Self::probe(table, key, 0)\n        }"
  },
  {
    "id": 1275,
    "function": "new",
    "file": "Chap47/LinkedListChainedHashTableStEph.rs",
    "lines": "15-17",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1), Span O(1).\n        /// - Claude-Opus-4.6: Work O(1), Span O(1) — empty LinkedList construction.\n        fn new() -> Self { LinkedList::new() }"
  },
  {
    "id": 1276,
    "function": "insert`",
    "file": "Chap47/LinkedListChainedHashTableStEph.rs",
    "lines": "19-30",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1+α) expected, Span O(1+α).\n        /// - Claude-Opus-4.6: Work O(n), Span O(n) — linear scan for duplicate key, n = chain length.\n        fn insert(&mut self, key: Key, value: Value) {\n            // Update if key exists, otherwise append\n            for (k, v) in self.iter_mut() {\n                if k == &key {\n                    *v = value;\n                    return;\n                }\n            }\n            self.push_back((key, value));\n        }"
  },
  {
    "id": 1277,
    "function": "lookup`",
    "file": "Chap47/LinkedListChainedHashTableStEph.rs",
    "lines": "32-41",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1+α) expected, Span O(1+α).\n        /// - Claude-Opus-4.6: Work O(n), Span O(n) — linear scan of chain, n = chain length.\n        fn lookup(&self, key: &Key) -> Option<Value> {\n            for (k, v) in self.iter() {\n                if k == key {\n                    return Some(v.clone());\n                }\n            }\n            None\n        }"
  },
  {
    "id": 1278,
    "function": "delete`",
    "file": "Chap47/LinkedListChainedHashTableStEph.rs",
    "lines": "43-61",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1+α) expected, Span O(1+α).\n        /// - Claude-Opus-4.6: Work O(n), Span O(n) — linear scan + split_off/append, n = chain length.\n        fn delete(&mut self, key: &Key) -> B {\n            let mut found_idx = None;\n            for (idx, (k, _)) in self.iter().enumerate() {\n                if k == key {\n                    found_idx = Some(idx);\n                    break;\n                }\n            }\n            if let Some(idx) = found_idx {\n                let mut split_off = self.split_off(idx);\n                split_off.pop_front();\n                self.append(&mut split_off);\n                true\n            } else {\n                false\n            }\n        }"
  },
  {
    "id": 1279,
    "function": "resize",
    "file": "Chap47/LinkedListChainedHashTableStEph.rs",
    "lines": "88-122",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(n + m + m'), Span O(n + m + m').\n        /// - Claude-Opus-4.6: Work O(n + m + m'), Span O(n + m + m') — collects n pairs, creates m' lists, reinserts.\n        fn resize(\n            table: &HashTable<Key, Value, LinkedList<(Key, Value)>, Metrics>,\n            new_size: N,\n        ) -> HashTable<Key, Value, LinkedList<(Key, Value)>, Metrics> {\n            // Collect all key-value pairs from all chains\n            let mut pairs = Vec::new();\n            for chain in &table.table {\n                for (k, v) in chain.iter() {\n                    pairs.push((k.clone(), v.clone()));\n                }\n            }\n\n            // Create new table with new size using the stored generator\n            let new_table_vec = (0..new_size).map(|_| LinkedList::new()).collect();\n            let new_hash_fn = (table.hash_fn_gen)(new_size);\n            let mut new_table = HashTable {\n                table: new_table_vec,\n                hash_fn_gen: table.hash_fn_gen.clone(),\n                hash_fn: new_hash_fn,\n                initial_size: table.initial_size,\n                current_size: new_size,\n                num_elements: 0,\n                metrics: Metrics::default(),\n                _phantom: PhantomData,\n            };\n\n            // Reinsert all pairs into new table\n            for (key, value) in pairs {\n                Self::insert(&mut new_table, key, value);\n            }\n\n            new_table\n        }"
  },
  {
    "id": 1280,
    "function": "hash_index",
    "file": "Chap47/LinkedListChainedHashTableStEph.rs",
    "lines": "128-134",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1), Span O(1).\n        /// - Claude-Opus-4.6: Work O(1), Span O(1) — placeholder always returns 0; should use actual hash function.\n        fn hash_index(table: &HashTable<Key, Value, LinkedList<(Key, Value)>, Metrics>, _key: &Key) -> N {\n            // Simple modulo hash - implementers can provide better hash function\n            let hash_val = 0; // Placeholder: would use actual hash function\n            hash_val % table.current_size\n        }"
  },
  {
    "id": 1281,
    "function": "new",
    "file": "Chap47/ParaHashTableStEph.rs",
    "lines": "44-46",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — inner table interface, cost depends on implementation.\n        /// - Claude-Opus-4.6: N/A — abstract trait method.\n        fn new()                        -> Self;"
  },
  {
    "id": 1282,
    "function": "insert`",
    "file": "Chap47/ParaHashTableStEph.rs",
    "lines": "79-82",
    "spec_strength": "",
    "snippet": "        /// Inserts a key-value pair into the hash table.\n        /// - APAS: Work O(1) expected, Span O(1).\n        /// - Claude-Opus-4.6: N/A — abstract trait method; cost depends on implementation.\n        fn insert(table: &mut HashTable<Key, Value, Entry, Metrics>, key: Key, value: Value);"
  },
  {
    "id": 1283,
    "function": "lookup`",
    "file": "Chap47/ParaHashTableStEph.rs",
    "lines": "84-87",
    "spec_strength": "",
    "snippet": "        /// Looks up a key in the hash table, returning its value if found.\n        /// - APAS: Work O(1) expected, Span O(1).\n        /// - Claude-Opus-4.6: N/A — abstract trait method; cost depends on implementation.\n        fn lookup(table: &HashTable<Key, Value, Entry, Metrics>, key: &Key)     -> Option<Value>;"
  },
  {
    "id": 1284,
    "function": "delete`",
    "file": "Chap47/ParaHashTableStEph.rs",
    "lines": "89-92",
    "spec_strength": "",
    "snippet": "        /// Deletes a key from the hash table if it exists.\n        /// - APAS: Work O(1) expected, Span O(1).\n        /// - Claude-Opus-4.6: N/A — abstract trait method; cost depends on implementation.\n        fn delete(table: &mut HashTable<Key, Value, Entry, Metrics>, key: &Key) -> B;"
  },
  {
    "id": 1285,
    "function": "createTable",
    "file": "Chap47/ParaHashTableStEph.rs",
    "lines": "60-77",
    "spec_strength": "",
    "snippet": "        /// Creates an empty hash table with the given initial size.\n        /// Takes a hash function generator that produces hash functions for different table sizes.\n        /// - APAS: Work O(m), Span O(m) where m is initial size.\n        /// - Claude-Opus-4.6: Work O(m), Span O(m) — agrees with APAS; iterates m times to create entries.\n        fn createTable(hash_fn_gen: HashFunGen<Key>, initial_size: N)           -> HashTable<Key, Value, Entry, Metrics> {\n            let table = (0..initial_size).map(|_| Entry::new()).collect();\n            let hash_fn = hash_fn_gen(initial_size);\n            HashTable {\n                table,\n                hash_fn_gen,\n                hash_fn,\n                initial_size,\n                current_size: initial_size,\n                num_elements: 0,\n                metrics: Metrics::default(),\n                _phantom: PhantomData,\n            }\n        }"
  },
  {
    "id": 1286,
    "function": "metrics",
    "file": "Chap47/ParaHashTableStEph.rs",
    "lines": "94-97",
    "spec_strength": "",
    "snippet": "        /// Accessor for metrics field.\n        /// - APAS: N/A — Verus-specific scaffolding.\n        /// - Claude-Opus-4.6: Work O(1), Span O(1) — field access.\n        fn metrics(table: &HashTable<Key, Value, Entry, Metrics>)               -> &Metrics { &table.metrics }"
  },
  {
    "id": 1287,
    "function": "loadAndSize",
    "file": "Chap47/ParaHashTableStEph.rs",
    "lines": "99-113",
    "spec_strength": "",
    "snippet": "        /// Returns the load (number of entries) and size (table capacity).\n        /// Load factor α = load/size = num_elements/size\n        /// - APAS: Work O(1), Span O(1).\n        /// - Claude-Opus-4.6: Work O(1), Span O(1) — agrees with APAS; field reads and one division.\n        fn loadAndSize(table: &HashTable<Key, Value, Entry, Metrics>)           -> LoadAndSize {\n            let load_factor = if table.current_size == 0 {\n                0.0\n            } else {\n                table.num_elements as f64 / table.current_size as f64\n            };\n            LoadAndSize {\n                load: load_factor,\n                size: table.current_size,\n            }\n        }"
  },
  {
    "id": 1288,
    "function": "resize",
    "file": "Chap47/ParaHashTableStEph.rs",
    "lines": "115-120",
    "spec_strength": "",
    "snippet": "        /// Resizes the hash table to a new size and rehashes all entries.\n        /// Uses the stored hash function generator to create a new hash function for the new size.\n        /// - APAS: Work O(n + m + m'), Span O(n + m + m') where n is number of elements,\n        ///   m is old size, m' is new size.\n        /// - Claude-Opus-4.6: N/A — abstract trait method; cost depends on implementation.\n        fn resize(table: &HashTable<Key, Value, Entry, Metrics>, new_size: N)   -> HashTable<Key, Value, Entry, Metrics>;"
  },
  {
    "id": 1289,
    "function": "insert",
    "file": "Chap47/QuadProbFlatHashTableStEph.rs",
    "lines": "20-39",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1/(1−α)) expected, Span O(1/(1−α)).\n        /// - Claude-Opus-4.6: Work O(1/(1−α)) expected, Span O(1/(1−α)) — quadratic probe find_slot then O(1) write.\n        fn insert(table: &mut HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: Key, value: Value) {\n            let slot = Self::find_slot(table, &key);\n            match &table.table[slot] {\n                | FlatEntry::Occupied(k, _) if k == &key => {\n                    // Update existing\n                    table.table[slot] = FlatEntry::Occupied(key, value);\n                }\n                | FlatEntry::Empty | FlatEntry::Deleted => {\n                    // Insert new\n                    table.table[slot] = FlatEntry::Occupied(key, value);\n                    table.num_elements += 1;\n                }\n                | _ => {\n                    table.table[slot] = FlatEntry::Occupied(key, value);\n                    table.num_elements += 1;\n                }\n            }\n        }"
  },
  {
    "id": 1290,
    "function": "lookup",
    "file": "Chap47/QuadProbFlatHashTableStEph.rs",
    "lines": "41-57",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1/(1−α)) expected, Span O(1/(1−α)).\n        /// - Claude-Opus-4.6: Work O(1/(1−α)) expected, Span O(1/(1−α)) — quadratic probe up to ⌈m/2⌉ attempts (Lemma 47.1).\n        fn lookup(table: &HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: &Key) -> Option<Value> {\n            let mut attempt = 0;\n            let max_attempts = table.current_size.div_ceil(2); // APAS Lemma 47.1: first ⌈m/2⌉ probes are distinct\n            while attempt < max_attempts {\n                let slot = Self::probe(table, key, attempt);\n                match &table.table[slot] {\n                    | FlatEntry::Occupied(k, v) if k == key => return Some(v.clone()),\n                    | FlatEntry::Empty => return None,\n                    | FlatEntry::Deleted | FlatEntry::Occupied(_, _) => {\n                        attempt += 1;\n                    }\n                }\n            }\n            None\n        }"
  },
  {
    "id": 1291,
    "function": "delete",
    "file": "Chap47/QuadProbFlatHashTableStEph.rs",
    "lines": "59-79",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1/(1−α)) expected, Span O(1/(1−α)).\n        /// - Claude-Opus-4.6: Work O(1/(1−α)) expected, Span O(1/(1−α)) — quadratic probe until found or empty, then tombstone.\n        fn delete(table: &mut HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: &Key) -> B {\n            let mut attempt = 0;\n            let max_attempts = table.current_size.div_ceil(2); // APAS Lemma 47.1: first ⌈m/2⌉ probes are distinct\n            while attempt < max_attempts {\n                let slot = Self::probe(table, key, attempt);\n                match &table.table[slot] {\n                    | FlatEntry::Occupied(k, _) if k == key => {\n                        table.table[slot] = FlatEntry::Deleted;\n                        table.num_elements -= 1;\n                        return true;\n                    }\n                    | FlatEntry::Empty => return false,\n                    | FlatEntry::Deleted | FlatEntry::Occupied(_, _) => {\n                        attempt += 1;\n                    }\n                }\n            }\n            false\n        }"
  },
  {
    "id": 1292,
    "function": "resize",
    "file": "Chap47/QuadProbFlatHashTableStEph.rs",
    "lines": "81-115",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(n + m + m'), Span O(n + m + m').\n        /// - Claude-Opus-4.6: Work O(n + m + m'), Span O(n + m + m') — collects n pairs from m slots, creates m' new slots, reinserts n pairs.\n        fn resize(\n            table: &HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>,\n            new_size: N,\n        ) -> HashTable<Key, Value, FlatEntry<Key, Value>, Metrics> {\n            // Collect all key-value pairs from old table\n            let mut pairs = Vec::new();\n            for entry in &table.table {\n                if let FlatEntry::Occupied(k, v) = entry {\n                    pairs.push((k.clone(), v.clone()));\n                }\n            }\n\n            // Create new table with new size using the stored generator\n            let new_table_vec = (0..new_size).map(|_| FlatEntry::new()).collect();\n            let new_hash_fn = (table.hash_fn_gen)(new_size);\n            let mut new_table = HashTable {\n                table: new_table_vec,\n                hash_fn_gen: table.hash_fn_gen.clone(),\n                hash_fn: new_hash_fn,\n                initial_size: table.initial_size,\n                current_size: new_size,\n                num_elements: 0,\n                metrics: Metrics::default(),\n                _phantom: PhantomData,\n            };\n\n            // Reinsert all pairs into new table\n            for (key, value) in pairs {\n                Self::insert(&mut new_table, key, value);\n            }\n\n            new_table\n        }"
  },
  {
    "id": 1293,
    "function": "probe",
    "file": "Chap47/QuadProbFlatHashTableStEph.rs",
    "lines": "121-128",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1), Span O(1).\n        /// - Claude-Opus-4.6: Work O(1), Span O(1) — hash + i² + modulo.\n        fn probe(table: &HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: &Key, attempt: N) -> N {\n            let hash_val = (table.hash_fn)(key);\n\n            // Quadratic probing: (hash(key) + i²) mod size\n            (hash_val + (attempt * attempt)) % table.current_size\n        }"
  },
  {
    "id": 1294,
    "function": "find_slot",
    "file": "Chap47/QuadProbFlatHashTableStEph.rs",
    "lines": "130-144",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1/(1−α)) expected, Span O(1/(1−α)).\n        /// - Claude-Opus-4.6: Work O(1/(1−α)) expected, Span O(1/(1−α)) — quadratic probe up to ⌈m/2⌉ (Lemma 47.1).\n        fn find_slot(table: &HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: &Key) -> N {\n            let mut attempt = 0;\n            let max_attempts = table.current_size.div_ceil(2); // APAS Lemma 47.1: first ⌈m/2⌉ probes are distinct\n            while attempt < max_attempts {\n                let slot = Self::probe(table, key, attempt);\n                match &table.table[slot] {\n                    | FlatEntry::Empty | FlatEntry::Deleted => return slot,\n                    | FlatEntry::Occupied(k, _) if k == key => return slot,\n                    | _ => attempt += 1,\n                }\n            }\n            Self::probe(table, key, 0)\n        }"
  },
  {
    "id": 1295,
    "function": "new",
    "file": "Chap47/StructChainedHashTable.rs",
    "lines": "28-30",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1), Span O(1).\n        /// - Claude-Opus-4.6: Work O(1), Span O(1) — empty list construction.\n        fn new() -> Self { ChainList { head: None } }"
  },
  {
    "id": 1296,
    "function": "insert`",
    "file": "Chap47/StructChainedHashTable.rs",
    "lines": "32-51",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1+α) expected, Span O(1+α).\n        /// - Claude-Opus-4.6: Work O(n), Span O(n) — linear scan for duplicate key, then head insert, n = chain length.\n        fn insert(&mut self, key: Key, value: Value) {\n            // Search for existing key and update\n            let mut current = &mut self.head;\n            while let Some(node) = current {\n                if node.key == key {\n                    node.value = value;\n                    return;\n                }\n                current = &mut node.next;\n            }\n            // Key not found, insert at head\n            let new_node = Box::new(Node {\n                key,\n                value,\n                next: self.head.take(),\n            });\n            self.head = Some(new_node);\n        }"
  },
  {
    "id": 1297,
    "function": "lookup`",
    "file": "Chap47/StructChainedHashTable.rs",
    "lines": "53-64",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1+α) expected, Span O(1+α).\n        /// - Claude-Opus-4.6: Work O(n), Span O(n) — linear scan of linked list, n = chain length.\n        fn lookup(&self, key: &Key) -> Option<Value> {\n            let mut current = &self.head;\n            while let Some(node) = current {\n                if &node.key == key {\n                    return Some(node.value.clone());\n                }\n                current = &node.next;\n            }\n            None\n        }"
  },
  {
    "id": 1298,
    "function": "delete`",
    "file": "Chap47/StructChainedHashTable.rs",
    "lines": "66-82",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1+α) expected, Span O(1+α).\n        /// - Claude-Opus-4.6: Work O(n), Span O(n) — linear scan + pointer surgery, n = chain length.\n        fn delete(&mut self, key: &Key) -> B {\n            let mut current = &mut self.head;\n            loop {\n                match current {\n                    | None => return false,\n                    | Some(node) if &node.key == key => {\n                        *current = node.next.take();\n                        return true;\n                    }\n                    | Some(node) => {\n                        current = &mut node.next;\n                    }\n                }\n            }\n        }"
  },
  {
    "id": 1299,
    "function": "default",
    "file": "Chap47/StructChainedHashTable.rs",
    "lines": "86-88",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — Verus-specific scaffolding.\n        /// - Claude-Opus-4.6: Work O(1), Span O(1) — empty list construction.\n        fn default() -> Self { ChainList { head: None } }"
  },
  {
    "id": 1300,
    "function": "resize",
    "file": "Chap47/StructChainedHashTable.rs",
    "lines": "115-151",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(n + m + m'), Span O(n + m + m').\n        /// - Claude-Opus-4.6: Work O(n + m + m'), Span O(n + m + m') — traverses all chains, creates m' lists, reinserts.\n        fn resize(\n            table: &HashTable<Key, Value, ChainList<Key, Value>, Metrics>,\n            new_size: N,\n        ) -> HashTable<Key, Value, ChainList<Key, Value>, Metrics> {\n            // Collect all key-value pairs from all chains\n            let mut pairs = Vec::new();\n            for chain in &table.table {\n                let mut current = &chain.head;\n                while let Some(node) = current {\n                    pairs.push((node.key.clone(), node.value.clone()));\n                    current = &node.next;\n                }\n            }\n\n            // Create new table with new size using the stored generator\n            let new_table_vec = (0..new_size).map(|_| ChainList::new()).collect();\n            let new_hash_fn = (table.hash_fn_gen)(new_size);\n            let mut new_table = HashTable {\n                table: new_table_vec,\n                hash_fn_gen: table.hash_fn_gen.clone(),\n                hash_fn: new_hash_fn,\n                initial_size: table.initial_size,\n                current_size: new_size,\n                num_elements: 0,\n                metrics: Metrics::default(),\n                _phantom: PhantomData,\n            };\n\n            // Reinsert all pairs into new table\n            for (key, value) in pairs {\n                Self::insert(&mut new_table, key, value);\n            }\n\n            new_table\n        }"
  },
  {
    "id": 1301,
    "function": "hash_index",
    "file": "Chap47/StructChainedHashTable.rs",
    "lines": "157-163",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1), Span O(1).\n        /// - Claude-Opus-4.6: Work O(1), Span O(1) — placeholder always returns 0; should use actual hash function.\n        fn hash_index(table: &HashTable<Key, Value, ChainList<Key, Value>, Metrics>, _key: &Key) -> N {\n            // Simple modulo hash - implementers can provide better hash function\n            let hash_val = 0; // Placeholder: would use actual hash function\n            hash_val % table.current_size\n        }"
  },
  {
    "id": 1302,
    "function": "new",
    "file": "Chap47/VecChainedHashTableStEph.rs",
    "lines": "14-16",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1), Span O(1).\n        /// - Claude-Opus-4.6: Work O(1), Span O(1) — empty Vec construction.\n        fn new() -> Self { Vec::new() }"
  },
  {
    "id": 1303,
    "function": "insert`",
    "file": "Chap47/VecChainedHashTableStEph.rs",
    "lines": "18-29",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1+α) expected, Span O(1+α).\n        /// - Claude-Opus-4.6: Work O(n) worst case, Span O(n) — linear scan for duplicate key, n = chain length.\n        fn insert(&mut self, key: Key, value: Value) {\n            // Update if key exists, otherwise append\n            for (k, v) in self.iter_mut() {\n                if k == &key {\n                    *v = value;\n                    return;\n                }\n            }\n            self.push((key, value));\n        }"
  },
  {
    "id": 1304,
    "function": "lookup`",
    "file": "Chap47/VecChainedHashTableStEph.rs",
    "lines": "31-40",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1+α) expected, Span O(1+α).\n        /// - Claude-Opus-4.6: Work O(n), Span O(n) — linear scan of chain, n = chain length.\n        fn lookup(&self, key: &Key) -> Option<Value> {\n            for (k, v) in self.iter() {\n                if k == key {\n                    return Some(v.clone());\n                }\n            }\n            None\n        }"
  },
  {
    "id": 1305,
    "function": "delete`",
    "file": "Chap47/VecChainedHashTableStEph.rs",
    "lines": "42-51",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1+α) expected, Span O(1+α).\n        /// - Claude-Opus-4.6: Work O(n), Span O(n) — linear scan + Vec::remove (shifts elements), n = chain length.\n        fn delete(&mut self, key: &Key) -> B {\n            if let Some(pos) = self.iter().position(|(k, _)| k == key) {\n                self.remove(pos);\n                true\n            } else {\n                false\n            }\n        }"
  },
  {
    "id": 1306,
    "function": "resize",
    "file": "Chap47/VecChainedHashTableStEph.rs",
    "lines": "78-112",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(n + m + m'), Span O(n + m + m').\n        /// - Claude-Opus-4.6: Work O(n + m + m'), Span O(n + m + m') — collects n pairs, creates m' chains, reinserts.\n        fn resize(\n            table: &HashTable<Key, Value, Vec<(Key, Value)>, Metrics>,\n            new_size: N,\n        ) -> HashTable<Key, Value, Vec<(Key, Value)>, Metrics> {\n            // Collect all key-value pairs from all chains\n            let mut pairs = Vec::new();\n            for chain in &table.table {\n                for (k, v) in chain.iter() {\n                    pairs.push((k.clone(), v.clone()));\n                }\n            }\n\n            // Create new table with new size using the stored generator\n            let new_table_vec = (0..new_size).map(|_| Vec::new()).collect();\n            let new_hash_fn = (table.hash_fn_gen)(new_size);\n            let mut new_table = HashTable {\n                table: new_table_vec,\n                hash_fn_gen: table.hash_fn_gen.clone(),\n                hash_fn: new_hash_fn,\n                initial_size: table.initial_size,\n                current_size: new_size,\n                num_elements: 0,\n                metrics: Metrics::default(),\n                _phantom: PhantomData,\n            };\n\n            // Reinsert all pairs into new table\n            for (key, value) in pairs {\n                Self::insert(&mut new_table, key, value);\n            }\n\n            new_table\n        }"
  },
  {
    "id": 1307,
    "function": "hash_index",
    "file": "Chap47/VecChainedHashTableStEph.rs",
    "lines": "118-124",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1), Span O(1).\n        /// - Claude-Opus-4.6: Work O(1), Span O(1) — placeholder always returns 0; should use actual hash function.\n        fn hash_index(table: &HashTable<Key, Value, Vec<(Key, Value)>, Metrics>, _key: &Key) -> N {\n            // Simple modulo hash - implementers can provide better hash function\n            let hash_val = 0; // Placeholder: would use actual hash function\n            hash_val % table.current_size\n        }"
  },
  {
    "id": 1308,
    "function": "new",
    "file": "Chap49/MinEditDistMtEph.rs",
    "lines": "24-27",
    "spec_strength": "",
    "snippet": "        /// Create new minimum edit distance solver\n        fn new()                                                                -> Self\n        where\n            T: Default;"
  },
  {
    "id": 1309,
    "function": "from_sequences",
    "file": "Chap49/MinEditDistMtEph.rs",
    "lines": "29-30",
    "spec_strength": "",
    "snippet": "        /// Create from source and target sequences\n        fn from_sequences(source: ArraySeqMtEphS<T>, target: ArraySeqMtEphS<T>) -> Self;"
  },
  {
    "id": 1310,
    "function": "min_edit_distance",
    "file": "Chap49/MinEditDistMtEph.rs",
    "lines": "32-36",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(|S|×|T|), Span Θ(|S|+|T|)\n        /// - Claude-Opus-4.6: Work Θ(|S|×|T|), Span Θ(|S|+|T|) — agrees with APAS; thread::spawn on delete/insert\n        fn min_edit_distance(&mut self)                                         -> usize\n        where\n            T: Send + Sync + 'static;"
  },
  {
    "id": 1311,
    "function": "source",
    "file": "Chap49/MinEditDistMtEph.rs",
    "lines": "38-39",
    "spec_strength": "",
    "snippet": "        /// Get the source sequence\n        fn source(&self)                                                        -> &ArraySeqMtEphS<T>;"
  },
  {
    "id": 1312,
    "function": "target",
    "file": "Chap49/MinEditDistMtEph.rs",
    "lines": "41-42",
    "spec_strength": "",
    "snippet": "        /// Get the target sequence\n        fn target(&self)                                                        -> &ArraySeqMtEphS<T>;"
  },
  {
    "id": 1313,
    "function": "source_mut",
    "file": "Chap49/MinEditDistMtEph.rs",
    "lines": "44-45",
    "spec_strength": "",
    "snippet": "        /// Get mutable source sequence (ephemeral allows mutation)\n        fn source_mut(&mut self)                                                -> &mut ArraySeqMtEphS<T>;"
  },
  {
    "id": 1314,
    "function": "target_mut",
    "file": "Chap49/MinEditDistMtEph.rs",
    "lines": "47-48",
    "spec_strength": "",
    "snippet": "        /// Get mutable target sequence (ephemeral allows mutation)\n        fn target_mut(&mut self)                                                -> &mut ArraySeqMtEphS<T>;"
  },
  {
    "id": 1315,
    "function": "set_source",
    "file": "Chap49/MinEditDistMtEph.rs",
    "lines": "50-51",
    "spec_strength": "",
    "snippet": "        /// Set element in source sequence\n        fn set_source(&mut self, index: usize, value: T);"
  },
  {
    "id": 1316,
    "function": "set_target",
    "file": "Chap49/MinEditDistMtEph.rs",
    "lines": "53-54",
    "spec_strength": "",
    "snippet": "        /// Set element in target sequence\n        fn set_target(&mut self, index: usize, value: T);"
  },
  {
    "id": 1317,
    "function": "clear_memo",
    "file": "Chap49/MinEditDistMtEph.rs",
    "lines": "56-57",
    "spec_strength": "",
    "snippet": "        /// Clear memoization table\n        fn clear_memo(&mut self);"
  },
  {
    "id": 1318,
    "function": "memo_size",
    "file": "Chap49/MinEditDistMtEph.rs",
    "lines": "59-60",
    "spec_strength": "",
    "snippet": "        /// Get memoization table size\n        fn memo_size(&self)                                                     -> usize;"
  },
  {
    "id": 1319,
    "function": "min_edit_distance_rec",
    "file": "Chap49/MinEditDistMtEph.rs",
    "lines": "64-112",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(|S|×|T|), Span Θ(|S|+|T|)\n        /// - Claude-Opus-4.6: Work Θ(|S|×|T|), Span Θ(|S|+|T|) — parallel fork on delete/insert branches\n        fn min_edit_distance_rec(&self, i: usize, j: usize) -> usize\n        where\n            T: Send + Sync + 'static,\n        {\n            // Check memo first (thread-safe)\n            {\n                let memo_guard = self.memo.lock().unwrap();\n                if let Some(&result) = memo_guard.get(&(i, j)) {\n                    return result;\n                }\n            }\n\n            let result = match (i, j) {\n                | (i, 0) => i, // Base case: need i deletions\n                | (0, j) => j, // Base case: need j insertions\n                | (i, j) => {\n                    let source_char = self.source.nth(i - 1).clone();\n                    let target_char = self.target.nth(j - 1).clone();\n\n                    if source_char == target_char {\n                        // Characters match, no edit needed\n                        self.min_edit_distance_rec(i - 1, j - 1)\n                    } else {\n                        // Parallel evaluation of both operations\n                        let self_clone1 = self.clone();\n                        let self_clone2 = self.clone();\n\n                        let handle1 = thread::spawn(move || self_clone1.min_edit_distance_rec(i - 1, j));\n\n                        let handle2 = thread::spawn(move || self_clone2.min_edit_distance_rec(i, j - 1));\n\n                        let delete_cost = handle1.join().unwrap();\n                        let insert_cost = handle2.join().unwrap();\n\n                        1 + std::cmp::min(delete_cost, insert_cost)\n                    }\n                }\n            };\n\n            // Memoize result (thread-safe)\n            {\n                let mut memo_guard = self.memo.lock().unwrap();\n                memo_guard.insert((i, j), result);\n            }\n\n            result\n        }"
  },
  {
    "id": 1320,
    "function": "eq",
    "file": "Chap49/MinEditDistMtEph.rs",
    "lines": "185",
    "spec_strength": "",
    "snippet": "        fn eq(&self, other: &Self) -> bool { self.source == other.source && self.target == other.target }"
  },
  {
    "id": 1321,
    "function": "new",
    "file": "Chap49/MinEditDistMtPer.rs",
    "lines": "23-26",
    "spec_strength": "",
    "snippet": "        /// Create new minimum edit distance solver\n        fn new()                                                                -> Self\n        where\n            T: Default;"
  },
  {
    "id": 1322,
    "function": "from_sequences",
    "file": "Chap49/MinEditDistMtPer.rs",
    "lines": "28-29",
    "spec_strength": "",
    "snippet": "        /// Create from source and target sequences\n        fn from_sequences(source: ArraySeqMtPerS<T>, target: ArraySeqMtPerS<T>) -> Self;"
  },
  {
    "id": 1323,
    "function": "min_edit_distance",
    "file": "Chap49/MinEditDistMtPer.rs",
    "lines": "31-35",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(|S|×|T|), Span Θ(|S|+|T|)\n        /// - Claude-Opus-4.6: Work Θ(|S|×|T|), Span Θ(|S|+|T|) — agrees with APAS; thread::spawn on delete/insert\n        fn min_edit_distance(&self)                                             -> usize\n        where\n            T: Send + Sync + 'static;"
  },
  {
    "id": 1324,
    "function": "source",
    "file": "Chap49/MinEditDistMtPer.rs",
    "lines": "37-38",
    "spec_strength": "",
    "snippet": "        /// Get the source sequence\n        fn source(&self)                                                        -> &ArraySeqMtPerS<T>;"
  },
  {
    "id": 1325,
    "function": "target",
    "file": "Chap49/MinEditDistMtPer.rs",
    "lines": "40-41",
    "spec_strength": "",
    "snippet": "        /// Get the target sequence\n        fn target(&self)                                                        -> &ArraySeqMtPerS<T>;"
  },
  {
    "id": 1326,
    "function": "memo_size",
    "file": "Chap49/MinEditDistMtPer.rs",
    "lines": "43-44",
    "spec_strength": "",
    "snippet": "        /// Get memoization table size\n        fn memo_size(&self)                                                     -> usize;"
  },
  {
    "id": 1327,
    "function": "min_edit_distance_rec",
    "file": "Chap49/MinEditDistMtPer.rs",
    "lines": "47-96",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work Θ(|S|×|T|), Span Θ(|S|+|T|)\n    /// - Claude-Opus-4.6: Work Θ(|S|×|T|), Span Θ(|S|+|T|) — parallel fork on delete/insert branches\n    fn min_edit_distance_rec<T: MtVal + Send + Sync + 'static>(\n        table: &MinEditDistMtPerS<T>,\n        i: usize,\n        j: usize,\n    ) -> usize {\n        // Check memo first (thread-safe)\n        {\n            let memo_guard = table.memo.lock().unwrap();\n            if let Some(&result) = memo_guard.get(&(i, j)) {\n                return result;\n            }\n        }\n\n        let result = match (i, j) {\n            | (i, 0) => i, // Base case: need i deletions\n            | (0, j) => j, // Base case: need j insertions\n            | (i, j) => {\n                let source_char = table.source.nth(i - 1);\n                let target_char = table.target.nth(j - 1);\n\n                if source_char == target_char {\n                    // Characters match, no edit needed\n                    min_edit_distance_rec(table, i - 1, j - 1)\n                } else {\n                    // Parallel evaluation of both operations\n                    let table_clone1 = table.clone();\n                    let table_clone2 = table.clone();\n\n                    let handle1 = thread::spawn(move || min_edit_distance_rec(&table_clone1, i - 1, j));\n\n                    let handle2 = thread::spawn(move || min_edit_distance_rec(&table_clone2, i, j - 1));\n\n                    let delete_cost = handle1.join().unwrap();\n                    let insert_cost = handle2.join().unwrap();\n\n                    1 + std::cmp::min(delete_cost, insert_cost)\n                }\n            }\n        };\n\n        // Memoize result (thread-safe)\n        {\n            let mut memo_guard = table.memo.lock().unwrap();\n            memo_guard.insert((i, j), result);\n        }\n\n        result\n    }"
  },
  {
    "id": 1328,
    "function": "eq",
    "file": "Chap49/MinEditDistMtPer.rs",
    "lines": "145",
    "spec_strength": "",
    "snippet": "        fn eq(&self, other: &Self) -> bool { self.source == other.source && self.target == other.target }"
  },
  {
    "id": 1329,
    "function": "new",
    "file": "Chap49/MinEditDistStEph.rs",
    "lines": "23-26",
    "spec_strength": "",
    "snippet": "        /// Create new minimum edit distance solver\n        fn new()                                                                -> Self\n        where\n            T: Default;"
  },
  {
    "id": 1330,
    "function": "from_sequences",
    "file": "Chap49/MinEditDistStEph.rs",
    "lines": "28-29",
    "spec_strength": "",
    "snippet": "        /// Create from source and target sequences\n        fn from_sequences(source: ArraySeqStEphS<T>, target: ArraySeqStEphS<T>) -> Self;"
  },
  {
    "id": 1331,
    "function": "min_edit_distance",
    "file": "Chap49/MinEditDistStEph.rs",
    "lines": "31-33",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(|S|×|T|), Span Θ(|S|+|T|)\n        /// - Claude-Opus-4.6: Work Θ(|S|×|T|), Span Θ(|S|×|T|) — sequential, span equals work\n        fn min_edit_distance(&mut self)                                         -> usize;"
  },
  {
    "id": 1332,
    "function": "source",
    "file": "Chap49/MinEditDistStEph.rs",
    "lines": "35-36",
    "spec_strength": "",
    "snippet": "        /// Get the source sequence\n        fn source(&self)                                                        -> &ArraySeqStEphS<T>;"
  },
  {
    "id": 1333,
    "function": "target",
    "file": "Chap49/MinEditDistStEph.rs",
    "lines": "38-39",
    "spec_strength": "",
    "snippet": "        /// Get the target sequence\n        fn target(&self)                                                        -> &ArraySeqStEphS<T>;"
  },
  {
    "id": 1334,
    "function": "source_mut",
    "file": "Chap49/MinEditDistStEph.rs",
    "lines": "41-42",
    "spec_strength": "",
    "snippet": "        /// Get mutable source sequence (ephemeral allows mutation)\n        fn source_mut(&mut self)                                                -> &mut ArraySeqStEphS<T>;"
  },
  {
    "id": 1335,
    "function": "target_mut",
    "file": "Chap49/MinEditDistStEph.rs",
    "lines": "44-45",
    "spec_strength": "",
    "snippet": "        /// Get mutable target sequence (ephemeral allows mutation)\n        fn target_mut(&mut self)                                                -> &mut ArraySeqStEphS<T>;"
  },
  {
    "id": 1336,
    "function": "set_source",
    "file": "Chap49/MinEditDistStEph.rs",
    "lines": "47-48",
    "spec_strength": "",
    "snippet": "        /// Set element in source sequence\n        fn set_source(&mut self, index: usize, value: T);"
  },
  {
    "id": 1337,
    "function": "set_target",
    "file": "Chap49/MinEditDistStEph.rs",
    "lines": "50-51",
    "spec_strength": "",
    "snippet": "        /// Set element in target sequence\n        fn set_target(&mut self, index: usize, value: T);"
  },
  {
    "id": 1338,
    "function": "clear_memo",
    "file": "Chap49/MinEditDistStEph.rs",
    "lines": "53-54",
    "spec_strength": "",
    "snippet": "        /// Clear memoization table\n        fn clear_memo(&mut self);"
  },
  {
    "id": 1339,
    "function": "memo_size",
    "file": "Chap49/MinEditDistStEph.rs",
    "lines": "56-57",
    "spec_strength": "",
    "snippet": "        /// Get memoization table size\n        fn memo_size(&self)                                                     -> usize;"
  },
  {
    "id": 1340,
    "function": "min_edit_distance_rec",
    "file": "Chap49/MinEditDistStEph.rs",
    "lines": "60-91",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work Θ(|S|×|T|), Span Θ(|S|+|T|)\n    /// - Claude-Opus-4.6: Work Θ(|S|×|T|), Span Θ(|S|×|T|) — sequential memoized recursion\n    fn min_edit_distance_rec<T: StT>(table: &mut MinEditDistStEphS<T>, i: usize, j: usize) -> usize {\n        // Check memo first\n        if let Some(&result) = table.memo.get(&(i, j)) {\n            return result;\n        }\n\n        let result = match (i, j) {\n            | (i, 0) => i, // Base case: need i deletions\n            | (0, j) => j, // Base case: need j insertions\n            | (i, j) => {\n                let source_char = table.source.nth(i - 1);\n                let target_char = table.target.nth(j - 1);\n\n                if source_char == target_char {\n                    // Characters match, no edit needed\n                    min_edit_distance_rec(table, i - 1, j - 1)\n                } else {\n                    // Characters don't match, try both operations\n                    let delete_cost = min_edit_distance_rec(table, i - 1, j);\n                    let insert_cost = min_edit_distance_rec(table, i, j - 1);\n\n                    1 + std::cmp::min(delete_cost, insert_cost)\n                }\n            }\n        };\n\n        // Memoize result\n        table.memo.insert((i, j), result);\n        result\n    }"
  },
  {
    "id": 1341,
    "function": "new",
    "file": "Chap49/MinEditDistStPer.rs",
    "lines": "23-26",
    "spec_strength": "",
    "snippet": "        /// Create new minimum edit distance solver\n        fn new()                                                                -> Self\n        where\n            T: Default;"
  },
  {
    "id": 1342,
    "function": "from_sequences",
    "file": "Chap49/MinEditDistStPer.rs",
    "lines": "28-29",
    "spec_strength": "",
    "snippet": "        /// Create from source and target sequences\n        fn from_sequences(source: ArraySeqStPerS<T>, target: ArraySeqStPerS<T>) -> Self;"
  },
  {
    "id": 1343,
    "function": "min_edit_distance",
    "file": "Chap49/MinEditDistStPer.rs",
    "lines": "31-33",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(|S|×|T|), Span Θ(|S|+|T|)\n        /// - Claude-Opus-4.6: Work Θ(|S|×|T|), Span Θ(|S|×|T|) — sequential, span equals work\n        fn min_edit_distance(&self)                                             -> usize;"
  },
  {
    "id": 1344,
    "function": "source",
    "file": "Chap49/MinEditDistStPer.rs",
    "lines": "35-36",
    "spec_strength": "",
    "snippet": "        /// Get the source sequence\n        fn source(&self)                                                        -> &ArraySeqStPerS<T>;"
  },
  {
    "id": 1345,
    "function": "target",
    "file": "Chap49/MinEditDistStPer.rs",
    "lines": "38-39",
    "spec_strength": "",
    "snippet": "        /// Get the target sequence\n        fn target(&self)                                                        -> &ArraySeqStPerS<T>;"
  },
  {
    "id": 1346,
    "function": "memo_size",
    "file": "Chap49/MinEditDistStPer.rs",
    "lines": "41-42",
    "spec_strength": "",
    "snippet": "        /// Get memoization table size\n        fn memo_size(&self)                                                     -> usize;"
  },
  {
    "id": 1347,
    "function": "min_edit_distance_rec",
    "file": "Chap49/MinEditDistStPer.rs",
    "lines": "45-76",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work Θ(|S|×|T|), Span Θ(|S|+|T|)\n    /// - Claude-Opus-4.6: Work Θ(|S|×|T|), Span Θ(|S|×|T|) — sequential memoized recursion\n    fn min_edit_distance_rec<T: StT>(table: &mut MinEditDistStPerS<T>, i: usize, j: usize) -> usize {\n        // Check memo first\n        if let Some(&result) = table.memo.get(&(i, j)) {\n            return result;\n        }\n\n        let result = match (i, j) {\n            | (i, 0) => i, // Base case: need i deletions\n            | (0, j) => j, // Base case: need j insertions\n            | (i, j) => {\n                let source_char = table.source.nth(i - 1);\n                let target_char = table.target.nth(j - 1);\n\n                if source_char == target_char {\n                    // Characters match, no edit needed\n                    min_edit_distance_rec(table, i - 1, j - 1)\n                } else {\n                    // Characters don't match, try both operations\n                    let delete_cost = min_edit_distance_rec(table, i - 1, j);\n                    let insert_cost = min_edit_distance_rec(table, i, j - 1);\n\n                    1 + std::cmp::min(delete_cost, insert_cost)\n                }\n            }\n        };\n\n        // Memoize result\n        table.memo.insert((i, j), result);\n        result\n    }"
  },
  {
    "id": 1348,
    "function": "new",
    "file": "Chap49/SubsetSumMtEph.rs",
    "lines": "23-26",
    "spec_strength": "",
    "snippet": "        /// Create new subset sum solver\n        fn new()                                      -> Self\n        where\n            T: Default;"
  },
  {
    "id": 1349,
    "function": "from_multiset",
    "file": "Chap49/SubsetSumMtEph.rs",
    "lines": "28-29",
    "spec_strength": "",
    "snippet": "        /// Create from multiset\n        fn from_multiset(multiset: ArraySeqMtEphS<T>) -> Self;"
  },
  {
    "id": 1350,
    "function": "subset_sum",
    "file": "Chap49/SubsetSumMtEph.rs",
    "lines": "31-35",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(k×|S|), Span Θ(|S|)\n        /// - Claude-Opus-4.6: Work Θ(k×|S|), Span Θ(|S|) — agrees with APAS; thread::spawn on both branches\n        fn subset_sum(&mut self, target: i32)         -> bool\n        where\n            T: Into<i32> + Copy + Send + Sync + 'static;"
  },
  {
    "id": 1351,
    "function": "multiset",
    "file": "Chap49/SubsetSumMtEph.rs",
    "lines": "37-38",
    "spec_strength": "",
    "snippet": "        /// Get the multiset\n        fn multiset(&self)                            -> &ArraySeqMtEphS<T>;"
  },
  {
    "id": 1352,
    "function": "multiset_mut",
    "file": "Chap49/SubsetSumMtEph.rs",
    "lines": "40-41",
    "spec_strength": "",
    "snippet": "        /// Get mutable multiset (ephemeral allows mutation)\n        fn multiset_mut(&mut self)                    -> &mut ArraySeqMtEphS<T>;"
  },
  {
    "id": 1353,
    "function": "set",
    "file": "Chap49/SubsetSumMtEph.rs",
    "lines": "43-44",
    "spec_strength": "",
    "snippet": "        /// Set element at index (ephemeral mutation)\n        fn set(&mut self, index: usize, value: T);"
  },
  {
    "id": 1354,
    "function": "clear_memo",
    "file": "Chap49/SubsetSumMtEph.rs",
    "lines": "46-47",
    "spec_strength": "",
    "snippet": "        /// Clear memoization table\n        fn clear_memo(&mut self);"
  },
  {
    "id": 1355,
    "function": "memo_size",
    "file": "Chap49/SubsetSumMtEph.rs",
    "lines": "49-50",
    "spec_strength": "",
    "snippet": "        /// Get memoization table size\n        fn memo_size(&self)                           -> usize;"
  },
  {
    "id": 1356,
    "function": "subset_sum_rec",
    "file": "Chap49/SubsetSumMtEph.rs",
    "lines": "53-100",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work Θ(k×|S|), Span Θ(|S|)\n    /// - Claude-Opus-4.6: Work Θ(k×|S|), Span Θ(|S|) — parallel fork on include/exclude branches\n    fn subset_sum_rec<T: MtVal + Into<i32> + Copy + Send + Sync + 'static>(\n        table: &SubsetSumMtEphS<T>,\n        i: usize,\n        j: i32,\n    ) -> bool {\n        // Check memo first (thread-safe)\n        {\n            let memo_guard = table.memo.lock().unwrap();\n            if let Some(&result) = memo_guard.get(&(i, j)) {\n                return result;\n            }\n        }\n\n        let result = match (i, j) {\n            | (_, 0) => true,  // Base case: target sum is 0\n            | (0, _) => false, // Base case: no elements left, target > 0\n            | (i, j) => {\n                let element_value: i32 = (*table.multiset.nth(i - 1)).clone().into();\n                if element_value > j {\n                    // Element too large, skip it\n                    subset_sum_rec(table, i - 1, j)\n                } else {\n                    // Parallel evaluation of both branches\n                    let table_clone1 = table.clone();\n                    let table_clone2 = table.clone();\n\n                    let handle1 = thread::spawn(move || subset_sum_rec(&table_clone1, i - 1, j - element_value));\n\n                    let handle2 = thread::spawn(move || subset_sum_rec(&table_clone2, i - 1, j));\n\n                    let result1 = handle1.join().unwrap();\n                    let result2 = handle2.join().unwrap();\n\n                    result1 || result2\n                }\n            }\n        };\n\n        // Memoize result (thread-safe)\n        {\n            let mut memo_guard = table.memo.lock().unwrap();\n            memo_guard.insert((i, j), result);\n        }\n\n        result\n    }"
  },
  {
    "id": 1357,
    "function": "eq",
    "file": "Chap49/SubsetSumMtEph.rs",
    "lines": "161",
    "spec_strength": "",
    "snippet": "        fn eq(&self, other: &Self) -> bool { self.multiset == other.multiset }"
  },
  {
    "id": 1358,
    "function": "new",
    "file": "Chap49/SubsetSumMtPer.rs",
    "lines": "22-25",
    "spec_strength": "",
    "snippet": "        /// Create new subset sum solver\n        fn new()                                      -> Self\n        where\n            T: Default;"
  },
  {
    "id": 1359,
    "function": "from_multiset",
    "file": "Chap49/SubsetSumMtPer.rs",
    "lines": "27-28",
    "spec_strength": "",
    "snippet": "        /// Create from multiset\n        fn from_multiset(multiset: ArraySeqMtPerS<T>) -> Self;"
  },
  {
    "id": 1360,
    "function": "subset_sum",
    "file": "Chap49/SubsetSumMtPer.rs",
    "lines": "30-34",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(k×|S|), Span Θ(|S|)\n        /// - Claude-Opus-4.6: Work Θ(k×|S|), Span Θ(|S|) — agrees with APAS; thread::spawn on both branches\n        fn subset_sum(&self, target: i32)             -> bool\n        where\n            T: Into<i32> + Copy + Send + Sync + 'static;"
  },
  {
    "id": 1361,
    "function": "multiset",
    "file": "Chap49/SubsetSumMtPer.rs",
    "lines": "36-37",
    "spec_strength": "",
    "snippet": "        /// Get the multiset\n        fn multiset(&self)                            -> &ArraySeqMtPerS<T>;"
  },
  {
    "id": 1362,
    "function": "memo_size",
    "file": "Chap49/SubsetSumMtPer.rs",
    "lines": "39-40",
    "spec_strength": "",
    "snippet": "        /// Get memoization table size\n        fn memo_size(&self)                           -> usize;"
  },
  {
    "id": 1363,
    "function": "subset_sum_rec",
    "file": "Chap49/SubsetSumMtPer.rs",
    "lines": "43-90",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work Θ(k×|S|), Span Θ(|S|)\n    /// - Claude-Opus-4.6: Work Θ(k×|S|), Span Θ(|S|) — parallel fork on include/exclude branches\n    fn subset_sum_rec<T: MtVal + Into<i32> + Copy + Send + Sync + 'static>(\n        table: &SubsetSumMtPerS<T>,\n        i: usize,\n        j: i32,\n    ) -> bool {\n        // Check memo first (thread-safe)\n        {\n            let memo_guard = table.memo.lock().unwrap();\n            if let Some(&result) = memo_guard.get(&(i, j)) {\n                return result;\n            }\n        }\n\n        let result = match (i, j) {\n            | (_, 0) => true,  // Base case: target sum is 0\n            | (0, _) => false, // Base case: no elements left, target > 0\n            | (i, j) => {\n                let element_value: i32 = (*table.multiset.nth(i - 1)).into();\n                if element_value > j {\n                    // Element too large, skip it\n                    subset_sum_rec(table, i - 1, j)\n                } else {\n                    // Parallel evaluation of both branches\n                    let table_clone1 = table.clone();\n                    let table_clone2 = table.clone();\n\n                    let handle1 = thread::spawn(move || subset_sum_rec(&table_clone1, i - 1, j - element_value));\n\n                    let handle2 = thread::spawn(move || subset_sum_rec(&table_clone2, i - 1, j));\n\n                    let result1 = handle1.join().unwrap();\n                    let result2 = handle2.join().unwrap();\n\n                    result1 || result2\n                }\n            }\n        };\n\n        // Memoize result (thread-safe)\n        {\n            let mut memo_guard = table.memo.lock().unwrap();\n            memo_guard.insert((i, j), result);\n        }\n\n        result\n    }"
  },
  {
    "id": 1364,
    "function": "eq",
    "file": "Chap49/SubsetSumMtPer.rs",
    "lines": "137",
    "spec_strength": "",
    "snippet": "        fn eq(&self, other: &Self) -> bool { self.multiset == other.multiset }"
  },
  {
    "id": 1365,
    "function": "new",
    "file": "Chap49/SubsetSumStEph.rs",
    "lines": "21-24",
    "spec_strength": "",
    "snippet": "        /// Create new subset sum solver\n        fn new()                                      -> Self\n        where\n            T: Default;"
  },
  {
    "id": 1366,
    "function": "from_multiset",
    "file": "Chap49/SubsetSumStEph.rs",
    "lines": "26-27",
    "spec_strength": "",
    "snippet": "        /// Create from multiset\n        fn from_multiset(multiset: ArraySeqStEphS<T>) -> Self;"
  },
  {
    "id": 1367,
    "function": "subset_sum",
    "file": "Chap49/SubsetSumStEph.rs",
    "lines": "29-33",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(k×|S|), Span Θ(|S|)\n        /// - Claude-Opus-4.6: Work Θ(k×|S|), Span Θ(k×|S|) — sequential, span equals work\n        fn subset_sum(&mut self, target: i32)         -> bool\n        where\n            T: Into<i32> + Copy;"
  },
  {
    "id": 1368,
    "function": "multiset",
    "file": "Chap49/SubsetSumStEph.rs",
    "lines": "35-36",
    "spec_strength": "",
    "snippet": "        /// Get the multiset\n        fn multiset(&self)                            -> &ArraySeqStEphS<T>;"
  },
  {
    "id": 1369,
    "function": "multiset_mut",
    "file": "Chap49/SubsetSumStEph.rs",
    "lines": "38-39",
    "spec_strength": "",
    "snippet": "        /// Get mutable multiset (ephemeral allows mutation)\n        fn multiset_mut(&mut self)                    -> &mut ArraySeqStEphS<T>;"
  },
  {
    "id": 1370,
    "function": "set",
    "file": "Chap49/SubsetSumStEph.rs",
    "lines": "41-42",
    "spec_strength": "",
    "snippet": "        /// Set element at index (ephemeral mutation)\n        fn set(&mut self, index: usize, value: T);"
  },
  {
    "id": 1371,
    "function": "clear_memo",
    "file": "Chap49/SubsetSumStEph.rs",
    "lines": "44-45",
    "spec_strength": "",
    "snippet": "        /// Clear memoization table\n        fn clear_memo(&mut self);"
  },
  {
    "id": 1372,
    "function": "memo_size",
    "file": "Chap49/SubsetSumStEph.rs",
    "lines": "47-48",
    "spec_strength": "",
    "snippet": "        /// Get memoization table size\n        fn memo_size(&self)                           -> usize;"
  },
  {
    "id": 1373,
    "function": "subset_sum_rec",
    "file": "Chap49/SubsetSumStEph.rs",
    "lines": "51-77",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work Θ(k×|S|), Span Θ(|S|)\n    /// - Claude-Opus-4.6: Work Θ(k×|S|), Span Θ(k×|S|) — sequential memoized recursion\n    fn subset_sum_rec<T: StT + Into<i32> + Copy>(table: &mut SubsetSumStEphS<T>, i: usize, j: i32) -> bool {\n        // Check memo first\n        if let Some(&result) = table.memo.get(&(i, j)) {\n            return result;\n        }\n\n        let result = match (i, j) {\n            | (_, 0) => true,  // Base case: target sum is 0\n            | (0, _) => false, // Base case: no elements left, target > 0\n            | (i, j) => {\n                let element_value: i32 = (*table.multiset.nth(i - 1)).into();\n                if element_value > j {\n                    // Element too large, skip it\n                    subset_sum_rec(table, i - 1, j)\n                } else {\n                    // Try both including and excluding the element\n                    subset_sum_rec(table, i - 1, j - element_value) || subset_sum_rec(table, i - 1, j)\n                }\n            }\n        };\n\n        // Memoize result\n        table.memo.insert((i, j), result);\n        result\n    }"
  },
  {
    "id": 1374,
    "function": "new",
    "file": "Chap49/SubsetSumStPer.rs",
    "lines": "21-24",
    "spec_strength": "",
    "snippet": "        /// Create new subset sum solver\n        fn new()                                      -> Self\n        where\n            T: Default;"
  },
  {
    "id": 1375,
    "function": "from_multiset",
    "file": "Chap49/SubsetSumStPer.rs",
    "lines": "26-27",
    "spec_strength": "",
    "snippet": "        /// Create from multiset\n        fn from_multiset(multiset: ArraySeqStPerS<T>) -> Self;"
  },
  {
    "id": 1376,
    "function": "subset_sum",
    "file": "Chap49/SubsetSumStPer.rs",
    "lines": "29-33",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(k×|S|), Span Θ(|S|)\n        /// - Claude-Opus-4.6: Work Θ(k×|S|), Span Θ(k×|S|) — sequential, span equals work\n        fn subset_sum(&self, target: i32)             -> bool\n        where\n            T: Into<i32> + Copy;"
  },
  {
    "id": 1377,
    "function": "multiset",
    "file": "Chap49/SubsetSumStPer.rs",
    "lines": "35-36",
    "spec_strength": "",
    "snippet": "        /// Get the multiset\n        fn multiset(&self)                            -> &ArraySeqStPerS<T>;"
  },
  {
    "id": 1378,
    "function": "memo_size",
    "file": "Chap49/SubsetSumStPer.rs",
    "lines": "38-39",
    "spec_strength": "",
    "snippet": "        /// Get memoization table size\n        fn memo_size(&self)                           -> usize;"
  },
  {
    "id": 1379,
    "function": "subset_sum_rec",
    "file": "Chap49/SubsetSumStPer.rs",
    "lines": "42-68",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work Θ(k×|S|), Span Θ(|S|)\n    /// - Claude-Opus-4.6: Work Θ(k×|S|), Span Θ(k×|S|) — sequential memoized recursion\n    fn subset_sum_rec<T: StT + Into<i32> + Copy>(table: &mut SubsetSumStPerS<T>, i: usize, j: i32) -> bool {\n        // Check memo first\n        if let Some(&result) = table.memo.get(&(i, j)) {\n            return result;\n        }\n\n        let result = match (i, j) {\n            | (_, 0) => true,  // Base case: target sum is 0\n            | (0, _) => false, // Base case: no elements left, target > 0\n            | (i, j) => {\n                let element_value: i32 = (*table.multiset.nth(i - 1)).into();\n                if element_value > j {\n                    // Element too large, skip it\n                    subset_sum_rec(table, i - 1, j)\n                } else {\n                    // Try both including and excluding the element\n                    subset_sum_rec(table, i - 1, j - element_value) || subset_sum_rec(table, i - 1, j)\n                }\n            }\n        };\n\n        // Memoize result\n        table.memo.insert((i, j), result);\n        result\n    }"
  },
  {
    "id": 1380,
    "function": "new",
    "file": "Chap50/MatrixChainMtEph.rs",
    "lines": "29-30",
    "spec_strength": "",
    "snippet": "        /// Create new matrix chain solver\n        fn new()                                              -> Self;"
  },
  {
    "id": 1381,
    "function": "from_dimensions",
    "file": "Chap50/MatrixChainMtEph.rs",
    "lines": "32-33",
    "spec_strength": "",
    "snippet": "        /// Create from matrix dimensions\n        fn from_dimensions(dimensions: Vec<MatrixDim>)        -> Self;"
  },
  {
    "id": 1382,
    "function": "from_dim_pairs",
    "file": "Chap50/MatrixChainMtEph.rs",
    "lines": "35-36",
    "spec_strength": "",
    "snippet": "        /// Create from dimension pairs (rows, cols)\n        fn from_dim_pairs(dim_pairs: Vec<Pair<usize, usize>>) -> Self;"
  },
  {
    "id": 1383,
    "function": "optimal_cost",
    "file": "Chap50/MatrixChainMtEph.rs",
    "lines": "38-40",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(n³), Span Θ(n log n)\n        /// Claude-Opus-4.6: Work O(n³), Span O(n log n)\n        fn optimal_cost(&mut self)                            -> usize;"
  },
  {
    "id": 1384,
    "function": "dimensions",
    "file": "Chap50/MatrixChainMtEph.rs",
    "lines": "42-43",
    "spec_strength": "",
    "snippet": "        /// Get a copy of the matrix dimensions (thread-safe)\n        fn dimensions(&self)                                  -> Vec<MatrixDim>;"
  },
  {
    "id": 1385,
    "function": "set_dimension",
    "file": "Chap50/MatrixChainMtEph.rs",
    "lines": "45-46",
    "spec_strength": "",
    "snippet": "        /// Set matrix dimension at index\n        fn set_dimension(&mut self, index: usize, dim: MatrixDim);"
  },
  {
    "id": 1386,
    "function": "update_dimension",
    "file": "Chap50/MatrixChainMtEph.rs",
    "lines": "48-49",
    "spec_strength": "",
    "snippet": "        /// Update matrix dimensions\n        fn update_dimension(&mut self, index: usize, rows: usize, cols: usize);"
  },
  {
    "id": 1387,
    "function": "num_matrices",
    "file": "Chap50/MatrixChainMtEph.rs",
    "lines": "51-52",
    "spec_strength": "",
    "snippet": "        /// Get number of matrices\n        fn num_matrices(&self)                                -> usize;"
  },
  {
    "id": 1388,
    "function": "clear_memo",
    "file": "Chap50/MatrixChainMtEph.rs",
    "lines": "54-55",
    "spec_strength": "",
    "snippet": "        /// Clear memoization table\n        fn clear_memo(&mut self);"
  },
  {
    "id": 1389,
    "function": "memo_size",
    "file": "Chap50/MatrixChainMtEph.rs",
    "lines": "57-58",
    "spec_strength": "",
    "snippet": "        /// Get memoization table size\n        fn memo_size(&self)                                   -> usize;"
  },
  {
    "id": 1390,
    "function": "multiply_cost",
    "file": "Chap50/MatrixChainMtEph.rs",
    "lines": "62-70",
    "spec_strength": "",
    "snippet": "        /// Calculate cost of multiplying matrices from i to j with split at k\n        /// Cost = rows[i] * cols[k] * cols[j] (scalar multiplications)\n        fn multiply_cost(&self, i: usize, k: usize, j: usize) -> usize {\n            let dimensions_guard = self.dimensions.lock().unwrap();\n            let left_rows = dimensions_guard[i].rows;\n            let split_cols = dimensions_guard[k].cols;\n            let right_cols = dimensions_guard[j].cols;\n            left_rows * split_cols * right_cols\n        }"
  },
  {
    "id": 1391,
    "function": "parallel_min_reduction",
    "file": "Chap50/MatrixChainMtEph.rs",
    "lines": "72-98",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(n), Span Θ(log n)\n        /// Claude-Opus-4.6 Work: O(n) - n comparisons\n        /// Claude-Opus-4.6 Span: O(log n) - parallel reduction tree\n        fn parallel_min_reduction(&self, costs: Vec<usize>) -> usize {\n            if costs.is_empty() {\n                return 0;\n            }\n            if costs.len() == 1 {\n                return costs[0];\n            }\n\n            let mid = costs.len() / 2;\n            let left_costs = costs[..mid].to_vec();\n            let right_costs = costs[mid..].to_vec();\n\n            let self_clone1 = self.clone();\n            let self_clone2 = self.clone();\n\n            let handle1 = thread::spawn(move || self_clone1.parallel_min_reduction(left_costs));\n\n            let handle2 = thread::spawn(move || self_clone2.parallel_min_reduction(right_costs));\n\n            let left_min = handle1.join().unwrap();\n            let right_min = handle2.join().unwrap();\n\n            left_min.min(right_min)\n        }"
  },
  {
    "id": 1392,
    "function": "matrix_chain_rec",
    "file": "Chap50/MatrixChainMtEph.rs",
    "lines": "100-135",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(n³), Span Θ(n log n)\n        /// Claude-Opus-4.6 Work: O(n³) - O(n²) subproblems, each O(n) work\n        /// Claude-Opus-4.6 Span: O(n log n) - recursion depth O(n), each level O(log n) parallel reduction\n        fn matrix_chain_rec(&self, i: usize, j: usize) -> usize {\n            // Check memo first (thread-safe)\n            {\n                let memo_guard = self.memo.lock().unwrap();\n                if let Some(&result) = memo_guard.get(&(i, j)) {\n                    return result;\n                }\n            }\n\n            let result = if i == j {\n                0 // Base case: single matrix, no multiplication needed\n            } else {\n                // Compute costs for each possible split in parallel\n                let costs = (i..j)\n                    .map(|k| {\n                        let left_cost = self.matrix_chain_rec(i, k);\n                        let right_cost = self.matrix_chain_rec(k + 1, j);\n                        let split_cost = self.multiply_cost(i, k, j);\n                        left_cost + right_cost + split_cost\n                    }).collect::<Vec<usize>>();\n\n                // Use parallel reduction to find minimum\n                self.parallel_min_reduction(costs)\n            };\n\n            // Memoize result (thread-safe)\n            {\n                let mut memo_guard = self.memo.lock().unwrap();\n                memo_guard.insert((i, j), result);\n            }\n\n            result\n        }"
  },
  {
    "id": 1393,
    "function": "eq",
    "file": "Chap50/MatrixChainMtEph.rs",
    "lines": "229-234",
    "spec_strength": "",
    "snippet": "        fn eq(&self, other: &Self) -> bool {\n            // Compare the contents of the Arc<Mutex<Vec>>\n            let self_dims = self.dimensions.lock().unwrap();\n            let other_dims = other.dimensions.lock().unwrap();\n            *self_dims == *other_dims\n        }"
  },
  {
    "id": 1394,
    "function": "new",
    "file": "Chap50/MatrixChainMtPer.rs",
    "lines": "31-32",
    "spec_strength": "",
    "snippet": "        /// Create new matrix chain solver\n        fn new()                                              -> Self;"
  },
  {
    "id": 1395,
    "function": "from_dimensions",
    "file": "Chap50/MatrixChainMtPer.rs",
    "lines": "34-35",
    "spec_strength": "",
    "snippet": "        /// Create from matrix dimensions\n        fn from_dimensions(dimensions: Vec<MatrixDim>)        -> Self;"
  },
  {
    "id": 1396,
    "function": "from_dim_pairs",
    "file": "Chap50/MatrixChainMtPer.rs",
    "lines": "37-38",
    "spec_strength": "",
    "snippet": "        /// Create from dimension pairs (rows, cols)\n        fn from_dim_pairs(dim_pairs: Vec<Pair<usize, usize>>) -> Self;"
  },
  {
    "id": 1397,
    "function": "optimal_cost",
    "file": "Chap50/MatrixChainMtPer.rs",
    "lines": "40-42",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(n³), Span Θ(n log n)\n        /// Claude-Opus-4.6: Work O(n³), Span O(n log n)\n        fn optimal_cost(&self)                                -> usize;"
  },
  {
    "id": 1398,
    "function": "dimensions",
    "file": "Chap50/MatrixChainMtPer.rs",
    "lines": "44-45",
    "spec_strength": "",
    "snippet": "        /// Get the matrix dimensions\n        fn dimensions(&self)                                  -> &Arc<Vec<MatrixDim>>;"
  },
  {
    "id": 1399,
    "function": "num_matrices",
    "file": "Chap50/MatrixChainMtPer.rs",
    "lines": "47-48",
    "spec_strength": "",
    "snippet": "        /// Get number of matrices\n        fn num_matrices(&self)                                -> usize;"
  },
  {
    "id": 1400,
    "function": "memo_size",
    "file": "Chap50/MatrixChainMtPer.rs",
    "lines": "50-51",
    "spec_strength": "",
    "snippet": "        /// Get memoization table size\n        fn memo_size(&self)                                   -> usize;"
  },
  {
    "id": 1401,
    "function": "multiply_cost",
    "file": "Chap50/MatrixChainMtPer.rs",
    "lines": "55-62",
    "spec_strength": "",
    "snippet": "        /// Calculate cost of multiplying matrices from i to j with split at k\n        /// Cost = rows[i] * cols[k] * cols[j] (scalar multiplications)\n        fn multiply_cost(&self, i: usize, k: usize, j: usize) -> usize {\n            let left_rows = self.dimensions[i].rows;\n            let split_cols = self.dimensions[k].cols;\n            let right_cols = self.dimensions[j].cols;\n            left_rows * split_cols * right_cols\n        }"
  },
  {
    "id": 1402,
    "function": "parallel_min_reduction",
    "file": "Chap50/MatrixChainMtPer.rs",
    "lines": "64-90",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(n), Span Θ(log n)\n        /// Claude-Opus-4.6 Work: O(n) - n comparisons\n        /// Claude-Opus-4.6 Span: O(log n) - parallel reduction tree\n        fn parallel_min_reduction(&self, costs: Vec<usize>) -> usize {\n            if costs.is_empty() {\n                return 0;\n            }\n            if costs.len() == 1 {\n                return costs[0];\n            }\n\n            let mid = costs.len() / 2;\n            let left_costs = costs[..mid].to_vec();\n            let right_costs = costs[mid..].to_vec();\n\n            let self_clone1 = self.clone();\n            let self_clone2 = self.clone();\n\n            let handle1 = thread::spawn(move || self_clone1.parallel_min_reduction(left_costs));\n\n            let handle2 = thread::spawn(move || self_clone2.parallel_min_reduction(right_costs));\n\n            let left_min = handle1.join().unwrap();\n            let right_min = handle2.join().unwrap();\n\n            left_min.min(right_min)\n        }"
  },
  {
    "id": 1403,
    "function": "matrix_chain_rec",
    "file": "Chap50/MatrixChainMtPer.rs",
    "lines": "92-127",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(n³), Span Θ(n log n)\n        /// Claude-Opus-4.6 Work: O(n³) - O(n²) subproblems, each O(n) work\n        /// Claude-Opus-4.6 Span: O(n log n) - recursion depth O(n), each level O(log n) parallel reduction\n        fn matrix_chain_rec(&self, i: usize, j: usize) -> usize {\n            // Check memo first (thread-safe)\n            {\n                let memo_guard = self.memo.lock().unwrap();\n                if let Some(&result) = memo_guard.get(&(i, j)) {\n                    return result;\n                }\n            }\n\n            let result = if i == j {\n                0 // Base case: single matrix, no multiplication needed\n            } else {\n                // Compute costs for each possible split in parallel\n                let costs = (i..j)\n                    .map(|k| {\n                        let left_cost = self.matrix_chain_rec(i, k);\n                        let right_cost = self.matrix_chain_rec(k + 1, j);\n                        let split_cost = self.multiply_cost(i, k, j);\n                        left_cost + right_cost + split_cost\n                    }).collect::<Vec<usize>>();\n\n                // Use parallel reduction to find minimum\n                self.parallel_min_reduction(costs)\n            };\n\n            // Memoize result (thread-safe)\n            {\n                let mut memo_guard = self.memo.lock().unwrap();\n                memo_guard.insert((i, j), result);\n            }\n\n            result\n        }"
  },
  {
    "id": 1404,
    "function": "eq",
    "file": "Chap50/MatrixChainMtPer.rs",
    "lines": "185",
    "spec_strength": "",
    "snippet": "        fn eq(&self, other: &Self) -> bool { self.dimensions == other.dimensions }"
  },
  {
    "id": 1405,
    "function": "new",
    "file": "Chap50/MatrixChainStEph.rs",
    "lines": "29-30",
    "spec_strength": "",
    "snippet": "        /// Create new matrix chain solver\n        fn new()                                              -> Self;"
  },
  {
    "id": 1406,
    "function": "from_dimensions",
    "file": "Chap50/MatrixChainStEph.rs",
    "lines": "32-33",
    "spec_strength": "",
    "snippet": "        /// Create from matrix dimensions\n        fn from_dimensions(dimensions: Vec<MatrixDim>)        -> Self;"
  },
  {
    "id": 1407,
    "function": "from_dim_pairs",
    "file": "Chap50/MatrixChainStEph.rs",
    "lines": "35-36",
    "spec_strength": "",
    "snippet": "        /// Create from dimension pairs (rows, cols)\n        fn from_dim_pairs(dim_pairs: Vec<Pair<usize, usize>>) -> Self;"
  },
  {
    "id": 1408,
    "function": "optimal_cost",
    "file": "Chap50/MatrixChainStEph.rs",
    "lines": "38-40",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(n³), Span Θ(n²)\n        /// Claude-Opus-4.6: Work O(n³), Span O(n²)\n        fn optimal_cost(&mut self)                            -> usize;"
  },
  {
    "id": 1409,
    "function": "dimensions",
    "file": "Chap50/MatrixChainStEph.rs",
    "lines": "42-43",
    "spec_strength": "",
    "snippet": "        /// Get the matrix dimensions\n        fn dimensions(&self)                                  -> &Vec<MatrixDim>;"
  },
  {
    "id": 1410,
    "function": "dimensions_mut",
    "file": "Chap50/MatrixChainStEph.rs",
    "lines": "45-46",
    "spec_strength": "",
    "snippet": "        /// Get mutable dimensions (ephemeral allows mutation)\n        fn dimensions_mut(&mut self)                          -> &mut Vec<MatrixDim>;"
  },
  {
    "id": 1411,
    "function": "set_dimension",
    "file": "Chap50/MatrixChainStEph.rs",
    "lines": "48-49",
    "spec_strength": "",
    "snippet": "        /// Set matrix dimension at index\n        fn set_dimension(&mut self, index: usize, dim: MatrixDim);"
  },
  {
    "id": 1412,
    "function": "update_dimension",
    "file": "Chap50/MatrixChainStEph.rs",
    "lines": "51-52",
    "spec_strength": "",
    "snippet": "        /// Update matrix dimensions\n        fn update_dimension(&mut self, index: usize, rows: usize, cols: usize);"
  },
  {
    "id": 1413,
    "function": "num_matrices",
    "file": "Chap50/MatrixChainStEph.rs",
    "lines": "54-55",
    "spec_strength": "",
    "snippet": "        /// Get number of matrices\n        fn num_matrices(&self)                                -> usize;"
  },
  {
    "id": 1414,
    "function": "clear_memo",
    "file": "Chap50/MatrixChainStEph.rs",
    "lines": "57-58",
    "spec_strength": "",
    "snippet": "        /// Clear memoization table\n        fn clear_memo(&mut self);"
  },
  {
    "id": 1415,
    "function": "memo_size",
    "file": "Chap50/MatrixChainStEph.rs",
    "lines": "60-61",
    "spec_strength": "",
    "snippet": "        /// Get memoization table size\n        fn memo_size(&self)                                   -> usize;"
  },
  {
    "id": 1416,
    "function": "multiply_cost",
    "file": "Chap50/MatrixChainStEph.rs",
    "lines": "65-72",
    "spec_strength": "",
    "snippet": "        /// Calculate cost of multiplying matrices from i to j with split at k\n        /// Cost = rows[i] * cols[k] * cols[j] (scalar multiplications)\n        fn multiply_cost(&self, i: usize, k: usize, j: usize) -> usize {\n            let left_rows = self.dimensions[i].rows;\n            let split_cols = self.dimensions[k].cols;\n            let right_cols = self.dimensions[j].cols;\n            left_rows * split_cols * right_cols\n        }"
  },
  {
    "id": 1417,
    "function": "matrix_chain_rec",
    "file": "Chap50/MatrixChainStEph.rs",
    "lines": "74-101",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(n³), Span Θ(n²)\n        /// Claude-Opus-4.6 Work: O(n³) - O(n²) subproblems, each O(n) work\n        /// Claude-Opus-4.6 Span: O(n²) - recursion depth O(n), each level O(n) work\n        fn matrix_chain_rec(&mut self, i: usize, j: usize) -> usize {\n            // Check memo first\n            if let Some(&result) = self.memo.get(&(i, j)) {\n                return result;\n            }\n\n            let result = if i == j {\n                0 // Base case: single matrix, no multiplication needed\n            } else {\n                // Try each possible split point and find minimum cost\n                (i..j)\n                    .map(|k| {\n                        let left_cost = self.matrix_chain_rec(i, k);\n                        let right_cost = self.matrix_chain_rec(k + 1, j);\n                        let split_cost = self.multiply_cost(i, k, j);\n                        left_cost + right_cost + split_cost\n                    })\n                    .min()\n                    .unwrap_or(0)\n            };\n\n            // Memoize result\n            self.memo.insert((i, j), result);\n            result\n        }"
  },
  {
    "id": 1418,
    "function": "new",
    "file": "Chap50/MatrixChainStPer.rs",
    "lines": "29-30",
    "spec_strength": "",
    "snippet": "        /// Create new matrix chain solver\n        fn new()                                              -> Self;"
  },
  {
    "id": 1419,
    "function": "from_dimensions",
    "file": "Chap50/MatrixChainStPer.rs",
    "lines": "32-33",
    "spec_strength": "",
    "snippet": "        /// Create from matrix dimensions\n        fn from_dimensions(dimensions: Vec<MatrixDim>)        -> Self;"
  },
  {
    "id": 1420,
    "function": "from_dim_pairs",
    "file": "Chap50/MatrixChainStPer.rs",
    "lines": "35-36",
    "spec_strength": "",
    "snippet": "        /// Create from dimension pairs (rows, cols)\n        fn from_dim_pairs(dim_pairs: Vec<Pair<usize, usize>>) -> Self;"
  },
  {
    "id": 1421,
    "function": "optimal_cost",
    "file": "Chap50/MatrixChainStPer.rs",
    "lines": "38-40",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(n³), Span Θ(n²)\n        /// Claude-Opus-4.6: Work O(n³), Span O(n²)\n        fn optimal_cost(&self)                                -> usize;"
  },
  {
    "id": 1422,
    "function": "dimensions",
    "file": "Chap50/MatrixChainStPer.rs",
    "lines": "42-43",
    "spec_strength": "",
    "snippet": "        /// Get the matrix dimensions\n        fn dimensions(&self)                                  -> &Vec<MatrixDim>;"
  },
  {
    "id": 1423,
    "function": "num_matrices",
    "file": "Chap50/MatrixChainStPer.rs",
    "lines": "45-46",
    "spec_strength": "",
    "snippet": "        /// Get number of matrices\n        fn num_matrices(&self)                                -> usize;"
  },
  {
    "id": 1424,
    "function": "memo_size",
    "file": "Chap50/MatrixChainStPer.rs",
    "lines": "48-49",
    "spec_strength": "",
    "snippet": "        /// Get memoization table size\n        fn memo_size(&self)                                   -> usize;"
  },
  {
    "id": 1425,
    "function": "multiply_cost",
    "file": "Chap50/MatrixChainStPer.rs",
    "lines": "53-60",
    "spec_strength": "",
    "snippet": "        /// Calculate cost of multiplying matrices from i to j with split at k\n        /// Cost = rows[i] * cols[k] * cols[j] (scalar multiplications)\n        fn multiply_cost(&self, i: usize, k: usize, j: usize) -> usize {\n            let left_rows = self.dimensions[i].rows;\n            let split_cols = self.dimensions[k].cols;\n            let right_cols = self.dimensions[j].cols;\n            left_rows * split_cols * right_cols\n        }"
  },
  {
    "id": 1426,
    "function": "matrix_chain_rec",
    "file": "Chap50/MatrixChainStPer.rs",
    "lines": "62-89",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(n³), Span Θ(n²)\n        /// Claude-Opus-4.6 Work: O(n³) - O(n²) subproblems, each O(n) work\n        /// Claude-Opus-4.6 Span: O(n²) - recursion depth O(n), each level O(n) work\n        fn matrix_chain_rec(&mut self, i: usize, j: usize) -> usize {\n            // Check memo first\n            if let Some(&result) = self.memo.get(&(i, j)) {\n                return result;\n            }\n\n            let result = if i == j {\n                0 // Base case: single matrix, no multiplication needed\n            } else {\n                // Try each possible split point and find minimum cost\n                (i..j)\n                    .map(|k| {\n                        let left_cost = self.matrix_chain_rec(i, k);\n                        let right_cost = self.matrix_chain_rec(k + 1, j);\n                        let split_cost = self.multiply_cost(i, k, j);\n                        left_cost + right_cost + split_cost\n                    })\n                    .min()\n                    .unwrap_or(0)\n            };\n\n            // Memoize result\n            self.memo.insert((i, j), result);\n            result\n        }"
  },
  {
    "id": 1427,
    "function": "new",
    "file": "Chap50/OptBinSearchTreeMtEph.rs",
    "lines": "30-31",
    "spec_strength": "",
    "snippet": "        /// Create new optimal BST solver\n        fn new()                                                  -> Self;"
  },
  {
    "id": 1428,
    "function": "from_keys_probs",
    "file": "Chap50/OptBinSearchTreeMtEph.rs",
    "lines": "33-34",
    "spec_strength": "",
    "snippet": "        /// Create from keys and probabilities\n        fn from_keys_probs(keys: Vec<T>, probs: Vec<Probability>) -> Self;"
  },
  {
    "id": 1429,
    "function": "from_key_probs",
    "file": "Chap50/OptBinSearchTreeMtEph.rs",
    "lines": "36-37",
    "spec_strength": "",
    "snippet": "        /// Create from key-probability pairs\n        fn from_key_probs(key_probs: Vec<KeyProb<T>>)             -> Self;"
  },
  {
    "id": 1430,
    "function": "optimal_cost",
    "file": "Chap50/OptBinSearchTreeMtEph.rs",
    "lines": "39-43",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(n³), Span Θ(n log n)\n        /// Claude-Opus-4.6: Work O(n³), Span O(n log n)\n        fn optimal_cost(&mut self)                                -> Probability\n        where\n            T: Send + Sync + 'static;"
  },
  {
    "id": 1431,
    "function": "keys",
    "file": "Chap50/OptBinSearchTreeMtEph.rs",
    "lines": "45-46",
    "spec_strength": "",
    "snippet": "        /// Get a copy of the keys with probabilities (thread-safe)\n        fn keys(&self)                                            -> Vec<KeyProb<T>>;"
  },
  {
    "id": 1432,
    "function": "set_key_prob",
    "file": "Chap50/OptBinSearchTreeMtEph.rs",
    "lines": "48-49",
    "spec_strength": "",
    "snippet": "        /// Set key-probability pair at index\n        fn set_key_prob(&mut self, index: usize, key_prob: KeyProb<T>);"
  },
  {
    "id": 1433,
    "function": "update_prob",
    "file": "Chap50/OptBinSearchTreeMtEph.rs",
    "lines": "51-52",
    "spec_strength": "",
    "snippet": "        /// Update probability for key at index\n        fn update_prob(&mut self, index: usize, prob: Probability);"
  },
  {
    "id": 1434,
    "function": "num_keys",
    "file": "Chap50/OptBinSearchTreeMtEph.rs",
    "lines": "54-55",
    "spec_strength": "",
    "snippet": "        /// Get number of keys\n        fn num_keys(&self)                                        -> usize;"
  },
  {
    "id": 1435,
    "function": "clear_memo",
    "file": "Chap50/OptBinSearchTreeMtEph.rs",
    "lines": "57-58",
    "spec_strength": "",
    "snippet": "        /// Clear memoization table\n        fn clear_memo(&mut self);"
  },
  {
    "id": 1436,
    "function": "memo_size",
    "file": "Chap50/OptBinSearchTreeMtEph.rs",
    "lines": "60-61",
    "spec_strength": "",
    "snippet": "        /// Get memoization table size\n        fn memo_size(&self)                                       -> usize;"
  },
  {
    "id": 1437,
    "function": "parallel_min_reduction",
    "file": "Chap50/OptBinSearchTreeMtEph.rs",
    "lines": "64-90",
    "spec_strength": "",
    "snippet": "    /// APAS: Work Θ(n), Span Θ(log n)\n    /// Claude-Opus-4.6 Work: O(n) - n comparisons\n    /// Claude-Opus-4.6 Span: O(log n) - parallel reduction tree\n    fn parallel_min_reduction<T: MtVal>(table: &OBSTMtEphS<T>, costs: Vec<Probability>) -> Probability {\n        if costs.is_empty() {\n            return Probability::infinity();\n        }\n        if costs.len() == 1 {\n            return costs[0];\n        }\n\n        let mid = costs.len() / 2;\n        let left_costs = costs[..mid].to_vec();\n        let right_costs = costs[mid..].to_vec();\n\n        let table_clone1 = table.clone();\n        let table_clone2 = table.clone();\n\n        let handle1 = thread::spawn(move || parallel_min_reduction(&table_clone1, left_costs));\n\n        let handle2 = thread::spawn(move || parallel_min_reduction(&table_clone2, right_costs));\n\n        let left_min = handle1.join().unwrap();\n        let right_min = handle2.join().unwrap();\n\n        std::cmp::min(left_min, right_min)\n    }"
  },
  {
    "id": 1438,
    "function": "obst_rec",
    "file": "Chap50/OptBinSearchTreeMtEph.rs",
    "lines": "92-136",
    "spec_strength": "",
    "snippet": "    /// APAS: Work Θ(n³), Span Θ(n log n)\n    /// Claude-Opus-4.6 Work: O(n³) - O(n²) subproblems, each O(n) work\n    /// Claude-Opus-4.6 Span: O(n log n) - recursion depth O(n), each level O(log n) parallel reduction\n    fn obst_rec<T: MtVal + Send + Sync + 'static>(table: &OBSTMtEphS<T>, i: usize, l: usize) -> Probability {\n        // Check memo first (thread-safe)\n        {\n            let memo_guard = table.memo.lock().unwrap();\n            if let Some(&result) = memo_guard.get(&(i, l)) {\n                return result;\n            }\n        }\n\n        let result = if l == 0 {\n            Probability::zero() // Base case: empty subsequence\n        } else {\n            // Sum probabilities for this subsequence (thread-safe access)\n            let prob_sum = {\n                let keys_guard = table.keys.lock().unwrap();\n                (0..l)\n                    .map(|k| keys_guard[i + k].prob)\n                    .fold(Probability::zero(), |acc, p| acc + p)\n            };\n\n            // Compute costs for each possible root in parallel\n            let costs = (0..l)\n                .map(|k| {\n                    let left_cost = obst_rec(table, i, k);\n                    let right_cost = obst_rec(table, i + k + 1, l - k - 1);\n                    left_cost + right_cost\n                }).collect::<Vec<Probability>>();\n\n            // Use parallel reduction to find minimum\n            let min_cost = parallel_min_reduction(table, costs);\n\n            prob_sum + min_cost\n        };\n\n        // Memoize result (thread-safe)\n        {\n            let mut memo_guard = table.memo.lock().unwrap();\n            memo_guard.insert((i, l), result);\n        }\n\n        result\n    }"
  },
  {
    "id": 1439,
    "function": "eq`",
    "file": "Chap50/OptBinSearchTreeMtEph.rs",
    "lines": "229-234",
    "spec_strength": "",
    "snippet": "        fn eq(&self, other: &Self) -> bool {\n            // Compare the contents of the Arc<Mutex<Vec>>\n            let self_keys = self.keys.lock().unwrap();\n            let other_keys = other.keys.lock().unwrap();\n            *self_keys == *other_keys\n        }"
  },
  {
    "id": 1440,
    "function": "new",
    "file": "Chap50/OptBinSearchTreeMtPer.rs",
    "lines": "32-33",
    "spec_strength": "",
    "snippet": "        /// Create new optimal BST solver\n        fn new()                                                  -> Self;"
  },
  {
    "id": 1441,
    "function": "from_keys_probs",
    "file": "Chap50/OptBinSearchTreeMtPer.rs",
    "lines": "35-36",
    "spec_strength": "",
    "snippet": "        /// Create from keys and probabilities\n        fn from_keys_probs(keys: Vec<T>, probs: Vec<Probability>) -> Self;"
  },
  {
    "id": 1442,
    "function": "from_key_probs",
    "file": "Chap50/OptBinSearchTreeMtPer.rs",
    "lines": "38-39",
    "spec_strength": "",
    "snippet": "        /// Create from key-probability pairs\n        fn from_key_probs(key_probs: Vec<KeyProb<T>>)             -> Self;"
  },
  {
    "id": 1443,
    "function": "optimal_cost",
    "file": "Chap50/OptBinSearchTreeMtPer.rs",
    "lines": "41-45",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(n³), Span Θ(n log n)\n        /// Claude-Opus-4.6: Work O(n³), Span O(n log n)\n        fn optimal_cost(&self)                                    -> Probability\n        where\n            T: Send + Sync + 'static;"
  },
  {
    "id": 1444,
    "function": "keys",
    "file": "Chap50/OptBinSearchTreeMtPer.rs",
    "lines": "47-48",
    "spec_strength": "",
    "snippet": "        /// Get the keys with probabilities\n        fn keys(&self)                                            -> &Arc<Vec<KeyProb<T>>>;"
  },
  {
    "id": 1445,
    "function": "num_keys",
    "file": "Chap50/OptBinSearchTreeMtPer.rs",
    "lines": "50-51",
    "spec_strength": "",
    "snippet": "        /// Get number of keys\n        fn num_keys(&self)                                        -> usize;"
  },
  {
    "id": 1446,
    "function": "memo_size",
    "file": "Chap50/OptBinSearchTreeMtPer.rs",
    "lines": "53-54",
    "spec_strength": "",
    "snippet": "        /// Get memoization table size\n        fn memo_size(&self)                                       -> usize;"
  },
  {
    "id": 1447,
    "function": "parallel_min_reduction",
    "file": "Chap50/OptBinSearchTreeMtPer.rs",
    "lines": "57-83",
    "spec_strength": "",
    "snippet": "    /// APAS: Work Θ(n), Span Θ(log n)\n    /// Claude-Opus-4.6 Work: O(n) - n comparisons\n    /// Claude-Opus-4.6 Span: O(log n) - parallel reduction tree\n    fn parallel_min_reduction<T: MtVal>(table: &OBSTMtPerS<T>, costs: Vec<Probability>) -> Probability {\n        if costs.is_empty() {\n            return Probability::infinity();\n        }\n        if costs.len() == 1 {\n            return costs[0];\n        }\n\n        let mid = costs.len() / 2;\n        let left_costs = costs[..mid].to_vec();\n        let right_costs = costs[mid..].to_vec();\n\n        let table_clone1 = table.clone();\n        let table_clone2 = table.clone();\n\n        let handle1 = thread::spawn(move || parallel_min_reduction(&table_clone1, left_costs));\n\n        let handle2 = thread::spawn(move || parallel_min_reduction(&table_clone2, right_costs));\n\n        let left_min = handle1.join().unwrap();\n        let right_min = handle2.join().unwrap();\n\n        std::cmp::min(left_min, right_min)\n    }"
  },
  {
    "id": 1448,
    "function": "obst_rec",
    "file": "Chap50/OptBinSearchTreeMtPer.rs",
    "lines": "85-126",
    "spec_strength": "",
    "snippet": "    /// APAS: Work Θ(n³), Span Θ(n log n)\n    /// Claude-Opus-4.6 Work: O(n³) - O(n²) subproblems, each O(n) work\n    /// Claude-Opus-4.6 Span: O(n log n) - recursion depth O(n), each level O(log n) parallel reduction\n    fn obst_rec<T: MtVal + Send + Sync + 'static>(table: &OBSTMtPerS<T>, i: usize, l: usize) -> Probability {\n        // Check memo first (thread-safe)\n        {\n            let memo_guard = table.memo.lock().unwrap();\n            if let Some(&result) = memo_guard.get(&(i, l)) {\n                return result;\n            }\n        }\n\n        let result = if l == 0 {\n            Probability::zero() // Base case: empty subsequence\n        } else {\n            // Sum probabilities for this subsequence\n            let prob_sum = (0..l)\n                .map(|k| table.keys[i + k].prob)\n                .fold(Probability::zero(), |acc, p| acc + p);\n\n            // Compute costs for each possible root in parallel\n            let costs = (0..l)\n                .map(|k| {\n                    let left_cost = obst_rec(table, i, k);\n                    let right_cost = obst_rec(table, i + k + 1, l - k - 1);\n                    left_cost + right_cost\n                }).collect::<Vec<Probability>>();\n\n            // Use parallel reduction to find minimum\n            let min_cost = parallel_min_reduction(table, costs);\n\n            prob_sum + min_cost\n        };\n\n        // Memoize result (thread-safe)\n        {\n            let mut memo_guard = table.memo.lock().unwrap();\n            memo_guard.insert((i, l), result);\n        }\n\n        result\n    }"
  },
  {
    "id": 1449,
    "function": "eq`",
    "file": "Chap50/OptBinSearchTreeMtPer.rs",
    "lines": "184",
    "spec_strength": "",
    "snippet": "        fn eq(&self, other: &Self) -> bool { self.keys == other.keys }"
  },
  {
    "id": 1450,
    "function": "new",
    "file": "Chap50/OptBinSearchTreeStEph.rs",
    "lines": "32-33",
    "spec_strength": "",
    "snippet": "        /// Create new optimal BST solver\n        fn new()                                                  -> Self;"
  },
  {
    "id": 1451,
    "function": "from_keys_probs",
    "file": "Chap50/OptBinSearchTreeStEph.rs",
    "lines": "35-36",
    "spec_strength": "",
    "snippet": "        /// Create from keys and probabilities\n        fn from_keys_probs(keys: Vec<T>, probs: Vec<Probability>) -> Self;"
  },
  {
    "id": 1452,
    "function": "from_key_probs",
    "file": "Chap50/OptBinSearchTreeStEph.rs",
    "lines": "38-39",
    "spec_strength": "",
    "snippet": "        /// Create from key-probability pairs\n        fn from_key_probs(key_probs: Vec<KeyProb<T>>)             -> Self;"
  },
  {
    "id": 1453,
    "function": "optimal_cost",
    "file": "Chap50/OptBinSearchTreeStEph.rs",
    "lines": "41-43",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(n³), Span Θ(n²)\n        /// Claude-Opus-4.6: Work O(n³), Span O(n²)\n        fn optimal_cost(&mut self)                                -> Probability;"
  },
  {
    "id": 1454,
    "function": "keys",
    "file": "Chap50/OptBinSearchTreeStEph.rs",
    "lines": "45-46",
    "spec_strength": "",
    "snippet": "        /// Get the keys with probabilities\n        fn keys(&self)                                            -> &Vec<KeyProb<T>>;"
  },
  {
    "id": 1455,
    "function": "keys_mut",
    "file": "Chap50/OptBinSearchTreeStEph.rs",
    "lines": "48-49",
    "spec_strength": "",
    "snippet": "        /// Get mutable keys (ephemeral allows mutation)\n        fn keys_mut(&mut self)                                    -> &mut Vec<KeyProb<T>>;"
  },
  {
    "id": 1456,
    "function": "set_key_prob",
    "file": "Chap50/OptBinSearchTreeStEph.rs",
    "lines": "51-52",
    "spec_strength": "",
    "snippet": "        /// Set key-probability pair at index\n        fn set_key_prob(&mut self, index: usize, key_prob: KeyProb<T>);"
  },
  {
    "id": 1457,
    "function": "update_prob",
    "file": "Chap50/OptBinSearchTreeStEph.rs",
    "lines": "54-55",
    "spec_strength": "",
    "snippet": "        /// Update probability for key at index\n        fn update_prob(&mut self, index: usize, prob: Probability);"
  },
  {
    "id": 1458,
    "function": "num_keys",
    "file": "Chap50/OptBinSearchTreeStEph.rs",
    "lines": "57-58",
    "spec_strength": "",
    "snippet": "        /// Get number of keys\n        fn num_keys(&self)                                        -> usize;"
  },
  {
    "id": 1459,
    "function": "clear_memo",
    "file": "Chap50/OptBinSearchTreeStEph.rs",
    "lines": "60-61",
    "spec_strength": "",
    "snippet": "        /// Clear memoization table\n        fn clear_memo(&mut self);"
  },
  {
    "id": 1460,
    "function": "memo_size",
    "file": "Chap50/OptBinSearchTreeStEph.rs",
    "lines": "63-64",
    "spec_strength": "",
    "snippet": "        /// Get memoization table size\n        fn memo_size(&self)                                       -> usize;"
  },
  {
    "id": 1461,
    "function": "obst_rec",
    "file": "Chap50/OptBinSearchTreeStEph.rs",
    "lines": "68-100",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(n³), Span Θ(n²)\n        /// Claude-Opus-4.6 Work: O(n³) - O(n²) subproblems, each O(n) work\n        /// Claude-Opus-4.6 Span: O(n²) - recursion depth O(n), each level O(n) work\n        fn obst_rec(&mut self, i: usize, l: usize) -> Probability {\n            // Check memo first\n            if let Some(&result) = self.memo.get(&(i, l)) {\n                return result;\n            }\n\n            let result = if l == 0 {\n                Probability::zero() // Base case: empty subsequence\n            } else {\n                // Sum probabilities for this subsequence\n                let prob_sum = (0..l)\n                    .map(|k| self.keys[i + k].prob)\n                    .fold(Probability::zero(), |acc, p| acc + p);\n\n                // Try each key as root and find minimum cost\n                let min_cost = (0..l)\n                    .map(|k| {\n                        let left_cost = self.obst_rec(i, k);\n                        let right_cost = self.obst_rec(i + k + 1, l - k - 1);\n                        left_cost + right_cost\n                    })\n                    .fold(Probability::infinity(), min);\n\n                prob_sum + min_cost\n            };\n\n            // Memoize result\n            self.memo.insert((i, l), result);\n            result\n        }"
  },
  {
    "id": 1462,
    "function": "new",
    "file": "Chap50/OptBinSearchTreeStPer.rs",
    "lines": "32-33",
    "spec_strength": "",
    "snippet": "        /// Create new optimal BST solver\n        fn new()                                                  -> Self;"
  },
  {
    "id": 1463,
    "function": "from_keys_probs",
    "file": "Chap50/OptBinSearchTreeStPer.rs",
    "lines": "35-36",
    "spec_strength": "",
    "snippet": "        /// Create from keys and probabilities\n        fn from_keys_probs(keys: Vec<T>, probs: Vec<Probability>) -> Self;"
  },
  {
    "id": 1464,
    "function": "from_key_probs",
    "file": "Chap50/OptBinSearchTreeStPer.rs",
    "lines": "38-39",
    "spec_strength": "",
    "snippet": "        /// Create from key-probability pairs\n        fn from_key_probs(key_probs: Vec<KeyProb<T>>)             -> Self;"
  },
  {
    "id": 1465,
    "function": "optimal_cost",
    "file": "Chap50/OptBinSearchTreeStPer.rs",
    "lines": "41-43",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(n³), Span Θ(n²)\n        /// Claude-Opus-4.6: Work O(n³), Span O(n²)\n        fn optimal_cost(&self)                                    -> Probability;"
  },
  {
    "id": 1466,
    "function": "keys",
    "file": "Chap50/OptBinSearchTreeStPer.rs",
    "lines": "45-46",
    "spec_strength": "",
    "snippet": "        /// Get the keys with probabilities\n        fn keys(&self)                                            -> &Vec<KeyProb<T>>;"
  },
  {
    "id": 1467,
    "function": "num_keys",
    "file": "Chap50/OptBinSearchTreeStPer.rs",
    "lines": "48-49",
    "spec_strength": "",
    "snippet": "        /// Get number of keys\n        fn num_keys(&self)                                        -> usize;"
  },
  {
    "id": 1468,
    "function": "memo_size",
    "file": "Chap50/OptBinSearchTreeStPer.rs",
    "lines": "51-52",
    "spec_strength": "",
    "snippet": "        /// Get memoization table size\n        fn memo_size(&self)                                       -> usize;"
  },
  {
    "id": 1469,
    "function": "obst_rec",
    "file": "Chap50/OptBinSearchTreeStPer.rs",
    "lines": "56-88",
    "spec_strength": "",
    "snippet": "        /// APAS: Work Θ(n³), Span Θ(n²)\n        /// Claude-Opus-4.6 Work: O(n³) - O(n²) subproblems, each O(n) work\n        /// Claude-Opus-4.6 Span: O(n²) - recursion depth O(n), each level O(n) work\n        fn obst_rec(&mut self, i: usize, l: usize) -> Probability {\n            // Check memo first\n            if let Some(&result) = self.memo.get(&(i, l)) {\n                return result;\n            }\n\n            let result = if l == 0 {\n                Probability::zero() // Base case: empty subsequence\n            } else {\n                // Sum probabilities for this subsequence\n                let prob_sum = (0..l)\n                    .map(|k| self.keys[i + k].prob)\n                    .fold(Probability::zero(), |acc, p| acc + p);\n\n                // Try each key as root and find minimum cost\n                let min_cost = (0..l)\n                    .map(|k| {\n                        let left_cost = self.obst_rec(i, k);\n                        let right_cost = self.obst_rec(i + k + 1, l - k - 1);\n                        left_cost + right_cost\n                    })\n                    .fold(Probability::infinity(), min);\n\n                prob_sum + min_cost\n            };\n\n            // Memoize result\n            self.memo.insert((i, l), result);\n            result\n        }"
  },
  {
    "id": 1470,
    "function": "new",
    "file": "Chap50/Probability.rs",
    "lines": "19-21",
    "spec_strength": "",
    "snippet": "        /// Create new probability from f64\n        /// APAS: Work Θ(1), Span Θ(1)\n        fn new(value: f64) -> Self;"
  },
  {
    "id": 1471,
    "function": "value",
    "file": "Chap50/Probability.rs",
    "lines": "23-25",
    "spec_strength": "",
    "snippet": "        /// Get the underlying f64 value\n        /// APAS: Work Θ(1), Span Θ(1)\n        fn value(&self)    -> f64;"
  },
  {
    "id": 1472,
    "function": "infinity",
    "file": "Chap50/Probability.rs",
    "lines": "44-46",
    "spec_strength": "",
    "snippet": "        /// Claude-Opus-4.6 Work: O(1) - constant time construction\n        /// Claude-Opus-4.6 Span: O(1) - constant time construction\n        pub fn infinity() -> Self { Probability(f64::INFINITY) }"
  },
  {
    "id": 1473,
    "function": "zero",
    "file": "Chap50/Probability.rs",
    "lines": "48-50",
    "spec_strength": "",
    "snippet": "        /// Claude-Opus-4.6 Work: O(1) - constant time construction\n        /// Claude-Opus-4.6 Span: O(1) - constant time construction\n        pub fn zero() -> Self { Probability(0.0) }"
  },
  {
    "id": 1474,
    "function": "default",
    "file": "Chap50/Probability.rs",
    "lines": "54",
    "spec_strength": "",
    "snippet": "        fn default() -> Self { Probability::zero() }"
  },
  {
    "id": 1475,
    "function": "eq",
    "file": "Chap50/Probability.rs",
    "lines": "58-61",
    "spec_strength": "",
    "snippet": "        fn eq(&self, other: &Self) -> bool {\n            // Use bit-level comparison for exact equality\n            self.0.to_bits() == other.0.to_bits()\n        }"
  },
  {
    "id": 1476,
    "function": "partial_cmp",
    "file": "Chap50/Probability.rs",
    "lines": "67",
    "spec_strength": "",
    "snippet": "        fn partial_cmp(&self, other: &Self) -> Option<Ordering> { Some(self.cmp(other)) }"
  },
  {
    "id": 1477,
    "function": "cmp",
    "file": "Chap50/Probability.rs",
    "lines": "71-87",
    "spec_strength": "",
    "snippet": "        fn cmp(&self, other: &Self) -> Ordering {\n            // Handle NaN and infinity cases properly\n            match (self.0.is_nan(), other.0.is_nan()) {\n                | (true, true) => Ordering::Equal,\n                | (true, false) => Ordering::Greater, // NaN > everything\n                | (false, true) => Ordering::Less,    // everything < NaN\n                | (false, false) => {\n                    if self.0 < other.0 {\n                        Ordering::Less\n                    } else if self.0 > other.0 {\n                        Ordering::Greater\n                    } else {\n                        Ordering::Equal\n                    }\n                }\n            }\n        }"
  },
  {
    "id": 1478,
    "function": "hash",
    "file": "Chap50/Probability.rs",
    "lines": "91",
    "spec_strength": "",
    "snippet": "        fn hash<H: Hasher>(&self, state: &mut H) { self.0.to_bits().hash(state); }"
  },
  {
    "id": 1479,
    "function": "from`",
    "file": "Chap50/Probability.rs",
    "lines": "103",
    "spec_strength": "",
    "snippet": "        fn from(value: f64) -> Self { Probability(value) }"
  },
  {
    "id": 1480,
    "function": "add",
    "file": "Chap50/Probability.rs",
    "lines": "114",
    "spec_strength": "",
    "snippet": "        fn add(self, other: Self) -> Self { Probability(self.0 + other.0) }"
  },
  {
    "id": 1481,
    "function": "sub",
    "file": "Chap50/Probability.rs",
    "lines": "120",
    "spec_strength": "",
    "snippet": "        fn sub(self, other: Self) -> Self { Probability(self.0 - other.0) }"
  },
  {
    "id": 1482,
    "function": "mul",
    "file": "Chap50/Probability.rs",
    "lines": "126",
    "spec_strength": "",
    "snippet": "        fn mul(self, other: Self) -> Self { Probability(self.0 * other.0) }"
  },
  {
    "id": 1483,
    "function": "div",
    "file": "Chap50/Probability.rs",
    "lines": "132",
    "spec_strength": "",
    "snippet": "        fn div(self, other: Self) -> Self { Probability(self.0 / other.0) }"
  },
  {
    "id": 1484,
    "function": "new",
    "file": "Chap51/BottomUpDPMtEph.rs",
    "lines": "19-21",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(1), Span Θ(1)\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1) — agrees with APAS.\n        fn new()                     -> Self;"
  },
  {
    "id": 1485,
    "function": "solve",
    "file": "Chap51/BottomUpDPMtEph.rs",
    "lines": "23-25",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(|S|×|T|), Span O(|S|+|T|) — diagonal parallelism.\n        /// - Claude-Opus-4.6: Work Θ(|S|×|T|), Span Θ(|S|+|T|) — agrees with APAS; diagonals processed in parallel.\n        fn solve(&self, input: &[T]) -> T;"
  },
  {
    "id": 1486,
    "function": "med_bottom_up_parallel",
    "file": "Chap51/BottomUpDPMtEph.rs",
    "lines": "41-59",
    "spec_strength": "",
    "snippet": "        /// Compute minimum edit distance using parallel bottom-up diagonal pebbling (Algorithm 51.1).\n        /// - APAS: Work Θ(|S|×|T|), Span Θ(|S|+|T|) — diagonal parallelism.\n        /// - Claude-Opus-4.6: Work Θ(|S|×|T|), Span Θ(|S|+|T|) — parallel: thread::spawn per diagonal element.\n        pub fn med_bottom_up_parallel(&mut self) -> usize {\n            let s_len = self.seq_s.length();\n            let t_len = self.seq_t.length();\n\n            // Create shared mutable DP table for parallel computation\n            let table = Arc::new(Mutex::new(self.initialize_base_cases()));\n\n            // Process diagonals with parallel computation within each diagonal\n            for k in 1..=(s_len + t_len) {\n                self.compute_diagonal_parallel(Arc::clone(&table), k);\n            }\n\n            // Extract result from bottom-right corner\n            let final_table = table.lock().unwrap();\n            final_table[s_len][t_len]\n        }"
  },
  {
    "id": 1487,
    "function": "initialize_base_cases",
    "file": "Chap51/BottomUpDPMtEph.rs",
    "lines": "61-80",
    "spec_strength": "",
    "snippet": "        /// Initialize base cases for DP table.\n        /// - APAS: N/A — Verus-specific scaffolding.\n        /// - Claude-Opus-4.6: Work Θ(|S|+|T|), Span Θ(|S|+|T|)\n        fn initialize_base_cases(&self) -> Vec<Vec<usize>> {\n            let s_len = self.seq_s.length();\n            let t_len = self.seq_t.length();\n\n            // Initialize with zeros - using Vec for 2D table as Mt sequences lack nested mutation\n            let mut table = vec![vec![0usize; t_len + 1]; s_len + 1];\n\n            // Set base cases: empty string transformations\n            for (i, row) in table.iter_mut().enumerate().take(s_len + 1) {\n                row[0] = i;\n            }\n            for (j, cell) in table[0].iter_mut().enumerate().take(t_len + 1) {\n                *cell = j;\n            }\n\n            table\n        }"
  },
  {
    "id": 1488,
    "function": "compute_diagonal_parallel",
    "file": "Chap51/BottomUpDPMtEph.rs",
    "lines": "82-121",
    "spec_strength": "",
    "snippet": "        /// Compute one diagonal of the DP table in parallel.\n        /// - APAS: Work Θ(diagonal length), Span Θ(1) — each element computed in parallel.\n        /// - Claude-Opus-4.6: Work Θ(min(|S|,|T|)), Span Θ(1) — agrees with APAS; thread::spawn per element.\n        fn compute_diagonal_parallel(&self, table: Arc<Mutex<Vec<Vec<usize>>>>, k: usize) {\n            let s_len = self.seq_s.length();\n            let t_len = self.seq_t.length();\n\n            let start = max(1, k.saturating_sub(t_len));\n            let end = min(k, s_len);\n\n            // Collect diagonal positions\n            let positions = (start..=end)\n                .filter_map(|i| {\n                    let j = k - i;\n                    if j > 0 && j <= t_len { Some((i, j)) } else { None }\n                }).collect::<Vec<(usize, usize)>>();\n\n            // Process diagonal elements in parallel\n            let handles = positions\n                .into_iter()\n                .map(|(i, j)| {\n                    let table_clone = Arc::clone(&table);\n                    let seq_s_clone = self.seq_s.clone();\n                    let seq_t_clone = self.seq_t.clone();\n\n                    thread::spawn(move || {\n                        let new_value = Self::compute_cell_value_static(&seq_s_clone, &seq_t_clone, &table_clone, i, j);\n                        (i, j, new_value)\n                    })\n                }).collect::<Vec<_>>();\n\n            // Collect results from all threads FIRST (without holding lock)\n            let results = handles.into_iter().map(|handle| handle.join().unwrap()).collect::<Vec<(usize, usize, usize)>>();\n\n            // Then acquire lock once and write all results in-place\n            let mut table_guard = table.lock().unwrap();\n            for (i, j, new_value) in results {\n                table_guard[i][j] = new_value;\n            }\n        }"
  },
  {
    "id": 1489,
    "function": "compute_cell_value_static",
    "file": "Chap51/BottomUpDPMtEph.rs",
    "lines": "123-148",
    "spec_strength": "",
    "snippet": "        /// Compute value for a single DP table cell (medOne from Algorithm 51.1).\n        /// - APAS: Work Θ(1), Span Θ(1)\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1) — agrees with APAS.\n        fn compute_cell_value_static(\n            seq_s: &ArraySeqMtEphS<char>,\n            seq_t: &ArraySeqMtEphS<char>,\n            table: &Arc<Mutex<Vec<Vec<usize>>>>,\n            i: usize,\n            j: usize,\n        ) -> usize {\n            // Access sequences using nth_cloned as nth() not available for MtEph\n            let s_char = seq_s.nth(i - 1).clone();\n            let t_char = seq_t.nth(j - 1).clone();\n\n            let table_guard = table.lock().unwrap();\n\n            if s_char == t_char {\n                // Characters match: take diagonal value\n                table_guard[i - 1][j - 1]\n            } else {\n                // Characters don't match: take minimum of insert/delete + 1\n                let delete_cost = table_guard[i - 1][j];\n                let insert_cost = table_guard[i][j - 1];\n                1 + min(delete_cost, insert_cost)\n            }\n        }"
  },
  {
    "id": 1490,
    "function": "s_length",
    "file": "Chap51/BottomUpDPMtEph.rs",
    "lines": "150-152",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — accessor.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        pub fn s_length(&self) -> usize { self.seq_s.length() }"
  },
  {
    "id": 1491,
    "function": "t_length",
    "file": "Chap51/BottomUpDPMtEph.rs",
    "lines": "154-156",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — accessor.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        pub fn t_length(&self) -> usize { self.seq_t.length() }"
  },
  {
    "id": 1492,
    "function": "is_empty",
    "file": "Chap51/BottomUpDPMtEph.rs",
    "lines": "158-160",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — accessor.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        pub fn is_empty(&self) -> bool { self.seq_s.length() == 0usize && self.seq_t.length() == 0usize }"
  },
  {
    "id": 1493,
    "function": "set_s",
    "file": "Chap51/BottomUpDPMtEph.rs",
    "lines": "162-164",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — mutator.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        pub fn set_s(&mut self, s: ArraySeqMtEphS<char>) { self.seq_s = s; }"
  },
  {
    "id": 1494,
    "function": "set_t",
    "file": "Chap51/BottomUpDPMtEph.rs",
    "lines": "166-168",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — mutator.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        pub fn set_t(&mut self, t: ArraySeqMtEphS<char>) { self.seq_t = t; }"
  },
  {
    "id": 1495,
    "function": "default",
    "file": "Chap51/BottomUpDPMtEph.rs",
    "lines": "172-176",
    "spec_strength": "",
    "snippet": "        fn default() -> Self {\n            let empty_s = ArraySeqMtEphS::new(0, ' ');\n            let empty_t = ArraySeqMtEphS::new(0, ' ');\n            Self::new(empty_s, empty_t)\n        }"
  },
  {
    "id": 1496,
    "function": "new",
    "file": "Chap51/BottomUpDPMtPer.rs",
    "lines": "19-21",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(1), Span Θ(1)\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1) — agrees with APAS.\n        fn new()                     -> Self;"
  },
  {
    "id": 1497,
    "function": "solve",
    "file": "Chap51/BottomUpDPMtPer.rs",
    "lines": "23-25",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(|S|×|T|), Span O(|S|+|T|) — diagonal parallelism.\n        /// - Claude-Opus-4.6: Work Θ(|S|×|T|), Span Θ(|S|+|T|) — agrees with APAS; diagonals processed in parallel.\n        fn solve(&self, input: &[T]) -> T;"
  },
  {
    "id": 1498,
    "function": "med_bottom_up_parallel",
    "file": "Chap51/BottomUpDPMtPer.rs",
    "lines": "41-59",
    "spec_strength": "",
    "snippet": "        /// Compute minimum edit distance using parallel bottom-up diagonal pebbling (Algorithm 51.1).\n        /// - APAS: Work Θ(|S|×|T|), Span Θ(|S|+|T|) — diagonal parallelism.\n        /// - Claude-Opus-4.6: Work Θ(|S|×|T|), Span Θ(|S|+|T|) — parallel: thread::spawn per diagonal element.\n        pub fn med_bottom_up_parallel(&self) -> usize {\n            let s_len = self.seq_s.length();\n            let t_len = self.seq_t.length();\n\n            // Create shared DP table for parallel computation\n            let table = Arc::new(Mutex::new(self.initialize_base_cases()));\n\n            // Process diagonals with parallel computation within each diagonal\n            for k in 1..=(s_len + t_len) {\n                self.compute_diagonal_parallel(Arc::clone(&table), k);\n            }\n\n            // Extract result from bottom-right corner\n            let final_table = table.lock().unwrap();\n            final_table[s_len][t_len]\n        }"
  },
  {
    "id": 1499,
    "function": "initialize_base_cases",
    "file": "Chap51/BottomUpDPMtPer.rs",
    "lines": "61-80",
    "spec_strength": "",
    "snippet": "        /// Initialize base cases for DP table.\n        /// - APAS: N/A — Verus-specific scaffolding.\n        /// - Claude-Opus-4.6: Work Θ(|S|+|T|), Span Θ(|S|+|T|)\n        fn initialize_base_cases(&self) -> Vec<Vec<usize>> {\n            let s_len = self.seq_s.length();\n            let t_len = self.seq_t.length();\n\n            // Initialize with zeros - using Vec for 2D table as Mt sequences lack method-call API\n            let mut table = vec![vec![0usize; t_len + 1]; s_len + 1];\n\n            // Set base cases: empty string transformations\n            for (i, row) in table.iter_mut().enumerate().take(s_len + 1) {\n                row[0] = i;\n            }\n            for (j, cell) in table[0].iter_mut().enumerate().take(t_len + 1) {\n                *cell = j;\n            }\n\n            table\n        }"
  },
  {
    "id": 1500,
    "function": "compute_diagonal_parallel",
    "file": "Chap51/BottomUpDPMtPer.rs",
    "lines": "82-121",
    "spec_strength": "",
    "snippet": "        /// Compute one diagonal of the DP table in parallel.\n        /// - APAS: Work Θ(diagonal length), Span Θ(1) — each element computed in parallel.\n        /// - Claude-Opus-4.6: Work Θ(min(|S|,|T|)), Span Θ(1) — agrees with APAS; thread::spawn per element.\n        fn compute_diagonal_parallel(&self, table: Arc<Mutex<Vec<Vec<usize>>>>, k: usize) {\n            let s_len = self.seq_s.length();\n            let t_len = self.seq_t.length();\n\n            let start = max(1, k.saturating_sub(t_len));\n            let end = min(k, s_len);\n\n            // Collect diagonal positions\n            let positions = (start..=end)\n                .filter_map(|i| {\n                    let j = k - i;\n                    if j > 0 && j <= t_len { Some((i, j)) } else { None }\n                }).collect::<Vec<(usize, usize)>>();\n\n            // Process diagonal elements in parallel\n            let handles = positions\n                .into_iter()\n                .map(|(i, j)| {\n                    let table_clone = Arc::clone(&table);\n                    let seq_s_clone = self.seq_s.clone();\n                    let seq_t_clone = self.seq_t.clone();\n\n                    thread::spawn(move || {\n                        let new_value = Self::compute_cell_value_static(&seq_s_clone, &seq_t_clone, &table_clone, i, j);\n                        (i, j, new_value)\n                    })\n                }).collect::<Vec<_>>();\n\n            // Collect results from all threads FIRST (without holding lock)\n            let results = handles.into_iter().map(|handle| handle.join().unwrap()).collect::<Vec<(usize, usize, usize)>>();\n\n            // Then acquire lock once and write all results\n            let mut table_guard = table.lock().unwrap();\n            for (i, j, new_value) in results {\n                table_guard[i][j] = new_value;\n            }\n        }"
  },
  {
    "id": 1501,
    "function": "compute_cell_value_static",
    "file": "Chap51/BottomUpDPMtPer.rs",
    "lines": "123-147",
    "spec_strength": "",
    "snippet": "        /// Compute value for a single DP table cell (medOne from Algorithm 51.1).\n        /// - APAS: Work Θ(1), Span Θ(1)\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1) — agrees with APAS.\n        fn compute_cell_value_static(\n            seq_s: &ArraySeqMtPerS<char>,\n            seq_t: &ArraySeqMtPerS<char>,\n            table: &Arc<Mutex<Vec<Vec<usize>>>>,\n            i: usize,\n            j: usize,\n        ) -> usize {\n            let s_char = *seq_s.nth(i - 1);\n            let t_char = *seq_t.nth(j - 1);\n\n            let table_guard = table.lock().unwrap();\n\n            if s_char == t_char {\n                // Characters match: take diagonal value\n                table_guard[i - 1][j - 1]\n            } else {\n                // Characters don't match: take minimum of insert/delete + 1\n                let delete_cost = table_guard[i - 1][j];\n                let insert_cost = table_guard[i][j - 1];\n                1 + min(delete_cost, insert_cost)\n            }\n        }"
  },
  {
    "id": 1502,
    "function": "s_length",
    "file": "Chap51/BottomUpDPMtPer.rs",
    "lines": "149-151",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — accessor.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        pub fn s_length(&self) -> usize { self.seq_s.length() }"
  },
  {
    "id": 1503,
    "function": "t_length",
    "file": "Chap51/BottomUpDPMtPer.rs",
    "lines": "153-155",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — accessor.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        pub fn t_length(&self) -> usize { self.seq_t.length() }"
  },
  {
    "id": 1504,
    "function": "is_empty",
    "file": "Chap51/BottomUpDPMtPer.rs",
    "lines": "157-159",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — accessor.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        pub fn is_empty(&self) -> bool { self.seq_s.length() == 0usize && self.seq_t.length() == 0usize }"
  },
  {
    "id": 1505,
    "function": "default",
    "file": "Chap51/BottomUpDPMtPer.rs",
    "lines": "163-167",
    "spec_strength": "",
    "snippet": "        fn default() -> Self {\n            let empty_s = ArraySeqMtPerS::new(0, ' ');\n            let empty_t = ArraySeqMtPerS::new(0, ' ');\n            Self::new(empty_s, empty_t)\n        }"
  },
  {
    "id": 1506,
    "function": "new",
    "file": "Chap51/BottomUpDPStEph.rs",
    "lines": "17-20",
    "spec_strength": "",
    "snippet": "        /// Create new bottom-up DP solver\n        /// - APAS: Work Θ(1), Span Θ(1)\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1) — agrees with APAS.\n        fn new()                     -> Self;"
  },
  {
    "id": 1507,
    "function": "solve",
    "file": "Chap51/BottomUpDPStEph.rs",
    "lines": "22-25",
    "spec_strength": "",
    "snippet": "        /// Solve DP problem\n        /// - APAS: Work O(|S|×|T|), Span O(|S|+|T|)\n        /// - Claude-Opus-4.6: Work Θ(|S|×|T|), Span Θ(|S|×|T|) — sequential: no parallelism within diagonals.\n        fn solve(&self, input: &[T]) -> T;"
  },
  {
    "id": 1508,
    "function": "med_bottom_up",
    "file": "Chap51/BottomUpDPStEph.rs",
    "lines": "41-58",
    "spec_strength": "",
    "snippet": "        /// Compute minimum edit distance using bottom-up diagonal pebbling (Algorithm 51.1).\n        /// - APAS: Work Θ(|S|×|T|), Span Θ(|S|+|T|) — diagonal parallelism.\n        /// - Claude-Opus-4.6: Work Θ(|S|×|T|), Span Θ(|S|×|T|) — sequential: no parallelism within diagonals.\n        pub fn med_bottom_up(&mut self) -> usize {\n            let s_len = self.seq_s.length();\n            let t_len = self.seq_t.length();\n\n            // Create mutable DP table for computation\n            let mut table = self.initialize_base_cases();\n\n            // Process diagonals from top-left to bottom-right\n            for k in 1..=(s_len + t_len) {\n                self.compute_diagonal(&mut table, k);\n            }\n\n            // Extract result from bottom-right corner\n            table[s_len][t_len]\n        }"
  },
  {
    "id": 1509,
    "function": "initialize_base_cases",
    "file": "Chap51/BottomUpDPStEph.rs",
    "lines": "60-79",
    "spec_strength": "",
    "snippet": "        /// Initialize base cases for DP table.\n        /// - APAS: N/A — Verus-specific scaffolding.\n        /// - Claude-Opus-4.6: Work Θ(|S|+|T|), Span Θ(|S|+|T|)\n        fn initialize_base_cases(&self) -> Vec<Vec<usize>> {\n            let s_len = self.seq_s.length();\n            let t_len = self.seq_t.length();\n\n            // Initialize with zeros - using Vec for 2D table as sequences lack nested mutation\n            let mut table = vec![vec![0usize; t_len + 1]; s_len + 1];\n\n            // Set base cases: empty string transformations\n            for (i, row) in table.iter_mut().enumerate().take(s_len + 1) {\n                row[0] = i;\n            }\n            for (j, cell) in table[0].iter_mut().enumerate().take(t_len + 1) {\n                *cell = j;\n            }\n\n            table\n        }"
  },
  {
    "id": 1510,
    "function": "compute_diagonal",
    "file": "Chap51/BottomUpDPStEph.rs",
    "lines": "81-98",
    "spec_strength": "",
    "snippet": "        /// Compute one diagonal of the DP table.\n        /// - APAS: Work Θ(diagonal length), Span Θ(1) — each element computed in parallel.\n        /// - Claude-Opus-4.6: Work Θ(min(|S|,|T|)), Span Θ(min(|S|,|T|)) — sequential loop, no parallelism.\n        fn compute_diagonal(&self, table: &mut [Vec<usize>], k: usize) {\n            let s_len = self.seq_s.length();\n            let t_len = self.seq_t.length();\n\n            let start = max(1, k.saturating_sub(t_len));\n            let end = min(k, s_len);\n\n            for i in start..=end {\n                let j = k - i;\n                if j > 0 && j <= t_len {\n                    let new_value = self.compute_cell_value(table, i, j);\n                    table[i][j] = new_value;\n                }\n            }\n        }"
  },
  {
    "id": 1511,
    "function": "compute_cell_value",
    "file": "Chap51/BottomUpDPStEph.rs",
    "lines": "100-116",
    "spec_strength": "",
    "snippet": "        /// Compute value for a single DP table cell (medOne from Algorithm 51.1).\n        /// - APAS: Work Θ(1), Span Θ(1)\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1) — agrees with APAS.\n        fn compute_cell_value(&self, table: &[Vec<usize>], i: usize, j: usize) -> usize {\n            let s_char = *self.seq_s.nth(i - 1);\n            let t_char = *self.seq_t.nth(j - 1);\n\n            if s_char == t_char {\n                // Characters match: take diagonal value\n                table[i - 1][j - 1]\n            } else {\n                // Characters don't match: take minimum of insert/delete + 1\n                let delete_cost = table[i - 1][j];\n                let insert_cost = table[i][j - 1];\n                1 + min(delete_cost, insert_cost)\n            }\n        }"
  },
  {
    "id": 1512,
    "function": "s_length",
    "file": "Chap51/BottomUpDPStEph.rs",
    "lines": "118-120",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — accessor.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        pub fn s_length(&self) -> usize { self.seq_s.length() }"
  },
  {
    "id": 1513,
    "function": "t_length",
    "file": "Chap51/BottomUpDPStEph.rs",
    "lines": "122-124",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — accessor.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        pub fn t_length(&self) -> usize { self.seq_t.length() }"
  },
  {
    "id": 1514,
    "function": "is_empty",
    "file": "Chap51/BottomUpDPStEph.rs",
    "lines": "126-128",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — accessor.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        pub fn is_empty(&self) -> bool { self.seq_s.length() == 0usize && self.seq_t.length() == 0usize }"
  },
  {
    "id": 1515,
    "function": "set_s",
    "file": "Chap51/BottomUpDPStEph.rs",
    "lines": "130-132",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — mutator.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        pub fn set_s(&mut self, s: ArraySeqStEphS<char>) { self.seq_s = s; }"
  },
  {
    "id": 1516,
    "function": "set_t",
    "file": "Chap51/BottomUpDPStEph.rs",
    "lines": "134-136",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — mutator.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        pub fn set_t(&mut self, t: ArraySeqStEphS<char>) { self.seq_t = t; }"
  },
  {
    "id": 1517,
    "function": "default",
    "file": "Chap51/BottomUpDPStEph.rs",
    "lines": "140-144",
    "spec_strength": "",
    "snippet": "        fn default() -> Self {\n            let empty_s = ArraySeqStEphS::new(0, ' ');\n            let empty_t = ArraySeqStEphS::new(0, ' ');\n            Self::new(empty_s, empty_t)\n        }"
  },
  {
    "id": 1518,
    "function": "new",
    "file": "Chap51/BottomUpDPStPer.rs",
    "lines": "17-19",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(1), Span Θ(1)\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1) — agrees with APAS.\n        fn new()                     -> Self;"
  },
  {
    "id": 1519,
    "function": "solve",
    "file": "Chap51/BottomUpDPStPer.rs",
    "lines": "21-23",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(|S|×|T|), Span O(|S|+|T|)\n        /// - Claude-Opus-4.6: Work Θ(|S|×|T|), Span Θ(|S|×|T|) — sequential: no parallelism within diagonals.\n        fn solve(&self, input: &[T]) -> T;"
  },
  {
    "id": 1520,
    "function": "med_bottom_up",
    "file": "Chap51/BottomUpDPStPer.rs",
    "lines": "39-56",
    "spec_strength": "",
    "snippet": "        /// Compute minimum edit distance using bottom-up diagonal pebbling (Algorithm 51.1).\n        /// - APAS: Work Θ(|S|×|T|), Span Θ(|S|+|T|) — diagonal parallelism.\n        /// - Claude-Opus-4.6: Work Θ(|S|×|T|), Span Θ(|S|×|T|) — sequential: no parallelism within diagonals.\n        pub fn med_bottom_up(&self) -> usize {\n            let s_len = self.seq_s.length();\n            let t_len = self.seq_t.length();\n\n            // Create mutable copy for computation\n            let mut table = self.initialize_base_cases();\n\n            // Process diagonals from top-left to bottom-right\n            for k in 1..=(s_len + t_len) {\n                table = self.compute_diagonal(table, k);\n            }\n\n            // Extract result from bottom-right corner\n            table[s_len][t_len]\n        }"
  },
  {
    "id": 1521,
    "function": "initialize_base_cases",
    "file": "Chap51/BottomUpDPStPer.rs",
    "lines": "58-77",
    "spec_strength": "",
    "snippet": "        /// Initialize base cases for DP table.\n        /// - APAS: N/A — Verus-specific scaffolding.\n        /// - Claude-Opus-4.6: Work Θ(|S|+|T|), Span Θ(|S|+|T|)\n        fn initialize_base_cases(&self) -> Vec<Vec<usize>> {\n            let s_len = self.seq_s.length();\n            let t_len = self.seq_t.length();\n\n            // Initialize with zeros - using Vec for 2D table as sequences lack nested indexing\n            let mut table = vec![vec![0usize; t_len + 1]; s_len + 1];\n\n            // Set base cases: empty string transformations\n            for (i, row) in table.iter_mut().enumerate().take(s_len + 1) {\n                row[0] = i;\n            }\n            for (j, cell) in table[0].iter_mut().enumerate().take(t_len + 1) {\n                *cell = j;\n            }\n\n            table\n        }"
  },
  {
    "id": 1522,
    "function": "compute_diagonal",
    "file": "Chap51/BottomUpDPStPer.rs",
    "lines": "79-98",
    "spec_strength": "",
    "snippet": "        /// Compute one diagonal of the DP table.\n        /// - APAS: Work Θ(diagonal length), Span Θ(1) — each element computed in parallel.\n        /// - Claude-Opus-4.6: Work Θ(min(|S|,|T|)), Span Θ(min(|S|,|T|)) — sequential loop, no parallelism.\n        fn compute_diagonal(&self, mut table: Vec<Vec<usize>>, k: usize) -> Vec<Vec<usize>> {\n            let s_len = self.seq_s.length();\n            let t_len = self.seq_t.length();\n\n            let start = max(1, k.saturating_sub(t_len));\n            let end = min(k, s_len);\n\n            for i in start..=end {\n                let j = k - i;\n                if j > 0 && j <= t_len {\n                    let new_value = self.compute_cell_value(&table, i, j);\n                    table[i][j] = new_value;\n                }\n            }\n\n            table\n        }"
  },
  {
    "id": 1523,
    "function": "compute_cell_value",
    "file": "Chap51/BottomUpDPStPer.rs",
    "lines": "100-116",
    "spec_strength": "",
    "snippet": "        /// Compute value for a single DP table cell (medOne from Algorithm 51.1).\n        /// - APAS: Work Θ(1), Span Θ(1)\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1) — agrees with APAS.\n        fn compute_cell_value(&self, table: &[Vec<usize>], i: usize, j: usize) -> usize {\n            let s_char = *self.seq_s.nth(i - 1);\n            let t_char = *self.seq_t.nth(j - 1);\n\n            if s_char == t_char {\n                // Characters match: take diagonal value\n                table[i - 1][j - 1]\n            } else {\n                // Characters don't match: take minimum of insert/delete + 1\n                let delete_cost = table[i - 1][j];\n                let insert_cost = table[i][j - 1];\n                1 + min(delete_cost, insert_cost)\n            }\n        }"
  },
  {
    "id": 1524,
    "function": "s_length",
    "file": "Chap51/BottomUpDPStPer.rs",
    "lines": "118-120",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — accessor.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        pub fn s_length(&self) -> usize { self.seq_s.length() }"
  },
  {
    "id": 1525,
    "function": "t_length",
    "file": "Chap51/BottomUpDPStPer.rs",
    "lines": "122-124",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — accessor.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        pub fn t_length(&self) -> usize { self.seq_t.length() }"
  },
  {
    "id": 1526,
    "function": "is_empty",
    "file": "Chap51/BottomUpDPStPer.rs",
    "lines": "126-128",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — accessor.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        pub fn is_empty(&self) -> bool { self.seq_s.length() == 0usize && self.seq_t.length() == 0usize }"
  },
  {
    "id": 1527,
    "function": "default",
    "file": "Chap51/BottomUpDPStPer.rs",
    "lines": "132-136",
    "spec_strength": "",
    "snippet": "        fn default() -> Self {\n            let empty_s = ArraySeqStPerS::new(0, ' ');\n            let empty_t = ArraySeqStPerS::new(0, ' ');\n            Self::new(empty_s, empty_t)\n        }"
  },
  {
    "id": 1528,
    "function": "new",
    "file": "Chap51/TopDownDPMtEph.rs",
    "lines": "19-21",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(1), Span Θ(1)\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1) — agrees with APAS.\n        fn new()                     -> Self;"
  },
  {
    "id": 1529,
    "function": "solve",
    "file": "Chap51/TopDownDPMtEph.rs",
    "lines": "23-25",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(|S|×|T|), Span O(|S|×|T|) — inherently sequential (memo threading).\n        /// - Claude-Opus-4.6: Work Θ(|S|×|T|), Span Θ(|S|×|T|) — sequential despite concurrent memo table.\n        fn solve(&self, input: &[T]) -> T;"
  },
  {
    "id": 1530,
    "function": "med_memoized_concurrent",
    "file": "Chap51/TopDownDPMtEph.rs",
    "lines": "49-57",
    "spec_strength": "",
    "snippet": "        /// Compute minimum edit distance using concurrent top-down memoization (Algorithm 51.4).\n        /// - APAS: Work Θ(|S|×|T|), Span Θ(|S|×|T|) — inherently sequential (memo threading).\n        /// - Claude-Opus-4.6: Work Θ(|S|×|T|), Span Θ(|S|×|T|) — sequential recursive calls despite concurrent memo.\n        pub fn med_memoized_concurrent(&mut self) -> usize {\n            let s_len = self.seq_s.length();\n            let t_len = self.seq_t.length();\n\n            self.med_recursive_concurrent(s_len, t_len)\n        }"
  },
  {
    "id": 1531,
    "function": "med_recursive_concurrent",
    "file": "Chap51/TopDownDPMtEph.rs",
    "lines": "59-100",
    "spec_strength": "",
    "snippet": "        /// Recursive MED with concurrent memoization.\n        /// - APAS: Work Θ(1) amortized per call, Θ(|S|×|T|) total; Span Θ(|S|×|T|).\n        /// - Claude-Opus-4.6: Work Θ(1) amortized, Span Θ(|S|×|T|) — sequential recursive calls.\n        fn med_recursive_concurrent(&self, i: usize, j: usize) -> usize {\n            // Check memo table first\n            {\n                let memo_guard = self.memo_table.lock().unwrap();\n                if let Some(&cached_result) = memo_guard.get(&(i, j)) {\n                    return cached_result;\n                }\n            }\n\n            // Base cases\n            let result = match (i, j) {\n                | (0, j) => j, // Insert all remaining characters from T\n                | (i, 0) => i, // Delete all remaining characters from S\n                | (i, j) => {\n                    let s_char = self.seq_s.nth(i - 1).clone();\n                    let t_char = self.seq_t.nth(j - 1).clone();\n\n                    if s_char == t_char {\n                        // Characters match: no edit needed\n                        self.med_recursive_concurrent(i - 1, j - 1)\n                    } else {\n                        // Characters don't match: try insert, delete, or substitute\n                        let insert_cost = 1 + self.med_recursive_concurrent(i, j - 1);\n                        let delete_cost = 1 + self.med_recursive_concurrent(i - 1, j);\n                        let substitute_cost = 1 + self.med_recursive_concurrent(i - 1, j - 1);\n\n                        insert_cost.min(delete_cost).min(substitute_cost)\n                    }\n                }\n            };\n\n            // Store result in memo table\n            {\n                let mut memo_guard = self.memo_table.lock().unwrap();\n                memo_guard.insert((i, j), result);\n            }\n\n            result\n        }"
  },
  {
    "id": 1532,
    "function": "med_memoized_parallel",
    "file": "Chap51/TopDownDPMtEph.rs",
    "lines": "102-110",
    "spec_strength": "",
    "snippet": "        /// Compute minimum edit distance with parallel subproblem exploration.\n        /// - APAS: (no cost stated) — prose says top-down is inherently sequential.\n        /// - Claude-Opus-4.6: Work Θ(|S|×|T|), Span Θ(|S|+|T|) — parallel: thread::spawn per recursive branch.\n        pub fn med_memoized_parallel(&mut self) -> usize {\n            let s_len = self.seq_s.length();\n            let t_len = self.seq_t.length();\n\n            self.med_recursive_parallel(s_len, t_len)\n        }"
  },
  {
    "id": 1533,
    "function": "med_recursive_parallel",
    "file": "Chap51/TopDownDPMtEph.rs",
    "lines": "112-163",
    "spec_strength": "",
    "snippet": "        /// Recursive MED with parallel branch exploration.\n        /// - APAS: (no cost stated) — prose says top-down is inherently sequential.\n        /// - Claude-Opus-4.6: Work Θ(1) amortized per call, Span Θ(|S|+|T|) — parallel recursive branches via thread::spawn.\n        fn med_recursive_parallel(&self, i: usize, j: usize) -> usize {\n            // Check memo table first\n            {\n                let memo_guard = self.memo_table.lock().unwrap();\n                if let Some(&cached_result) = memo_guard.get(&(i, j)) {\n                    return cached_result;\n                }\n            }\n\n            // Base cases\n            let result = match (i, j) {\n                | (0, j) => j, // Insert all remaining characters from T\n                | (i, 0) => i, // Delete all remaining characters from S\n                | (i, j) => {\n                    let s_char = self.seq_s.nth(i - 1).clone();\n                    let t_char = self.seq_t.nth(j - 1).clone();\n\n                    if s_char == t_char {\n                        // Characters match: no edit needed\n                        self.med_recursive_parallel(i - 1, j - 1)\n                    } else {\n                        // Characters don't match: explore branches in parallel\n                        let self_clone1 = self.clone();\n                        let self_clone2 = self.clone();\n                        let self_clone3 = self.clone();\n\n                        let handle1 = thread::spawn(move || 1 + self_clone1.med_recursive_parallel(i, j - 1));\n\n                        let handle2 = thread::spawn(move || 1 + self_clone2.med_recursive_parallel(i - 1, j));\n\n                        let handle3 = thread::spawn(move || 1 + self_clone3.med_recursive_parallel(i - 1, j - 1));\n\n                        let insert_cost = handle1.join().unwrap();\n                        let delete_cost = handle2.join().unwrap();\n                        let substitute_cost = handle3.join().unwrap();\n\n                        insert_cost.min(delete_cost).min(substitute_cost)\n                    }\n                }\n            };\n\n            // Store result in memo table\n            {\n                let mut memo_guard = self.memo_table.lock().unwrap();\n                memo_guard.insert((i, j), result);\n            }\n\n            result\n        }"
  },
  {
    "id": 1534,
    "function": "memo_size",
    "file": "Chap51/TopDownDPMtEph.rs",
    "lines": "165-170",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — accessor.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        pub fn memo_size(&self) -> usize {\n            let memo_guard = self.memo_table.lock().unwrap();\n            memo_guard.len()\n        }"
  },
  {
    "id": 1535,
    "function": "is_memoized",
    "file": "Chap51/TopDownDPMtEph.rs",
    "lines": "172-177",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — accessor.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        pub fn is_memoized(&self, i: usize, j: usize) -> bool {\n            let memo_guard = self.memo_table.lock().unwrap();\n            memo_guard.contains_key(&(i, j))\n        }"
  },
  {
    "id": 1536,
    "function": "get_memoized",
    "file": "Chap51/TopDownDPMtEph.rs",
    "lines": "179-184",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — accessor.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        pub fn get_memoized(&self, i: usize, j: usize) -> Option<usize> {\n            let memo_guard = self.memo_table.lock().unwrap();\n            memo_guard.get(&(i, j)).copied()\n        }"
  },
  {
    "id": 1537,
    "function": "insert_memo",
    "file": "Chap51/TopDownDPMtEph.rs",
    "lines": "186-191",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — mutator.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        pub fn insert_memo(&mut self, i: usize, j: usize, value: usize) {\n            let mut memo_guard = self.memo_table.lock().unwrap();\n            memo_guard.insert((i, j), value);\n        }"
  },
  {
    "id": 1538,
    "function": "s_length",
    "file": "Chap51/TopDownDPMtEph.rs",
    "lines": "193-195",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — accessor.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        pub fn s_length(&self) -> usize { self.seq_s.length() }"
  },
  {
    "id": 1539,
    "function": "t_length",
    "file": "Chap51/TopDownDPMtEph.rs",
    "lines": "197-199",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — accessor.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        pub fn t_length(&self) -> usize { self.seq_t.length() }"
  },
  {
    "id": 1540,
    "function": "is_empty",
    "file": "Chap51/TopDownDPMtEph.rs",
    "lines": "201-203",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — accessor.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        pub fn is_empty(&self) -> bool { self.seq_s.length() == 0usize && self.seq_t.length() == 0usize }"
  },
  {
    "id": 1541,
    "function": "clear_memo",
    "file": "Chap51/TopDownDPMtEph.rs",
    "lines": "205-210",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — mutator.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        pub fn clear_memo(&mut self) {\n            let mut memo_guard = self.memo_table.lock().unwrap();\n            memo_guard.clear();\n        }"
  },
  {
    "id": 1542,
    "function": "set_s",
    "file": "Chap51/TopDownDPMtEph.rs",
    "lines": "212-217",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — mutator.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        pub fn set_s(&mut self, s: ArraySeqMtEphS<char>) {\n            self.seq_s = s;\n            self.clear_memo();\n        }"
  },
  {
    "id": 1543,
    "function": "set_t",
    "file": "Chap51/TopDownDPMtEph.rs",
    "lines": "219-224",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — mutator.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        pub fn set_t(&mut self, t: ArraySeqMtEphS<char>) {\n            self.seq_t = t;\n            self.clear_memo();\n        }"
  },
  {
    "id": 1544,
    "function": "eq",
    "file": "Chap51/TopDownDPMtEph.rs",
    "lines": "228-232",
    "spec_strength": "",
    "snippet": "        fn eq(&self, other: &Self) -> bool {\n            let self_memo = self.memo_table.lock().unwrap();\n            let other_memo = other.memo_table.lock().unwrap();\n            self.seq_s == other.seq_s && self.seq_t == other.seq_t && *self_memo == *other_memo\n        }"
  },
  {
    "id": 1545,
    "function": "default",
    "file": "Chap51/TopDownDPMtEph.rs",
    "lines": "236-240",
    "spec_strength": "",
    "snippet": "        fn default() -> Self {\n            let empty_s = ArraySeqMtEphS::new(0, ' ');\n            let empty_t = ArraySeqMtEphS::new(0, ' ');\n            Self::new(empty_s, empty_t)\n        }"
  },
  {
    "id": 1546,
    "function": "new",
    "file": "Chap51/TopDownDPMtPer.rs",
    "lines": "19-21",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(1), Span Θ(1)\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1) — agrees with APAS.\n        fn new()                     -> Self;"
  },
  {
    "id": 1547,
    "function": "solve",
    "file": "Chap51/TopDownDPMtPer.rs",
    "lines": "23-25",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(|S|×|T|), Span O(|S|×|T|) — inherently sequential (memo threading).\n        /// - Claude-Opus-4.6: Work Θ(|S|×|T|), Span Θ(|S|×|T|) — sequential despite concurrent memo table.\n        fn solve(&self, input: &[T]) -> T;"
  },
  {
    "id": 1548,
    "function": "med_memoized_concurrent",
    "file": "Chap51/TopDownDPMtPer.rs",
    "lines": "49-57",
    "spec_strength": "",
    "snippet": "        /// Compute minimum edit distance using concurrent top-down memoization (Algorithm 51.4).\n        /// - APAS: Work Θ(|S|×|T|), Span Θ(|S|×|T|) — inherently sequential (memo threading).\n        /// - Claude-Opus-4.6: Work Θ(|S|×|T|), Span Θ(|S|×|T|) — sequential recursive calls despite concurrent memo.\n        pub fn med_memoized_concurrent(&self) -> usize {\n            let s_len = self.seq_s.length();\n            let t_len = self.seq_t.length();\n\n            self.med_recursive_concurrent(s_len, t_len)\n        }"
  },
  {
    "id": 1549,
    "function": "med_recursive_concurrent",
    "file": "Chap51/TopDownDPMtPer.rs",
    "lines": "59-102",
    "spec_strength": "",
    "snippet": "        /// Recursive MED with concurrent memoization.\n        /// - APAS: Work Θ(1) amortized per call, Θ(|S|×|T|) total; Span Θ(|S|×|T|).\n        /// - Claude-Opus-4.6: Work Θ(1) amortized, Span Θ(|S|×|T|) — sequential recursive calls.\n        fn med_recursive_concurrent(&self, i: usize, j: usize) -> usize {\n            // Check memo table first\n            {\n                let memo_guard = self.memo_table.lock().unwrap();\n                if let Some(&cached_result) = memo_guard.get(&(i, j)) {\n                    return cached_result;\n                }\n            }\n\n            // Base cases\n            let result = match (i, j) {\n                | (0, j) => j, // Insert all remaining characters from T\n                | (i, 0) => i, // Delete all remaining characters from S\n                | (i, j) => {\n                    let s_char = *self.seq_s.nth(i - 1);\n                    let t_char = *self.seq_t.nth(j - 1);\n\n                    if s_char == t_char {\n                        // Characters match: no edit needed\n                        self.med_recursive_concurrent(i - 1, j - 1)\n                    } else {\n                        // Characters don't match: try insert, delete, or substitute\n                        // For better parallelism, we could spawn threads for each branch\n                        // but dependencies limit effectiveness\n                        let insert_cost = 1 + self.med_recursive_concurrent(i, j - 1);\n                        let delete_cost = 1 + self.med_recursive_concurrent(i - 1, j);\n                        let substitute_cost = 1 + self.med_recursive_concurrent(i - 1, j - 1);\n\n                        insert_cost.min(delete_cost).min(substitute_cost)\n                    }\n                }\n            };\n\n            // Store result in memo table\n            {\n                let mut memo_guard = self.memo_table.lock().unwrap();\n                memo_guard.insert((i, j), result);\n            }\n\n            result\n        }"
  },
  {
    "id": 1550,
    "function": "med_memoized_parallel",
    "file": "Chap51/TopDownDPMtPer.rs",
    "lines": "104-112",
    "spec_strength": "",
    "snippet": "        /// Compute minimum edit distance with parallel subproblem exploration.\n        /// - APAS: (no cost stated) — prose says top-down is inherently sequential.\n        /// - Claude-Opus-4.6: Work Θ(|S|×|T|), Span Θ(|S|+|T|) — parallel: thread::spawn per recursive branch.\n        pub fn med_memoized_parallel(&self) -> usize {\n            let s_len = self.seq_s.length();\n            let t_len = self.seq_t.length();\n\n            self.med_recursive_parallel(s_len, t_len)\n        }"
  },
  {
    "id": 1551,
    "function": "med_recursive_parallel",
    "file": "Chap51/TopDownDPMtPer.rs",
    "lines": "114-165",
    "spec_strength": "",
    "snippet": "        /// Recursive MED with parallel branch exploration.\n        /// - APAS: (no cost stated) — prose says top-down is inherently sequential.\n        /// - Claude-Opus-4.6: Work Θ(1) amortized per call, Span Θ(|S|+|T|) — parallel recursive branches via thread::spawn.\n        fn med_recursive_parallel(&self, i: usize, j: usize) -> usize {\n            // Check memo table first\n            {\n                let memo_guard = self.memo_table.lock().unwrap();\n                if let Some(&cached_result) = memo_guard.get(&(i, j)) {\n                    return cached_result;\n                }\n            }\n\n            // Base cases\n            let result = match (i, j) {\n                | (0, j) => j, // Insert all remaining characters from T\n                | (i, 0) => i, // Delete all remaining characters from S\n                | (i, j) => {\n                    let s_char = *self.seq_s.nth(i - 1);\n                    let t_char = *self.seq_t.nth(j - 1);\n\n                    if s_char == t_char {\n                        // Characters match: no edit needed\n                        self.med_recursive_parallel(i - 1, j - 1)\n                    } else {\n                        // Characters don't match: explore branches in parallel\n                        let self_clone1 = self.clone();\n                        let self_clone2 = self.clone();\n                        let self_clone3 = self.clone();\n\n                        let handle1 = thread::spawn(move || 1 + self_clone1.med_recursive_parallel(i, j - 1));\n\n                        let handle2 = thread::spawn(move || 1 + self_clone2.med_recursive_parallel(i - 1, j));\n\n                        let handle3 = thread::spawn(move || 1 + self_clone3.med_recursive_parallel(i - 1, j - 1));\n\n                        let insert_cost = handle1.join().unwrap();\n                        let delete_cost = handle2.join().unwrap();\n                        let substitute_cost = handle3.join().unwrap();\n\n                        insert_cost.min(delete_cost).min(substitute_cost)\n                    }\n                }\n            };\n\n            // Store result in memo table\n            {\n                let mut memo_guard = self.memo_table.lock().unwrap();\n                memo_guard.insert((i, j), result);\n            }\n\n            result\n        }"
  },
  {
    "id": 1552,
    "function": "with_memo_table",
    "file": "Chap51/TopDownDPMtPer.rs",
    "lines": "167-175",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — Verus-specific scaffolding.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        pub fn with_memo_table(self, memo: HashMap<(usize, usize), usize>) -> Self {\n            TopDownDPMtPerS {\n                seq_s: self.seq_s,\n                seq_t: self.seq_t,\n                memo_table: Arc::new(Mutex::new(memo)),\n            }\n        }"
  },
  {
    "id": 1553,
    "function": "memo_size",
    "file": "Chap51/TopDownDPMtPer.rs",
    "lines": "177-182",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — accessor.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        pub fn memo_size(&self) -> usize {\n            let memo_guard = self.memo_table.lock().unwrap();\n            memo_guard.len()\n        }"
  },
  {
    "id": 1554,
    "function": "is_memoized",
    "file": "Chap51/TopDownDPMtPer.rs",
    "lines": "184-189",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — accessor.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        pub fn is_memoized(&self, i: usize, j: usize) -> bool {\n            let memo_guard = self.memo_table.lock().unwrap();\n            memo_guard.contains_key(&(i, j))\n        }"
  },
  {
    "id": 1555,
    "function": "get_memoized",
    "file": "Chap51/TopDownDPMtPer.rs",
    "lines": "191-196",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — accessor.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        pub fn get_memoized(&self, i: usize, j: usize) -> Option<usize> {\n            let memo_guard = self.memo_table.lock().unwrap();\n            memo_guard.get(&(i, j)).copied()\n        }"
  },
  {
    "id": 1556,
    "function": "s_length",
    "file": "Chap51/TopDownDPMtPer.rs",
    "lines": "198-200",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — accessor.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        pub fn s_length(&self) -> usize { self.seq_s.length() }"
  },
  {
    "id": 1557,
    "function": "t_length",
    "file": "Chap51/TopDownDPMtPer.rs",
    "lines": "202-204",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — accessor.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        pub fn t_length(&self) -> usize { self.seq_t.length() }"
  },
  {
    "id": 1558,
    "function": "is_empty",
    "file": "Chap51/TopDownDPMtPer.rs",
    "lines": "206-208",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — accessor.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        pub fn is_empty(&self) -> bool { self.seq_s.length() == 0usize && self.seq_t.length() == 0usize }"
  },
  {
    "id": 1559,
    "function": "clear_memo",
    "file": "Chap51/TopDownDPMtPer.rs",
    "lines": "210-218",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — mutator.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        pub fn clear_memo(self) -> Self {\n            TopDownDPMtPerS {\n                seq_s: self.seq_s,\n                seq_t: self.seq_t,\n                memo_table: Arc::new(Mutex::new(HashMap::new())),\n            }\n        }"
  },
  {
    "id": 1560,
    "function": "eq",
    "file": "Chap51/TopDownDPMtPer.rs",
    "lines": "222-226",
    "spec_strength": "",
    "snippet": "        fn eq(&self, other: &Self) -> bool {\n            let self_memo = self.memo_table.lock().unwrap();\n            let other_memo = other.memo_table.lock().unwrap();\n            self.seq_s == other.seq_s && self.seq_t == other.seq_t && *self_memo == *other_memo\n        }"
  },
  {
    "id": 1561,
    "function": "default",
    "file": "Chap51/TopDownDPMtPer.rs",
    "lines": "230-234",
    "spec_strength": "",
    "snippet": "        fn default() -> Self {\n            let empty_s = ArraySeqMtPerS::new(0, ' ');\n            let empty_t = ArraySeqMtPerS::new(0, ' ');\n            Self::new(empty_s, empty_t)\n        }"
  },
  {
    "id": 1562,
    "function": "new",
    "file": "Chap51/TopDownDPStEph.rs",
    "lines": "17-19",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(1), Span Θ(1)\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1) — agrees with APAS.\n        fn new()                     -> Self;"
  },
  {
    "id": 1563,
    "function": "solve",
    "file": "Chap51/TopDownDPStEph.rs",
    "lines": "21-23",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(|S|×|T|), Span O(|S|×|T|) — inherently sequential (memo threading).\n        /// - Claude-Opus-4.6: Work Θ(|S|×|T|), Span Θ(|S|×|T|) — agrees with APAS.\n        fn solve(&self, input: &[T]) -> T;"
  },
  {
    "id": 1564,
    "function": "med_memoized",
    "file": "Chap51/TopDownDPStEph.rs",
    "lines": "47-55",
    "spec_strength": "",
    "snippet": "        /// Compute minimum edit distance using top-down memoization (Algorithm 51.4).\n        /// - APAS: Work Θ(|S|×|T|), Span Θ(|S|×|T|) — inherently sequential (memo threading).\n        /// - Claude-Opus-4.6: Work Θ(|S|×|T|), Span Θ(|S|×|T|) — agrees with APAS.\n        pub fn med_memoized(&mut self) -> usize {\n            let s_len = self.seq_s.length();\n            let t_len = self.seq_t.length();\n\n            self.med_recursive(s_len, t_len)\n        }"
  },
  {
    "id": 1565,
    "function": "med_recursive",
    "file": "Chap51/TopDownDPStEph.rs",
    "lines": "57-91",
    "spec_strength": "",
    "snippet": "        /// Recursive MED with memoization (medOne from Algorithm 51.4).\n        /// - APAS: Work Θ(1) amortized per call, Θ(|S|×|T|) total; Span Θ(|S|×|T|).\n        /// - Claude-Opus-4.6: Work Θ(1) amortized, Span Θ(|S|×|T|) — agrees with APAS. Includes substitute branch not in APAS.\n        fn med_recursive(&mut self, i: usize, j: usize) -> usize {\n            // Check memo table first\n            if let Some(&cached_result) = self.memo_table.get(&(i, j)) {\n                return cached_result;\n            }\n\n            // Base cases\n            let result = match (i, j) {\n                | (0, j) => j, // Insert all remaining characters from T\n                | (i, 0) => i, // Delete all remaining characters from S\n                | (i, j) => {\n                    let s_char = *self.seq_s.nth(i - 1);\n                    let t_char = *self.seq_t.nth(j - 1);\n\n                    if s_char == t_char {\n                        // Characters match: no edit needed\n                        self.med_recursive(i - 1, j - 1)\n                    } else {\n                        // Characters don't match: try insert, delete, or substitute\n                        let insert_cost = 1 + self.med_recursive(i, j - 1);\n                        let delete_cost = 1 + self.med_recursive(i - 1, j);\n                        let substitute_cost = 1 + self.med_recursive(i - 1, j - 1);\n\n                        insert_cost.min(delete_cost).min(substitute_cost)\n                    }\n                }\n            };\n\n            // Store result in memo table\n            self.memo_table.insert((i, j), result);\n            result\n        }"
  },
  {
    "id": 1566,
    "function": "memo_size",
    "file": "Chap51/TopDownDPStEph.rs",
    "lines": "93-95",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — accessor.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        pub fn memo_size(&self) -> usize { self.memo_table.len() }"
  },
  {
    "id": 1567,
    "function": "is_memoized",
    "file": "Chap51/TopDownDPStEph.rs",
    "lines": "97-99",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — accessor.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        pub fn is_memoized(&self, i: usize, j: usize) -> bool { self.memo_table.contains_key(&(i, j)) }"
  },
  {
    "id": 1568,
    "function": "get_memoized",
    "file": "Chap51/TopDownDPStEph.rs",
    "lines": "101-103",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — accessor.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        pub fn get_memoized(&self, i: usize, j: usize) -> Option<usize> { self.memo_table.get(&(i, j)).copied() }"
  },
  {
    "id": 1569,
    "function": "insert_memo",
    "file": "Chap51/TopDownDPStEph.rs",
    "lines": "105-107",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — mutator.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        pub fn insert_memo(&mut self, i: usize, j: usize, value: usize) { self.memo_table.insert((i, j), value); }"
  },
  {
    "id": 1570,
    "function": "s_length",
    "file": "Chap51/TopDownDPStEph.rs",
    "lines": "109-111",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — accessor.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        pub fn s_length(&self) -> usize { self.seq_s.length() }"
  },
  {
    "id": 1571,
    "function": "t_length",
    "file": "Chap51/TopDownDPStEph.rs",
    "lines": "113-115",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — accessor.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        pub fn t_length(&self) -> usize { self.seq_t.length() }"
  },
  {
    "id": 1572,
    "function": "is_empty",
    "file": "Chap51/TopDownDPStEph.rs",
    "lines": "117-119",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — accessor.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        pub fn is_empty(&self) -> bool { self.seq_s.length() == 0usize && self.seq_t.length() == 0usize }"
  },
  {
    "id": 1573,
    "function": "clear_memo",
    "file": "Chap51/TopDownDPStEph.rs",
    "lines": "121-123",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — mutator.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        pub fn clear_memo(&mut self) { self.memo_table.clear(); }"
  },
  {
    "id": 1574,
    "function": "set_s",
    "file": "Chap51/TopDownDPStEph.rs",
    "lines": "125-130",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — mutator.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        pub fn set_s(&mut self, s: ArraySeqStEphS<char>) {\n            self.seq_s = s;\n            self.clear_memo();\n        }"
  },
  {
    "id": 1575,
    "function": "set_t",
    "file": "Chap51/TopDownDPStEph.rs",
    "lines": "132-137",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — mutator.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        pub fn set_t(&mut self, t: ArraySeqStEphS<char>) {\n            self.seq_t = t;\n            self.clear_memo();\n        }"
  },
  {
    "id": 1576,
    "function": "default",
    "file": "Chap51/TopDownDPStEph.rs",
    "lines": "141-145",
    "spec_strength": "",
    "snippet": "        fn default() -> Self {\n            let empty_s = ArraySeqStEphS::new(0, ' ');\n            let empty_t = ArraySeqStEphS::new(0, ' ');\n            Self::new(empty_s, empty_t)\n        }"
  },
  {
    "id": 1577,
    "function": "new",
    "file": "Chap51/TopDownDPStPer.rs",
    "lines": "17-19",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work Θ(1), Span Θ(1)\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1) — agrees with APAS.\n        fn new()                     -> Self;"
  },
  {
    "id": 1578,
    "function": "solve",
    "file": "Chap51/TopDownDPStPer.rs",
    "lines": "21-23",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(|S|×|T|), Span O(|S|×|T|) — inherently sequential (memo threading).\n        /// - Claude-Opus-4.6: Work Θ(|S|×|T|), Span Θ(|S|×|T|) — agrees with APAS.\n        fn solve(&self, input: &[T]) -> T;"
  },
  {
    "id": 1579,
    "function": "med_memoized",
    "file": "Chap51/TopDownDPStPer.rs",
    "lines": "47-58",
    "spec_strength": "",
    "snippet": "        /// Compute minimum edit distance using top-down memoization (Algorithm 51.4).\n        /// - APAS: Work Θ(|S|×|T|), Span Θ(|S|×|T|) — inherently sequential (memo threading).\n        /// - Claude-Opus-4.6: Work Θ(|S|×|T|), Span Θ(|S|×|T|) — agrees with APAS.\n        pub fn med_memoized(&self) -> usize {\n            let s_len = self.seq_s.length();\n            let t_len = self.seq_t.length();\n\n            // Create mutable copy of memo table for computation\n            let mut memo = self.memo_table.clone();\n\n            self.med_recursive(s_len, t_len, &mut memo)\n        }"
  },
  {
    "id": 1580,
    "function": "med_recursive",
    "file": "Chap51/TopDownDPStPer.rs",
    "lines": "60-94",
    "spec_strength": "",
    "snippet": "        /// Recursive MED with memoization (medOne from Algorithm 51.4).\n        /// - APAS: Work Θ(1) amortized per call, Θ(|S|×|T|) total; Span Θ(|S|×|T|).\n        /// - Claude-Opus-4.6: Work Θ(1) amortized, Span Θ(|S|×|T|) — agrees with APAS. Includes substitute branch not in APAS.\n        fn med_recursive(&self, i: usize, j: usize, memo: &mut HashMap<(usize, usize), usize>) -> usize {\n            // Check memo table first\n            if let Some(&cached_result) = memo.get(&(i, j)) {\n                return cached_result;\n            }\n\n            // Base cases\n            let result = match (i, j) {\n                | (0, j) => j, // Insert all remaining characters from T\n                | (i, 0) => i, // Delete all remaining characters from S\n                | (i, j) => {\n                    let s_char = *self.seq_s.nth(i - 1);\n                    let t_char = *self.seq_t.nth(j - 1);\n\n                    if s_char == t_char {\n                        // Characters match: no edit needed\n                        self.med_recursive(i - 1, j - 1, memo)\n                    } else {\n                        // Characters don't match: try insert, delete, or substitute\n                        let insert_cost = 1 + self.med_recursive(i, j - 1, memo);\n                        let delete_cost = 1 + self.med_recursive(i - 1, j, memo);\n                        let substitute_cost = 1 + self.med_recursive(i - 1, j - 1, memo);\n\n                        insert_cost.min(delete_cost).min(substitute_cost)\n                    }\n                }\n            };\n\n            // Store result in memo table\n            memo.insert((i, j), result);\n            result\n        }"
  },
  {
    "id": 1581,
    "function": "with_memo_table",
    "file": "Chap51/TopDownDPStPer.rs",
    "lines": "96-104",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — Verus-specific scaffolding.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        pub fn with_memo_table(self, memo: HashMap<(usize, usize), usize>) -> Self {\n            TopDownDPStPerS {\n                seq_s: self.seq_s,\n                seq_t: self.seq_t,\n                memo_table: memo,\n            }\n        }"
  },
  {
    "id": 1582,
    "function": "memo_size",
    "file": "Chap51/TopDownDPStPer.rs",
    "lines": "106-108",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — accessor.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        pub fn memo_size(&self) -> usize { self.memo_table.len() }"
  },
  {
    "id": 1583,
    "function": "is_memoized",
    "file": "Chap51/TopDownDPStPer.rs",
    "lines": "110-112",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — accessor.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        pub fn is_memoized(&self, i: usize, j: usize) -> bool { self.memo_table.contains_key(&(i, j)) }"
  },
  {
    "id": 1584,
    "function": "get_memoized",
    "file": "Chap51/TopDownDPStPer.rs",
    "lines": "114-116",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — accessor.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        pub fn get_memoized(&self, i: usize, j: usize) -> Option<usize> { self.memo_table.get(&(i, j)).copied() }"
  },
  {
    "id": 1585,
    "function": "s_length",
    "file": "Chap51/TopDownDPStPer.rs",
    "lines": "118-120",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — accessor.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        pub fn s_length(&self) -> usize { self.seq_s.length() }"
  },
  {
    "id": 1586,
    "function": "t_length",
    "file": "Chap51/TopDownDPStPer.rs",
    "lines": "122-124",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — accessor.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        pub fn t_length(&self) -> usize { self.seq_t.length() }"
  },
  {
    "id": 1587,
    "function": "is_empty",
    "file": "Chap51/TopDownDPStPer.rs",
    "lines": "126-128",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — accessor.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        pub fn is_empty(&self) -> bool { self.seq_s.length() == 0usize && self.seq_t.length() == 0usize }"
  },
  {
    "id": 1588,
    "function": "clear_memo",
    "file": "Chap51/TopDownDPStPer.rs",
    "lines": "130-138",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A — mutator.\n        /// - Claude-Opus-4.6: Work Θ(1), Span Θ(1)\n        pub fn clear_memo(self) -> Self {\n            TopDownDPStPerS {\n                seq_s: self.seq_s,\n                seq_t: self.seq_t,\n                memo_table: HashMap::new(),\n            }\n        }"
  },
  {
    "id": 1589,
    "function": "default",
    "file": "Chap51/TopDownDPStPer.rs",
    "lines": "142-146",
    "spec_strength": "",
    "snippet": "        fn default() -> Self {\n            let empty_s = ArraySeqStPerS::new(0, ' ');\n            let empty_t = ArraySeqStPerS::new(0, ' ');\n            Self::new(empty_s, empty_t)\n        }"
  }
]