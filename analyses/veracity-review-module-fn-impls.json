[
  {
    "id": 1,
    "function": "spanning_tree_star_contraction_mt",
    "file": "Chap64/SpanTreeMtEph.rs",
    "lines": "22-26",
    "spec_strength": "",
    "snippet": "        /// Parallel spanning tree via star contraction\n        /// APAS: Work O(|V| + |E|), Span O(lg² |V|)\n        fn spanning_tree_star_contraction_mt<V: StT + MtT + Hash + Ord + 'static>(\n            graph: &UnDirGraphMtEph<V>,\n        ) -> SetStEph<Edge<V>>;"
  },
  {
    "id": 2,
    "function": "verify_spanning_tree",
    "file": "Chap64/SpanTreeMtEph.rs",
    "lines": "28-30",
    "spec_strength": "",
    "snippet": "        /// Verify spanning tree properties\n        /// APAS: Work O(|V| + |E|), Span O(lg |V|)\n        fn verify_spanning_tree<V: StT + MtT + Hash + Ord>(graph: &UnDirGraphMtEph<V>, tree: &SetStEph<Edge<V>>) -> B;"
  },
  {
    "id": 3,
    "function": "spanning_tree_star_contraction",
    "file": "Chap64/SpanTreeStEph.rs",
    "lines": "19-21",
    "spec_strength": "",
    "snippet": "        /// Sequential spanning tree via star contraction\n        /// APAS: Work O(|V| + |E|), Span O(|V| + |E|)\n        fn spanning_tree_star_contraction<V: StT + Hash + Ord>(graph: &UnDirGraphStEph<V>)                 -> SetStEph<Edge<V>>;"
  },
  {
    "id": 4,
    "function": "verify_spanning_tree",
    "file": "Chap64/SpanTreeStEph.rs",
    "lines": "23-25",
    "spec_strength": "",
    "snippet": "        /// Verify spanning tree properties\n        /// APAS: Work O(|V| + |E|), Span O(|V| + |E|)\n        fn verify_spanning_tree<V: StT + Hash + Ord>(graph: &UnDirGraphStEph<V>, tree: &SetStEph<Edge<V>>) -> B;"
  },
  {
    "id": 5,
    "function": "euler_tour",
    "file": "Chap64/TSPApproxStEph.rs",
    "lines": "24-26",
    "spec_strength": "",
    "snippet": "        /// Compute Euler tour of a tree\n        /// APAS: Work O(|V|), Span O(|V|)\n        fn euler_tour<V: StT + Hash + Ord>(tree: &LabUnDirGraphStEph<V, OrderedFloat<f64>>, start: V) -> Vec<V>;"
  },
  {
    "id": 6,
    "function": "shortcut_tour",
    "file": "Chap64/TSPApproxStEph.rs",
    "lines": "28-30",
    "spec_strength": "",
    "snippet": "        /// Shortcut Euler tour to avoid revisiting vertices\n        /// APAS: Work O(|V|), Span O(|V|)\n        fn shortcut_tour<V: StT + Hash + Ord>(euler_tour: &[V])                                       -> Vec<V>;"
  },
  {
    "id": 7,
    "function": "tour_weight",
    "file": "Chap64/TSPApproxStEph.rs",
    "lines": "32-37",
    "spec_strength": "",
    "snippet": "        /// Compute total weight of a tour\n        /// APAS: Work O(|V|), Span O(|V|)\n        fn tour_weight<V: StT + Hash + Ord>(\n            tour: &[V],\n            distances: &HashMap<(V, V), OrderedFloat<f64>>,\n        ) -> OrderedFloat<f64>;"
  },
  {
    "id": 8,
    "function": "approx_metric_tsp",
    "file": "Chap64/TSPApproxStEph.rs",
    "lines": "39-44",
    "spec_strength": "",
    "snippet": "        /// 2-approximation algorithm for metric TSP\n        /// APAS: Work O(|V|² log |V|), Span O(|V|² log |V|)\n        fn approx_metric_tsp<V: StT + Hash + Ord>(\n            distances: &HashMap<(V, V), OrderedFloat<f64>>,\n            vertices: &SetStEph<V>,\n        ) -> Vec<V>;"
  },
  {
    "id": 9,
    "function": "euler_tour_dfs",
    "file": "Chap64/TSPApproxStEph.rs",
    "lines": "75-122",
    "spec_strength": "",
    "snippet": "    fn euler_tour_dfs<V: StT + Hash + Ord>(\n        graph: &LabUnDirGraphStEph<V, OrderedFloat<f64>>,\n        current: &V,\n        parent: Option<&V>,\n        tree_edges: &SetStEph<LabEdge<V, OrderedFloat<f64>>>,\n        tour: &mut Vec<V>,\n        visited_edges: &mut HashSet<(V, V)>,\n    ) {\n        tour.push(current.clone());\n\n        // Visit all neighbors connected by tree edges\n        let neighbors = get_neighbors(graph, current);\n        for neighbor in neighbors.iter() {\n            // Skip parent to avoid immediate backtrack\n            if let Some(p) = parent {\n                if neighbor == p {\n                    continue;\n                }\n            }\n\n            // Check if edge is in tree and not yet traversed\n            let edge_key = if current < neighbor {\n                (current.clone(), neighbor.clone())\n            } else {\n                (neighbor.clone(), current.clone())\n            };\n\n            if visited_edges.contains(&edge_key) {\n                continue;\n            }\n\n            // Check if edge exists in tree_edges\n            let mut edge_found = false;\n            for edge in tree_edges.iter() {\n                let LabEdge(u, v, _) = edge;\n                if (u == current && v == neighbor) || (u == neighbor && v == current) {\n                    edge_found = true;\n                    break;\n                }\n            }\n\n            if edge_found {\n                visited_edges.insert(edge_key);\n                euler_tour_dfs(graph, neighbor, Some(current), tree_edges, tour, visited_edges);\n                tour.push(current.clone());\n            }\n        }\n    }"
  },
  {
    "id": 10,
    "function": "get_neighbors",
    "file": "Chap64/TSPApproxStEph.rs",
    "lines": "185-196",
    "spec_strength": "",
    "snippet": "    fn get_neighbors<V: StT + Hash + Ord>(graph: &LabUnDirGraphStEph<V, OrderedFloat<f64>>, v: &V) -> SetStEph<V> {\n        let mut neighbors = SetLit![];\n        for edge in graph.labeled_edges().iter() {\n            let LabEdge(a, b, _) = edge;\n            if a == v {\n                let _ = neighbors.insert(b.clone());\n            } else if b == v {\n                let _ = neighbors.insert(a.clone());\n            }\n        }\n        neighbors\n    }"
  },
  {
    "id": 11,
    "function": "get_edge_weight",
    "file": "Chap64/TSPApproxStEph.rs",
    "lines": "198-210",
    "spec_strength": "",
    "snippet": "    fn get_edge_weight<V: StT + Hash + Ord>(\n        graph: &LabUnDirGraphStEph<V, OrderedFloat<f64>>,\n        u: &V,\n        v: &V,\n    ) -> Option<OrderedFloat<f64>> {\n        for edge in graph.labeled_edges().iter() {\n            let LabEdge(a, b, w) = edge;\n            if (a == u && b == v) || (a == v && b == u) {\n                return Some(*w);\n            }\n        }\n        None\n    }"
  }
]