[
  {
    "id": 1,
    "function": "lemma_pow2_mono",
    "file": "Chap02/FibonacciHFScheduler.rs",
    "lines": "23-25",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_pow2_mono(a: nat, b: nat)\n        requires a <= b,\n        ensures pow2(a) <= pow2(b),"
  },
  {
    "id": 2,
    "function": "lemma_pow2_46_lt_u64_max",
    "file": "Chap02/FibonacciHFScheduler.rs",
    "lines": "30-31",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_pow2_46_lt_u64_max()\n        ensures pow2(46) < u64::MAX as nat,"
  },
  {
    "id": 3,
    "function": "lemma_fib_bound",
    "file": "Chap02/FibonacciHFScheduler.rs",
    "lines": "36-38",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_fib_bound(n: nat)\n        ensures spec_fib(n) < pow2(n),\n        decreases n,"
  },
  {
    "id": 4,
    "function": "lemma_fib_fits_u64",
    "file": "Chap02/FibonacciHFScheduler.rs",
    "lines": "53-55",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_fib_fits_u64(n: nat)\n        requires n <= 46,\n        ensures spec_fib(n) <= u64::MAX as nat,"
  },
  {
    "id": 5,
    "function": "lemma_fib_sum_fits_u64",
    "file": "Chap02/FibonacciHFScheduler.rs",
    "lines": "62-64",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_fib_sum_fits_u64(n: nat)\n        requires 2 <= n <= 46,\n        ensures spec_fib((n-1) as nat) + spec_fib((n-2) as nat) <= u64::MAX as nat,"
  },
  {
    "id": 6,
    "function": "fib_seq",
    "file": "Chap02/FibonacciHFScheduler.rs",
    "lines": "71-74",
    "spec_strength": "unknown",
    "snippet": "    pub fn fib_seq(n: u64) -> (fibonacci: u64)\n        requires n <= 46,\n        ensures fibonacci == spec_fib(n as nat),\n        decreases n,"
  },
  {
    "id": 7,
    "function": "fib_par",
    "file": "Chap02/FibonacciHFScheduler.rs",
    "lines": "86-89",
    "spec_strength": "unknown",
    "snippet": "    pub fn fib_par(n: u64) -> (fibonacci: u64)\n        requires n <= 46,\n        ensures fibonacci == spec_fib(n as nat),\n        decreases n,"
  },
  {
    "id": 8,
    "function": "set_parallelism",
    "file": "Chap02/HFSchedulerMtEph.rs",
    "lines": "85",
    "spec_strength": "hole",
    "snippet": "    pub fn set_parallelism(n: usize) {"
  },
  {
    "id": 9,
    "function": "join",
    "file": "Chap02/HFSchedulerMtEph.rs",
    "lines": "95-106",
    "spec_strength": "hole",
    "snippet": "    pub fn join<A, B, FA, FB>(fa: FA, fb: FB) -> (joined_pair: (A, B))\n    where\n        FA: FnOnce() -> A + Send + 'static,\n        FB: FnOnce() -> B + Send + 'static,\n        A: Send + 'static,\n        B: Send + 'static,\n        requires\n            fa.requires(()),\n            fb.requires(()),\n        ensures\n            fa.ensures((), joined_pair.0),\n            fb.ensures((), joined_pair.1),"
  },
  {
    "id": 10,
    "function": "spawn_join",
    "file": "Chap02/HFSchedulerMtEph.rs",
    "lines": "122-133",
    "spec_strength": "hole",
    "snippet": "    pub fn spawn_join<A, B, FA, FB>(fa: FA, fb: FB) -> (joined_pair: (A, B))\n    where\n        FA: FnOnce() -> A + Send + 'static,\n        FB: FnOnce() -> B + Send + 'static,\n        A: Send + 'static,\n        B: Send + 'static,\n        requires\n            fa.requires(()),\n            fb.requires(()),\n        ensures\n            fa.ensures((), joined_pair.0),\n            fb.ensures((), joined_pair.1),"
  },
  {
    "id": 11,
    "function": "spawn",
    "file": "Chap02/HFSchedulerMtEph.rs",
    "lines": "153-160",
    "spec_strength": "hole",
    "snippet": "    pub fn spawn<T, F>(f: F) -> (task: TaskState<T>)\n    where\n        F: FnOnce() -> T + Send + 'static,\n        T: Send + 'static,\n        requires\n            f.requires(()),\n        ensures\n            forall|ret: T| #[trigger] task.predicate(ret) ==> f.ensures((), ret),"
  },
  {
    "id": 12,
    "function": "wait",
    "file": "Chap02/HFSchedulerMtEph.rs",
    "lines": "175-177",
    "spec_strength": "hole",
    "snippet": "    pub fn wait<T: Send + 'static>(task: TaskState<T>) -> (task_result: T)\n        ensures\n            task.predicate(task_result),"
  },
  {
    "id": 13,
    "function": "try_acquire",
    "file": "Chap02/HFSchedulerMtEph.rs",
    "lines": "46-54",
    "spec_strength": "",
    "snippet": "    fn try_acquire() -> bool {\n        let mut available = POOL.available_tasks.lock().unwrap();\n        if *available > 0 {\n            *available -= 1;\n            true\n        } else {\n            false\n        }\n    }"
  },
  {
    "id": 14,
    "function": "acquire",
    "file": "Chap02/HFSchedulerMtEph.rs",
    "lines": "56-62",
    "spec_strength": "",
    "snippet": "    fn acquire() {\n        let mut available = POOL.available_tasks.lock().unwrap();\n        while *available == 0 {\n            available = POOL.task_freed.wait(available).unwrap();\n        }\n        *available -= 1;\n    }"
  },
  {
    "id": 15,
    "function": "release",
    "file": "Chap02/HFSchedulerMtEph.rs",
    "lines": "64-68",
    "spec_strength": "",
    "snippet": "    fn release() {\n        let mut available = POOL.available_tasks.lock().unwrap();\n        *available += 1;\n        POOL.task_freed.notify_one();\n    }"
  },
  {
    "id": 16,
    "function": "insertion_sort",
    "file": "Chap03/InsertionSortStEph.rs",
    "lines": "34-38",
    "spec_strength": "unknown",
    "snippet": "pub fn insertion_sort<T: TotalOrder + Copy>(a: &mut [T]) -> (sorted: &[T])\n        ensures\n          sorted.len() == old(a).len(),\n          sorted@.to_multiset() == old(a)@.to_multiset(),\n          is_sorted(sorted),"
  },
  {
    "id": 17,
    "function": "lemma_star_closed_under_concat",
    "file": "Chap05/KleeneStPer.rs",
    "lines": "78-83",
    "spec_strength": "unknown",
    "snippet": "    pub proof fn lemma_star_closed_under_concat<V>(alphabet: Set<V>, s1: Seq<V>, s2: Seq<V>)\n        requires\n            in_star(alphabet, s1),\n            in_star(alphabet, s2),\n        ensures\n            in_star(alphabet, s1.add(s2)),"
  },
  {
    "id": 18,
    "function": "lemma_plus_closed_under_concat",
    "file": "Chap05/KleeneStPer.rs",
    "lines": "96-101",
    "spec_strength": "unknown",
    "snippet": "    pub proof fn lemma_plus_closed_under_concat<V>(alphabet: Set<V>, s1: Seq<V>, s2: Seq<V>)\n        requires\n            in_plus(alphabet, s1),\n            in_plus(alphabet, s2),\n        ensures\n            in_plus(alphabet, s1.add(s2)),"
  },
  {
    "id": 19,
    "function": "ptt_star_contains_empty",
    "file": "Chap05/KleeneStPer.rs",
    "lines": "108-109",
    "spec_strength": "unknown",
    "snippet": "    proof fn ptt_star_contains_empty<V>(alphabet: Set<V>)\n        ensures in_star(alphabet, Seq::<V>::empty()),"
  },
  {
    "id": 20,
    "function": "ptt_plus_rejects_empty",
    "file": "Chap05/KleeneStPer.rs",
    "lines": "114-115",
    "spec_strength": "unknown",
    "snippet": "    proof fn ptt_plus_rejects_empty<V>(alphabet: Set<V>)\n        ensures !in_plus(alphabet, Seq::<V>::empty()),"
  },
  {
    "id": 21,
    "function": "ptt_singleton_in_star_and_plus",
    "file": "Chap05/KleeneStPer.rs",
    "lines": "120-124",
    "spec_strength": "unknown",
    "snippet": "    proof fn ptt_singleton_in_star_and_plus<V>(alphabet: Set<V>, x: V)\n        requires alphabet.contains(x)\n        ensures\n            in_star(alphabet, seq![x]),\n            in_plus(alphabet, seq![x]),"
  },
  {
    "id": 22,
    "function": "ptt_plus_subset_of_star",
    "file": "Chap05/KleeneStPer.rs",
    "lines": "129-131",
    "spec_strength": "unknown",
    "snippet": "    proof fn ptt_plus_subset_of_star<V>(alphabet: Set<V>, s: Seq<V>)\n        requires in_plus(alphabet, s)\n        ensures in_star(alphabet, s)"
  },
  {
    "id": 23,
    "function": "ptt_star_property_transfer",
    "file": "Chap05/KleeneStPer.rs",
    "lines": "137-146",
    "spec_strength": "unknown",
    "snippet": "    proof fn ptt_star_property_transfer<V>(\n        alphabet: Set<V>,\n        s: Seq<V>,\n        p: spec_fn(V) -> bool,\n    )\n        requires\n            in_star(alphabet, s),\n            forall|x: V| alphabet.contains(x) ==> p(x),\n        ensures\n            forall|i: int| 0 <= i < s.len() ==> p(#[trigger] s[i]),"
  },
  {
    "id": 24,
    "function": "ptt_star_concat_plus_is_plus",
    "file": "Chap05/KleeneStPer.rs",
    "lines": "152-157",
    "spec_strength": "unknown",
    "snippet": "    proof fn ptt_star_concat_plus_is_plus<V>(alphabet: Set<V>, s1: Seq<V>, s2: Seq<V>)\n        requires\n            in_star(alphabet, s1),\n            in_plus(alphabet, s2),\n        ensures\n            in_plus(alphabet, s1.add(s2)),"
  },
  {
    "id": 25,
    "function": "ptt_plus_concat_star_is_plus",
    "file": "Chap05/KleeneStPer.rs",
    "lines": "166-171",
    "spec_strength": "unknown",
    "snippet": "    proof fn ptt_plus_concat_star_is_plus<V>(alphabet: Set<V>, s1: Seq<V>, s2: Seq<V>)\n        requires\n            in_plus(alphabet, s1),\n            in_star(alphabet, s2),\n        ensures\n            in_plus(alphabet, s1.add(s2)),"
  },
  {
    "id": 26,
    "function": "new",
    "file": "Chap05/KleeneStPer.rs",
    "lines": "187-189",
    "spec_strength": "unknown",
    "snippet": "        fn new(alphabet: SetStEph<T>) -> (kleene: Self)\n            requires valid_key_type::<T>()\n            ensures kleene@ == alphabet@;"
  },
  {
    "id": 27,
    "function": "mem_star",
    "file": "Chap05/KleeneStPer.rs",
    "lines": "194-196",
    "spec_strength": "unknown",
    "snippet": "        fn mem_star(&self, s: &[T]) -> (member: bool)\n            requires valid_key_type::<T>()\n            ensures member == in_star(self@, viewed(s@));"
  },
  {
    "id": 28,
    "function": "mem_plus",
    "file": "Chap05/KleeneStPer.rs",
    "lines": "201-203",
    "spec_strength": "unknown",
    "snippet": "        fn mem_plus(&self, s: &[T]) -> (member: bool)\n            requires valid_key_type::<T>()\n            ensures member == in_plus(self@, viewed(s@));"
  },
  {
    "id": 29,
    "function": "alphabet",
    "file": "Chap05/KleeneStPer.rs",
    "lines": "208-209",
    "spec_strength": "unknown",
    "snippet": "        fn alphabet(&self) -> (alpha: &SetStEph<T>)\n            ensures alpha@ == self@;"
  },
  {
    "id": 30,
    "function": "is_functional_vec",
    "file": "Chap05/MappingStEph.rs",
    "lines": "137-139",
    "spec_strength": "unknown",
    "snippet": "        fn is_functional_vec(v: &Vec<Pair<X, Y>>) -> (functional: bool)\n            requires valid_key_type_Pair::<X, Y>()\n            ensures functional == is_functional_seq(v@);"
  },
  {
    "id": 31,
    "function": "is_functional_vec_at",
    "file": "Chap05/MappingStEph.rs",
    "lines": "143-145",
    "spec_strength": "unknown",
    "snippet": "        fn is_functional_vec_at(v: &Vec<Pair<X, Y>>, p: &Pair<X, Y>) -> (functional: bool)\n            requires valid_key_type_Pair::<X, Y>()\n            ensures functional == is_functional_seq_at(v@, p@);"
  },
  {
    "id": 32,
    "function": "is_functional_SetStEph_at",
    "file": "Chap05/MappingStEph.rs",
    "lines": "149-151",
    "spec_strength": "unknown",
    "snippet": "        fn is_functional_SetStEph_at(s: &SetStEph<Pair<X, Y>>, p: &Pair<X, Y>) -> (functional: bool)\n            requires valid_key_type_Pair::<X, Y>()\n            ensures functional == is_functional_set_at(s@, p@);"
  },
  {
    "id": 33,
    "function": "is_functional_SetStEph",
    "file": "Chap05/MappingStEph.rs",
    "lines": "155-157",
    "spec_strength": "unknown",
    "snippet": "        fn is_functional_SetStEph(s: &SetStEph<Pair<X, Y>>) -> (functional: bool)\n            requires valid_key_type_Pair::<X, Y>()\n            ensures functional == is_functional_set(s@);"
  },
  {
    "id": 34,
    "function": "is_functional_RelationStEph",
    "file": "Chap05/MappingStEph.rs",
    "lines": "161-163",
    "spec_strength": "unknown",
    "snippet": "        fn is_functional_RelationStEph(r: &RelationStEph<X, Y>) -> (functional: bool)\n            requires valid_key_type_Pair::<X, Y>()\n            ensures functional == is_functional_relation(*r);"
  },
  {
    "id": 35,
    "function": "empty",
    "file": "Chap05/MappingStEph.rs",
    "lines": "167-172",
    "spec_strength": "unknown",
    "snippet": "        fn empty() -> (empty: Self)\n            requires valid_key_type_Pair::<X, Y>()\n            ensures \n                empty@.dom().finite(),\n                empty@ == Map::<X::V, Y::V>::empty(),\n                empty.is_functional();"
  },
  {
    "id": 36,
    "function": "from_vec",
    "file": "Chap05/MappingStEph.rs",
    "lines": "176-178",
    "spec_strength": "unknown",
    "snippet": "        fn from_vec(v: Vec<Pair<X, Y>>) -> (mapping: Self)\n            requires valid_key_type_Pair::<X, Y>(), is_functional_seq(v@)\n            ensures mapping@.dom().finite(), mapping.is_functional();"
  },
  {
    "id": 37,
    "function": "from_relation",
    "file": "Chap05/MappingStEph.rs",
    "lines": "182-184",
    "spec_strength": "unknown",
    "snippet": "        fn from_relation(r: &RelationStEph<X, Y>) -> (mapping: Self)\n            requires valid_key_type_Pair::<X, Y>(), is_functional_relation(*r)\n            ensures mapping@.dom().finite(), mapping.is_functional();"
  },
  {
    "id": 38,
    "function": "size",
    "file": "Chap05/MappingStEph.rs",
    "lines": "188-189",
    "spec_strength": "unknown",
    "snippet": "        fn size(&self) -> N\n            requires self.is_functional();"
  },
  {
    "id": 39,
    "function": "domain",
    "file": "Chap05/MappingStEph.rs",
    "lines": "193-195",
    "spec_strength": "unknown",
    "snippet": "        fn domain(&self) -> (domain: SetStEph<X>)\n            requires valid_key_type_Pair::<X, Y>(), self.is_functional()\n            ensures domain@.finite(), domain@ == self@.dom();"
  },
  {
    "id": 40,
    "function": "range",
    "file": "Chap05/MappingStEph.rs",
    "lines": "200-205",
    "spec_strength": "unknown",
    "snippet": "        fn range(&self) -> (range: SetStEph<Y>)\n            requires valid_key_type_Pair::<X, Y>(), self.is_functional()\n            ensures \n                range@.finite(), \n                range@ =~= Set::<Y::V>::new(|y: Y::V| exists |x: X::V| #![trigger self@[x]] self@.dom().contains(x) && self@[x] == y),\n                range@ == self@.values();  // vstd equivalence"
  },
  {
    "id": 41,
    "function": "mem",
    "file": "Chap05/MappingStEph.rs",
    "lines": "210-214",
    "spec_strength": "unknown",
    "snippet": "        fn mem(&self, p: &Pair<X, Y>) -> (contains: B)\n            requires valid_key_type_Pair::<X, Y>(), self.is_functional()\n            ensures \n                contains == (self@.dom().contains(p@.0) && self@[p@.0] == p@.1),\n                contains == self@.contains_pair(p@.0, p@.1);  // vstd equivalence"
  },
  {
    "id": 42,
    "function": "iter",
    "file": "Chap05/MappingStEph.rs",
    "lines": "218-224",
    "spec_strength": "unknown",
    "snippet": "        fn iter<'a>(&'a self) -> (it: MappingStEphIter<'a, X, Y>)\n            requires valid_key_type_Pair::<X, Y>(), self.is_functional()\n            ensures\n                it@.0 == 0int,\n                it@.1.map(|i: int, p: Pair<X, Y>| p@).to_set() == \n                    Set::new(|p: (X::V, Y::V)| self@.dom().contains(p.0) && self@[p.0] == p.1),\n                it@.1.no_duplicates();"
  },
  {
    "id": 43,
    "function": "next",
    "file": "Chap05/MappingStEph.rs",
    "lines": "449-465",
    "spec_strength": "unknown",
    "snippet": "        fn next(&mut self) -> (next: Option<&'a Pair<X, Y>>)\n            ensures ({\n                let (old_index, old_seq) = old(self)@;\n                match next {\n                    None => {\n                        &&& self@ == old(self)@\n                        &&& old_index >= old_seq.len()\n                    },\n                    Some(element) => {\n                        let (new_index, new_seq) = self@;\n                        &&& 0 <= old_index < old_seq.len()\n                        &&& new_seq == old_seq\n                        &&& new_index == old_index + 1\n                        &&& element == old_seq[old_index]\n                    },\n                }\n            })"
  },
  {
    "id": 44,
    "function": "hash",
    "file": "Chap05/MappingStEph.rs",
    "lines": "560",
    "spec_strength": "",
    "snippet": "        fn hash<H: std::hash::Hasher>(&self, state: &mut H) { self.mapping.hash(state); }"
  },
  {
    "id": 45,
    "function": "eq",
    "file": "Chap05/MappingStEph.rs",
    "lines": "566-567",
    "spec_strength": "hole",
    "snippet": "        fn eq(&self, other: &Self) -> (equal: bool)\n            ensures equal == (self@ == other@)"
  },
  {
    "id": 46,
    "function": "empty",
    "file": "Chap05/RelationStEph.rs",
    "lines": "98-100",
    "spec_strength": "unknown",
    "snippet": "        fn empty() -> (empty: Self)\n            requires valid_key_type_Pair::<X, Y>()\n            ensures empty@.finite(), empty@ == Set::<(<X as View>::V, <Y as View>::V)>::empty();"
  },
  {
    "id": 47,
    "function": "from_set",
    "file": "Chap05/RelationStEph.rs",
    "lines": "104-106",
    "spec_strength": "unknown",
    "snippet": "        fn from_set(pairs: SetStEph<Pair<X, Y>>) -> (relation: Self)\n            requires valid_key_type_Pair::<X, Y>()\n            ensures relation@.finite(), relation@ == pairs@;"
  },
  {
    "id": 48,
    "function": "from_vec",
    "file": "Chap05/RelationStEph.rs",
    "lines": "110-112",
    "spec_strength": "unknown",
    "snippet": "        fn from_vec(v: Vec<Pair<X, Y>>) -> (relation: Self)\n            requires valid_key_type_Pair::<X, Y>()\n            ensures relation@.finite(), relation@ == v@.map(|i: int, p: Pair<X, Y>| p@).to_set();"
  },
  {
    "id": 49,
    "function": "size",
    "file": "Chap05/RelationStEph.rs",
    "lines": "116-118",
    "spec_strength": "unknown",
    "snippet": "        fn size(&self) -> (size: N)\n          ensures \n           size == self@.len();"
  },
  {
    "id": 50,
    "function": "domain",
    "file": "Chap05/RelationStEph.rs",
    "lines": "122-124",
    "spec_strength": "unknown",
    "snippet": "        fn domain(&self) -> (domain: SetStEph<X>)\n            requires valid_key_type_Pair::<X, Y>()\n            ensures domain@.finite(), domain@ == Set::<X::V>::new(|x: X::V| exists |y: Y::V| self@.contains((x, y)));"
  },
  {
    "id": 51,
    "function": "range",
    "file": "Chap05/RelationStEph.rs",
    "lines": "128-130",
    "spec_strength": "unknown",
    "snippet": "        fn range(&self) -> (range: SetStEph<Y>)\n            requires valid_key_type_Pair::<X, Y>()\n            ensures range@.finite(), range@ == Set::<Y::V>::new(|y: Y::V| exists |x: X::V| self@.contains((x, y)));"
  },
  {
    "id": 52,
    "function": "mem",
    "file": "Chap05/RelationStEph.rs",
    "lines": "134-136",
    "spec_strength": "unknown",
    "snippet": "        fn mem(&self, a: &X, b: &Y) -> (contains: B)\n            requires valid_key_type_Pair::<X, Y>()\n            ensures contains == self@.contains((a@, b@));"
  },
  {
    "id": 53,
    "function": "relates",
    "file": "Chap05/RelationStEph.rs",
    "lines": "140-142",
    "spec_strength": "unknown",
    "snippet": "        fn relates(&self, p: &Pair<X, Y>) -> (contains: B)\n            requires valid_key_type_Pair::<X, Y>()\n            ensures contains == self@.contains(p@);"
  },
  {
    "id": 54,
    "function": "iter",
    "file": "Chap05/RelationStEph.rs",
    "lines": "146-151",
    "spec_strength": "unknown",
    "snippet": "        fn iter<'a>(&'a self) -> (it: RelationStEphIter<'a, X, Y>)\n            requires valid_key_type_Pair::<X, Y>()\n            ensures\n                it@.0 == 0int,\n                it@.1.map(|i: int, p: Pair<X, Y>| p@).to_set() == self@,\n                it@.1.no_duplicates();"
  },
  {
    "id": 55,
    "function": "next",
    "file": "Chap05/RelationStEph.rs",
    "lines": "287-303",
    "spec_strength": "unknown",
    "snippet": "        fn next(&mut self) -> (next: Option<&'a Pair<X, Y>>)\n            ensures ({\n                let (old_index, old_seq) = old(self)@;\n                match next {\n                    None => {\n                        &&& self@ == old(self)@\n                        &&& old_index >= old_seq.len()\n                    },\n                    Some(element) => {\n                        let (new_index, new_seq) = self@;\n                        &&& 0 <= old_index < old_seq.len()\n                        &&& new_seq == old_seq\n                        &&& new_index == old_index + 1\n                        &&& element == old_seq[old_index]\n                    },\n                }\n            })"
  },
  {
    "id": 56,
    "function": "hash",
    "file": "Chap05/RelationStEph.rs",
    "lines": "397",
    "spec_strength": "",
    "snippet": "        fn hash<H: std::hash::Hasher>(&self, state: &mut H) { self.pairs.hash(state); }"
  },
  {
    "id": 57,
    "function": "eq",
    "file": "Chap05/RelationStEph.rs",
    "lines": "403-404",
    "spec_strength": "unknown",
    "snippet": "        fn eq(&self, other: &Self) -> (equal: bool)\n            ensures equal == (self@ == other@)"
  },
  {
    "id": 58,
    "function": "lemma_singleton_choose",
    "file": "Chap05/SetMtEph.rs",
    "lines": "103-109",
    "spec_strength": "unknown",
    "snippet": "    pub broadcast proof fn lemma_singleton_choose<A>(s: Set<A>, a: A)\n        requires\n            s.finite(),\n            s.len() == 1,\n            #[trigger] s.contains(a),\n        ensures\n            s.choose() == a,"
  },
  {
    "id": 59,
    "function": "from_vec",
    "file": "Chap05/SetMtEph.rs",
    "lines": "130-132",
    "spec_strength": "unknown",
    "snippet": "        fn from_vec(v: Vec<T>) -> (s: SetMtEph<T>)\n            requires valid_key_type::<T>()\n            ensures s@.finite(), s@ == v@.map(|i: int, x: T| x@).to_set();"
  },
  {
    "id": 60,
    "function": "iter",
    "file": "Chap05/SetMtEph.rs",
    "lines": "136-141",
    "spec_strength": "unknown",
    "snippet": "        fn iter<'a>(&'a self) -> (it: SetMtEphIter<'a, T>)\n            requires valid_key_type::<T>()\n            ensures\n                it@.0 == 0int,\n                it@.1.map(|i: int, k: T| k@).to_set() == self@,\n                it@.1.no_duplicates();"
  },
  {
    "id": 61,
    "function": "to_seq",
    "file": "Chap05/SetMtEph.rs",
    "lines": "145-149",
    "spec_strength": "unknown",
    "snippet": "        fn to_seq(&self) -> (seq: Vec<T>)\n            requires valid_key_type::<T>()\n            ensures\n                seq@.no_duplicates(),\n                forall |x: T::V| self@.contains(x) <==> seq@.map(|_i: int, t: T| t@).contains(x);"
  },
  {
    "id": 62,
    "function": "empty",
    "file": "Chap05/SetMtEph.rs",
    "lines": "153-155",
    "spec_strength": "unknown",
    "snippet": "        fn empty()                           -> (empty: Self)\n            requires valid_key_type::<T>()\n            ensures empty@.finite(), empty@ == Set::<<T as View>::V>::empty();"
  },
  {
    "id": 63,
    "function": "singleton",
    "file": "Chap05/SetMtEph.rs",
    "lines": "159-161",
    "spec_strength": "unknown",
    "snippet": "        fn singleton(x: T)                   -> (s: Self)\n            requires valid_key_type::<T>()\n            ensures s@.finite(), s@ == Set::empty().insert(x@);"
  },
  {
    "id": 64,
    "function": "size",
    "file": "Chap05/SetMtEph.rs",
    "lines": "165-166",
    "spec_strength": "unknown",
    "snippet": "        fn size(&self)                       -> (size: N)\n            ensures size == self@.len();"
  },
  {
    "id": 65,
    "function": "mem",
    "file": "Chap05/SetMtEph.rs",
    "lines": "170-172",
    "spec_strength": "unknown",
    "snippet": "        fn mem(&self, x: &T)                 -> (contains: B)\n            requires valid_key_type::<T>()\n            ensures contains == self@.contains(x@);"
  },
  {
    "id": 66,
    "function": "insert",
    "file": "Chap05/SetMtEph.rs",
    "lines": "176-180",
    "spec_strength": "unknown",
    "snippet": "        fn insert(&mut self, x: T)           -> (inserted: bool)\n            requires valid_key_type::<T>()\n            ensures\n                self@ == old(self)@.insert(x@),\n                inserted == !old(self)@.contains(x@);"
  },
  {
    "id": 67,
    "function": "union",
    "file": "Chap05/SetMtEph.rs",
    "lines": "184-187",
    "spec_strength": "unknown",
    "snippet": "        fn union(&self, s2: &SetMtEph<T>) -> (union: Self)\n            requires \n               valid_key_type::<T>(),\n            ensures union@.finite(), union@ == self@.union(s2@);"
  },
  {
    "id": 68,
    "function": "disjoint_union",
    "file": "Chap05/SetMtEph.rs",
    "lines": "192-199",
    "spec_strength": "unknown",
    "snippet": "        fn disjoint_union(&self, s2: &SetMtEph<T>) -> (union: Self)\n            requires \n               valid_key_type::<T>(),\n               self@.disjoint(s2@),\n            ensures \n               union@.finite(),\n               union@ == self@.union(s2@),\n               union@.len() == self@.len() + s2@.len();"
  },
  {
    "id": 69,
    "function": "intersection",
    "file": "Chap05/SetMtEph.rs",
    "lines": "203-205",
    "spec_strength": "unknown",
    "snippet": "        fn intersection(&self, s2: &SetMtEph<T>) -> (intersection: Self)\n            requires valid_key_type::<T>()\n            ensures intersection@.finite(), intersection@ == self@.intersect(s2@);"
  },
  {
    "id": 70,
    "function": "elt_cross_set",
    "file": "Chap05/SetMtEph.rs",
    "lines": "209-216",
    "spec_strength": "unknown",
    "snippet": "        fn elt_cross_set<U: StT + Hash + Clone>(a: &T, s2: &SetMtEph<U>) -> (product: SetMtEph<Pair<T, U>>)\n            requires \n              valid_key_type::<T>(),\n              valid_key_type::<U>(),\n              valid_key_type::<Pair<T, U>>(),\n            ensures  \n               product@.finite(),\n               forall |av: T::V, bv: U::V| product@.contains((av, bv)) <==> (av == a@ && s2@.contains(bv));"
  },
  {
    "id": 71,
    "function": "cartesian_product",
    "file": "Chap05/SetMtEph.rs",
    "lines": "220-228",
    "spec_strength": "unknown",
    "snippet": "        fn cartesian_product<U: StT + Hash + Clone + Send + Sync + 'static>(&self, s2: &SetMtEph<U>) -> (product: SetMtEph<Pair<T, U>>)\n            where T: Send + Sync + 'static, Pair<T, U>: StT + Hash + View<V = (T::V, U::V)>,\n            requires \n                valid_key_type::<T>(),\n                valid_key_type::<U>(),\n                valid_key_type::<Pair<T, U>>(),\n            ensures  \n                product@.finite(),\n                forall |av: T::V, bv: U::V| product@.contains((av, bv)) <==> (self@.contains(av) && s2@.contains(bv));"
  },
  {
    "id": 72,
    "function": "all_nonempty",
    "file": "Chap05/SetMtEph.rs",
    "lines": "232-237",
    "spec_strength": "unknown",
    "snippet": "        fn all_nonempty(parts: &SetMtEph<SetMtEph<T>>) -> (all_nonempty: bool)\n            requires \n                valid_key_type::<T>(),\n                valid_key_type::<SetMtEph<T>>(),\n            ensures \n                all_nonempty <==> forall |s: Set<T::V>| #![trigger parts@.contains(s)] parts@.contains(s) ==> s.len() != 0;"
  },
  {
    "id": 73,
    "function": "partition_on_elt",
    "file": "Chap05/SetMtEph.rs",
    "lines": "241-252",
    "spec_strength": "unknown",
    "snippet": "        fn partition_on_elt(x: &T, parts: &SetMtEph<SetMtEph<T>>) -> (partition_on_elt: bool)\n            requires \n                valid_key_type::<T>(),\n                valid_key_type::<SetMtEph<T>>(),\n            ensures \n                partition_on_elt <==> (\n                    (exists |s: Set<T::V>| #![trigger parts@.contains(s)] parts@.contains(s) && s.contains(x@)) &&\n                    (forall |s1: Set<T::V>, s2: Set<T::V>|\n                        #![trigger parts@.contains(s1), parts@.contains(s2)]\n                        parts@.contains(s1) && s1.contains(x@) &&\n                        parts@.contains(s2) && s2.contains(x@) ==> s1 == s2)\n                );"
  },
  {
    "id": 74,
    "function": "partition",
    "file": "Chap05/SetMtEph.rs",
    "lines": "256-270",
    "spec_strength": "unknown",
    "snippet": "        fn partition(&self, parts: &SetMtEph<SetMtEph<T>>) -> (partition: bool)\n            requires \n                valid_key_type::<T>(),\n                valid_key_type::<SetMtEph<T>>(),\n            ensures \n                partition <==> (\n                    (forall |x: T::V| self@.contains(x) ==> (\n                        (exists |s: Set<T::V>| #![trigger parts@.contains(s)] parts@.contains(s) && s.contains(x)) &&\n                        (forall |s1: Set<T::V>, s2: Set<T::V>|\n                            #![trigger parts@.contains(s1), parts@.contains(s2)]\n                            parts@.contains(s1) && s1.contains(x) &&\n                            parts@.contains(s2) && s2.contains(x) ==> s1 == s2)\n                    )) &&\n                    (forall |s: Set<T::V>| #![trigger parts@.contains(s)] parts@.contains(s) ==> s.len() != 0)\n                );"
  },
  {
    "id": 75,
    "function": "choose",
    "file": "Chap05/SetMtEph.rs",
    "lines": "275-280",
    "spec_strength": "unknown",
    "snippet": "        fn choose(&self) -> (element: T)\n            requires \n                valid_key_type::<T>(),\n                self@.len() > 0,\n            ensures \n                self@.contains(element@);"
  },
  {
    "id": 76,
    "function": "next",
    "file": "Chap05/SetMtEph.rs",
    "lines": "850-866",
    "spec_strength": "unknown",
    "snippet": "        fn next(&mut self) -> (next: Option<&'a T>)\n            ensures ({\n                let (old_index, old_seq) = old(self)@;\n                match next {\n                    None => {\n                        &&& self@ == old(self)@\n                        &&& old_index >= old_seq.len()\n                    },\n                    Some(element) => {\n                        let (new_index, new_seq) = self@;\n                        &&& 0 <= old_index < old_seq.len()\n                        &&& new_seq == old_seq\n                        &&& new_index == old_index + 1\n                        &&& element == old_seq[old_index]\n                    },\n                }\n            })"
  },
  {
    "id": 77,
    "function": "hash",
    "file": "Chap05/SetMtEph.rs",
    "lines": "959",
    "spec_strength": "",
    "snippet": "        fn hash<H: std::hash::Hasher>(&self, state: &mut H) { self.elements.hash(state); }"
  },
  {
    "id": 78,
    "function": "eq",
    "file": "Chap05/SetMtEph.rs",
    "lines": "965-966",
    "spec_strength": "hole",
    "snippet": "        fn eq(&self, other: &Self) -> (equal: bool)\n            ensures equal == (self@ == other@)"
  },
  {
    "id": 79,
    "function": "lemma_singleton_choose",
    "file": "Chap05/SetStEph.rs",
    "lines": "99-105",
    "spec_strength": "unknown",
    "snippet": "    pub broadcast proof fn lemma_singleton_choose<A>(s: Set<A>, a: A)\n        requires\n            s.finite(),\n            s.len() == 1,\n            #[trigger] s.contains(a),\n        ensures\n            s.choose() == a,"
  },
  {
    "id": 80,
    "function": "from_vec",
    "file": "Chap05/SetStEph.rs",
    "lines": "126-128",
    "spec_strength": "unknown",
    "snippet": "        fn from_vec(v: Vec<T>) -> (s: SetStEph<T>)\n            requires valid_key_type::<T>()\n            ensures s@.finite(), s@ == v@.map(|i: int, x: T| x@).to_set();"
  },
  {
    "id": 81,
    "function": "iter",
    "file": "Chap05/SetStEph.rs",
    "lines": "132-137",
    "spec_strength": "unknown",
    "snippet": "        fn iter<'a>(&'a self) -> (it: SetStEphIter<'a, T>)\n            requires valid_key_type::<T>()\n            ensures\n                it@.0 == 0int,\n                it@.1.map(|i: int, k: T| k@).to_set() == self@,\n                it@.1.no_duplicates();"
  },
  {
    "id": 82,
    "function": "to_seq",
    "file": "Chap05/SetStEph.rs",
    "lines": "141-145",
    "spec_strength": "unknown",
    "snippet": "        fn to_seq(&self) -> (seq: Vec<T>)\n            requires valid_key_type::<T>()\n            ensures\n                seq@.no_duplicates(),\n                forall |x: T::V| self@.contains(x) <==> seq@.map(|_i: int, t: T| t@).contains(x);"
  },
  {
    "id": 83,
    "function": "empty",
    "file": "Chap05/SetStEph.rs",
    "lines": "149-151",
    "spec_strength": "unknown",
    "snippet": "        fn empty()                           -> (empty: Self)\n            requires valid_key_type::<T>()\n            ensures empty@.finite(), empty@ == Set::<<T as View>::V>::empty();"
  },
  {
    "id": 84,
    "function": "singleton",
    "file": "Chap05/SetStEph.rs",
    "lines": "155-157",
    "spec_strength": "unknown",
    "snippet": "        fn singleton(x: T)                   -> (s: Self)\n            requires valid_key_type::<T>()\n            ensures s@.finite(), s@ == Set::empty().insert(x@);"
  },
  {
    "id": 85,
    "function": "size",
    "file": "Chap05/SetStEph.rs",
    "lines": "161-162",
    "spec_strength": "unknown",
    "snippet": "        fn size(&self)                       -> (size: N)\n            ensures size == self@.len();"
  },
  {
    "id": 86,
    "function": "mem",
    "file": "Chap05/SetStEph.rs",
    "lines": "166-168",
    "spec_strength": "unknown",
    "snippet": "        fn mem(&self, x: &T)                 -> (contains: B)\n            requires valid_key_type::<T>()\n            ensures contains == self@.contains(x@);"
  },
  {
    "id": 87,
    "function": "insert",
    "file": "Chap05/SetStEph.rs",
    "lines": "172-176",
    "spec_strength": "unknown",
    "snippet": "        fn insert(&mut self, x: T)           -> (inserted: bool)\n            requires valid_key_type::<T>()\n            ensures\n                self@ == old(self)@.insert(x@),\n                inserted == !old(self)@.contains(x@);"
  },
  {
    "id": 88,
    "function": "union",
    "file": "Chap05/SetStEph.rs",
    "lines": "180-183",
    "spec_strength": "unknown",
    "snippet": "        fn union(&self, s2: &SetStEph<T>) -> (union: Self)\n            requires \n               valid_key_type::<T>(),\n            ensures union@.finite(), union@ == self@.union(s2@);"
  },
  {
    "id": 89,
    "function": "disjoint_union",
    "file": "Chap05/SetStEph.rs",
    "lines": "188-195",
    "spec_strength": "unknown",
    "snippet": "        fn disjoint_union(&self, s2: &SetStEph<T>) -> (union: Self)\n            requires \n               valid_key_type::<T>(),\n               self@.disjoint(s2@),\n            ensures \n               union@.finite(),\n               union@ == self@.union(s2@),\n               union@.len() == self@.len() + s2@.len();"
  },
  {
    "id": 90,
    "function": "intersection",
    "file": "Chap05/SetStEph.rs",
    "lines": "199-201",
    "spec_strength": "unknown",
    "snippet": "        fn intersection(&self, s2: &SetStEph<T>) -> (intersection: Self)\n            requires valid_key_type::<T>()\n            ensures intersection@.finite(), intersection@ == self@.intersect(s2@);"
  },
  {
    "id": 91,
    "function": "elt_cross_set",
    "file": "Chap05/SetStEph.rs",
    "lines": "205-212",
    "spec_strength": "unknown",
    "snippet": "        fn elt_cross_set<U: StT + Hash + Clone>(a: &T, s2: &SetStEph<U>) -> (product: SetStEph<Pair<T, U>>)\n            requires \n              valid_key_type::<T>(),\n              valid_key_type::<U>(),\n              valid_key_type::<Pair<T, U>>(),\n            ensures  \n               product@.finite(),\n               forall |av: T::V, bv: U::V| product@.contains((av, bv)) <==> (av == a@ && s2@.contains(bv));"
  },
  {
    "id": 92,
    "function": "cartesian_product",
    "file": "Chap05/SetStEph.rs",
    "lines": "216-223",
    "spec_strength": "unknown",
    "snippet": "        fn cartesian_product<U: StT + Hash + Clone>(&self, s2: &SetStEph<U>) -> (product: SetStEph<Pair<T, U>>)\n            requires \n                valid_key_type::<T>(),\n                valid_key_type::<U>(),\n                valid_key_type::<Pair<T, U>>(),\n            ensures  \n                product@.finite(),\n                forall |av: T::V, bv: U::V| product@.contains((av, bv)) <==> (self@.contains(av) && s2@.contains(bv));"
  },
  {
    "id": 93,
    "function": "all_nonempty",
    "file": "Chap05/SetStEph.rs",
    "lines": "227-232",
    "spec_strength": "unknown",
    "snippet": "        fn all_nonempty(parts: &SetStEph<SetStEph<T>>) -> (all_nonempty: bool)\n            requires \n                valid_key_type::<T>(),\n                valid_key_type::<SetStEph<T>>(),\n            ensures \n                all_nonempty <==> forall |s: Set<T::V>| #![trigger parts@.contains(s)] parts@.contains(s) ==> s.len() != 0;"
  },
  {
    "id": 94,
    "function": "partition_on_elt",
    "file": "Chap05/SetStEph.rs",
    "lines": "236-247",
    "spec_strength": "unknown",
    "snippet": "        fn partition_on_elt(x: &T, parts: &SetStEph<SetStEph<T>>) -> (partition_on_elt: bool)\n            requires \n                valid_key_type::<T>(),\n                valid_key_type::<SetStEph<T>>(),\n            ensures \n                partition_on_elt <==> (\n                    (exists |s: Set<T::V>| #![trigger parts@.contains(s)] parts@.contains(s) && s.contains(x@)) &&\n                    (forall |s1: Set<T::V>, s2: Set<T::V>|\n                        #![trigger parts@.contains(s1), parts@.contains(s2)]\n                        parts@.contains(s1) && s1.contains(x@) &&\n                        parts@.contains(s2) && s2.contains(x@) ==> s1 == s2)\n                );"
  },
  {
    "id": 95,
    "function": "partition",
    "file": "Chap05/SetStEph.rs",
    "lines": "251-265",
    "spec_strength": "unknown",
    "snippet": "        fn partition(&self, parts: &SetStEph<SetStEph<T>>) -> (partition: bool)\n            requires \n                valid_key_type::<T>(),\n                valid_key_type::<SetStEph<T>>(),\n            ensures \n                partition <==> (\n                    (forall |x: T::V| self@.contains(x) ==> (\n                        (exists |s: Set<T::V>| #![trigger parts@.contains(s)] parts@.contains(s) && s.contains(x)) &&\n                        (forall |s1: Set<T::V>, s2: Set<T::V>|\n                            #![trigger parts@.contains(s1), parts@.contains(s2)]\n                            parts@.contains(s1) && s1.contains(x) &&\n                            parts@.contains(s2) && s2.contains(x) ==> s1 == s2)\n                    )) &&\n                    (forall |s: Set<T::V>| #![trigger parts@.contains(s)] parts@.contains(s) ==> s.len() != 0)\n                );"
  },
  {
    "id": 96,
    "function": "split",
    "file": "Chap05/SetStEph.rs",
    "lines": "270-282",
    "spec_strength": "unknown",
    "snippet": "        fn split(&self, n: usize) -> (n_set_rest_set: (SetStEph<T>, SetStEph<T>))\n            requires \n                valid_key_type::<T>(),\n                self@.len() >= n,\n            ensures \n               ({let (n_set, rest_set) = n_set_rest_set;\n                  &&& n_set@.finite()\n                  &&& rest_set@.finite()\n                  &&& n_set@.disjoint(rest_set@)\n                  &&& n_set@.union(rest_set@) == self@\n                  &&& n_set@.len() == n\n                  &&& rest_set@.len() == self@.len() - n\n               });"
  },
  {
    "id": 97,
    "function": "choose",
    "file": "Chap05/SetStEph.rs",
    "lines": "288-293",
    "spec_strength": "unknown",
    "snippet": "        fn choose(&self) -> (element: T)\n            requires \n                valid_key_type::<T>(),\n                self@.len() > 0,\n            ensures \n                self@.contains(element@);"
  },
  {
    "id": 98,
    "function": "next",
    "file": "Chap05/SetStEph.rs",
    "lines": "772-788",
    "spec_strength": "unknown",
    "snippet": "        fn next(&mut self) -> (next: Option<&'a T>)\n            ensures ({\n                let (old_index, old_seq) = old(self)@;\n                match next {\n                    None => {\n                        &&& self@ == old(self)@\n                        &&& old_index >= old_seq.len()\n                    },\n                    Some(element) => {\n                        let (new_index, new_seq) = self@;\n                        &&& 0 <= old_index < old_seq.len()\n                        &&& new_seq == old_seq\n                        &&& new_index == old_index + 1\n                        &&& element == old_seq[old_index]\n                    },\n                }\n            })"
  },
  {
    "id": 99,
    "function": "hash",
    "file": "Chap05/SetStEph.rs",
    "lines": "867",
    "spec_strength": "",
    "snippet": "        fn hash<H: std::hash::Hasher>(&self, state: &mut H) { self.elements.hash(state); }"
  },
  {
    "id": 100,
    "function": "eq",
    "file": "Chap05/SetStEph.rs",
    "lines": "873-874",
    "spec_strength": "hole",
    "snippet": "        fn eq(&self, other: &Self) -> (equal: bool)\n            ensures equal == (self@ == other@)"
  },
  {
    "id": 101,
    "function": "empty",
    "file": "Chap06/DirGraphMtEph.rs",
    "lines": "96-101",
    "spec_strength": "unknown",
    "snippet": "        fn empty() -> (g: Self)\n            requires valid_key_type_for_graph::<V>()\n            ensures \n                wf_graph_view(g@),\n                g@.V == Set::<<V as View>::V>::empty(), \n                g@.A == Set::<(<V as View>::V, <V as View>::V)>::empty();"
  },
  {
    "id": 102,
    "function": "from_sets",
    "file": "Chap06/DirGraphMtEph.rs",
    "lines": "105-115",
    "spec_strength": "unknown",
    "snippet": "        fn from_sets(V: SetStEph<V>, A: SetStEph<Edge<V>>) -> (g: Self)\n            requires \n                valid_key_type_for_graph::<V>(),\n                V@.finite(),\n                A@.finite(),\n                forall |u: V::V, w: V::V| \n                    #[trigger] A@.contains((u, w)) ==> V@.contains(u) && V@.contains(w),\n            ensures \n                wf_graph_view(g@),\n                g@.V == V@, \n                g@.A == A@;"
  },
  {
    "id": 103,
    "function": "vertices",
    "file": "Chap06/DirGraphMtEph.rs",
    "lines": "119-120",
    "spec_strength": "unknown",
    "snippet": "        fn vertices(&self) -> (v: &SetStEph<V>)\n            ensures v@ == self@.V;"
  },
  {
    "id": 104,
    "function": "arcs",
    "file": "Chap06/DirGraphMtEph.rs",
    "lines": "124-125",
    "spec_strength": "unknown",
    "snippet": "        fn arcs(&self) -> (a: &SetStEph<Edge<V>>)\n            ensures a@ == self@.A;"
  },
  {
    "id": 105,
    "function": "sizeV",
    "file": "Chap06/DirGraphMtEph.rs",
    "lines": "129-130",
    "spec_strength": "unknown",
    "snippet": "        fn sizeV(&self) -> (n: N)\n            ensures n == self@.V.len();"
  },
  {
    "id": 106,
    "function": "sizeA",
    "file": "Chap06/DirGraphMtEph.rs",
    "lines": "134-135",
    "spec_strength": "unknown",
    "snippet": "        fn sizeA(&self) -> (n: N)\n            ensures n == self@.A.len();"
  },
  {
    "id": 107,
    "function": "neighbor",
    "file": "Chap06/DirGraphMtEph.rs",
    "lines": "139-145",
    "spec_strength": "unknown",
    "snippet": "        fn neighbor(&self, u: &V, v: &V) -> (b: B)\n            requires \n                wf_graph_view(self@),\n                valid_key_type_for_graph::<V>(),\n                self@.V.contains(u@),\n                self@.V.contains(v@),\n            ensures b == self@.A.contains((u@, v@));"
  },
  {
    "id": 108,
    "function": "incident",
    "file": "Chap06/DirGraphMtEph.rs",
    "lines": "149-151",
    "spec_strength": "unknown",
    "snippet": "        fn incident(&self, e: &Edge<V>, v: &V) -> (b: B)\n            requires valid_key_type_for_graph::<V>()\n            ensures b == (e@.0 == v@ || e@.1 == v@);"
  },
  {
    "id": 109,
    "function": "n_plus",
    "file": "Chap06/DirGraphMtEph.rs",
    "lines": "169-176",
    "spec_strength": "unknown",
    "snippet": "        fn n_plus(&self, v: &V) -> (out_neighbors: SetStEph<V>)\n            requires \n                wf_graph_view(self@),\n                valid_key_type_for_graph::<V>(),\n                self@.V.contains(v@),\n            ensures \n                out_neighbors@ == self.spec_n_plus(v@),\n                out_neighbors@ <= self@.V;"
  },
  {
    "id": 110,
    "function": "out_degree",
    "file": "Chap06/DirGraphMtEph.rs",
    "lines": "180-185",
    "spec_strength": "unknown",
    "snippet": "        fn out_degree(&self, v: &V) -> (n: N)\n            requires \n                wf_graph_view(self@),\n                valid_key_type_for_graph::<V>(),\n                self@.V.contains(v@),\n            ensures n == self.spec_n_plus(v@).len();"
  },
  {
    "id": 111,
    "function": "n_minus",
    "file": "Chap06/DirGraphMtEph.rs",
    "lines": "203-210",
    "spec_strength": "unknown",
    "snippet": "        fn n_minus(&self, v: &V) -> (in_neighbors: SetStEph<V>)\n            requires \n                wf_graph_view(self@),\n                valid_key_type_for_graph::<V>(),\n                self@.V.contains(v@),\n            ensures \n                in_neighbors@ == self.spec_n_minus(v@),\n                in_neighbors@ <= self@.V;"
  },
  {
    "id": 112,
    "function": "in_degree",
    "file": "Chap06/DirGraphMtEph.rs",
    "lines": "214-219",
    "spec_strength": "unknown",
    "snippet": "        fn in_degree(&self, v: &V) -> (n: N)\n            requires \n                wf_graph_view(self@),\n                valid_key_type_for_graph::<V>(),\n                self@.V.contains(v@),\n            ensures n == self.spec_n_minus(v@).len();"
  },
  {
    "id": 113,
    "function": "ng",
    "file": "Chap06/DirGraphMtEph.rs",
    "lines": "229-236",
    "spec_strength": "unknown",
    "snippet": "        fn ng(&self, v: &V) -> (neighbors: SetStEph<V>)\n            requires \n                wf_graph_view(self@),\n                valid_key_type_for_graph::<V>(),\n                self@.V.contains(v@),\n            ensures \n                neighbors@ == self.spec_ng(v@),\n                neighbors@ <= self@.V;"
  },
  {
    "id": 114,
    "function": "degree",
    "file": "Chap06/DirGraphMtEph.rs",
    "lines": "246-251",
    "spec_strength": "unknown",
    "snippet": "        fn degree(&self, v: &V) -> (n: N)\n            requires \n                wf_graph_view(self@),\n                valid_key_type_for_graph::<V>(),\n                self@.V.contains(v@),\n            ensures n == self.spec_degree(v@);"
  },
  {
    "id": 115,
    "function": "n_plus_of_vertices",
    "file": "Chap06/DirGraphMtEph.rs",
    "lines": "267-274",
    "spec_strength": "unknown",
    "snippet": "        fn n_plus_of_vertices(&self, u_set: &SetStEph<V>) -> (out_neighbors: SetStEph<V>)\n            requires \n                wf_graph_view(self@),\n                valid_key_type_for_graph::<V>(),\n                u_set@ <= self@.V,\n            ensures \n                out_neighbors@ == self.spec_n_plus_of_vertices(u_set@),\n                out_neighbors@ <= self@.V;"
  },
  {
    "id": 116,
    "function": "n_minus_of_vertices",
    "file": "Chap06/DirGraphMtEph.rs",
    "lines": "290-297",
    "spec_strength": "unknown",
    "snippet": "        fn n_minus_of_vertices(&self, u_set: &SetStEph<V>) -> (in_neighbors: SetStEph<V>)\n            requires \n                wf_graph_view(self@),\n                valid_key_type_for_graph::<V>(),\n                u_set@ <= self@.V,\n            ensures \n                in_neighbors@ == self.spec_n_minus_of_vertices(u_set@),\n                in_neighbors@ <= self@.V;"
  },
  {
    "id": 117,
    "function": "ng_of_vertices",
    "file": "Chap06/DirGraphMtEph.rs",
    "lines": "313-320",
    "spec_strength": "unknown",
    "snippet": "        fn ng_of_vertices(&self, u_set: &SetStEph<V>) -> (neighbors: SetStEph<V>)\n            requires \n                wf_graph_view(self@),\n                valid_key_type_for_graph::<V>(),\n                u_set@ <= self@.V,\n            ensures \n                neighbors@ == self.spec_ng_of_vertices(u_set@),\n                neighbors@ <= self@.V;"
  },
  {
    "id": 118,
    "function": "n_plus_par",
    "file": "Chap06/DirGraphMtEph.rs",
    "lines": "327-337",
    "spec_strength": "unknown",
    "snippet": "    fn n_plus_par<V: StTInMtT + Hash + 'static>(g: &DirGraphMtEph<V>, v: V, arcs: SetStEph<Edge<V>>) \n                                                     -> (out_neighbors: SetStEph<V>)\n        requires\n            valid_key_type::<V>(),\n            valid_key_type::<Edge<V>>(),\n            wf_graph_view(g@),\n            arcs@ <= g@.A,\n        ensures \n            out_neighbors@ == g.spec_n_plus_from_set(v@, arcs@),\n            out_neighbors@ <= g.spec_n_plus(v@)\n        decreases arcs@.len()"
  },
  {
    "id": 119,
    "function": "n_minus_par",
    "file": "Chap06/DirGraphMtEph.rs",
    "lines": "374-384",
    "spec_strength": "unknown",
    "snippet": "    fn n_minus_par<V: StTInMtT + Hash + 'static>(g: &DirGraphMtEph<V>, v: V, arcs: SetStEph<Edge<V>>) \n                                                      -> (in_neighbors: SetStEph<V>)\n        requires\n            valid_key_type::<V>(),\n            valid_key_type::<Edge<V>>(),\n            wf_graph_view(g@),\n            arcs@ <= g@.A,\n        ensures \n            in_neighbors@ == g.spec_n_minus_from_set(v@, arcs@),\n            in_neighbors@ <= g.spec_n_minus(v@)\n        decreases arcs@.len()"
  },
  {
    "id": 120,
    "function": "n_plus_of_vertices_par",
    "file": "Chap06/DirGraphMtEph.rs",
    "lines": "421-433",
    "spec_strength": "unknown",
    "snippet": "    fn n_plus_of_vertices_par<V: StTInMtT + Hash + 'static>(\n        g: &DirGraphMtEph<V>,\n        verts: SetStEph<V>,\n    ) -> (out_neighbors: SetStEph<V>)\n        requires \n            valid_key_type::<V>(),\n            valid_key_type::<Edge<V>>(),\n            wf_graph_view(g@),\n            verts@ <= g@.V,\n        ensures \n            out_neighbors@ == g.spec_n_plus_of_vertices_from_set(verts@),\n            out_neighbors@ <= g@.V\n        decreases verts@.len()"
  },
  {
    "id": 121,
    "function": "n_minus_of_vertices_par",
    "file": "Chap06/DirGraphMtEph.rs",
    "lines": "488-500",
    "spec_strength": "unknown",
    "snippet": "    fn n_minus_of_vertices_par<V: StTInMtT + Hash + 'static>(\n        g: &DirGraphMtEph<V>,\n        verts: SetStEph<V>,\n    ) -> (in_neighbors: SetStEph<V>)\n        requires \n            valid_key_type::<V>(),\n            valid_key_type::<Edge<V>>(),\n            wf_graph_view(g@),\n            verts@ <= g@.V,\n        ensures \n            in_neighbors@ == g.spec_n_minus_of_vertices_from_set(verts@),\n            in_neighbors@ <= g@.V\n        decreases verts@.len()"
  },
  {
    "id": 122,
    "function": "ng_of_vertices_par",
    "file": "Chap06/DirGraphMtEph.rs",
    "lines": "555-567",
    "spec_strength": "unknown",
    "snippet": "    fn ng_of_vertices_par<V: StTInMtT + Hash + 'static>(\n        g: &DirGraphMtEph<V>,\n        verts: SetStEph<V>,\n    ) -> (neighbors: SetStEph<V>)\n        requires \n            valid_key_type::<V>(),\n            valid_key_type::<Edge<V>>(),\n            wf_graph_view(g@),\n            verts@ <= g@.V,\n        ensures \n            neighbors@ == g.spec_ng_of_vertices_from_set(verts@),\n            neighbors@ <= g@.V\n        decreases verts@.len()"
  },
  {
    "id": 123,
    "function": "eq",
    "file": "Chap06/DirGraphMtEph.rs",
    "lines": "695-696",
    "spec_strength": "unknown",
    "snippet": "        fn eq(&self, other: &Self) -> (equal: bool)\n            ensures equal == (self@ == other@)"
  },
  {
    "id": 124,
    "function": "empty",
    "file": "Chap06/DirGraphStEph.rs",
    "lines": "112-117",
    "spec_strength": "unknown",
    "snippet": "        fn empty() -> (g: DirGraphStEph<V>)\n            requires valid_key_type_Edge::<V>()\n            ensures\n                wf_graph_view(g@),\n                g@.V =~= Set::<<V as View>::V>::empty(),\n                g@.A =~= Set::<(<V as View>::V, <V as View>::V)>::empty();"
  },
  {
    "id": 125,
    "function": "from_sets",
    "file": "Chap06/DirGraphStEph.rs",
    "lines": "121-129",
    "spec_strength": "unknown",
    "snippet": "        fn from_sets(vertices: SetStEph<V>, arcs: SetStEph<Edge<V>>) -> (g: DirGraphStEph<V>)\n            requires\n                forall |u: V::V, w: V::V| \n                    #[trigger] arcs@.contains((u, w)) ==> \n                        vertices@.contains(u) && vertices@.contains(w),\n            ensures\n                wf_graph_view(g@),\n                g@.V =~= vertices@,\n                g@.A =~= arcs@;"
  },
  {
    "id": 126,
    "function": "vertices",
    "file": "Chap06/DirGraphStEph.rs",
    "lines": "133-134",
    "spec_strength": "unknown",
    "snippet": "        fn vertices(&self) -> (v: &SetStEph<V>)\n            ensures v@ == self@.V;"
  },
  {
    "id": 127,
    "function": "arcs",
    "file": "Chap06/DirGraphStEph.rs",
    "lines": "138-139",
    "spec_strength": "unknown",
    "snippet": "        fn arcs(&self) -> (a: &SetStEph<Edge<V>>)\n            ensures a@ =~= self@.A;"
  },
  {
    "id": 128,
    "function": "sizeV",
    "file": "Chap06/DirGraphStEph.rs",
    "lines": "143-145",
    "spec_strength": "unknown",
    "snippet": "        fn sizeV(&self) -> (n: N)\n            requires wf_graph_view(self@), valid_key_type_Edge::<V>()\n            ensures n == self@.V.len();"
  },
  {
    "id": 129,
    "function": "sizeA",
    "file": "Chap06/DirGraphStEph.rs",
    "lines": "149-151",
    "spec_strength": "unknown",
    "snippet": "        fn sizeA(&self) -> (n: N)\n            requires wf_graph_view(self@), valid_key_type_Edge::<V>()\n            ensures n == self@.A.len();"
  },
  {
    "id": 130,
    "function": "neighbor",
    "file": "Chap06/DirGraphStEph.rs",
    "lines": "155-157",
    "spec_strength": "unknown",
    "snippet": "        fn neighbor(&self, u: &V, v: &V) -> (b: B)\n            requires wf_graph_view(self@), valid_key_type_Edge::<V>()\n            ensures b == self@.A.contains((u@, v@));"
  },
  {
    "id": 131,
    "function": "ng",
    "file": "Chap06/DirGraphStEph.rs",
    "lines": "161-163",
    "spec_strength": "unknown",
    "snippet": "        fn ng(&self, v: &V) -> (neighbors: SetStEph<V>)\n            requires wf_graph_view(self@), valid_key_type_Edge::<V>(), self@.V.contains(v@)\n            ensures neighbors@ == self.spec_ng(v@);"
  },
  {
    "id": 132,
    "function": "ng_of_vertices",
    "file": "Chap06/DirGraphStEph.rs",
    "lines": "167-169",
    "spec_strength": "unknown",
    "snippet": "        fn ng_of_vertices(&self, vertices: &SetStEph<V>) -> (neighbors: SetStEph<V>)\n            requires wf_graph_view(self@), valid_key_type_Edge::<V>(), vertices@ <= self@.V\n            ensures neighbors@ == self.spec_ng_of_vertices(vertices@);"
  },
  {
    "id": 133,
    "function": "n_plus",
    "file": "Chap06/DirGraphStEph.rs",
    "lines": "173-175",
    "spec_strength": "unknown",
    "snippet": "        fn n_plus(&self, v: &V) -> (out_neighbors: SetStEph<V>)\n            requires wf_graph_view(self@), valid_key_type_Edge::<V>(), self@.V.contains(v@)\n            ensures out_neighbors@ == self.spec_n_plus(v@);"
  },
  {
    "id": 134,
    "function": "n_minus",
    "file": "Chap06/DirGraphStEph.rs",
    "lines": "179-181",
    "spec_strength": "unknown",
    "snippet": "        fn n_minus(&self, v: &V) -> (in_neighbors: SetStEph<V>)\n            requires wf_graph_view(self@), valid_key_type_Edge::<V>(), self@.V.contains(v@)\n            ensures in_neighbors@ == self.spec_n_minus(v@);"
  },
  {
    "id": 135,
    "function": "n_plus_of_vertices",
    "file": "Chap06/DirGraphStEph.rs",
    "lines": "185-187",
    "spec_strength": "unknown",
    "snippet": "        fn n_plus_of_vertices(&self, vertices: &SetStEph<V>) -> (out_neighbors: SetStEph<V>)\n            requires wf_graph_view(self@), valid_key_type_Edge::<V>(), vertices@ <= self@.V\n            ensures out_neighbors@ == self.spec_n_plus_of_vertices(vertices@);"
  },
  {
    "id": 136,
    "function": "n_minus_of_vertices",
    "file": "Chap06/DirGraphStEph.rs",
    "lines": "191-193",
    "spec_strength": "unknown",
    "snippet": "        fn n_minus_of_vertices(&self, vertices: &SetStEph<V>) -> (in_neighbors: SetStEph<V>)\n            requires wf_graph_view(self@), valid_key_type_Edge::<V>(), vertices@ <= self@.V\n            ensures in_neighbors@ == self.spec_n_minus_of_vertices(vertices@);"
  },
  {
    "id": 137,
    "function": "incident",
    "file": "Chap06/DirGraphStEph.rs",
    "lines": "197-199",
    "spec_strength": "unknown",
    "snippet": "        fn incident(&self, e: &Edge<V>, v: &V) -> (b: B)\n            requires valid_key_type_Edge::<V>()\n            ensures b == (e@.0 == v@ || e@.1 == v@);"
  },
  {
    "id": 138,
    "function": "degree",
    "file": "Chap06/DirGraphStEph.rs",
    "lines": "203-205",
    "spec_strength": "unknown",
    "snippet": "        fn degree(&self, v: &V) -> (n: N)\n            requires wf_graph_view(self@), valid_key_type_Edge::<V>(), self@.V.contains(v@)\n            ensures n == self.spec_degree(v@);"
  },
  {
    "id": 139,
    "function": "in_degree",
    "file": "Chap06/DirGraphStEph.rs",
    "lines": "209-211",
    "spec_strength": "unknown",
    "snippet": "        fn in_degree(&self, v: &V) -> (n: N)\n            requires wf_graph_view(self@), valid_key_type_Edge::<V>(), self@.V.contains(v@)\n            ensures n == self.spec_n_minus(v@).len();"
  },
  {
    "id": 140,
    "function": "out_degree",
    "file": "Chap06/DirGraphStEph.rs",
    "lines": "215-217",
    "spec_strength": "unknown",
    "snippet": "        fn out_degree(&self, v: &V) -> (n: N)\n            requires wf_graph_view(self@), valid_key_type_Edge::<V>(), self@.V.contains(v@)\n            ensures n == self.spec_n_plus(v@).len();"
  },
  {
    "id": 141,
    "function": "iter_vertices",
    "file": "Chap06/DirGraphStEph.rs",
    "lines": "225-226",
    "spec_strength": "unknown",
    "snippet": "        pub fn iter_vertices(&self) -> (it: SetStEphIter<'_, V>)\n            requires valid_key_type_Edge::<V>() "
  },
  {
    "id": 142,
    "function": "iter_arcs",
    "file": "Chap06/DirGraphStEph.rs",
    "lines": "230-231",
    "spec_strength": "unknown",
    "snippet": "        pub fn iter_arcs(&self) -> (it: SetStEphIter<'_, Edge<V>>)\n            requires valid_key_type_Edge::<V>()"
  },
  {
    "id": 143,
    "function": "eq",
    "file": "Chap06/DirGraphStEph.rs",
    "lines": "590-591",
    "spec_strength": "unknown",
    "snippet": "        fn eq(&self, other: &Self) -> (equal: bool)\n            ensures equal == (self@ == other@)"
  },
  {
    "id": 144,
    "function": "empty",
    "file": "Chap06/LabDirGraphMtEph.rs",
    "lines": "95-100",
    "spec_strength": "unknown",
    "snippet": "        fn empty() -> (g: Self)\n            requires valid_key_type_for_lab_graph::<V, L>()\n            ensures\n                wf_lab_graph_view(g@),\n                g@.V == Set::<<V as View>::V>::empty(),\n                g@.A == Set::<(<V as View>::V, <V as View>::V, <L as View>::V)>::empty();"
  },
  {
    "id": 145,
    "function": "from_vertices_and_labeled_arcs",
    "file": "Chap06/LabDirGraphMtEph.rs",
    "lines": "104-114",
    "spec_strength": "unknown",
    "snippet": "        fn from_vertices_and_labeled_arcs(vertices: SetStEph<V>, labeled_arcs: SetStEph<LabEdge<V, L>>) -> (g: Self)\n            requires\n                valid_key_type_for_lab_graph::<V, L>(),\n                vertices@.finite(),\n                labeled_arcs@.finite(),\n                forall |u: V::V, w: V::V, l: L::V|\n                    #[trigger] labeled_arcs@.contains((u, w, l)) ==> vertices@.contains(u) && vertices@.contains(w),\n            ensures\n                wf_lab_graph_view(g@),\n                g@.V == vertices@,\n                g@.A == labeled_arcs@;"
  },
  {
    "id": 146,
    "function": "vertices",
    "file": "Chap06/LabDirGraphMtEph.rs",
    "lines": "118-119",
    "spec_strength": "unknown",
    "snippet": "        fn vertices(&self) -> (v: &SetStEph<V>)\n            ensures v@ == self@.V;"
  },
  {
    "id": 147,
    "function": "labeled_arcs",
    "file": "Chap06/LabDirGraphMtEph.rs",
    "lines": "123-124",
    "spec_strength": "unknown",
    "snippet": "        fn labeled_arcs(&self) -> (a: &SetStEph<LabEdge<V, L>>)\n            ensures a@ == self@.A;"
  },
  {
    "id": 148,
    "function": "arcs",
    "file": "Chap06/LabDirGraphMtEph.rs",
    "lines": "128-131",
    "spec_strength": "unknown",
    "snippet": "        fn arcs(&self) -> (arcs: SetStEph<Edge<V>>)\n            requires wf_lab_graph_view(self@), valid_key_type_for_lab_graph::<V, L>(), valid_key_type_Edge::<V>()\n            ensures forall |u: V::V, w: V::V| arcs@.contains((u, w)) == \n                (exists |l: L::V| #![trigger self@.A.contains((u, w, l))] self@.A.contains((u, w, l)));"
  },
  {
    "id": 149,
    "function": "add_vertex",
    "file": "Chap06/LabDirGraphMtEph.rs",
    "lines": "135-137",
    "spec_strength": "unknown",
    "snippet": "        fn add_vertex(&mut self, v: V)\n            requires wf_lab_graph_view(old(self)@), valid_key_type_for_lab_graph::<V, L>()\n            ensures wf_lab_graph_view(self@), self@.V == old(self)@.V.insert(v@), self@.A == old(self)@.A;"
  },
  {
    "id": 150,
    "function": "add_labeled_arc",
    "file": "Chap06/LabDirGraphMtEph.rs",
    "lines": "141-146",
    "spec_strength": "unknown",
    "snippet": "        fn add_labeled_arc(&mut self, from: V, to: V, label: L)\n            requires wf_lab_graph_view(old(self)@), valid_key_type_for_lab_graph::<V, L>()\n            ensures \n                wf_lab_graph_view(self@),\n                self@.V == old(self)@.V.insert(from@).insert(to@),\n                self@.A == old(self)@.A.insert((from@, to@, label@));"
  },
  {
    "id": 151,
    "function": "get_arc_label",
    "file": "Chap06/LabDirGraphMtEph.rs",
    "lines": "150-155",
    "spec_strength": "unknown",
    "snippet": "        fn get_arc_label(&self, from: &V, to: &V) -> (label: Option<&L>)\n            requires wf_lab_graph_view(self@), valid_key_type_for_lab_graph::<V, L>()\n            ensures match label {\n                Some(l) => self@.A.contains((from@, to@, l@)),\n                None => forall |l: L::V| !self@.A.contains((from@, to@, l)),\n            };"
  },
  {
    "id": 152,
    "function": "has_arc",
    "file": "Chap06/LabDirGraphMtEph.rs",
    "lines": "159-161",
    "spec_strength": "unknown",
    "snippet": "        fn has_arc(&self, from: &V, to: &V) -> (b: bool)\n            requires wf_lab_graph_view(self@), valid_key_type_for_lab_graph::<V, L>()\n            ensures b == (exists |l: L::V| #![trigger self@.A.contains((from@, to@, l))] self@.A.contains((from@, to@, l)));"
  },
  {
    "id": 153,
    "function": "n_plus",
    "file": "Chap06/LabDirGraphMtEph.rs",
    "lines": "194-201",
    "spec_strength": "unknown",
    "snippet": "        fn n_plus(&self, v: &V) -> (n_plus: SetStEph<V>)\n            requires \n                wf_lab_graph_view(self@), \n                valid_key_type_for_lab_graph::<V, L>(),\n                self@.V.contains(v@),\n            ensures \n                n_plus@ == self.spec_n_plus(v@),\n                n_plus@ <= self@.V;"
  },
  {
    "id": 154,
    "function": "n_minus",
    "file": "Chap06/LabDirGraphMtEph.rs",
    "lines": "206-213",
    "spec_strength": "unknown",
    "snippet": "        fn n_minus(&self, v: &V) -> (n_minus: SetStEph<V>)\n            requires \n                wf_lab_graph_view(self@), \n                valid_key_type_for_lab_graph::<V, L>(),\n                self@.V.contains(v@),\n            ensures \n                n_minus@ == self.spec_n_minus(v@),\n                n_minus@ <= self@.V;"
  },
  {
    "id": 155,
    "function": "n_plus_par",
    "file": "Chap06/LabDirGraphMtEph.rs",
    "lines": "220-233",
    "spec_strength": "unknown",
    "snippet": "    fn n_plus_par<V: StTInMtT + Hash + 'static, L: StTInMtT + Hash + 'static>(\n        g: &LabDirGraphMtEph<V, L>, \n        v: V, \n        arcs: SetStEph<LabEdge<V, L>>\n    ) -> (n_plus: SetStEph<V>)\n        requires\n            valid_key_type::<V>(),\n            valid_key_type_LabEdge::<V, L>(),\n            wf_lab_graph_view(g@),\n            arcs@ <= g@.A,\n        ensures \n            n_plus@ == g.spec_n_plus_from_set(v@, arcs@),\n            n_plus@ <= g.spec_n_plus(v@)\n        decreases arcs@.len()"
  },
  {
    "id": 156,
    "function": "n_minus_par",
    "file": "Chap06/LabDirGraphMtEph.rs",
    "lines": "335-348",
    "spec_strength": "unknown",
    "snippet": "    fn n_minus_par<V: StTInMtT + Hash + 'static, L: StTInMtT + Hash + 'static>(\n        g: &LabDirGraphMtEph<V, L>, \n        v: V, \n        arcs: SetStEph<LabEdge<V, L>>\n    ) -> (n_minus: SetStEph<V>)\n        requires\n            valid_key_type::<V>(),\n            valid_key_type_LabEdge::<V, L>(),\n            wf_lab_graph_view(g@),\n            arcs@ <= g@.A,\n        ensures \n            n_minus@ == g.spec_n_minus_from_set(v@, arcs@),\n            n_minus@ <= g.spec_n_minus(v@)\n        decreases arcs@.len()"
  },
  {
    "id": 157,
    "function": "empty",
    "file": "Chap06/LabDirGraphStEph.rs",
    "lines": "70-75",
    "spec_strength": "unknown",
    "snippet": "        fn empty() -> (g: LabDirGraphStEph<V, L>)\n            requires valid_key_type_LabEdge::<V, L>()\n            ensures\n                wf_lab_graph_view(g@),\n                g@.V =~= Set::<<V as View>::V>::empty(),\n                g@.A =~= Set::<(<V as View>::V, <V as View>::V, <L as View>::V)>::empty();"
  },
  {
    "id": 158,
    "function": "from_vertices_and_labeled_arcs",
    "file": "Chap06/LabDirGraphStEph.rs",
    "lines": "79-87",
    "spec_strength": "unknown",
    "snippet": "        fn from_vertices_and_labeled_arcs(vertices: SetStEph<V>, labeled_arcs: SetStEph<LabEdge<V, L>>) -> (g: LabDirGraphStEph<V, L>)\n            requires\n                forall |u: V::V, w: V::V, l: L::V| \n                    #[trigger] labeled_arcs@.contains((u, w, l)) ==> \n                        vertices@.contains(u) && vertices@.contains(w),\n            ensures\n                wf_lab_graph_view(g@),\n                g@.V =~= vertices@,\n                g@.A =~= labeled_arcs@;"
  },
  {
    "id": 159,
    "function": "vertices",
    "file": "Chap06/LabDirGraphStEph.rs",
    "lines": "91-92",
    "spec_strength": "unknown",
    "snippet": "        fn vertices(&self) -> (v: &SetStEph<V>)\n            ensures v@ == self@.V;"
  },
  {
    "id": 160,
    "function": "labeled_arcs",
    "file": "Chap06/LabDirGraphStEph.rs",
    "lines": "96-97",
    "spec_strength": "unknown",
    "snippet": "        fn labeled_arcs(&self) -> (a: &SetStEph<LabEdge<V, L>>)\n            ensures a@ =~= self@.A;"
  },
  {
    "id": 161,
    "function": "arcs",
    "file": "Chap06/LabDirGraphStEph.rs",
    "lines": "101-103",
    "spec_strength": "unknown",
    "snippet": "        fn arcs(&self) -> (arcs: SetStEph<Edge<V>>)\n            requires valid_key_type_LabEdge::<V, L>(), valid_key_type_Edge::<V>()\n            ensures arcs@.finite(), arcs@ == self.spec_arcs();"
  },
  {
    "id": 162,
    "function": "add_vertex",
    "file": "Chap06/LabDirGraphStEph.rs",
    "lines": "107-109",
    "spec_strength": "unknown",
    "snippet": "        fn add_vertex(&mut self, v: V)\n            requires valid_key_type_LabEdge::<V, L>()\n            ensures self@.V == old(self)@.V.insert(v@), self@.A == old(self)@.A;"
  },
  {
    "id": 163,
    "function": "add_labeled_arc",
    "file": "Chap06/LabDirGraphStEph.rs",
    "lines": "113-117",
    "spec_strength": "unknown",
    "snippet": "        fn add_labeled_arc(&mut self, from: V, to: V, label: L)\n            requires valid_key_type_LabEdge::<V, L>()\n            ensures \n                self@.V == old(self)@.V.insert(from@).insert(to@),\n                self@.A == old(self)@.A.insert((from@, to@, label@));"
  },
  {
    "id": 164,
    "function": "get_arc_label",
    "file": "Chap06/LabDirGraphStEph.rs",
    "lines": "121-125",
    "spec_strength": "unknown",
    "snippet": "        fn get_arc_label(&self, from: &V, to: &V) -> (label: Option<&L>)\n            requires wf_lab_graph_view(self@), valid_key_type_LabEdge::<V, L>()\n            ensures \n                label.is_some() == (exists |l: L::V| #![trigger self@.A.contains((from@, to@, l))] self@.A.contains((from@, to@, l))),\n                label.is_some() ==> self@.A.contains((from@, to@, label.unwrap()@));"
  },
  {
    "id": 165,
    "function": "has_arc",
    "file": "Chap06/LabDirGraphStEph.rs",
    "lines": "129-131",
    "spec_strength": "unknown",
    "snippet": "        fn has_arc(&self, from: &V, to: &V) -> (b: bool)\n            requires wf_lab_graph_view(self@), valid_key_type_LabEdge::<V, L>()\n            ensures b == (exists |l: L::V| #![trigger self@.A.contains((from@, to@, l))] self@.A.contains((from@, to@, l)));"
  },
  {
    "id": 166,
    "function": "n_plus",
    "file": "Chap06/LabDirGraphStEph.rs",
    "lines": "136-138",
    "spec_strength": "unknown",
    "snippet": "        fn n_plus(&self, v: &V) -> (n_plus: SetStEph<V>)\n            requires wf_lab_graph_view(self@), valid_key_type_LabEdge::<V, L>()\n            ensures n_plus@.finite(), n_plus@ == self.spec_n_plus(v@);"
  },
  {
    "id": 167,
    "function": "n_minus",
    "file": "Chap06/LabDirGraphStEph.rs",
    "lines": "143-145",
    "spec_strength": "unknown",
    "snippet": "        fn n_minus(&self, v: &V) -> (n_minus: SetStEph<V>)\n            requires wf_lab_graph_view(self@), valid_key_type_LabEdge::<V, L>()\n            ensures n_minus@.finite(), n_minus@ == self.spec_n_minus(v@);"
  },
  {
    "id": 168,
    "function": "empty",
    "file": "Chap06/LabUnDirGraphMtEph.rs",
    "lines": "103-108",
    "spec_strength": "unknown",
    "snippet": "        fn empty() -> (g: Self)\n            requires valid_key_type_for_lab_graph::<V, L>()\n            ensures\n                wf_lab_graph_view(g@),\n                g@.V == Set::<<V as View>::V>::empty(),\n                g@.A == Set::<(<V as View>::V, <V as View>::V, <L as View>::V)>::empty();"
  },
  {
    "id": 169,
    "function": "from_vertices_and_labeled_edges",
    "file": "Chap06/LabUnDirGraphMtEph.rs",
    "lines": "112-122",
    "spec_strength": "unknown",
    "snippet": "        fn from_vertices_and_labeled_edges(vertices: SetStEph<V>, labeled_edges: SetStEph<LabEdge<V, L>>) -> (g: Self)\n            requires\n                valid_key_type_for_lab_graph::<V, L>(),\n                vertices@.finite(),\n                labeled_edges@.finite(),\n                forall |u: V::V, w: V::V, l: L::V|\n                    #[trigger] labeled_edges@.contains((u, w, l)) ==> vertices@.contains(u) && vertices@.contains(w),\n            ensures\n                wf_lab_graph_view(g@),\n                g@.V == vertices@,\n                g@.A == labeled_edges@;"
  },
  {
    "id": 170,
    "function": "vertices",
    "file": "Chap06/LabUnDirGraphMtEph.rs",
    "lines": "126-127",
    "spec_strength": "unknown",
    "snippet": "        fn vertices(&self) -> (v: &SetStEph<V>)\n            ensures v@ == self@.V;"
  },
  {
    "id": 171,
    "function": "labeled_edges",
    "file": "Chap06/LabUnDirGraphMtEph.rs",
    "lines": "131-132",
    "spec_strength": "unknown",
    "snippet": "        fn labeled_edges(&self) -> (e: &SetStEph<LabEdge<V, L>>)\n            ensures e@ == self@.A;"
  },
  {
    "id": 172,
    "function": "edges",
    "file": "Chap06/LabUnDirGraphMtEph.rs",
    "lines": "136-139",
    "spec_strength": "unknown",
    "snippet": "        fn edges(&self) -> (edges: SetStEph<Edge<V>>)\n            requires wf_lab_graph_view(self@), valid_key_type_for_lab_graph::<V, L>(), valid_key_type_Edge::<V>()\n            ensures forall |u: V::V, w: V::V| edges@.contains((u, w)) ==\n                (exists |l: L::V| #![trigger self@.A.contains((u, w, l))] self@.A.contains((u, w, l)));"
  },
  {
    "id": 173,
    "function": "add_vertex",
    "file": "Chap06/LabUnDirGraphMtEph.rs",
    "lines": "143-145",
    "spec_strength": "unknown",
    "snippet": "        fn add_vertex(&mut self, v: V)\n            requires wf_lab_graph_view(old(self)@), valid_key_type_for_lab_graph::<V, L>()\n            ensures wf_lab_graph_view(self@), self@.V == old(self)@.V.insert(v@), self@.A == old(self)@.A;"
  },
  {
    "id": 174,
    "function": "add_labeled_edge",
    "file": "Chap06/LabUnDirGraphMtEph.rs",
    "lines": "149-151",
    "spec_strength": "unknown",
    "snippet": "        fn add_labeled_edge(&mut self, v1: V, v2: V, label: L)\n            requires wf_lab_graph_view(old(self)@), valid_key_type_for_lab_graph::<V, L>()\n            ensures wf_lab_graph_view(self@);"
  },
  {
    "id": 175,
    "function": "get_edge_label",
    "file": "Chap06/LabUnDirGraphMtEph.rs",
    "lines": "155-160",
    "spec_strength": "unknown",
    "snippet": "        fn get_edge_label(&self, v1: &V, v2: &V) -> (label: Option<&L>)\n            requires wf_lab_graph_view(self@), valid_key_type_for_lab_graph::<V, L>()\n            ensures match label {\n                Some(l) => self@.A.contains((v1@, v2@, l@)) || self@.A.contains((v2@, v1@, l@)),\n                None => forall |l: L::V| !self@.A.contains((v1@, v2@, l)) && !self@.A.contains((v2@, v1@, l)),\n            };"
  },
  {
    "id": 176,
    "function": "has_edge",
    "file": "Chap06/LabUnDirGraphMtEph.rs",
    "lines": "164-169",
    "spec_strength": "unknown",
    "snippet": "        fn has_edge(&self, v1: &V, v2: &V) -> (b: bool)\n            requires wf_lab_graph_view(self@), valid_key_type_for_lab_graph::<V, L>()\n            ensures b == (exists |l: L::V| \n                #![trigger self@.A.contains((v1@, v2@, l))] \n                #![trigger self@.A.contains((v2@, v1@, l))]\n                self@.A.contains((v1@, v2@, l)) || self@.A.contains((v2@, v1@, l)));"
  },
  {
    "id": 177,
    "function": "ng",
    "file": "Chap06/LabUnDirGraphMtEph.rs",
    "lines": "179-186",
    "spec_strength": "unknown",
    "snippet": "        fn ng(&self, v: &V) -> (ng: SetStEph<V>)\n            requires\n                wf_lab_graph_view(self@),\n                valid_key_type_for_lab_graph::<V, L>(),\n                self@.V.contains(v@),\n            ensures\n                ng@ == self.spec_ng(v@),\n                ng@ <= self@.V;"
  },
  {
    "id": 178,
    "function": "ng_par",
    "file": "Chap06/LabUnDirGraphMtEph.rs",
    "lines": "193-206",
    "spec_strength": "unknown",
    "snippet": "    fn ng_par<V: StTInMtT + Hash + Ord + 'static, L: StTInMtT + Hash + 'static>(\n        g: &LabUnDirGraphMtEph<V, L>, \n        v: V, \n        edges: SetStEph<LabEdge<V, L>>\n    ) -> (neighbors: SetStEph<V>)\n        requires\n            valid_key_type::<V>(),\n            valid_key_type_LabEdge::<V, L>(),\n            wf_lab_graph_view(g@),\n            edges@ <= g@.A,\n        ensures \n            neighbors@ == g.spec_ng_from_set(v@, edges@),\n            neighbors@ <= g.spec_ng(v@)\n        decreases edges@.len()"
  },
  {
    "id": 179,
    "function": "empty",
    "file": "Chap06/LabUnDirGraphStEph.rs",
    "lines": "64-69",
    "spec_strength": "unknown",
    "snippet": "        fn empty() -> (g: LabUnDirGraphStEph<V, L>)\n            requires valid_key_type_LabEdge::<V, L>()\n            ensures\n                wf_lab_graph_view(g@),\n                g@.V =~= Set::<<V as View>::V>::empty(),\n                g@.A =~= Set::<(<V as View>::V, <V as View>::V, <L as View>::V)>::empty();"
  },
  {
    "id": 180,
    "function": "from_vertices_and_labeled_edges",
    "file": "Chap06/LabUnDirGraphStEph.rs",
    "lines": "73-81",
    "spec_strength": "unknown",
    "snippet": "        fn from_vertices_and_labeled_edges(vertices: SetStEph<V>, labeled_edges: SetStEph<LabEdge<V, L>>) -> (g: LabUnDirGraphStEph<V, L>)\n            requires\n                forall |u: V::V, w: V::V, l: L::V| \n                    #[trigger] labeled_edges@.contains((u, w, l)) ==> \n                        vertices@.contains(u) && vertices@.contains(w),\n            ensures\n                wf_lab_graph_view(g@),\n                g@.V =~= vertices@,\n                g@.A =~= labeled_edges@;"
  },
  {
    "id": 181,
    "function": "vertices",
    "file": "Chap06/LabUnDirGraphStEph.rs",
    "lines": "85-86",
    "spec_strength": "unknown",
    "snippet": "        fn vertices(&self) -> (v: &SetStEph<V>)\n            ensures v@ == self@.V;"
  },
  {
    "id": 182,
    "function": "labeled_edges",
    "file": "Chap06/LabUnDirGraphStEph.rs",
    "lines": "90-91",
    "spec_strength": "unknown",
    "snippet": "        fn labeled_edges(&self) -> (e: &SetStEph<LabEdge<V, L>>)\n            ensures e@ =~= self@.A;"
  },
  {
    "id": 183,
    "function": "edges",
    "file": "Chap06/LabUnDirGraphStEph.rs",
    "lines": "95-98",
    "spec_strength": "unknown",
    "snippet": "        fn edges(&self) -> (edges: SetStEph<Edge<V>>)\n            requires valid_key_type_LabEdge::<V, L>(), valid_key_type_Edge::<V>()\n            ensures \n                forall |e: (V::V, V::V)| edges@.contains(e) == (exists |l: L::V| #![trigger self@.A.contains((e.0, e.1, l))] self@.A.contains((e.0, e.1, l)));"
  },
  {
    "id": 184,
    "function": "add_vertex",
    "file": "Chap06/LabUnDirGraphStEph.rs",
    "lines": "102-104",
    "spec_strength": "unknown",
    "snippet": "        fn add_vertex(&mut self, v: V)\n            requires valid_key_type_LabEdge::<V, L>()\n            ensures self@.V == old(self)@.V.insert(v@), self@.A == old(self)@.A;"
  },
  {
    "id": 185,
    "function": "add_labeled_edge",
    "file": "Chap06/LabUnDirGraphStEph.rs",
    "lines": "108-113",
    "spec_strength": "unknown",
    "snippet": "        fn add_labeled_edge(&mut self, v1: V, v2: V, label: L)\n            requires valid_key_type_LabEdge::<V, L>()\n            ensures \n                self@.V == old(self)@.V.insert(v1@).insert(v2@),\n                self@.A == old(self)@.A.insert((v1@, v2@, label@)) || \n                self@.A == old(self)@.A.insert((v2@, v1@, label@));"
  },
  {
    "id": 186,
    "function": "get_edge_label",
    "file": "Chap06/LabUnDirGraphStEph.rs",
    "lines": "117-123",
    "spec_strength": "unknown",
    "snippet": "        fn get_edge_label(&self, v1: &V, v2: &V) -> (label: Option<&L>)\n            requires wf_lab_graph_view(self@), valid_key_type_LabEdge::<V, L>()\n            ensures \n                label.is_some() == (exists |l: L::V| \n                    self@.A.contains((v1@, v2@, l)) || self@.A.contains((v2@, v1@, l))),\n                label.is_some() ==> (self@.A.contains((v1@, v2@, label.unwrap()@)) || \n                                      self@.A.contains((v2@, v1@, label.unwrap()@)));"
  },
  {
    "id": 187,
    "function": "has_edge",
    "file": "Chap06/LabUnDirGraphStEph.rs",
    "lines": "127-130",
    "spec_strength": "unknown",
    "snippet": "        fn has_edge(&self, v1: &V, v2: &V) -> (b: bool)\n            requires wf_lab_graph_view(self@), valid_key_type_LabEdge::<V, L>()\n            ensures b == (exists |l: L::V| \n                self@.A.contains((v1@, v2@, l)) || self@.A.contains((v2@, v1@, l)));"
  },
  {
    "id": 188,
    "function": "ng",
    "file": "Chap06/LabUnDirGraphStEph.rs",
    "lines": "134-136",
    "spec_strength": "unknown",
    "snippet": "        fn ng(&self, v: &V) -> (ng: SetStEph<V>)\n            requires wf_lab_graph_view(self@), valid_key_type_LabEdge::<V, L>()\n            ensures ng@ == self.spec_ng(v@);"
  },
  {
    "id": 189,
    "function": "empty",
    "file": "Chap06/UnDirGraphMtEph.rs",
    "lines": "108-113",
    "spec_strength": "unknown",
    "snippet": "        fn empty() -> (g: Self)\n            requires valid_key_type_for_graph::<V>()\n            ensures \n                wf_graph_view(g@),\n                g@.V == Set::<<V as View>::V>::empty(), \n                g@.A == Set::<(<V as View>::V, <V as View>::V)>::empty();"
  },
  {
    "id": 190,
    "function": "from_sets",
    "file": "Chap06/UnDirGraphMtEph.rs",
    "lines": "117-127",
    "spec_strength": "unknown",
    "snippet": "        fn from_sets(V: SetStEph<V>, E: SetStEph<Edge<V>>) -> (g: Self)\n            requires \n                valid_key_type_for_graph::<V>(),\n                V@.finite(),\n                E@.finite(),\n                forall |u: V::V, w: V::V| \n                    #[trigger] E@.contains((u, w)) ==> V@.contains(u) && V@.contains(w),\n            ensures \n                wf_graph_view(g@),\n                g@.V == V@, \n                g@.A == E@;"
  },
  {
    "id": 191,
    "function": "vertices",
    "file": "Chap06/UnDirGraphMtEph.rs",
    "lines": "131-132",
    "spec_strength": "unknown",
    "snippet": "        fn vertices(&self) -> (v: &SetStEph<V>)\n            ensures v@ == self@.V;"
  },
  {
    "id": 192,
    "function": "edges",
    "file": "Chap06/UnDirGraphMtEph.rs",
    "lines": "136-137",
    "spec_strength": "unknown",
    "snippet": "        fn edges(&self) -> (e: &SetStEph<Edge<V>>)\n            ensures e@ == self@.A;"
  },
  {
    "id": 193,
    "function": "sizeV",
    "file": "Chap06/UnDirGraphMtEph.rs",
    "lines": "141-142",
    "spec_strength": "unknown",
    "snippet": "        fn sizeV(&self) -> (n: N)\n            ensures n == self@.V.len();"
  },
  {
    "id": 194,
    "function": "sizeE",
    "file": "Chap06/UnDirGraphMtEph.rs",
    "lines": "146-147",
    "spec_strength": "unknown",
    "snippet": "        fn sizeE(&self) -> (n: N)\n            ensures n == self@.A.len();"
  },
  {
    "id": 195,
    "function": "neighbor",
    "file": "Chap06/UnDirGraphMtEph.rs",
    "lines": "151-157",
    "spec_strength": "unknown",
    "snippet": "        fn neighbor(&self, u: &V, v: &V) -> (b: B)\n            requires \n                wf_graph_view(self@),\n                valid_key_type_for_graph::<V>(),\n                self@.V.contains(u@),\n                self@.V.contains(v@),\n            ensures b == (self@.A.contains((u@, v@)) || self@.A.contains((v@, u@)));"
  },
  {
    "id": 196,
    "function": "ng",
    "file": "Chap06/UnDirGraphMtEph.rs",
    "lines": "167-174",
    "spec_strength": "unknown",
    "snippet": "        fn ng(&self, v: &V) -> (neighbors: SetStEph<V>)\n            requires \n                wf_graph_view(self@),\n                valid_key_type_for_graph::<V>(),\n                self@.V.contains(v@),\n            ensures \n                neighbors@ == self.spec_ng(v@),\n                neighbors@ <= self@.V;"
  },
  {
    "id": 197,
    "function": "ng_of_vertices",
    "file": "Chap06/UnDirGraphMtEph.rs",
    "lines": "184-191",
    "spec_strength": "unknown",
    "snippet": "        fn ng_of_vertices(&self, u_set: &SetStEph<V>) -> (neighbors: SetStEph<V>)\n            requires \n                wf_graph_view(self@),\n                valid_key_type_for_graph::<V>(),\n                u_set@ <= self@.V,\n            ensures \n                neighbors@ == self.spec_ng_of_vertices(u_set@),\n                neighbors@ <= self@.V;"
  },
  {
    "id": 198,
    "function": "incident",
    "file": "Chap06/UnDirGraphMtEph.rs",
    "lines": "195-197",
    "spec_strength": "unknown",
    "snippet": "        fn incident(&self, e: &Edge<V>, v: &V) -> (b: B)\n            requires valid_key_type_for_graph::<V>()\n            ensures b == (e@.0 == v@ || e@.1 == v@);"
  },
  {
    "id": 199,
    "function": "degree",
    "file": "Chap06/UnDirGraphMtEph.rs",
    "lines": "201-206",
    "spec_strength": "unknown",
    "snippet": "        fn degree(&self, v: &V) -> (n: N)\n            requires \n                wf_graph_view(self@),\n                valid_key_type_for_graph::<V>(),\n                self@.V.contains(v@),\n            ensures n == self.spec_ng(v@).len();"
  },
  {
    "id": 200,
    "function": "ng_par",
    "file": "Chap06/UnDirGraphMtEph.rs",
    "lines": "213-223",
    "spec_strength": "unknown",
    "snippet": "    fn ng_par<V: StTInMtT + Hash + 'static>(g: &UnDirGraphMtEph<V>, v: V, edges: SetStEph<Edge<V>>) \n                                                  -> (neighbors: SetStEph<V>)\n        requires\n            valid_key_type::<V>(),\n            valid_key_type::<Edge<V>>(),\n            wf_graph_view(g@),\n            edges@ <= g@.A,\n        ensures \n            neighbors@ == g.spec_ng_from_set(v@, edges@),\n            neighbors@ <= g.spec_ng(v@)\n        decreases edges@.len()"
  },
  {
    "id": 201,
    "function": "ng_of_vertices_par",
    "file": "Chap06/UnDirGraphMtEph.rs",
    "lines": "310-322",
    "spec_strength": "unknown",
    "snippet": "    fn ng_of_vertices_par<V: StTInMtT + Hash + 'static>(\n        g: &UnDirGraphMtEph<V>,\n        verts: SetStEph<V>,\n    ) -> (neighbors: SetStEph<V>)\n        requires \n            valid_key_type::<V>(),\n            valid_key_type::<Edge<V>>(),\n            wf_graph_view(g@),\n            verts@ <= g@.V,\n        ensures \n            neighbors@ == g.spec_ng_of_vertices_from_set(verts@),\n            neighbors@ <= g@.V\n        decreases verts@.len()"
  },
  {
    "id": 202,
    "function": "eq",
    "file": "Chap06/UnDirGraphMtEph.rs",
    "lines": "478-479",
    "spec_strength": "unknown",
    "snippet": "        fn eq(&self, other: &Self) -> (equal: bool)\n            ensures equal == (self@ == other@)"
  },
  {
    "id": 203,
    "function": "empty",
    "file": "Chap06/UnDirGraphStEph.rs",
    "lines": "93-98",
    "spec_strength": "unknown",
    "snippet": "        fn empty() -> (g: UnDirGraphStEph<V>)\n            requires valid_key_type_Edge::<V>()\n            ensures\n                wf_graph_view(g@),\n                g@.V =~= Set::<<V as View>::V>::empty(),\n                g@.A =~= Set::<(<V as View>::V, <V as View>::V)>::empty();"
  },
  {
    "id": 204,
    "function": "from_sets",
    "file": "Chap06/UnDirGraphStEph.rs",
    "lines": "101-108",
    "spec_strength": "unknown",
    "snippet": "        fn from_sets(vertices: SetStEph<V>, edges: SetStEph<Edge<V>>) -> (g: UnDirGraphStEph<V>)\n            requires\n                forall |u: V::V, w: V::V| \n                    #[trigger] edges@.contains((u, w)) ==> vertices@.contains(u) && vertices@.contains(w),\n            ensures\n                wf_graph_view(g@),\n                g@.V =~= vertices@,\n                g@.A =~= edges@;"
  },
  {
    "id": 205,
    "function": "vertices",
    "file": "Chap06/UnDirGraphStEph.rs",
    "lines": "112-113",
    "spec_strength": "unknown",
    "snippet": "        fn vertices(&self) -> (v: &SetStEph<V>)\n            ensures v@ == self@.V;"
  },
  {
    "id": 206,
    "function": "edges",
    "file": "Chap06/UnDirGraphStEph.rs",
    "lines": "117-118",
    "spec_strength": "unknown",
    "snippet": "        fn edges(&self) -> (e: &SetStEph<Edge<V>>)\n            ensures e@ =~= self@.A;"
  },
  {
    "id": 207,
    "function": "sizeV",
    "file": "Chap06/UnDirGraphStEph.rs",
    "lines": "122-124",
    "spec_strength": "unknown",
    "snippet": "        fn sizeV(&self) -> (n: N)\n            requires valid_key_type_Edge::<V>()\n            ensures n == self@.V.len();"
  },
  {
    "id": 208,
    "function": "sizeE",
    "file": "Chap06/UnDirGraphStEph.rs",
    "lines": "128-130",
    "spec_strength": "unknown",
    "snippet": "        fn sizeE(&self) -> (n: N)\n            requires valid_key_type_Edge::<V>()\n            ensures n == self@.A.len();"
  },
  {
    "id": 209,
    "function": "neighbor",
    "file": "Chap06/UnDirGraphStEph.rs",
    "lines": "133-139",
    "spec_strength": "unknown",
    "snippet": "        fn neighbor(&self, u: &V, v: &V) -> (b: B)\n            requires \n                wf_graph_view(self@),\n                valid_key_type_Edge::<V>(),\n                self@.V.contains(u@),\n                self@.V.contains(v@),\n            ensures b == (self@.A.contains((u@, v@)) || self@.A.contains((v@, u@)));"
  },
  {
    "id": 210,
    "function": "ng",
    "file": "Chap06/UnDirGraphStEph.rs",
    "lines": "142-149",
    "spec_strength": "unknown",
    "snippet": "        fn ng(&self, v: &V) -> (neighbors: SetStEph<V>)\n            requires \n                wf_graph_view(self@),\n                valid_key_type_Edge::<V>(),\n                self@.V.contains(v@),\n            ensures \n                neighbors@ == self.spec_ng(v@),\n                neighbors@ <= self@.V;"
  },
  {
    "id": 211,
    "function": "ng_of_vertices",
    "file": "Chap06/UnDirGraphStEph.rs",
    "lines": "152-159",
    "spec_strength": "unknown",
    "snippet": "        fn ng_of_vertices(&self, vertices: &SetStEph<V>) -> (neighbors: SetStEph<V>)\n            requires \n                wf_graph_view(self@),\n                valid_key_type_Edge::<V>(),\n                vertices@ <= self@.V,\n            ensures \n                neighbors@ == self.spec_ng_of_vertices(vertices@),\n                neighbors@ <= self@.V;"
  },
  {
    "id": 212,
    "function": "incident",
    "file": "Chap06/UnDirGraphStEph.rs",
    "lines": "162-164",
    "spec_strength": "unknown",
    "snippet": "        fn incident(&self, e: &Edge<V>, v: &V) -> (b: B)\n            requires valid_key_type_Edge::<V>()\n            ensures b == (e@.0 == v@ || e@.1 == v@);"
  },
  {
    "id": 213,
    "function": "degree",
    "file": "Chap06/UnDirGraphStEph.rs",
    "lines": "167-172",
    "spec_strength": "unknown",
    "snippet": "        fn degree(&self, v: &V) -> (n: N)\n            requires \n                wf_graph_view(self@),\n                valid_key_type_Edge::<V>(),\n                self@.V.contains(v@),\n            ensures n == self.spec_degree(v@);"
  },
  {
    "id": 214,
    "function": "eq",
    "file": "Chap06/UnDirGraphStEph.rs",
    "lines": "356-357",
    "spec_strength": "unknown",
    "snippet": "        fn eq(&self, other: &Self) -> (equal: bool)\n            ensures equal == (self@ == other@)"
  },
  {
    "id": 215,
    "function": "from_weighed_edges",
    "file": "Chap06/WeightedDirGraphStEphI128.rs",
    "lines": "42-48",
    "spec_strength": "unknown",
    "snippet": "        fn from_weighed_edges(vertices: SetStEph<V>, edges: SetStEph<WeightedEdge<V, i128>>) -> (g: WeightedDirGraphStEphI128<V>)\n            requires \n                valid_key_type_WeightedEdge::<V, i128>(),\n                forall |u: V::V, w: V::V, weight: i128| \n                    #[trigger] edges@.contains((u, w, weight)) ==> \n                        vertices@.contains(u) && vertices@.contains(w),\n            ensures wf_lab_graph_view(g@), g@.V =~= vertices@;"
  },
  {
    "id": 216,
    "function": "add_weighed_edge",
    "file": "Chap06/WeightedDirGraphStEphI128.rs",
    "lines": "51-55",
    "spec_strength": "unknown",
    "snippet": "        fn add_weighed_edge(&mut self, from: V, to: V, weight: i128)\n            requires valid_key_type_WeightedEdge::<V, i128>()\n            ensures \n                self@.V == old(self)@.V.insert(from@).insert(to@),\n                self@.A == old(self)@.A.insert((from@, to@, weight));"
  },
  {
    "id": 217,
    "function": "get_edge_weight",
    "file": "Chap06/WeightedDirGraphStEphI128.rs",
    "lines": "58-62",
    "spec_strength": "unknown",
    "snippet": "        fn get_edge_weight(&self, from: &V, to: &V) -> (weight: Option<i128>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, i128>()\n            ensures \n                weight.is_some() == (exists |w: i128| #![trigger self@.A.contains((from@, to@, w))] self@.A.contains((from@, to@, w))),\n                weight.is_some() ==> self@.A.contains((from@, to@, weight.unwrap()));"
  },
  {
    "id": 218,
    "function": "weighed_edges",
    "file": "Chap06/WeightedDirGraphStEphI128.rs",
    "lines": "65-68",
    "spec_strength": "unknown",
    "snippet": "        fn weighed_edges(&self) -> (weighed_edges: SetStEph<WeightedEdge<V, i128>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, i128>()\n            ensures \n                forall |t: (V::V, V::V, i128)| #[trigger] weighed_edges@.contains(t) == self@.A.contains(t);"
  },
  {
    "id": 219,
    "function": "out_neighbors_weighed",
    "file": "Chap06/WeightedDirGraphStEphI128.rs",
    "lines": "71-75",
    "spec_strength": "unknown",
    "snippet": "        fn out_neighbors_weighed(&self, v: &V) -> (out_neighbors: SetStEph<Pair<V, i128>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, i128>()\n            ensures \n                forall |p: (V::V, i128)| out_neighbors@.contains(p) == \n                    (exists |w: i128| #![trigger self@.A.contains((v@, p.0, w))] self@.A.contains((v@, p.0, w)) && p.1 == w);"
  },
  {
    "id": 220,
    "function": "in_neighbors_weighed",
    "file": "Chap06/WeightedDirGraphStEphI128.rs",
    "lines": "78-82",
    "spec_strength": "unknown",
    "snippet": "        fn in_neighbors_weighed(&self, v: &V) -> (in_neighbors: SetStEph<Pair<V, i128>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, i128>()\n            ensures \n                forall |p: (V::V, i128)| in_neighbors@.contains(p) == \n                    (exists |w: i128| #![trigger self@.A.contains((p.0, v@, w))] self@.A.contains((p.0, v@, w)) && p.1 == w);"
  },
  {
    "id": 221,
    "function": "total_weight",
    "file": "Chap06/WeightedDirGraphStEphI128.rs",
    "lines": "85-87",
    "spec_strength": "unknown",
    "snippet": "        fn total_weight(&self) -> (total_weight: CheckedI128)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, i128>()\n            ensures total_weight@ == self.spec_total_weight();"
  },
  {
    "id": 222,
    "function": "edges_above_weight",
    "file": "Chap06/WeightedDirGraphStEphI128.rs",
    "lines": "89-93",
    "spec_strength": "unknown",
    "snippet": "        fn edges_above_weight(&self, threshold: i128) -> (edges_above: SetStEph<WeightedEdge<V, i128>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, i128>()\n            ensures \n                forall |t: (V::V, V::V, i128)| #[trigger] edges_above@.contains(t) == \n                    (self@.A.contains(t) && t.2 > threshold);"
  },
  {
    "id": 223,
    "function": "edges_below_weight",
    "file": "Chap06/WeightedDirGraphStEphI128.rs",
    "lines": "95-99",
    "spec_strength": "unknown",
    "snippet": "        fn edges_below_weight(&self, threshold: i128) -> (edges_below: SetStEph<WeightedEdge<V, i128>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, i128>()\n            ensures \n                forall |t: (V::V, V::V, i128)| #[trigger] edges_below@.contains(t) == \n                    (self@.A.contains(t) && t.2 < threshold);"
  },
  {
    "id": 224,
    "function": "from_weighed_edges",
    "file": "Chap06/WeightedDirGraphStEphI16.rs",
    "lines": "42-48",
    "spec_strength": "unknown",
    "snippet": "        fn from_weighed_edges(vertices: SetStEph<V>, edges: SetStEph<WeightedEdge<V, i16>>) -> (g: WeightedDirGraphStEphI16<V>)\n            requires \n                valid_key_type_WeightedEdge::<V, i16>(),\n                forall |u: V::V, w: V::V, weight: i16| \n                    #[trigger] edges@.contains((u, w, weight)) ==> \n                        vertices@.contains(u) && vertices@.contains(w),\n            ensures wf_lab_graph_view(g@), g@.V =~= vertices@;"
  },
  {
    "id": 225,
    "function": "add_weighed_edge",
    "file": "Chap06/WeightedDirGraphStEphI16.rs",
    "lines": "51-55",
    "spec_strength": "unknown",
    "snippet": "        fn add_weighed_edge(&mut self, from: V, to: V, weight: i16)\n            requires valid_key_type_WeightedEdge::<V, i16>()\n            ensures \n                self@.V == old(self)@.V.insert(from@).insert(to@),\n                self@.A == old(self)@.A.insert((from@, to@, weight));"
  },
  {
    "id": 226,
    "function": "get_edge_weight",
    "file": "Chap06/WeightedDirGraphStEphI16.rs",
    "lines": "58-62",
    "spec_strength": "unknown",
    "snippet": "        fn get_edge_weight(&self, from: &V, to: &V) -> (weight: Option<i16>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, i16>()\n            ensures \n                weight.is_some() == (exists |w: i16| #![trigger self@.A.contains((from@, to@, w))] self@.A.contains((from@, to@, w))),\n                weight.is_some() ==> self@.A.contains((from@, to@, weight.unwrap()));"
  },
  {
    "id": 227,
    "function": "weighed_edges",
    "file": "Chap06/WeightedDirGraphStEphI16.rs",
    "lines": "65-68",
    "spec_strength": "unknown",
    "snippet": "        fn weighed_edges(&self) -> (weighed_edges: SetStEph<WeightedEdge<V, i16>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, i16>()\n            ensures \n                forall |t: (V::V, V::V, i16)| #[trigger] weighed_edges@.contains(t) == self@.A.contains(t);"
  },
  {
    "id": 228,
    "function": "out_neighbors_weighed",
    "file": "Chap06/WeightedDirGraphStEphI16.rs",
    "lines": "71-75",
    "spec_strength": "unknown",
    "snippet": "        fn out_neighbors_weighed(&self, v: &V) -> (out_neighbors: SetStEph<Pair<V, i16>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, i16>()\n            ensures \n                forall |p: (V::V, i16)| out_neighbors@.contains(p) == \n                    (exists |w: i16| #![trigger self@.A.contains((v@, p.0, w))] self@.A.contains((v@, p.0, w)) && p.1 == w);"
  },
  {
    "id": 229,
    "function": "in_neighbors_weighed",
    "file": "Chap06/WeightedDirGraphStEphI16.rs",
    "lines": "78-82",
    "spec_strength": "unknown",
    "snippet": "        fn in_neighbors_weighed(&self, v: &V) -> (in_neighbors: SetStEph<Pair<V, i16>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, i16>()\n            ensures \n                forall |p: (V::V, i16)| in_neighbors@.contains(p) == \n                    (exists |w: i16| #![trigger self@.A.contains((p.0, v@, w))] self@.A.contains((p.0, v@, w)) && p.1 == w);"
  },
  {
    "id": 230,
    "function": "total_weight",
    "file": "Chap06/WeightedDirGraphStEphI16.rs",
    "lines": "85-87",
    "spec_strength": "unknown",
    "snippet": "        fn total_weight(&self) -> (total_weight: CheckedI16)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, i16>()\n            ensures total_weight@ == self.spec_total_weight();"
  },
  {
    "id": 231,
    "function": "edges_above_weight",
    "file": "Chap06/WeightedDirGraphStEphI16.rs",
    "lines": "89-93",
    "spec_strength": "unknown",
    "snippet": "        fn edges_above_weight(&self, threshold: i16) -> (edges_above: SetStEph<WeightedEdge<V, i16>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, i16>()\n            ensures \n                forall |t: (V::V, V::V, i16)| #[trigger] edges_above@.contains(t) == \n                    (self@.A.contains(t) && t.2 > threshold);"
  },
  {
    "id": 232,
    "function": "edges_below_weight",
    "file": "Chap06/WeightedDirGraphStEphI16.rs",
    "lines": "95-99",
    "spec_strength": "unknown",
    "snippet": "        fn edges_below_weight(&self, threshold: i16) -> (edges_below: SetStEph<WeightedEdge<V, i16>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, i16>()\n            ensures \n                forall |t: (V::V, V::V, i16)| #[trigger] edges_below@.contains(t) == \n                    (self@.A.contains(t) && t.2 < threshold);"
  },
  {
    "id": 233,
    "function": "from_weighed_edges",
    "file": "Chap06/WeightedDirGraphStEphI32.rs",
    "lines": "42-48",
    "spec_strength": "unknown",
    "snippet": "        fn from_weighed_edges(vertices: SetStEph<V>, edges: SetStEph<WeightedEdge<V, i32>>) -> (g: WeightedDirGraphStEphI32<V>)\n            requires \n                valid_key_type_WeightedEdge::<V, i32>(),\n                forall |u: V::V, w: V::V, weight: i32| \n                    #[trigger] edges@.contains((u, w, weight)) ==> \n                        vertices@.contains(u) && vertices@.contains(w),\n            ensures wf_lab_graph_view(g@), g@.V =~= vertices@;"
  },
  {
    "id": 234,
    "function": "add_weighed_edge",
    "file": "Chap06/WeightedDirGraphStEphI32.rs",
    "lines": "51-55",
    "spec_strength": "unknown",
    "snippet": "        fn add_weighed_edge(&mut self, from: V, to: V, weight: i32)\n            requires valid_key_type_WeightedEdge::<V, i32>()\n            ensures \n                self@.V == old(self)@.V.insert(from@).insert(to@),\n                self@.A == old(self)@.A.insert((from@, to@, weight));"
  },
  {
    "id": 235,
    "function": "get_edge_weight",
    "file": "Chap06/WeightedDirGraphStEphI32.rs",
    "lines": "58-62",
    "spec_strength": "unknown",
    "snippet": "        fn get_edge_weight(&self, from: &V, to: &V) -> (weight: Option<i32>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, i32>()\n            ensures \n                weight.is_some() == (exists |w: i32| #![trigger self@.A.contains((from@, to@, w))] self@.A.contains((from@, to@, w))),\n                weight.is_some() ==> self@.A.contains((from@, to@, weight.unwrap()));"
  },
  {
    "id": 236,
    "function": "weighed_edges",
    "file": "Chap06/WeightedDirGraphStEphI32.rs",
    "lines": "65-68",
    "spec_strength": "unknown",
    "snippet": "        fn weighed_edges(&self) -> (weighed_edges: SetStEph<WeightedEdge<V, i32>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, i32>()\n            ensures \n                forall |t: (V::V, V::V, i32)| #[trigger] weighed_edges@.contains(t) == self@.A.contains(t);"
  },
  {
    "id": 237,
    "function": "out_neighbors_weighed",
    "file": "Chap06/WeightedDirGraphStEphI32.rs",
    "lines": "71-75",
    "spec_strength": "unknown",
    "snippet": "        fn out_neighbors_weighed(&self, v: &V) -> (out_neighbors: SetStEph<Pair<V, i32>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, i32>()\n            ensures \n                forall |p: (V::V, i32)| out_neighbors@.contains(p) == \n                    (exists |w: i32| #![trigger self@.A.contains((v@, p.0, w))] self@.A.contains((v@, p.0, w)) && p.1 == w);"
  },
  {
    "id": 238,
    "function": "in_neighbors_weighed",
    "file": "Chap06/WeightedDirGraphStEphI32.rs",
    "lines": "78-82",
    "spec_strength": "unknown",
    "snippet": "        fn in_neighbors_weighed(&self, v: &V) -> (in_neighbors: SetStEph<Pair<V, i32>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, i32>()\n            ensures \n                forall |p: (V::V, i32)| in_neighbors@.contains(p) == \n                    (exists |w: i32| #![trigger self@.A.contains((p.0, v@, w))] self@.A.contains((p.0, v@, w)) && p.1 == w);"
  },
  {
    "id": 239,
    "function": "total_weight",
    "file": "Chap06/WeightedDirGraphStEphI32.rs",
    "lines": "85-87",
    "spec_strength": "unknown",
    "snippet": "        fn total_weight(&self) -> (total_weight: CheckedI32)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, i32>()\n            ensures total_weight@ == self.spec_total_weight();"
  },
  {
    "id": 240,
    "function": "edges_above_weight",
    "file": "Chap06/WeightedDirGraphStEphI32.rs",
    "lines": "89-93",
    "spec_strength": "unknown",
    "snippet": "        fn edges_above_weight(&self, threshold: i32) -> (edges_above: SetStEph<WeightedEdge<V, i32>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, i32>()\n            ensures \n                forall |t: (V::V, V::V, i32)| #[trigger] edges_above@.contains(t) == \n                    (self@.A.contains(t) && t.2 > threshold);"
  },
  {
    "id": 241,
    "function": "edges_below_weight",
    "file": "Chap06/WeightedDirGraphStEphI32.rs",
    "lines": "95-99",
    "spec_strength": "unknown",
    "snippet": "        fn edges_below_weight(&self, threshold: i32) -> (edges_below: SetStEph<WeightedEdge<V, i32>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, i32>()\n            ensures \n                forall |t: (V::V, V::V, i32)| #[trigger] edges_below@.contains(t) == \n                    (self@.A.contains(t) && t.2 < threshold);"
  },
  {
    "id": 242,
    "function": "from_weighed_edges",
    "file": "Chap06/WeightedDirGraphStEphI64.rs",
    "lines": "42-48",
    "spec_strength": "unknown",
    "snippet": "        fn from_weighed_edges(vertices: SetStEph<V>, edges: SetStEph<WeightedEdge<V, i64>>) -> (g: WeightedDirGraphStEphI64<V>)\n            requires \n                valid_key_type_WeightedEdge::<V, i64>(),\n                forall |u: V::V, w: V::V, weight: i64| \n                    #[trigger] edges@.contains((u, w, weight)) ==> \n                        vertices@.contains(u) && vertices@.contains(w),\n            ensures wf_lab_graph_view(g@), g@.V =~= vertices@;"
  },
  {
    "id": 243,
    "function": "add_weighed_edge",
    "file": "Chap06/WeightedDirGraphStEphI64.rs",
    "lines": "51-55",
    "spec_strength": "unknown",
    "snippet": "        fn add_weighed_edge(&mut self, from: V, to: V, weight: i64)\n            requires valid_key_type_WeightedEdge::<V, i64>()\n            ensures \n                self@.V == old(self)@.V.insert(from@).insert(to@),\n                self@.A == old(self)@.A.insert((from@, to@, weight));"
  },
  {
    "id": 244,
    "function": "get_edge_weight",
    "file": "Chap06/WeightedDirGraphStEphI64.rs",
    "lines": "58-62",
    "spec_strength": "unknown",
    "snippet": "        fn get_edge_weight(&self, from: &V, to: &V) -> (weight: Option<i64>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, i64>()\n            ensures \n                weight.is_some() == (exists |w: i64| #![trigger self@.A.contains((from@, to@, w))] self@.A.contains((from@, to@, w))),\n                weight.is_some() ==> self@.A.contains((from@, to@, weight.unwrap()));"
  },
  {
    "id": 245,
    "function": "weighed_edges",
    "file": "Chap06/WeightedDirGraphStEphI64.rs",
    "lines": "65-68",
    "spec_strength": "unknown",
    "snippet": "        fn weighed_edges(&self) -> (weighed_edges: SetStEph<WeightedEdge<V, i64>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, i64>()\n            ensures \n                forall |t: (V::V, V::V, i64)| #[trigger] weighed_edges@.contains(t) == self@.A.contains(t);"
  },
  {
    "id": 246,
    "function": "out_neighbors_weighed",
    "file": "Chap06/WeightedDirGraphStEphI64.rs",
    "lines": "71-75",
    "spec_strength": "unknown",
    "snippet": "        fn out_neighbors_weighed(&self, v: &V) -> (out_neighbors: SetStEph<Pair<V, i64>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, i64>()\n            ensures \n                forall |p: (V::V, i64)| out_neighbors@.contains(p) == \n                    (exists |w: i64| #![trigger self@.A.contains((v@, p.0, w))] self@.A.contains((v@, p.0, w)) && p.1 == w);"
  },
  {
    "id": 247,
    "function": "in_neighbors_weighed",
    "file": "Chap06/WeightedDirGraphStEphI64.rs",
    "lines": "78-82",
    "spec_strength": "unknown",
    "snippet": "        fn in_neighbors_weighed(&self, v: &V) -> (in_neighbors: SetStEph<Pair<V, i64>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, i64>()\n            ensures \n                forall |p: (V::V, i64)| in_neighbors@.contains(p) == \n                    (exists |w: i64| #![trigger self@.A.contains((p.0, v@, w))] self@.A.contains((p.0, v@, w)) && p.1 == w);"
  },
  {
    "id": 248,
    "function": "total_weight",
    "file": "Chap06/WeightedDirGraphStEphI64.rs",
    "lines": "85-87",
    "spec_strength": "unknown",
    "snippet": "        fn total_weight(&self) -> (total_weight: CheckedI64)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, i64>()\n            ensures total_weight@ == self.spec_total_weight();"
  },
  {
    "id": 249,
    "function": "edges_above_weight",
    "file": "Chap06/WeightedDirGraphStEphI64.rs",
    "lines": "89-93",
    "spec_strength": "unknown",
    "snippet": "        fn edges_above_weight(&self, threshold: i64) -> (edges_above: SetStEph<WeightedEdge<V, i64>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, i64>()\n            ensures \n                forall |t: (V::V, V::V, i64)| #[trigger] edges_above@.contains(t) == \n                    (self@.A.contains(t) && t.2 > threshold);"
  },
  {
    "id": 250,
    "function": "edges_below_weight",
    "file": "Chap06/WeightedDirGraphStEphI64.rs",
    "lines": "95-99",
    "spec_strength": "unknown",
    "snippet": "        fn edges_below_weight(&self, threshold: i64) -> (edges_below: SetStEph<WeightedEdge<V, i64>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, i64>()\n            ensures \n                forall |t: (V::V, V::V, i64)| #[trigger] edges_below@.contains(t) == \n                    (self@.A.contains(t) && t.2 < threshold);"
  },
  {
    "id": 251,
    "function": "from_weighed_edges",
    "file": "Chap06/WeightedDirGraphStEphI8.rs",
    "lines": "42-48",
    "spec_strength": "unknown",
    "snippet": "        fn from_weighed_edges(vertices: SetStEph<V>, edges: SetStEph<WeightedEdge<V, i8>>) -> (g: WeightedDirGraphStEphI8<V>)\n            requires \n                valid_key_type_WeightedEdge::<V, i8>(),\n                forall |u: V::V, w: V::V, weight: i8| \n                    #[trigger] edges@.contains((u, w, weight)) ==> \n                        vertices@.contains(u) && vertices@.contains(w),\n            ensures wf_lab_graph_view(g@), g@.V =~= vertices@;"
  },
  {
    "id": 252,
    "function": "add_weighed_edge",
    "file": "Chap06/WeightedDirGraphStEphI8.rs",
    "lines": "51-55",
    "spec_strength": "unknown",
    "snippet": "        fn add_weighed_edge(&mut self, from: V, to: V, weight: i8)\n            requires valid_key_type_WeightedEdge::<V, i8>()\n            ensures \n                self@.V == old(self)@.V.insert(from@).insert(to@),\n                self@.A == old(self)@.A.insert((from@, to@, weight));"
  },
  {
    "id": 253,
    "function": "get_edge_weight",
    "file": "Chap06/WeightedDirGraphStEphI8.rs",
    "lines": "58-62",
    "spec_strength": "unknown",
    "snippet": "        fn get_edge_weight(&self, from: &V, to: &V) -> (weight: Option<i8>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, i8>()\n            ensures \n                weight.is_some() == (exists |w: i8| #![trigger self@.A.contains((from@, to@, w))] self@.A.contains((from@, to@, w))),\n                weight.is_some() ==> self@.A.contains((from@, to@, weight.unwrap()));"
  },
  {
    "id": 254,
    "function": "weighed_edges",
    "file": "Chap06/WeightedDirGraphStEphI8.rs",
    "lines": "65-68",
    "spec_strength": "unknown",
    "snippet": "        fn weighed_edges(&self) -> (weighed_edges: SetStEph<WeightedEdge<V, i8>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, i8>()\n            ensures \n                forall |t: (V::V, V::V, i8)| #[trigger] weighed_edges@.contains(t) == self@.A.contains(t);"
  },
  {
    "id": 255,
    "function": "out_neighbors_weighed",
    "file": "Chap06/WeightedDirGraphStEphI8.rs",
    "lines": "71-75",
    "spec_strength": "unknown",
    "snippet": "        fn out_neighbors_weighed(&self, v: &V) -> (out_neighbors: SetStEph<Pair<V, i8>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, i8>()\n            ensures \n                forall |p: (V::V, i8)| out_neighbors@.contains(p) == \n                    (exists |w: i8| #![trigger self@.A.contains((v@, p.0, w))] self@.A.contains((v@, p.0, w)) && p.1 == w);"
  },
  {
    "id": 256,
    "function": "in_neighbors_weighed",
    "file": "Chap06/WeightedDirGraphStEphI8.rs",
    "lines": "78-82",
    "spec_strength": "unknown",
    "snippet": "        fn in_neighbors_weighed(&self, v: &V) -> (in_neighbors: SetStEph<Pair<V, i8>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, i8>()\n            ensures \n                forall |p: (V::V, i8)| in_neighbors@.contains(p) == \n                    (exists |w: i8| #![trigger self@.A.contains((p.0, v@, w))] self@.A.contains((p.0, v@, w)) && p.1 == w);"
  },
  {
    "id": 257,
    "function": "total_weight",
    "file": "Chap06/WeightedDirGraphStEphI8.rs",
    "lines": "85-87",
    "spec_strength": "unknown",
    "snippet": "        fn total_weight(&self) -> (total_weight: CheckedI8)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, i8>()\n            ensures total_weight@ == self.spec_total_weight();"
  },
  {
    "id": 258,
    "function": "edges_above_weight",
    "file": "Chap06/WeightedDirGraphStEphI8.rs",
    "lines": "89-93",
    "spec_strength": "unknown",
    "snippet": "        fn edges_above_weight(&self, threshold: i8) -> (edges_above: SetStEph<WeightedEdge<V, i8>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, i8>()\n            ensures \n                forall |t: (V::V, V::V, i8)| #[trigger] edges_above@.contains(t) == \n                    (self@.A.contains(t) && t.2 > threshold);"
  },
  {
    "id": 259,
    "function": "edges_below_weight",
    "file": "Chap06/WeightedDirGraphStEphI8.rs",
    "lines": "95-99",
    "spec_strength": "unknown",
    "snippet": "        fn edges_below_weight(&self, threshold: i8) -> (edges_below: SetStEph<WeightedEdge<V, i8>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, i8>()\n            ensures \n                forall |t: (V::V, V::V, i8)| #[trigger] edges_below@.contains(t) == \n                    (self@.A.contains(t) && t.2 < threshold);"
  },
  {
    "id": 260,
    "function": "from_weighed_edges",
    "file": "Chap06/WeightedDirGraphStEphIsize.rs",
    "lines": "42-48",
    "spec_strength": "unknown",
    "snippet": "        fn from_weighed_edges(vertices: SetStEph<V>, edges: SetStEph<WeightedEdge<V, isize>>) -> (g: WeightedDirGraphStEphIsize<V>)\n            requires \n                valid_key_type_WeightedEdge::<V, isize>(),\n                forall |u: V::V, w: V::V, weight: isize| \n                    #[trigger] edges@.contains((u, w, weight)) ==> \n                        vertices@.contains(u) && vertices@.contains(w),\n            ensures wf_lab_graph_view(g@), g@.V =~= vertices@;"
  },
  {
    "id": 261,
    "function": "add_weighed_edge",
    "file": "Chap06/WeightedDirGraphStEphIsize.rs",
    "lines": "51-55",
    "spec_strength": "unknown",
    "snippet": "        fn add_weighed_edge(&mut self, from: V, to: V, weight: isize)\n            requires valid_key_type_WeightedEdge::<V, isize>()\n            ensures \n                self@.V == old(self)@.V.insert(from@).insert(to@),\n                self@.A == old(self)@.A.insert((from@, to@, weight));"
  },
  {
    "id": 262,
    "function": "get_edge_weight",
    "file": "Chap06/WeightedDirGraphStEphIsize.rs",
    "lines": "58-62",
    "spec_strength": "unknown",
    "snippet": "        fn get_edge_weight(&self, from: &V, to: &V) -> (weight: Option<isize>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, isize>()\n            ensures \n                weight.is_some() == (exists |w: isize| #![trigger self@.A.contains((from@, to@, w))] self@.A.contains((from@, to@, w))),\n                weight.is_some() ==> self@.A.contains((from@, to@, weight.unwrap()));"
  },
  {
    "id": 263,
    "function": "weighed_edges",
    "file": "Chap06/WeightedDirGraphStEphIsize.rs",
    "lines": "65-68",
    "spec_strength": "unknown",
    "snippet": "        fn weighed_edges(&self) -> (weighed_edges: SetStEph<WeightedEdge<V, isize>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, isize>()\n            ensures \n                forall |t: (V::V, V::V, isize)| #[trigger] weighed_edges@.contains(t) == self@.A.contains(t);"
  },
  {
    "id": 264,
    "function": "out_neighbors_weighed",
    "file": "Chap06/WeightedDirGraphStEphIsize.rs",
    "lines": "71-75",
    "spec_strength": "unknown",
    "snippet": "        fn out_neighbors_weighed(&self, v: &V) -> (out_neighbors: SetStEph<Pair<V, isize>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, isize>()\n            ensures \n                forall |p: (V::V, isize)| out_neighbors@.contains(p) == \n                    (exists |w: isize| #![trigger self@.A.contains((v@, p.0, w))] self@.A.contains((v@, p.0, w)) && p.1 == w);"
  },
  {
    "id": 265,
    "function": "in_neighbors_weighed",
    "file": "Chap06/WeightedDirGraphStEphIsize.rs",
    "lines": "78-82",
    "spec_strength": "unknown",
    "snippet": "        fn in_neighbors_weighed(&self, v: &V) -> (in_neighbors: SetStEph<Pair<V, isize>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, isize>()\n            ensures \n                forall |p: (V::V, isize)| in_neighbors@.contains(p) == \n                    (exists |w: isize| #![trigger self@.A.contains((p.0, v@, w))] self@.A.contains((p.0, v@, w)) && p.1 == w);"
  },
  {
    "id": 266,
    "function": "total_weight",
    "file": "Chap06/WeightedDirGraphStEphIsize.rs",
    "lines": "85-87",
    "spec_strength": "unknown",
    "snippet": "        fn total_weight(&self) -> (total_weight: CheckedIsize)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, isize>()\n            ensures total_weight@ == self.spec_total_weight();"
  },
  {
    "id": 267,
    "function": "edges_above_weight",
    "file": "Chap06/WeightedDirGraphStEphIsize.rs",
    "lines": "89-93",
    "spec_strength": "unknown",
    "snippet": "        fn edges_above_weight(&self, threshold: isize) -> (edges_above: SetStEph<WeightedEdge<V, isize>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, isize>()\n            ensures \n                forall |t: (V::V, V::V, isize)| #[trigger] edges_above@.contains(t) == \n                    (self@.A.contains(t) && t.2 > threshold);"
  },
  {
    "id": 268,
    "function": "edges_below_weight",
    "file": "Chap06/WeightedDirGraphStEphIsize.rs",
    "lines": "95-99",
    "spec_strength": "unknown",
    "snippet": "        fn edges_below_weight(&self, threshold: isize) -> (edges_below: SetStEph<WeightedEdge<V, isize>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, isize>()\n            ensures \n                forall |t: (V::V, V::V, isize)| #[trigger] edges_below@.contains(t) == \n                    (self@.A.contains(t) && t.2 < threshold);"
  },
  {
    "id": 269,
    "function": "from_weighed_edges",
    "file": "Chap06/WeightedDirGraphStEphU128.rs",
    "lines": "42-48",
    "spec_strength": "unknown",
    "snippet": "        fn from_weighed_edges(vertices: SetStEph<V>, edges: SetStEph<WeightedEdge<V, u128>>) -> (g: WeightedDirGraphStEphU128<V>)\n            requires \n                valid_key_type_WeightedEdge::<V, u128>(),\n                forall |u: V::V, w: V::V, weight: u128| \n                    #[trigger] edges@.contains((u, w, weight)) ==> \n                        vertices@.contains(u) && vertices@.contains(w),\n            ensures wf_lab_graph_view(g@), g@.V =~= vertices@;"
  },
  {
    "id": 270,
    "function": "add_weighed_edge",
    "file": "Chap06/WeightedDirGraphStEphU128.rs",
    "lines": "51-55",
    "spec_strength": "unknown",
    "snippet": "        fn add_weighed_edge(&mut self, from: V, to: V, weight: u128)\n            requires valid_key_type_WeightedEdge::<V, u128>()\n            ensures \n                self@.V == old(self)@.V.insert(from@).insert(to@),\n                self@.A == old(self)@.A.insert((from@, to@, weight));"
  },
  {
    "id": 271,
    "function": "get_edge_weight",
    "file": "Chap06/WeightedDirGraphStEphU128.rs",
    "lines": "58-62",
    "spec_strength": "unknown",
    "snippet": "        fn get_edge_weight(&self, from: &V, to: &V) -> (weight: Option<u128>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, u128>()\n            ensures \n                weight.is_some() == (exists |w: u128| #![trigger self@.A.contains((from@, to@, w))] self@.A.contains((from@, to@, w))),\n                weight.is_some() ==> self@.A.contains((from@, to@, weight.unwrap()));"
  },
  {
    "id": 272,
    "function": "weighed_edges",
    "file": "Chap06/WeightedDirGraphStEphU128.rs",
    "lines": "65-68",
    "spec_strength": "unknown",
    "snippet": "        fn weighed_edges(&self) -> (weighed_edges: SetStEph<WeightedEdge<V, u128>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, u128>()\n            ensures \n                forall |t: (V::V, V::V, u128)| #[trigger] weighed_edges@.contains(t) == self@.A.contains(t);"
  },
  {
    "id": 273,
    "function": "out_neighbors_weighed",
    "file": "Chap06/WeightedDirGraphStEphU128.rs",
    "lines": "71-75",
    "spec_strength": "unknown",
    "snippet": "        fn out_neighbors_weighed(&self, v: &V) -> (out_neighbors: SetStEph<Pair<V, u128>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, u128>()\n            ensures \n                forall |p: (V::V, u128)| out_neighbors@.contains(p) == \n                    (exists |w: u128| #![trigger self@.A.contains((v@, p.0, w))] self@.A.contains((v@, p.0, w)) && p.1 == w);"
  },
  {
    "id": 274,
    "function": "in_neighbors_weighed",
    "file": "Chap06/WeightedDirGraphStEphU128.rs",
    "lines": "78-82",
    "spec_strength": "unknown",
    "snippet": "        fn in_neighbors_weighed(&self, v: &V) -> (in_neighbors: SetStEph<Pair<V, u128>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, u128>()\n            ensures \n                forall |p: (V::V, u128)| in_neighbors@.contains(p) == \n                    (exists |w: u128| #![trigger self@.A.contains((p.0, v@, w))] self@.A.contains((p.0, v@, w)) && p.1 == w);"
  },
  {
    "id": 275,
    "function": "total_weight",
    "file": "Chap06/WeightedDirGraphStEphU128.rs",
    "lines": "85-87",
    "spec_strength": "unknown",
    "snippet": "        fn total_weight(&self) -> (total_weight: CheckedU128)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, u128>()\n            ensures total_weight@ == self.spec_total_weight() as int;"
  },
  {
    "id": 276,
    "function": "edges_above_weight",
    "file": "Chap06/WeightedDirGraphStEphU128.rs",
    "lines": "89-93",
    "spec_strength": "unknown",
    "snippet": "        fn edges_above_weight(&self, threshold: u128) -> (edges_above: SetStEph<WeightedEdge<V, u128>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, u128>()\n            ensures \n                forall |t: (V::V, V::V, u128)| #[trigger] edges_above@.contains(t) == \n                    (self@.A.contains(t) && t.2 > threshold);"
  },
  {
    "id": 277,
    "function": "edges_below_weight",
    "file": "Chap06/WeightedDirGraphStEphU128.rs",
    "lines": "95-99",
    "spec_strength": "unknown",
    "snippet": "        fn edges_below_weight(&self, threshold: u128) -> (edges_below: SetStEph<WeightedEdge<V, u128>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, u128>()\n            ensures \n                forall |t: (V::V, V::V, u128)| #[trigger] edges_below@.contains(t) == \n                    (self@.A.contains(t) && t.2 < threshold);"
  },
  {
    "id": 278,
    "function": "from_weighed_edges",
    "file": "Chap06/WeightedDirGraphStEphU16.rs",
    "lines": "42-48",
    "spec_strength": "unknown",
    "snippet": "        fn from_weighed_edges(vertices: SetStEph<V>, edges: SetStEph<WeightedEdge<V, u16>>) -> (g: WeightedDirGraphStEphU16<V>)\n            requires \n                valid_key_type_WeightedEdge::<V, u16>(),\n                forall |u: V::V, w: V::V, weight: u16| \n                    #[trigger] edges@.contains((u, w, weight)) ==> \n                        vertices@.contains(u) && vertices@.contains(w),\n            ensures wf_lab_graph_view(g@), g@.V =~= vertices@;"
  },
  {
    "id": 279,
    "function": "add_weighed_edge",
    "file": "Chap06/WeightedDirGraphStEphU16.rs",
    "lines": "51-55",
    "spec_strength": "unknown",
    "snippet": "        fn add_weighed_edge(&mut self, from: V, to: V, weight: u16)\n            requires valid_key_type_WeightedEdge::<V, u16>()\n            ensures \n                self@.V == old(self)@.V.insert(from@).insert(to@),\n                self@.A == old(self)@.A.insert((from@, to@, weight));"
  },
  {
    "id": 280,
    "function": "get_edge_weight",
    "file": "Chap06/WeightedDirGraphStEphU16.rs",
    "lines": "58-62",
    "spec_strength": "unknown",
    "snippet": "        fn get_edge_weight(&self, from: &V, to: &V) -> (weight: Option<u16>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, u16>()\n            ensures \n                weight.is_some() == (exists |w: u16| #![trigger self@.A.contains((from@, to@, w))] self@.A.contains((from@, to@, w))),\n                weight.is_some() ==> self@.A.contains((from@, to@, weight.unwrap()));"
  },
  {
    "id": 281,
    "function": "weighed_edges",
    "file": "Chap06/WeightedDirGraphStEphU16.rs",
    "lines": "65-68",
    "spec_strength": "unknown",
    "snippet": "        fn weighed_edges(&self) -> (weighed_edges: SetStEph<WeightedEdge<V, u16>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, u16>()\n            ensures \n                forall |t: (V::V, V::V, u16)| #[trigger] weighed_edges@.contains(t) == self@.A.contains(t);"
  },
  {
    "id": 282,
    "function": "out_neighbors_weighed",
    "file": "Chap06/WeightedDirGraphStEphU16.rs",
    "lines": "71-75",
    "spec_strength": "unknown",
    "snippet": "        fn out_neighbors_weighed(&self, v: &V) -> (out_neighbors: SetStEph<Pair<V, u16>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, u16>()\n            ensures \n                forall |p: (V::V, u16)| out_neighbors@.contains(p) == \n                    (exists |w: u16| #![trigger self@.A.contains((v@, p.0, w))] self@.A.contains((v@, p.0, w)) && p.1 == w);"
  },
  {
    "id": 283,
    "function": "in_neighbors_weighed",
    "file": "Chap06/WeightedDirGraphStEphU16.rs",
    "lines": "78-82",
    "spec_strength": "unknown",
    "snippet": "        fn in_neighbors_weighed(&self, v: &V) -> (in_neighbors: SetStEph<Pair<V, u16>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, u16>()\n            ensures \n                forall |p: (V::V, u16)| in_neighbors@.contains(p) == \n                    (exists |w: u16| #![trigger self@.A.contains((p.0, v@, w))] self@.A.contains((p.0, v@, w)) && p.1 == w);"
  },
  {
    "id": 284,
    "function": "total_weight",
    "file": "Chap06/WeightedDirGraphStEphU16.rs",
    "lines": "85-87",
    "spec_strength": "unknown",
    "snippet": "        fn total_weight(&self) -> (total_weight: CheckedU16)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, u16>()\n            ensures total_weight@ == self.spec_total_weight() as int;"
  },
  {
    "id": 285,
    "function": "edges_above_weight",
    "file": "Chap06/WeightedDirGraphStEphU16.rs",
    "lines": "89-93",
    "spec_strength": "unknown",
    "snippet": "        fn edges_above_weight(&self, threshold: u16) -> (edges_above: SetStEph<WeightedEdge<V, u16>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, u16>()\n            ensures \n                forall |t: (V::V, V::V, u16)| #[trigger] edges_above@.contains(t) == \n                    (self@.A.contains(t) && t.2 > threshold);"
  },
  {
    "id": 286,
    "function": "edges_below_weight",
    "file": "Chap06/WeightedDirGraphStEphU16.rs",
    "lines": "95-99",
    "spec_strength": "unknown",
    "snippet": "        fn edges_below_weight(&self, threshold: u16) -> (edges_below: SetStEph<WeightedEdge<V, u16>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, u16>()\n            ensures \n                forall |t: (V::V, V::V, u16)| #[trigger] edges_below@.contains(t) == \n                    (self@.A.contains(t) && t.2 < threshold);"
  },
  {
    "id": 287,
    "function": "from_weighed_edges",
    "file": "Chap06/WeightedDirGraphStEphU32.rs",
    "lines": "42-48",
    "spec_strength": "unknown",
    "snippet": "        fn from_weighed_edges(vertices: SetStEph<V>, edges: SetStEph<WeightedEdge<V, u32>>) -> (g: WeightedDirGraphStEphU32<V>)\n            requires \n                valid_key_type_WeightedEdge::<V, u32>(),\n                forall |u: V::V, w: V::V, weight: u32| \n                    #[trigger] edges@.contains((u, w, weight)) ==> \n                        vertices@.contains(u) && vertices@.contains(w),\n            ensures wf_lab_graph_view(g@), g@.V =~= vertices@;"
  },
  {
    "id": 288,
    "function": "add_weighed_edge",
    "file": "Chap06/WeightedDirGraphStEphU32.rs",
    "lines": "51-55",
    "spec_strength": "unknown",
    "snippet": "        fn add_weighed_edge(&mut self, from: V, to: V, weight: u32)\n            requires valid_key_type_WeightedEdge::<V, u32>()\n            ensures \n                self@.V == old(self)@.V.insert(from@).insert(to@),\n                self@.A == old(self)@.A.insert((from@, to@, weight));"
  },
  {
    "id": 289,
    "function": "get_edge_weight",
    "file": "Chap06/WeightedDirGraphStEphU32.rs",
    "lines": "58-62",
    "spec_strength": "unknown",
    "snippet": "        fn get_edge_weight(&self, from: &V, to: &V) -> (weight: Option<u32>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, u32>()\n            ensures \n                weight.is_some() == (exists |w: u32| #![trigger self@.A.contains((from@, to@, w))] self@.A.contains((from@, to@, w))),\n                weight.is_some() ==> self@.A.contains((from@, to@, weight.unwrap()));"
  },
  {
    "id": 290,
    "function": "weighed_edges",
    "file": "Chap06/WeightedDirGraphStEphU32.rs",
    "lines": "65-68",
    "spec_strength": "unknown",
    "snippet": "        fn weighed_edges(&self) -> (weighed_edges: SetStEph<WeightedEdge<V, u32>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, u32>()\n            ensures \n                forall |t: (V::V, V::V, u32)| #[trigger] weighed_edges@.contains(t) == self@.A.contains(t);"
  },
  {
    "id": 291,
    "function": "out_neighbors_weighed",
    "file": "Chap06/WeightedDirGraphStEphU32.rs",
    "lines": "71-75",
    "spec_strength": "unknown",
    "snippet": "        fn out_neighbors_weighed(&self, v: &V) -> (out_neighbors: SetStEph<Pair<V, u32>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, u32>()\n            ensures \n                forall |p: (V::V, u32)| out_neighbors@.contains(p) == \n                    (exists |w: u32| #![trigger self@.A.contains((v@, p.0, w))] self@.A.contains((v@, p.0, w)) && p.1 == w);"
  },
  {
    "id": 292,
    "function": "in_neighbors_weighed",
    "file": "Chap06/WeightedDirGraphStEphU32.rs",
    "lines": "78-82",
    "spec_strength": "unknown",
    "snippet": "        fn in_neighbors_weighed(&self, v: &V) -> (in_neighbors: SetStEph<Pair<V, u32>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, u32>()\n            ensures \n                forall |p: (V::V, u32)| in_neighbors@.contains(p) == \n                    (exists |w: u32| #![trigger self@.A.contains((p.0, v@, w))] self@.A.contains((p.0, v@, w)) && p.1 == w);"
  },
  {
    "id": 293,
    "function": "total_weight",
    "file": "Chap06/WeightedDirGraphStEphU32.rs",
    "lines": "85-87",
    "spec_strength": "unknown",
    "snippet": "        fn total_weight(&self) -> (total_weight: CheckedU32)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, u32>()\n            ensures total_weight@ == self.spec_total_weight() as int;"
  },
  {
    "id": 294,
    "function": "edges_above_weight",
    "file": "Chap06/WeightedDirGraphStEphU32.rs",
    "lines": "89-93",
    "spec_strength": "unknown",
    "snippet": "        fn edges_above_weight(&self, threshold: u32) -> (edges_above: SetStEph<WeightedEdge<V, u32>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, u32>()\n            ensures \n                forall |t: (V::V, V::V, u32)| #[trigger] edges_above@.contains(t) == \n                    (self@.A.contains(t) && t.2 > threshold);"
  },
  {
    "id": 295,
    "function": "edges_below_weight",
    "file": "Chap06/WeightedDirGraphStEphU32.rs",
    "lines": "95-99",
    "spec_strength": "unknown",
    "snippet": "        fn edges_below_weight(&self, threshold: u32) -> (edges_below: SetStEph<WeightedEdge<V, u32>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, u32>()\n            ensures \n                forall |t: (V::V, V::V, u32)| #[trigger] edges_below@.contains(t) == \n                    (self@.A.contains(t) && t.2 < threshold);"
  },
  {
    "id": 296,
    "function": "from_weighed_edges",
    "file": "Chap06/WeightedDirGraphStEphU64.rs",
    "lines": "42-48",
    "spec_strength": "unknown",
    "snippet": "        fn from_weighed_edges(vertices: SetStEph<V>, edges: SetStEph<WeightedEdge<V, u64>>) -> (g: WeightedDirGraphStEphU64<V>)\n            requires \n                valid_key_type_WeightedEdge::<V, u64>(),\n                forall |u: V::V, w: V::V, weight: u64| \n                    #[trigger] edges@.contains((u, w, weight)) ==> \n                        vertices@.contains(u) && vertices@.contains(w),\n            ensures wf_lab_graph_view(g@), g@.V =~= vertices@;"
  },
  {
    "id": 297,
    "function": "add_weighed_edge",
    "file": "Chap06/WeightedDirGraphStEphU64.rs",
    "lines": "51-55",
    "spec_strength": "unknown",
    "snippet": "        fn add_weighed_edge(&mut self, from: V, to: V, weight: u64)\n            requires valid_key_type_WeightedEdge::<V, u64>()\n            ensures \n                self@.V == old(self)@.V.insert(from@).insert(to@),\n                self@.A == old(self)@.A.insert((from@, to@, weight));"
  },
  {
    "id": 298,
    "function": "get_edge_weight",
    "file": "Chap06/WeightedDirGraphStEphU64.rs",
    "lines": "58-62",
    "spec_strength": "unknown",
    "snippet": "        fn get_edge_weight(&self, from: &V, to: &V) -> (weight: Option<u64>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, u64>()\n            ensures \n                weight.is_some() == (exists |w: u64| #![trigger self@.A.contains((from@, to@, w))] self@.A.contains((from@, to@, w))),\n                weight.is_some() ==> self@.A.contains((from@, to@, weight.unwrap()));"
  },
  {
    "id": 299,
    "function": "weighed_edges",
    "file": "Chap06/WeightedDirGraphStEphU64.rs",
    "lines": "65-68",
    "spec_strength": "unknown",
    "snippet": "        fn weighed_edges(&self) -> (weighed_edges: SetStEph<WeightedEdge<V, u64>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, u64>()\n            ensures \n                forall |t: (V::V, V::V, u64)| #[trigger] weighed_edges@.contains(t) == self@.A.contains(t);"
  },
  {
    "id": 300,
    "function": "out_neighbors_weighed",
    "file": "Chap06/WeightedDirGraphStEphU64.rs",
    "lines": "71-75",
    "spec_strength": "unknown",
    "snippet": "        fn out_neighbors_weighed(&self, v: &V) -> (out_neighbors: SetStEph<Pair<V, u64>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, u64>()\n            ensures \n                forall |p: (V::V, u64)| out_neighbors@.contains(p) == \n                    (exists |w: u64| #![trigger self@.A.contains((v@, p.0, w))] self@.A.contains((v@, p.0, w)) && p.1 == w);"
  },
  {
    "id": 301,
    "function": "in_neighbors_weighed",
    "file": "Chap06/WeightedDirGraphStEphU64.rs",
    "lines": "78-82",
    "spec_strength": "unknown",
    "snippet": "        fn in_neighbors_weighed(&self, v: &V) -> (in_neighbors: SetStEph<Pair<V, u64>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, u64>()\n            ensures \n                forall |p: (V::V, u64)| in_neighbors@.contains(p) == \n                    (exists |w: u64| #![trigger self@.A.contains((p.0, v@, w))] self@.A.contains((p.0, v@, w)) && p.1 == w);"
  },
  {
    "id": 302,
    "function": "total_weight",
    "file": "Chap06/WeightedDirGraphStEphU64.rs",
    "lines": "85-87",
    "spec_strength": "unknown",
    "snippet": "        fn total_weight(&self) -> (total_weight: CheckedU64)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, u64>()\n            ensures total_weight@ == self.spec_total_weight() as int;"
  },
  {
    "id": 303,
    "function": "edges_above_weight",
    "file": "Chap06/WeightedDirGraphStEphU64.rs",
    "lines": "89-93",
    "spec_strength": "unknown",
    "snippet": "        fn edges_above_weight(&self, threshold: u64) -> (edges_above: SetStEph<WeightedEdge<V, u64>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, u64>()\n            ensures \n                forall |t: (V::V, V::V, u64)| #[trigger] edges_above@.contains(t) == \n                    (self@.A.contains(t) && t.2 > threshold);"
  },
  {
    "id": 304,
    "function": "edges_below_weight",
    "file": "Chap06/WeightedDirGraphStEphU64.rs",
    "lines": "95-99",
    "spec_strength": "unknown",
    "snippet": "        fn edges_below_weight(&self, threshold: u64) -> (edges_below: SetStEph<WeightedEdge<V, u64>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, u64>()\n            ensures \n                forall |t: (V::V, V::V, u64)| #[trigger] edges_below@.contains(t) == \n                    (self@.A.contains(t) && t.2 < threshold);"
  },
  {
    "id": 305,
    "function": "from_weighed_edges",
    "file": "Chap06/WeightedDirGraphStEphU8.rs",
    "lines": "42-48",
    "spec_strength": "unknown",
    "snippet": "        fn from_weighed_edges(vertices: SetStEph<V>, edges: SetStEph<WeightedEdge<V, u8>>) -> (g: WeightedDirGraphStEphU8<V>)\n            requires \n                valid_key_type_WeightedEdge::<V, u8>(),\n                forall |u: V::V, w: V::V, weight: u8| \n                    #[trigger] edges@.contains((u, w, weight)) ==> \n                        vertices@.contains(u) && vertices@.contains(w),\n            ensures wf_lab_graph_view(g@), g@.V =~= vertices@;"
  },
  {
    "id": 306,
    "function": "add_weighed_edge",
    "file": "Chap06/WeightedDirGraphStEphU8.rs",
    "lines": "51-55",
    "spec_strength": "unknown",
    "snippet": "        fn add_weighed_edge(&mut self, from: V, to: V, weight: u8)\n            requires valid_key_type_WeightedEdge::<V, u8>()\n            ensures \n                self@.V == old(self)@.V.insert(from@).insert(to@),\n                self@.A == old(self)@.A.insert((from@, to@, weight));"
  },
  {
    "id": 307,
    "function": "get_edge_weight",
    "file": "Chap06/WeightedDirGraphStEphU8.rs",
    "lines": "58-62",
    "spec_strength": "unknown",
    "snippet": "        fn get_edge_weight(&self, from: &V, to: &V) -> (weight: Option<u8>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, u8>()\n            ensures \n                weight.is_some() == (exists |w: u8| #![trigger self@.A.contains((from@, to@, w))] self@.A.contains((from@, to@, w))),\n                weight.is_some() ==> self@.A.contains((from@, to@, weight.unwrap()));"
  },
  {
    "id": 308,
    "function": "weighed_edges",
    "file": "Chap06/WeightedDirGraphStEphU8.rs",
    "lines": "65-68",
    "spec_strength": "unknown",
    "snippet": "        fn weighed_edges(&self) -> (weighed_edges: SetStEph<WeightedEdge<V, u8>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, u8>()\n            ensures \n                forall |t: (V::V, V::V, u8)| #[trigger] weighed_edges@.contains(t) == self@.A.contains(t);"
  },
  {
    "id": 309,
    "function": "out_neighbors_weighed",
    "file": "Chap06/WeightedDirGraphStEphU8.rs",
    "lines": "71-75",
    "spec_strength": "unknown",
    "snippet": "        fn out_neighbors_weighed(&self, v: &V) -> (out_neighbors: SetStEph<Pair<V, u8>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, u8>()\n            ensures \n                forall |p: (V::V, u8)| out_neighbors@.contains(p) == \n                    (exists |w: u8| #![trigger self@.A.contains((v@, p.0, w))] self@.A.contains((v@, p.0, w)) && p.1 == w);"
  },
  {
    "id": 310,
    "function": "in_neighbors_weighed",
    "file": "Chap06/WeightedDirGraphStEphU8.rs",
    "lines": "78-82",
    "spec_strength": "unknown",
    "snippet": "        fn in_neighbors_weighed(&self, v: &V) -> (in_neighbors: SetStEph<Pair<V, u8>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, u8>()\n            ensures \n                forall |p: (V::V, u8)| in_neighbors@.contains(p) == \n                    (exists |w: u8| #![trigger self@.A.contains((p.0, v@, w))] self@.A.contains((p.0, v@, w)) && p.1 == w);"
  },
  {
    "id": 311,
    "function": "total_weight",
    "file": "Chap06/WeightedDirGraphStEphU8.rs",
    "lines": "85-87",
    "spec_strength": "unknown",
    "snippet": "        fn total_weight(&self) -> (total_weight: CheckedU8)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, u8>()\n            ensures total_weight@ == self.spec_total_weight() as int;"
  },
  {
    "id": 312,
    "function": "edges_above_weight",
    "file": "Chap06/WeightedDirGraphStEphU8.rs",
    "lines": "89-93",
    "spec_strength": "unknown",
    "snippet": "        fn edges_above_weight(&self, threshold: u8) -> (edges_above: SetStEph<WeightedEdge<V, u8>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, u8>()\n            ensures \n                forall |t: (V::V, V::V, u8)| #[trigger] edges_above@.contains(t) == \n                    (self@.A.contains(t) && t.2 > threshold);"
  },
  {
    "id": 313,
    "function": "edges_below_weight",
    "file": "Chap06/WeightedDirGraphStEphU8.rs",
    "lines": "95-99",
    "spec_strength": "unknown",
    "snippet": "        fn edges_below_weight(&self, threshold: u8) -> (edges_below: SetStEph<WeightedEdge<V, u8>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, u8>()\n            ensures \n                forall |t: (V::V, V::V, u8)| #[trigger] edges_below@.contains(t) == \n                    (self@.A.contains(t) && t.2 < threshold);"
  },
  {
    "id": 314,
    "function": "from_weighed_edges",
    "file": "Chap06/WeightedDirGraphStEphUsize.rs",
    "lines": "42-48",
    "spec_strength": "unknown",
    "snippet": "        fn from_weighed_edges(vertices: SetStEph<V>, edges: SetStEph<WeightedEdge<V, usize>>) -> (g: WeightedDirGraphStEphUsize<V>)\n            requires \n                valid_key_type_WeightedEdge::<V, usize>(),\n                forall |u: V::V, w: V::V, weight: usize| \n                    #[trigger] edges@.contains((u, w, weight)) ==> \n                        vertices@.contains(u) && vertices@.contains(w),\n            ensures wf_lab_graph_view(g@), g@.V =~= vertices@;"
  },
  {
    "id": 315,
    "function": "add_weighed_edge",
    "file": "Chap06/WeightedDirGraphStEphUsize.rs",
    "lines": "51-55",
    "spec_strength": "unknown",
    "snippet": "        fn add_weighed_edge(&mut self, from: V, to: V, weight: usize)\n            requires valid_key_type_WeightedEdge::<V, usize>()\n            ensures \n                self@.V == old(self)@.V.insert(from@).insert(to@),\n                self@.A == old(self)@.A.insert((from@, to@, weight));"
  },
  {
    "id": 316,
    "function": "get_edge_weight",
    "file": "Chap06/WeightedDirGraphStEphUsize.rs",
    "lines": "58-62",
    "spec_strength": "unknown",
    "snippet": "        fn get_edge_weight(&self, from: &V, to: &V) -> (weight: Option<usize>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, usize>()\n            ensures \n                weight.is_some() == (exists |w: usize| #![trigger self@.A.contains((from@, to@, w))] self@.A.contains((from@, to@, w))),\n                weight.is_some() ==> self@.A.contains((from@, to@, weight.unwrap()));"
  },
  {
    "id": 317,
    "function": "weighed_edges",
    "file": "Chap06/WeightedDirGraphStEphUsize.rs",
    "lines": "65-68",
    "spec_strength": "unknown",
    "snippet": "        fn weighed_edges(&self) -> (weighed_edges: SetStEph<WeightedEdge<V, usize>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, usize>()\n            ensures \n                forall |t: (V::V, V::V, usize)| #[trigger] weighed_edges@.contains(t) == self@.A.contains(t);"
  },
  {
    "id": 318,
    "function": "out_neighbors_weighed",
    "file": "Chap06/WeightedDirGraphStEphUsize.rs",
    "lines": "71-75",
    "spec_strength": "unknown",
    "snippet": "        fn out_neighbors_weighed(&self, v: &V) -> (out_neighbors: SetStEph<Pair<V, usize>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, usize>()\n            ensures \n                forall |p: (V::V, usize)| out_neighbors@.contains(p) == \n                    (exists |w: usize| #![trigger self@.A.contains((v@, p.0, w))] self@.A.contains((v@, p.0, w)) && p.1 == w);"
  },
  {
    "id": 319,
    "function": "in_neighbors_weighed",
    "file": "Chap06/WeightedDirGraphStEphUsize.rs",
    "lines": "78-82",
    "spec_strength": "unknown",
    "snippet": "        fn in_neighbors_weighed(&self, v: &V) -> (in_neighbors: SetStEph<Pair<V, usize>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, usize>()\n            ensures \n                forall |p: (V::V, usize)| in_neighbors@.contains(p) == \n                    (exists |w: usize| #![trigger self@.A.contains((p.0, v@, w))] self@.A.contains((p.0, v@, w)) && p.1 == w);"
  },
  {
    "id": 320,
    "function": "total_weight",
    "file": "Chap06/WeightedDirGraphStEphUsize.rs",
    "lines": "85-87",
    "spec_strength": "unknown",
    "snippet": "        fn total_weight(&self) -> (total_weight: CheckedUsize)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, usize>()\n            ensures total_weight@ == self.spec_total_weight() as int;"
  },
  {
    "id": 321,
    "function": "edges_above_weight",
    "file": "Chap06/WeightedDirGraphStEphUsize.rs",
    "lines": "89-93",
    "spec_strength": "unknown",
    "snippet": "        fn edges_above_weight(&self, threshold: usize) -> (edges_above: SetStEph<WeightedEdge<V, usize>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, usize>()\n            ensures \n                forall |t: (V::V, V::V, usize)| #[trigger] edges_above@.contains(t) == \n                    (self@.A.contains(t) && t.2 > threshold);"
  },
  {
    "id": 322,
    "function": "edges_below_weight",
    "file": "Chap06/WeightedDirGraphStEphUsize.rs",
    "lines": "95-99",
    "spec_strength": "unknown",
    "snippet": "        fn edges_below_weight(&self, threshold: usize) -> (edges_below: SetStEph<WeightedEdge<V, usize>>)\n            requires wf_lab_graph_view(self@), valid_key_type_WeightedEdge::<V, usize>()\n            ensures \n                forall |t: (V::V, V::V, usize)| #[trigger] edges_below@.contains(t) == \n                    (self@.A.contains(t) && t.2 < threshold);"
  },
  {
    "id": 323,
    "function": "fib_2threads",
    "file": "Chap11/FibonacciMtEph2Threads.rs",
    "lines": "100-102",
    "spec_strength": "hole",
    "snippet": "pub fn fib_2threads(n: u64) -> (fibonacci: u64)\n    requires n >= 2 && n <= 46\n    ensures fibonacci == spec_fib(n as nat)"
  },
  {
    "id": 324,
    "function": "fib_recomputes",
    "file": "Chap11/FibonacciMtEphRecomputes.rs",
    "lines": "92-95",
    "spec_strength": "hole",
    "snippet": "pub fn fib_recomputes(n: u64) -> (fibonacci: u64)\n    requires n <= 46\n    ensures fibonacci == spec_fib(n as nat)\n    decreases n"
  },
  {
    "id": 325,
    "function": "fib",
    "file": "Chap11/FibonacciMtPerAllThreads.rs",
    "lines": "21-26",
    "spec_strength": "unknown",
    "snippet": "        pub fn fib(n: u64) -> (fibonacci: u64)\n            requires\n                n <= 46,\n            ensures\n                fibonacci == spec_fib(n as nat),\n            decreases n,"
  },
  {
    "id": 326,
    "function": "fib",
    "file": "Chap11/FibonacciMtPerTSM.rs",
    "lines": "86-89",
    "spec_strength": "hole",
    "snippet": "pub fn fib(n: u64) -> (fibonacci: u64)\n    requires n <= 46\n    ensures fibonacci == spec_fib(n as nat)\n    decreases n"
  },
  {
    "id": 327,
    "function": "lemma_fib_bound",
    "file": "Chap11/FibonacciStEph.rs",
    "lines": "48-50",
    "spec_strength": "unknown",
    "snippet": "        proof fn lemma_fib_bound(n: nat)\n            ensures spec_fib(n) < pow2(n),\n            decreases n,"
  },
  {
    "id": 328,
    "function": "lemma_fib_fits_u64",
    "file": "Chap11/FibonacciStEph.rs",
    "lines": "66-68",
    "spec_strength": "unknown",
    "snippet": "        proof fn lemma_fib_fits_u64(n: nat)\n            requires n <= 46,\n            ensures spec_fib(n) <= u64::MAX as nat,"
  },
  {
    "id": 329,
    "function": "lemma_fib_sum_fits_u64",
    "file": "Chap11/FibonacciStEph.rs",
    "lines": "76-78",
    "spec_strength": "unknown",
    "snippet": "        pub proof fn lemma_fib_sum_fits_u64(n: nat)\n            requires 2 <= n <= 46,\n            ensures spec_fib((n-1) as nat) + spec_fib((n-2) as nat) <= u64::MAX as nat,"
  },
  {
    "id": 330,
    "function": "fib",
    "file": "Chap11/FibonacciStEph.rs",
    "lines": "89-93",
    "spec_strength": "unknown",
    "snippet": "        pub fn fib(n: u64) -> (fibonacci: u64)\n            requires\n                n <= 46,\n            ensures\n                fibonacci == spec_fib(n as nat),"
  },
  {
    "id": 331,
    "function": "fib_recursive",
    "file": "Chap11/FibonacciStEph.rs",
    "lines": "127-132",
    "spec_strength": "unknown",
    "snippet": "        pub fn fib_recursive(n: u64) -> (fibonacci: u64)\n            requires\n                n <= 46,\n            ensures\n                fibonacci == spec_fib(n as nat),\n            decreases n,"
  },
  {
    "id": 332,
    "function": "new",
    "file": "Chap12/Exercise12_1.rs",
    "lines": "32-33",
    "spec_strength": "hole",
    "snippet": "        fn new() -> (lock: Self)\n            ensures !lock.spec_locked();"
  },
  {
    "id": 333,
    "function": "lock",
    "file": "Chap12/Exercise12_1.rs",
    "lines": "38-39",
    "spec_strength": "hole",
    "snippet": "        fn lock(&self)\n            ensures self.spec_locked();"
  },
  {
    "id": 334,
    "function": "unlock",
    "file": "Chap12/Exercise12_1.rs",
    "lines": "44-46",
    "spec_strength": "hole",
    "snippet": "        fn unlock(&self)\n            requires self.spec_locked()\n            ensures !self.spec_locked();"
  },
  {
    "id": 335,
    "function": "with_lock",
    "file": "Chap12/Exercise12_1.rs",
    "lines": "53",
    "spec_strength": "hole",
    "snippet": "        fn with_lock<T, F: FnOnce() -> T>(&self, action: F) -> T;"
  },
  {
    "id": 336,
    "function": "parallel_increment",
    "file": "Chap12/Exercise12_1.rs",
    "lines": "93-94",
    "spec_strength": "hole",
    "snippet": "    pub fn parallel_increment(iterations: usize) -> (incremented: usize)\n        ensures incremented == 4 * iterations"
  },
  {
    "id": 337,
    "function": "default",
    "file": "Chap12/Exercise12_1.rs",
    "lines": "120",
    "spec_strength": "",
    "snippet": "    fn default() -> Self { SpinLock::new() }"
  },
  {
    "id": 338,
    "function": "fetch_add_cas",
    "file": "Chap12/Exercise12_2.rs",
    "lines": "22",
    "spec_strength": "",
    "snippet": "    fn fetch_add_cas(&self, delta: usize) -> (previous: usize);"
  },
  {
    "id": 339,
    "function": "new",
    "file": "Chap12/Exercise12_5.rs",
    "lines": "58-59",
    "spec_strength": "hole",
    "snippet": "    fn new() -> (stack: Self)\n        ensures stack.wf();"
  },
  {
    "id": 340,
    "function": "push",
    "file": "Chap12/Exercise12_5.rs",
    "lines": "64-65",
    "spec_strength": "hole",
    "snippet": "    fn push(&self, value: T)\n        requires self.wf();"
  },
  {
    "id": 341,
    "function": "pop",
    "file": "Chap12/Exercise12_5.rs",
    "lines": "72-73",
    "spec_strength": "hole",
    "snippet": "    fn pop(&self) -> (possible_top: Option<T>)\n        requires self.wf();"
  },
  {
    "id": 342,
    "function": "is_empty",
    "file": "Chap12/Exercise12_5.rs",
    "lines": "79-80",
    "spec_strength": "hole",
    "snippet": "    fn is_empty(&self) -> (empty: bool)\n        requires self.wf();"
  },
  {
    "id": 343,
    "function": "drain",
    "file": "Chap12/Exercise12_5.rs",
    "lines": "87-88",
    "spec_strength": "hole",
    "snippet": "    fn drain(&self) -> (items: Vec<T>)\n        requires self.wf();"
  },
  {
    "id": 344,
    "function": "default",
    "file": "Chap12/Exercise12_5.rs",
    "lines": "148",
    "spec_strength": "",
    "snippet": "    fn default() -> Self { "
  },
  {
    "id": 345,
    "function": "drop",
    "file": "Chap12/Exercise12_5.rs",
    "lines": "155-157",
    "spec_strength": "hole",
    "snippet": "    fn drop(&mut self)\n        opens_invariants none\n        no_unwind"
  },
  {
    "id": 346,
    "function": "new",
    "file": "Chap17/MathSeq.rs",
    "lines": "141-144",
    "spec_strength": "unknown",
    "snippet": "            fn new(length: N, init_value: T) -> (new_seq: Self)\n                ensures\n                    new_seq.spec_len() == length,\n                    forall|i: int| #![trigger new_seq.spec_seq()[i]] 0 <= i < length ==> cloned(init_value, new_seq.spec_seq()[i]);"
  },
  {
    "id": 347,
    "function": "set",
    "file": "Chap17/MathSeq.rs",
    "lines": "148-154",
    "spec_strength": "unknown",
    "snippet": "            fn set(&mut self, index: N, value: T) -> (success: bool)\n                ensures\n                    success ==> index < old(self).spec_len()\n                        && self.spec_len() == old(self).spec_len()\n                        && self@[index as int] == value@\n                        && forall|i: int| 0 <= i < self.spec_len() && i != index as int ==> self@[i] == old(self)@[i],\n                    !success ==> index >= old(self).spec_len() && self@ == old(self)@;"
  },
  {
    "id": 348,
    "function": "length",
    "file": "Chap17/MathSeq.rs",
    "lines": "158-159",
    "spec_strength": "unknown",
    "snippet": "            fn length(&self) -> (len: N)\n                ensures len == self.spec_len();"
  },
  {
    "id": 349,
    "function": "nth",
    "file": "Chap17/MathSeq.rs",
    "lines": "163-165",
    "spec_strength": "unknown",
    "snippet": "            fn nth(&self, index: N) -> (elem: &T)\n                requires index < self.spec_len()\n                ensures elem@ == self@[index as int];"
  },
  {
    "id": 350,
    "function": "empty",
    "file": "Chap17/MathSeq.rs",
    "lines": "169-170",
    "spec_strength": "unknown",
    "snippet": "            fn empty() -> (empty_seq: Self)\n                ensures empty_seq.spec_len() == 0;"
  },
  {
    "id": 351,
    "function": "singleton",
    "file": "Chap17/MathSeq.rs",
    "lines": "174-177",
    "spec_strength": "unknown",
    "snippet": "            fn singleton(item: T) -> (singleton: Self)\n                ensures\n                    singleton.spec_len() == 1,\n                    singleton@[0] == item@;"
  },
  {
    "id": 352,
    "function": "add_last",
    "file": "Chap17/MathSeq.rs",
    "lines": "181-185",
    "spec_strength": "unknown",
    "snippet": "            fn add_last(&mut self, value: T)\n                ensures\n                    self.spec_len() == old(self).spec_len() + 1,\n                    self@[self.spec_len() - 1] == value@,\n                    forall|i: int| 0 <= i < old(self).spec_len() ==> self@[i] == old(self)@[i];"
  },
  {
    "id": 353,
    "function": "delete_last",
    "file": "Chap17/MathSeq.rs",
    "lines": "189-195",
    "spec_strength": "unknown",
    "snippet": "            fn delete_last(&mut self) -> (shortened: Option<T>)\n                ensures\n                    old(self).spec_len() == 0 ==> shortened is None && self@ == old(self)@,\n                    old(self).spec_len() > 0  ==> shortened is Some\n                        && shortened->Some_0@ == old(self)@[old(self).spec_len() - 1]\n                        && self.spec_len() == old(self).spec_len() - 1\n                        && forall|i: int| 0 <= i < self.spec_len() ==> self@[i] == old(self)@[i];"
  },
  {
    "id": 354,
    "function": "is_empty",
    "file": "Chap17/MathSeq.rs",
    "lines": "199-200",
    "spec_strength": "unknown",
    "snippet": "            fn is_empty(&self) -> (emptiness: bool)\n                ensures emptiness == self.spec_is_empty();"
  },
  {
    "id": 355,
    "function": "is_singleton",
    "file": "Chap17/MathSeq.rs",
    "lines": "204-205",
    "spec_strength": "unknown",
    "snippet": "            fn is_singleton(&self) -> (singularity: bool)\n                ensures singularity == self.spec_is_singleton();"
  },
  {
    "id": 356,
    "function": "from_vec",
    "file": "Chap17/MathSeq.rs",
    "lines": "209-210",
    "spec_strength": "unknown",
    "snippet": "            fn from_vec(data: Vec<T>) -> (seq: Self)\n                ensures seq.spec_seq() == data@;"
  },
  {
    "id": 357,
    "function": "with_len",
    "file": "Chap17/MathSeq.rs",
    "lines": "214-217",
    "spec_strength": "unknown",
    "snippet": "            fn with_len(length: N, init_value: T) -> (seq_of_len_value: Self)\n                ensures\n                    seq_of_len_value.spec_len() == length,\n                    forall|i: int| #![trigger seq_of_len_value.spec_seq()[i]] 0 <= i < length ==> cloned(init_value, seq_of_len_value.spec_seq()[i]);"
  },
  {
    "id": 358,
    "function": "subseq",
    "file": "Chap17/MathSeq.rs",
    "lines": "221-228",
    "spec_strength": "unknown",
    "snippet": "            fn subseq(&self, start: N, length: N) -> (subseq: &[T])\n                ensures\n                    subseq@.len() <= length,\n                ({\n                    let s = spec_clamp(start as int, self.spec_seq().len() as int);\n                    let e = spec_clamp((start + length) as int, self.spec_seq().len() as int);\n                    subseq@ == self.spec_seq().subrange(s, e)\n                });"
  },
  {
    "id": 359,
    "function": "subseq_copy",
    "file": "Chap17/MathSeq.rs",
    "lines": "232-237",
    "spec_strength": "unknown",
    "snippet": "            fn subseq_copy(&self, start: N, length: N) -> (subseq: Self) where T: Copy\n                requires\n                    start as int + length as int <= self.spec_seq().len(),\n                ensures\n                    subseq.spec_len() == length,\n                    subseq.spec_seq() == self.spec_seq().subrange(start as int, (start + length) as int);"
  },
  {
    "id": 360,
    "function": "domain",
    "file": "Chap17/MathSeq.rs",
    "lines": "241-242",
    "spec_strength": "unknown",
    "snippet": "            fn domain(&self) -> (domain: Vec<N>)\n                ensures domain@.len() == self.spec_len();"
  },
  {
    "id": 361,
    "function": "range",
    "file": "Chap17/MathSeq.rs",
    "lines": "246-250",
    "spec_strength": "unknown",
    "snippet": "            fn range(&self) -> (range: Vec<T>)\n                requires valid_key_type::<T>()\n                ensures\n                    range@.len() <= self.spec_seq().len(),\n                    range@.no_duplicates();"
  },
  {
    "id": 362,
    "function": "multiset_range",
    "file": "Chap17/MathSeq.rs",
    "lines": "254-259",
    "spec_strength": "unknown",
    "snippet": "            fn multiset_range(&self) -> (range: Vec<(N, T)>)\n                requires\n                    valid_key_type::<T>(),\n                    forall|k1: T, k2: T| k1@ == k2@ ==> k1 == k2,\n                ensures\n                    range@.len() <= self.spec_seq().len();"
  },
  {
    "id": 363,
    "function": "iter",
    "file": "Chap17/MathSeq.rs",
    "lines": "264-268",
    "spec_strength": "unknown",
    "snippet": "            fn iter(&self) -> (it: MathSeqIter<'_, T>)\n                ensures\n                    it@.0 == 0,\n                    it@.1 == self.spec_seq(),\n                    iter_invariant(&it);"
  },
  {
    "id": 364,
    "function": "next",
    "file": "Chap17/MathSeq.rs",
    "lines": "617-633",
    "spec_strength": "unknown",
    "snippet": "        fn next(&mut self) -> (next: Option<&'a T>)\n            ensures ({\n                let (old_index, old_seq) = old(self)@;\n                match next {\n                    None => {\n                        &&& self@ == old(self)@\n                        &&& old_index >= old_seq.len()\n                    },\n                    Some(element) => {\n                        let (new_index, new_seq) = self@;\n                        &&& 0 <= old_index < old_seq.len()\n                        &&& new_seq == old_seq\n                        &&& new_index == old_index + 1\n                        &&& element == old_seq[old_index]\n                    },\n                }\n            })"
  },
  {
    "id": 365,
    "function": "eq",
    "file": "Chap17/MathSeq.rs",
    "lines": "724-725",
    "spec_strength": "hole",
    "snippet": "        fn eq(&self, other: &Self) -> (equal: bool)\n            ensures equal == (self@ == other@)"
  },
  {
    "id": 366,
    "function": "iter_mut",
    "file": "Chap17/MathSeq.rs",
    "lines": "738-743",
    "spec_strength": "",
    "snippet": "        /// Mutable borrow iterator. Must stay outside verus! (returns &mut).\n        /// - APAS: no cost spec.\n        /// - Claude-Opus-4.6: O(1)  returns iterator wrapper.\n        pub fn iter_mut(&mut self) -> IterMut<'_, T> {\n            self.data.iter_mut()\n        }"
  },
  {
    "id": 367,
    "function": "lemma_deep_view_len",
    "file": "Chap18/ArraySeq.rs",
    "lines": "177-179",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_deep_view_len<T: DeepView>(v: &Vec<T>)\n        ensures\n            v.deep_view().len() == v@.len(),"
  },
  {
    "id": 368,
    "function": "lemma_deep_view_key",
    "file": "Chap18/ArraySeq.rs",
    "lines": "184-189",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_deep_view_key<K: DeepView, V: DeepView>(s: &Vec<(K, ArraySeqS<V>)>, i: int)\n        requires\n            0 <= i < s@.len(),\n        ensures\n            s.deep_view()[i].0 == s@[i].0.deep_view(),\n            s.deep_view().len() == s@.len(),"
  },
  {
    "id": 369,
    "function": "lemma_find_key_index_bounds",
    "file": "Chap18/ArraySeq.rs",
    "lines": "194-199",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_find_key_index_bounds<K, V>(groups: Seq<(K, Seq<V>)>, k: K, idx: int)\n        requires\n            spec_find_key_index(groups, k) == Some(idx),\n        ensures\n            0 <= idx < groups.len(),\n        decreases groups.len(),"
  },
  {
    "id": 370,
    "function": "lemma_find_key_index_found",
    "file": "Chap18/ArraySeq.rs",
    "lines": "209-220",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_find_key_index_found<K, V>(\n        groups: Seq<(K, Seq<V>)>,\n        k: K,\n        idx: int,\n    )\n        requires\n            0 <= idx < groups.len(),\n            groups[idx].0 == k,\n            forall|m: int| #![trigger groups[m]] 0 <= m < idx ==> groups[m].0 != k,\n        ensures\n            spec_find_key_index(groups, k) == Some(idx),\n        decreases groups.len(),"
  },
  {
    "id": 371,
    "function": "lemma_find_key_index_not_found",
    "file": "Chap18/ArraySeq.rs",
    "lines": "229-237",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_find_key_index_not_found<K, V>(\n        groups: Seq<(K, Seq<V>)>,\n        k: K,\n    )\n        requires\n            forall|m: int| #![trigger groups[m]] 0 <= m < groups.len() ==> groups[m].0 != k,\n        ensures\n            spec_find_key_index(groups, k) == None::<int>,\n        decreases groups.len(),"
  },
  {
    "id": 372,
    "function": "lemma_spec_collect_step_some",
    "file": "Chap18/ArraySeq.rs",
    "lines": "246-258",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_spec_collect_step_some<K, V>(\n        old_dv: Seq<(K, Seq<V>)>,\n        pairs_prefix: Seq<(K, V)>,\n        k: K,\n        v: V,\n        idx: int,\n    )\n        requires\n            old_dv =~= spec_collect(pairs_prefix),\n            spec_find_key_index(old_dv, k) == Some(idx),\n        ensures\n            spec_collect(pairs_prefix.push((k, v)))\n                =~= old_dv.remove(idx).insert(idx, (k, old_dv[idx].1.push(v))),"
  },
  {
    "id": 373,
    "function": "lemma_spec_collect_step_none",
    "file": "Chap18/ArraySeq.rs",
    "lines": "269-280",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_spec_collect_step_none<K, V>(\n        old_dv: Seq<(K, Seq<V>)>,\n        pairs_prefix: Seq<(K, V)>,\n        k: K,\n        v: V,\n    )\n        requires\n            old_dv =~= spec_collect(pairs_prefix),\n            spec_find_key_index(old_dv, k) == None::<int>,\n        ensures\n            spec_collect(pairs_prefix.push((k, v)))\n                =~= old_dv.push((k, seq![v])),"
  },
  {
    "id": 374,
    "function": "lemma_find_key_some",
    "file": "Chap18/ArraySeq.rs",
    "lines": "290-297",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_find_key_some<K: DeepView<V = K>, V: DeepView>(s: &Vec<(K, ArraySeqS<V>)>, k: K, idx: usize)\n        requires\n            obeys_generic_deep_eq::<K>(),\n            idx < s@.len(),\n            s@[idx as int].0 == k,\n            forall|m: int| #![trigger s@[m]] 0 <= m < idx as int ==> s@[m].0 != k,\n        ensures\n            spec_find_key_index(s.deep_view(), k.deep_view()) == Some(idx as int),"
  },
  {
    "id": 375,
    "function": "lemma_find_key_none",
    "file": "Chap18/ArraySeq.rs",
    "lines": "308-313",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_find_key_none<K: DeepView<V = K>, V: DeepView>(s: &Vec<(K, ArraySeqS<V>)>, k: K)\n        requires\n            obeys_generic_deep_eq::<K>(),\n            forall|m: int| #![trigger s@[m]] 0 <= m < s@.len() ==> s@[m].0 != k,\n        ensures\n            spec_find_key_index(s.deep_view(), k.deep_view()) == None::<int>,"
  },
  {
    "id": 376,
    "function": "new",
    "file": "Chap18/ArraySeq.rs",
    "lines": "338-345",
    "spec_strength": "unknown",
    "snippet": "        fn new(length: usize, init_value: T) -> (new_seq: Self)\n            where T: Clone + Eq\n            requires\n              obeys_feq_clone::<T>(),\n              length <= usize::MAX,\n            ensures \n              new_seq.spec_len() == length as int,\n              forall|i: int| #![trigger new_seq.spec_index(i)] 0 <= i < length ==> new_seq.spec_index(i) == init_value; "
  },
  {
    "id": 377,
    "function": "set",
    "file": "Chap18/ArraySeq.rs",
    "lines": "350-355",
    "spec_strength": "unknown",
    "snippet": "        fn set(&mut self, index: usize, item: T) -> (success: Result<(), &'static str>)\n            requires index < old(self).spec_len()\n            ensures\n                success.is_ok() ==> self.spec_len() == old(self).spec_len(),\n                success.is_ok() ==> self.spec_index(index as int) == item,\n                success.is_ok() ==> forall|i: int| #![trigger self.spec_index(i), old(self).spec_index(i)] 0 <= i < old(self).spec_len() && i != index ==> self.spec_index(i) == old(self).spec_index(i);"
  },
  {
    "id": 378,
    "function": "length",
    "file": "Chap18/ArraySeq.rs",
    "lines": "360-361",
    "spec_strength": "unknown",
    "snippet": "        fn length(&self) -> (len: usize)\n            ensures len as int == self.spec_len();"
  },
  {
    "id": 379,
    "function": "nth",
    "file": "Chap18/ArraySeq.rs",
    "lines": "366-368",
    "spec_strength": "unknown",
    "snippet": "        fn nth(&self, index: usize) -> (nth_elem: &T)\n            requires index < self.spec_len()\n            ensures *nth_elem == self.spec_index(index as int);"
  },
  {
    "id": 380,
    "function": "empty",
    "file": "Chap18/ArraySeq.rs",
    "lines": "373-374",
    "spec_strength": "unknown",
    "snippet": "        fn empty() -> (empty_seq: Self)\n            ensures empty_seq.spec_len() == 0;"
  },
  {
    "id": 381,
    "function": "singleton",
    "file": "Chap18/ArraySeq.rs",
    "lines": "379-382",
    "spec_strength": "unknown",
    "snippet": "        fn singleton(item: T) -> (singleton: Self)\n            ensures\n                singleton.spec_len() == 1,\n                singleton.spec_index(0) == item;"
  },
  {
    "id": 382,
    "function": "subseq",
    "file": "Chap18/ArraySeq.rs",
    "lines": "387-395",
    "spec_strength": "unknown",
    "snippet": "        fn subseq(a: &Self, start: usize, length: usize) -> (subseq: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                start + length <= usize::MAX,\n                start + length <= a.spec_len(),\n            ensures\n                subseq.spec_len() == length as int,\n                forall|i: int| #![trigger subseq.spec_index(i)] 0 <= i < length ==> subseq.spec_index(i) == a.spec_index(start as int + i);"
  },
  {
    "id": 383,
    "function": "append",
    "file": "Chap18/ArraySeq.rs",
    "lines": "400-408",
    "spec_strength": "unknown",
    "snippet": "        fn append(a: &Self, b: &Self) -> (appended: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                a.spec_len() + b.spec_len() <= usize::MAX as int,\n            ensures\n                appended.spec_len() == a.spec_len() + b.spec_len(),\n                forall|i: int| #![trigger appended.spec_index(i)] 0 <= i < a.spec_len() ==> appended.spec_index(i) == a.spec_index(i),\n                forall|i: int| #![trigger b.spec_index(i)] 0 <= i < b.spec_len() ==> appended.spec_index(a.spec_len() + i) == b.spec_index(i);"
  },
  {
    "id": 384,
    "function": "filter",
    "file": "Chap18/ArraySeq.rs",
    "lines": "415-430",
    "spec_strength": "unknown",
    "snippet": "        fn filter<F: Fn(&T) -> bool>(a: &Self, pred: &F, Ghost(spec_pred): Ghost<spec_fn(T) -> bool>) -> (filtered: Self)\n            where T: Clone + Eq\n            requires \n              obeys_feq_clone::<T>(),\n              forall|i: int| 0 <= i < a.spec_len() ==> #[trigger] pred.requires((&a.spec_index(i),)),\n              // The forward bridge ties the exec closure to the spec predicate.\n              forall|v: T, keep: bool| pred.ensures((&v,), keep) ==> spec_pred(v) == keep,\n            ensures\n                filtered.spec_len() <= a.spec_len(),\n                // The result length equals the spec_filter_len count.\n                filtered.spec_len() == spec_filter_len(Seq::new(a.spec_len(), |i: int| a.spec_index(i)), spec_pred),\n                // The result multiset equals the input multiset filtered by the spec predicate.\n                Seq::new(filtered.spec_len(), |i: int| filtered.spec_index(i)).to_multiset()\n                    =~= Seq::new(a.spec_len(), |i: int| a.spec_index(i)).to_multiset().filter(spec_pred),\n                // Every element of the filtered result satisfies the predicate.\n                forall|i: int| #![trigger filtered.spec_index(i)] 0 <= i < filtered.spec_len() ==> pred.ensures((&filtered.spec_index(i),), true);"
  },
  {
    "id": 385,
    "function": "update",
    "file": "Chap18/ArraySeq.rs",
    "lines": "435-443",
    "spec_strength": "unknown",
    "snippet": "        fn update(a: &Self, index: usize, item: T) -> (updated: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                index < a.spec_len(),\n            ensures\n                updated.spec_len() == a.spec_len(),\n                updated.spec_index(index as int) == item,\n                forall|i: int| #![trigger updated.spec_index(i)] 0 <= i < a.spec_len() && i != index as int ==> updated.spec_index(i) == a.spec_index(i);"
  },
  {
    "id": 386,
    "function": "is_empty",
    "file": "Chap18/ArraySeq.rs",
    "lines": "448-449",
    "spec_strength": "unknown",
    "snippet": "        fn is_empty(&self) -> (empty: bool)\n            ensures empty <==> self.spec_len() == 0;"
  },
  {
    "id": 387,
    "function": "is_singleton",
    "file": "Chap18/ArraySeq.rs",
    "lines": "454-455",
    "spec_strength": "unknown",
    "snippet": "        fn is_singleton(&self) -> (single: bool)\n            ensures single <==> self.spec_len() == 1;"
  },
  {
    "id": 388,
    "function": "iterate",
    "file": "Chap18/ArraySeq.rs",
    "lines": "461-466",
    "spec_strength": "unknown",
    "snippet": "        fn iterate<A, F: Fn(&A, &T) -> A>(a: &Self, f: &F, Ghost(spec_f): Ghost<spec_fn(A, T) -> A>, start_x: A) -> (accumulated: A)\n            requires\n                forall|x: &A, y: &T| #[trigger] f.requires((x, y)),\n                forall|a: A, t: T, ret: A| f.ensures((&a, &t), ret) ==> ret == spec_f(a, t),\n            ensures\n                accumulated == spec_iterate(Seq::new(a.spec_len(), |i: int| a.spec_index(i)), spec_f, start_x);"
  },
  {
    "id": 389,
    "function": "reduce",
    "file": "Chap18/ArraySeq.rs",
    "lines": "472-480",
    "spec_strength": "unknown",
    "snippet": "        fn reduce<F: Fn(&T, &T) -> T>(a: &Self, f: &F, Ghost(spec_f): Ghost<spec_fn(T, T) -> T>, id: T) -> (reduced: T)\n            where T: Clone\n            requires\n                spec_monoid(spec_f, id),\n                forall|x: &T, y: &T| #[trigger] f.requires((x, y)),\n                forall|x: T, y: T, ret: T| f.ensures((&x, &y), ret) ==> ret == spec_f(x, y),\n            ensures\n                reduced == spec_iterate(\n                    Seq::new(a.spec_len(), |i: int| a.spec_index(i)), spec_f, id);"
  },
  {
    "id": 390,
    "function": "scan",
    "file": "Chap18/ArraySeq.rs",
    "lines": "486-500",
    "spec_strength": "unknown",
    "snippet": "        fn scan<F: Fn(&T, &T) -> T>(a: &Self, f: &F, Ghost(spec_f): Ghost<spec_fn(T, T) -> T>, id: T) -> (scanned: (Self, T))\n            where T: Clone + Eq\n            requires\n                spec_monoid(spec_f, id),\n                obeys_feq_clone::<T>(),\n                forall|x: &T, y: &T| #[trigger] f.requires((x, y)),\n                forall|x: T, y: T, ret: T| f.ensures((&x, &y), ret) ==> ret == spec_f(x, y),\n            ensures\n                scanned.0.spec_len() == a.spec_len(),\n                // Each element is the fold of the first i+1 input elements (inclusive prefix sum).\n                forall|i: int| #![trigger scanned.0.spec_index(i)] 0 <= i < a.spec_len() ==>\n                    scanned.0.spec_index(i) == Seq::new(a.spec_len(), |j: int| a.spec_index(j)).take(i + 1).fold_left(id, spec_f),\n                // The total is the fold of the entire sequence.\n                scanned.1 == spec_iterate(\n                    Seq::new(a.spec_len(), |j: int| a.spec_index(j)), spec_f, id);"
  },
  {
    "id": 391,
    "function": "inject",
    "file": "Chap18/ArraySeq.rs",
    "lines": "506-515",
    "spec_strength": "unknown",
    "snippet": "        fn inject(a: &Self, updates: &Vec<(usize, T)>) -> (injected: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n            ensures\n                injected.spec_len() == a.spec_len(),\n                Seq::new(injected.spec_len(), |i: int| injected.spec_index(i))\n                    =~= spec_inject(\n                        Seq::new(a.spec_len(), |i: int| a.spec_index(i)),\n                        updates@);"
  },
  {
    "id": 392,
    "function": "scan_inclusive",
    "file": "Chap18/ArraySeq.rs",
    "lines": "521-531",
    "spec_strength": "unknown",
    "snippet": "        fn scan_inclusive<F: Fn(&T, &T) -> T>(a: &Self, f: &F, Ghost(spec_f): Ghost<spec_fn(T, T) -> T>, id: T) -> (scanned: Self)\n            where T: Clone + Eq\n            requires\n                spec_monoid(spec_f, id),\n                obeys_feq_clone::<T>(),\n                forall|x: &T, y: &T| #[trigger] f.requires((x, y)),\n                forall|x: T, y: T, ret: T| f.ensures((&x, &y), ret) ==> ret == spec_f(x, y),\n            ensures\n                scanned.spec_len() == a.spec_len(),\n                forall|i: int| #![trigger scanned.spec_index(i)] 0 <= i < a.spec_len() ==>\n                    scanned.spec_index(i) == Seq::new(a.spec_len(), |j: int| a.spec_index(j)).take(i + 1).fold_left(id, spec_f);"
  },
  {
    "id": 393,
    "function": "subseq_copy",
    "file": "Chap18/ArraySeq.rs",
    "lines": "536-544",
    "spec_strength": "unknown",
    "snippet": "        fn subseq_copy(&self, start: usize, length: usize) -> (subseq: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                start + length <= usize::MAX,\n                start + length <= self.spec_len(),\n            ensures\n                subseq.spec_len() == length as int,\n                forall|i: int| #![trigger subseq.spec_index(i)] 0 <= i < length ==> subseq.spec_index(i) == self.spec_index(start as int + i);"
  },
  {
    "id": 394,
    "function": "remove",
    "file": "Chap18/ArraySeq.rs",
    "lines": "549-556",
    "spec_strength": "unknown",
    "snippet": "        fn remove(&mut self, index: usize) -> (element: T)\n            requires\n                index < old(self).spec_len(),\n            ensures\n                element == old(self).spec_index(index as int),\n                self.spec_len() == old(self).spec_len() - 1,\n                forall|j: int| #![trigger self.spec_index(j)] 0 <= j < index ==> self.spec_index(j) == old(self).spec_index(j),\n                forall|j: int| #![trigger self.spec_index(j)] index <= j < self.spec_len() ==> self.spec_index(j) == old(self).spec_index(j + 1);"
  },
  {
    "id": 395,
    "function": "insert",
    "file": "Chap18/ArraySeq.rs",
    "lines": "561-568",
    "spec_strength": "unknown",
    "snippet": "        fn insert(&mut self, index: usize, element: T)\n            requires\n                index <= old(self).spec_len(),\n            ensures\n                self.spec_len() == old(self).spec_len() + 1,\n                self.spec_index(index as int) == element,\n                forall|j: int| #![trigger self.spec_index(j)] 0 <= j < index ==> self.spec_index(j) == old(self).spec_index(j),\n                forall|j: int| #![trigger self.spec_index(j)] index < j < self.spec_len() ==> self.spec_index(j) == old(self).spec_index(j - 1);"
  },
  {
    "id": 396,
    "function": "from_vec",
    "file": "Chap18/ArraySeq.rs",
    "lines": "573-576",
    "spec_strength": "unknown",
    "snippet": "        fn from_vec(elts: Vec<T>) -> (seq: Self)\n            ensures\n                seq.spec_len() == elts@.len(),\n                forall|i: int| #![trigger seq.spec_index(i)] 0 <= i < elts@.len() ==> seq.spec_index(i) == elts@[i];"
  },
  {
    "id": 397,
    "function": "find_key",
    "file": "Chap18/ArraySeq.rs",
    "lines": "579-591",
    "spec_strength": "unknown",
    "snippet": "        fn find_key<K: View + Eq + PartialEq, V: View>(\n            groups: &ArraySeqS<(K, ArraySeqS<V>)>,\n            needle: &K,\n        ) -> (found: Option<usize>)\n            requires\n              obeys_concrete_eq::<K>(),\n            ensures\n               match found {\n                   Some(idx) => idx < groups.seq@.len()\n                        && groups.seq@[idx as int].0 == *needle\n                        && forall|m: int| #![trigger groups.seq@[m]] 0 <= m < idx as int ==> groups.seq@[m].0 != *needle,\n                   None => forall|m: int| #![trigger groups.seq@[m]] 0 <= m < groups.seq@.len() ==> groups.seq@[m].0 != *needle,\n               };"
  },
  {
    "id": 398,
    "function": "collect",
    "file": "Chap18/ArraySeq.rs",
    "lines": "597-609",
    "spec_strength": "unknown",
    "snippet": "    fn collect<K: DeepView<V = K> + View + Clone + Eq + PartialEq, V: DeepView<V = V> + View + Clone + Eq>(\n        pairs: &ArraySeqS<(K, V)>,\n    ) -> (collected: ArraySeqS<(K, ArraySeqS<V>)>)\n        requires\n            obeys_feq_clone::<K>(),\n            obeys_feq_clone::<V>(),\n            obeys_concrete_eq::<K>(),\n            obeys_deep_eq::<K>(),\n            obeys_deep_eq::<V>(),\n            obeys_generic_deep_eq::<K>(),\n            obeys_generic_deep_eq::<V>(),\n        ensures\n           collected.seq.deep_view() =~= spec_collect(pairs.seq@);"
  },
  {
    "id": 399,
    "function": "map",
    "file": "Chap18/ArraySeq.rs",
    "lines": "1272-1276",
    "spec_strength": "unknown",
    "snippet": "    pub fn map<T: View, U: Clone + View, F: Fn(&T) -> U>(a: &ArraySeqS<T>, f: &F) -> (mapped: ArraySeqS<U>)\n        requires forall|i: int| 0 <= i < a.spec_len() ==> #[trigger] f.requires((&a.spec_index(i),))\n        ensures\n            mapped.spec_len() == a.spec_len(),\n            forall|i: int| #![trigger mapped.spec_index(i)] 0 <= i < a.spec_len() ==> f.ensures((&a.spec_index(i),), mapped.spec_index(i)),"
  },
  {
    "id": 400,
    "function": "tabulate",
    "file": "Chap18/ArraySeq.rs",
    "lines": "1303-1309",
    "spec_strength": "unknown",
    "snippet": "    pub fn tabulate<T: View, F: Fn(usize) -> T>(f: &F, length: usize) -> (tab_seq: ArraySeqS<T>)\n        requires\n            length <= usize::MAX,\n            forall|i: usize| i < length ==> #[trigger] f.requires((i,)),\n        ensures\n            tab_seq.spec_len() == length as int,\n            forall|i: int| #![trigger tab_seq.spec_index(i)] 0 <= i < length ==> f.ensures((i as usize,), tab_seq.spec_index(i)),"
  },
  {
    "id": 401,
    "function": "flatten",
    "file": "Chap18/ArraySeq.rs",
    "lines": "1330-1334",
    "spec_strength": "unknown",
    "snippet": "    pub fn flatten<T: View + Clone + Eq>(a: &ArraySeqS<ArraySeqS<T>>) -> (flattened: ArraySeqS<T>)\n        requires\n            obeys_feq_clone::<T>(),\n        ensures\n            flattened.seq@ =~= a.seq@.map_values(|inner: ArraySeqS<T>| inner.seq@).flatten(),"
  },
  {
    "id": 402,
    "function": "iterate_prefixes",
    "file": "Chap18/ArraySeq.rs",
    "lines": "1388-1403",
    "spec_strength": "unknown",
    "snippet": "    pub fn iterate_prefixes<T: View, A: View + Clone + Eq, F: Fn(&A, &T) -> A>(\n        a: &ArraySeqS<T>, f: &F,\n        Ghost(spec_f): Ghost<spec_fn(A, T) -> A>,\n        start_x: A,\n    ) -> (prefixes: (ArraySeqS<A>, A))\n        requires\n            obeys_feq_clone::<A>(),\n            forall|x: &A, y: &T| #[trigger] f.requires((x, y)),\n            forall|a: A, t: T, ret: A| f.ensures((&a, &t), ret) ==> ret == spec_f(a, t),\n        ensures\n            prefixes.0.spec_len() == a.spec_len(),\n            forall|i: int| #![trigger prefixes.0.spec_index(i)] 0 <= i < a.spec_len() ==>\n                prefixes.0.spec_index(i) == spec_iterate_prefixes(\n                    Seq::new(a.spec_len(), |j: int| a.spec_index(j)), spec_f, start_x).0[i],\n            prefixes.1 == spec_iterate(\n                Seq::new(a.spec_len(), |j: int| a.spec_index(j)), spec_f, start_x),"
  },
  {
    "id": 403,
    "function": "lemma_spec_index",
    "file": "Chap18/ArraySeq.rs",
    "lines": "1465-1467",
    "spec_strength": "unknown",
    "snippet": "        broadcast proof fn lemma_spec_index(&self, i: int)\n            requires 0 <= i < self.spec_len()\n            ensures #[trigger] self.seq@[i] == self.spec_index(i)"
  },
  {
    "id": 404,
    "function": "iter",
    "file": "Chap18/ArraySeq.rs",
    "lines": "1471-1475",
    "spec_strength": "unknown",
    "snippet": "        pub fn iter(&self) -> (it: ArraySeqIter<'_, T>)\n            ensures\n                it@.0 == 0,\n                it@.1 == self.seq@,\n                iter_invariant(&it),"
  },
  {
    "id": 405,
    "function": "iter_mut",
    "file": "Chap18/ArraySeq.rs",
    "lines": "1483",
    "spec_strength": "",
    "snippet": "        pub fn iter_mut(&mut self) -> IterMut<'_, T> { self.seq.iter_mut() }"
  },
  {
    "id": 406,
    "function": "next",
    "file": "Chap18/ArraySeq.rs",
    "lines": "1535-1551",
    "spec_strength": "unknown",
    "snippet": "        fn next(&mut self) -> (next: Option<&'a T>)\n            ensures ({\n                let (old_index, old_seq) = old(self)@;\n                match next {\n                    None => {\n                        &&& self@ == old(self)@\n                        &&& old_index >= old_seq.len()\n                    },\n                    Some(element) => {\n                        let (new_index, new_seq) = self@;\n                        &&& 0 <= old_index < old_seq.len()\n                        &&& new_seq == old_seq\n                        &&& new_index == old_index + 1\n                        &&& element == old_seq[old_index]\n                    },\n                }\n            })"
  },
  {
    "id": 407,
    "function": "eq",
    "file": "Chap18/ArraySeq.rs",
    "lines": "1642-1643",
    "spec_strength": "hole",
    "snippet": "        fn eq(&self, other: &Self) -> (equal: bool)\n            ensures equal == (self@ == other@)"
  },
  {
    "id": 408,
    "function": "lemma_spec_inject_element",
    "file": "Chap18/ArraySeqMtEph.rs",
    "lines": "120-129",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_spec_inject_element<T>(s: Seq<T>, u: Seq<(usize, T)>, i: int)\n        requires 0 <= i < s.len(),\n        ensures ({\n            let r = spec_inject(s, u);\n            r.len() == s.len()\n            && (r[i] == s[i]\n                || exists|j: int| #![trigger u[j]] 0 <= j < u.len()\n                    && u[j].0 == i as usize && r[i] == u[j].1)\n        }),\n        decreases u.len(),"
  },
  {
    "id": 409,
    "function": "lemma_spec_inject_len",
    "file": "Chap18/ArraySeqMtEph.rs",
    "lines": "160-162",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_spec_inject_len<T>(s: Seq<T>, u: Seq<(usize, T)>)\n        ensures spec_inject(s, u).len() == s.len(),\n        decreases u.len(),"
  },
  {
    "id": 410,
    "function": "apply_ninject_updates",
    "file": "Chap18/ArraySeqMtEph.rs",
    "lines": "194-202",
    "spec_strength": "unknown",
    "snippet": "    fn apply_ninject_updates<T: Clone + Eq + Send + Sync + 'static>(\n        lock: Arc<RwLock<Vec<T>, NinjectInv<T>>>,\n        updates: Vec<(usize, T)>,\n        Ghost(pred): Ghost<NinjectInv<T>>,\n    )\n        requires\n            obeys_feq_clone::<T>(),\n            lock.pred() == pred,\n            forall|k: int| #![trigger updates@[k]] 0 <= k < updates@.len() ==> {"
  },
  {
    "id": 411,
    "function": "new",
    "file": "Chap18/ArraySeqMtEph.rs",
    "lines": "265-272",
    "spec_strength": "unknown",
    "snippet": "        fn new(length: usize, init_value: T) -> (new_seq: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                length <= usize::MAX,\n            ensures\n                new_seq.spec_len() == length as int,\n                forall|i: int| #![trigger new_seq.spec_index(i)] 0 <= i < length ==> new_seq.spec_index(i) == init_value;"
  },
  {
    "id": 412,
    "function": "set",
    "file": "Chap18/ArraySeqMtEph.rs",
    "lines": "277-282",
    "spec_strength": "unknown",
    "snippet": "        fn set(&mut self, index: usize, item: T) -> (success: Result<(), &'static str>)\n            requires index < old(self).spec_len()\n            ensures\n                success.is_ok() ==> self.spec_len() == old(self).spec_len(),\n                success.is_ok() ==> self.spec_index(index as int) == item,\n                success.is_ok() ==> forall|i: int| #![trigger self.spec_index(i), old(self).spec_index(i)] 0 <= i < old(self).spec_len() && i != index ==> self.spec_index(i) == old(self).spec_index(i);"
  },
  {
    "id": 413,
    "function": "length",
    "file": "Chap18/ArraySeqMtEph.rs",
    "lines": "287-288",
    "spec_strength": "unknown",
    "snippet": "        fn length(&self) -> (len: usize)\n            ensures len as int == self.spec_len();"
  },
  {
    "id": 414,
    "function": "nth",
    "file": "Chap18/ArraySeqMtEph.rs",
    "lines": "293-295",
    "spec_strength": "unknown",
    "snippet": "        fn nth(&self, index: usize) -> (nth_elem: &T)\n            requires index < self.spec_len()\n            ensures *nth_elem == self.spec_index(index as int);"
  },
  {
    "id": 415,
    "function": "subseq_copy",
    "file": "Chap18/ArraySeqMtEph.rs",
    "lines": "300-308",
    "spec_strength": "unknown",
    "snippet": "        fn subseq_copy(&self, start: usize, length: usize) -> (subseq: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                start + length <= usize::MAX,\n                start + length <= self.spec_len(),\n            ensures\n                subseq.spec_len() == length as int,\n                forall|i: int| #![trigger subseq.spec_index(i)] 0 <= i < length ==> subseq.spec_index(i) == self.spec_index(start as int + i);"
  },
  {
    "id": 416,
    "function": "subseq",
    "file": "Chap18/ArraySeqMtEph.rs",
    "lines": "313-321",
    "spec_strength": "unknown",
    "snippet": "        fn subseq(a: &Self, start: usize, length: usize) -> (subseq: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                start + length <= usize::MAX,\n                start + length <= a.spec_len(),\n            ensures\n                subseq.spec_len() == length as int,\n                forall|i: int| #![trigger subseq.spec_index(i)] 0 <= i < length ==> subseq.spec_index(i) == a.spec_index(start as int + i);"
  },
  {
    "id": 417,
    "function": "from_vec",
    "file": "Chap18/ArraySeqMtEph.rs",
    "lines": "326-329",
    "spec_strength": "unknown",
    "snippet": "        fn from_vec(elts: Vec<T>) -> (seq: Self)\n            ensures\n                seq.spec_len() == elts@.len(),\n                forall|i: int| #![trigger seq.spec_index(i)] 0 <= i < elts@.len() ==> seq.spec_index(i) == elts@[i];"
  },
  {
    "id": 418,
    "function": "empty",
    "file": "Chap18/ArraySeqMtEph.rs",
    "lines": "338-339",
    "spec_strength": "unknown",
    "snippet": "        fn empty() -> (empty_seq: Self)\n            ensures empty_seq.spec_len() == 0;"
  },
  {
    "id": 419,
    "function": "singleton",
    "file": "Chap18/ArraySeqMtEph.rs",
    "lines": "344-347",
    "spec_strength": "unknown",
    "snippet": "        fn singleton(item: T) -> (singleton: Self)\n            ensures\n                singleton.spec_len() == 1,\n                singleton.spec_index(0) == item;"
  },
  {
    "id": 420,
    "function": "append",
    "file": "Chap18/ArraySeqMtEph.rs",
    "lines": "352-360",
    "spec_strength": "unknown",
    "snippet": "        fn append(a: &ArraySeqMtEphS<T>, b: &ArraySeqMtEphS<T>) -> (appended: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                a.seq@.len() + b.seq@.len() <= usize::MAX as int,\n            ensures\n                appended.spec_len() == a.seq@.len() + b.seq@.len(),\n                forall|i: int| #![trigger appended.spec_index(i)] 0 <= i < a.seq@.len() ==> appended.spec_index(i) == a.seq@[i],\n                forall|i: int| #![trigger b.seq@[i]] 0 <= i < b.seq@.len() ==> appended.spec_index(a.seq@.len() as int + i) == b.seq@[i];"
  },
  {
    "id": 421,
    "function": "filter",
    "file": "Chap18/ArraySeqMtEph.rs",
    "lines": "367-381",
    "spec_strength": "unknown",
    "snippet": "        fn filter<F: Fn(&T) -> bool>(a: &ArraySeqMtEphS<T>, pred: &F, Ghost(spec_pred): Ghost<spec_fn(T) -> bool>) -> (filtered: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                forall|i: int| 0 <= i < a.seq@.len() ==> #[trigger] pred.requires((&a.seq@[i],)),\n                // The biconditional bridge ties the exec closure to the spec predicate.\n                forall|v: T, keep: bool| pred.ensures((&v,), keep) ==> spec_pred(v) == keep,\n            ensures\n                filtered.spec_len() <= a.seq@.len(),\n                filtered.spec_len() == spec_filter_len(\n                    Seq::new(a.seq@.len(), |i: int| a.seq@[i]), spec_pred),\n                // The result multiset equals the input multiset filtered by the spec predicate.\n                Seq::new(filtered.spec_len(), |i: int| filtered.spec_index(i)).to_multiset()\n                    =~= Seq::new(a.seq@.len(), |i: int| a.seq@[i]).to_multiset().filter(spec_pred),\n                forall|i: int| #![trigger filtered.spec_index(i)] 0 <= i < filtered.spec_len() ==> pred.ensures((&filtered.spec_index(i),), true);"
  },
  {
    "id": 422,
    "function": "update",
    "file": "Chap18/ArraySeqMtEph.rs",
    "lines": "386-394",
    "spec_strength": "unknown",
    "snippet": "        fn update(a: &ArraySeqMtEphS<T>, index: usize, item: T) -> (updated: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                index < a.seq@.len(),\n            ensures\n                updated.spec_len() == a.seq@.len(),\n                updated.spec_index(index as int) == item,\n                forall|i: int| #![trigger updated.spec_index(i)] 0 <= i < a.seq@.len() && i != index as int ==> updated.spec_index(i) == a.seq@[i];"
  },
  {
    "id": 423,
    "function": "inject",
    "file": "Chap18/ArraySeqMtEph.rs",
    "lines": "400-409",
    "spec_strength": "unknown",
    "snippet": "        fn inject(a: &Self, updates: &Vec<(usize, T)>) -> (injected: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n            ensures\n                injected.spec_len() == a.spec_len(),\n                Seq::new(injected.spec_len(), |i: int| injected.spec_index(i))\n                    =~= spec_inject(\n                        Seq::new(a.spec_len(), |i: int| a.spec_index(i)),\n                        updates@);"
  },
  {
    "id": 424,
    "function": "ninject",
    "file": "Chap18/ArraySeqMtEph.rs",
    "lines": "415-423",
    "spec_strength": "unknown",
    "snippet": "        fn ninject(a: &Self, updates: &Vec<(usize, T)>) -> (result: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n            ensures\n                spec_ninject(\n                    Seq::new(a.spec_len(), |i: int| a.spec_index(i)),\n                    updates@,\n                    Seq::new(result.spec_len(), |i: int| result.spec_index(i)));"
  },
  {
    "id": 425,
    "function": "is_empty",
    "file": "Chap18/ArraySeqMtEph.rs",
    "lines": "428-429",
    "spec_strength": "unknown",
    "snippet": "        fn is_empty(&self) -> (empty: bool)\n            ensures empty <==> self.spec_len() == 0;"
  },
  {
    "id": 426,
    "function": "is_singleton",
    "file": "Chap18/ArraySeqMtEph.rs",
    "lines": "434-435",
    "spec_strength": "unknown",
    "snippet": "        fn is_singleton(&self) -> (single: bool)\n            ensures single <==> self.spec_len() == 1;"
  },
  {
    "id": 427,
    "function": "iterate",
    "file": "Chap18/ArraySeqMtEph.rs",
    "lines": "440-445",
    "spec_strength": "unknown",
    "snippet": "        fn iterate<A, F: Fn(&A, &T) -> A>(a: &ArraySeqMtEphS<T>, f: &F, Ghost(spec_f): Ghost<spec_fn(A, T) -> A>, seed: A) -> (result: A)\n            requires\n                forall|x: &A, y: &T| #[trigger] f.requires((x, y)),\n                forall|a: A, t: T, ret: A| f.ensures((&a, &t), ret) <==> ret == spec_f(a, t),\n            ensures\n                result == spec_iterate(Seq::new(a.spec_len(), |i: int| a.spec_index(i)), spec_f, seed);"
  },
  {
    "id": 428,
    "function": "reduce",
    "file": "Chap18/ArraySeqMtEph.rs",
    "lines": "450-458",
    "spec_strength": "unknown",
    "snippet": "        fn reduce<F: Fn(&T, &T) -> T>(a: &ArraySeqMtEphS<T>, f: &F, Ghost(spec_f): Ghost<spec_fn(T, T) -> T>, id: T) -> (result: T)\n            where T: Clone\n            requires\n                spec_monoid(spec_f, id),\n                forall|x: &T, y: &T| #[trigger] f.requires((x, y)),\n                forall|x: T, y: T, ret: T| f.ensures((&x, &y), ret) <==> ret == spec_f(x, y),\n            ensures\n                result == spec_iterate(\n                    Seq::new(a.spec_len(), |i: int| a.spec_index(i)), spec_f, id);"
  },
  {
    "id": 429,
    "function": "scan",
    "file": "Chap18/ArraySeqMtEph.rs",
    "lines": "463-475",
    "spec_strength": "unknown",
    "snippet": "        fn scan<F: Fn(&T, &T) -> T>(a: &ArraySeqMtEphS<T>, f: &F, Ghost(spec_f): Ghost<spec_fn(T, T) -> T>, id: T) -> (scanned: (ArraySeqMtEphS<T>, T))\n            where T: Clone + Eq\n            requires\n                spec_monoid(spec_f, id),\n                obeys_feq_clone::<T>(),\n                forall|x: &T, y: &T| #[trigger] f.requires((x, y)),\n                forall|x: T, y: T, ret: T| f.ensures((&x, &y), ret) <==> ret == spec_f(x, y),\n            ensures\n                scanned.0.spec_len() == a.spec_len(),\n                forall|i: int| #![trigger scanned.0.spec_index(i)] 0 <= i < a.spec_len() ==>\n                    scanned.0.spec_index(i) == Seq::new(a.spec_len(), |j: int| a.spec_index(j)).take(i + 1).fold_left(id, spec_f),\n                scanned.1 == spec_iterate(\n                    Seq::new(a.spec_len(), |j: int| a.spec_index(j)), spec_f, id);"
  },
  {
    "id": 430,
    "function": "map",
    "file": "Chap18/ArraySeqMtEph.rs",
    "lines": "480-485",
    "spec_strength": "unknown",
    "snippet": "        fn map<U: Clone, F: Fn(&T) -> U>(a: &ArraySeqMtEphS<T>, f: &F) -> (mapped: ArraySeqMtEphS<U>)\n            requires\n                forall|i: int| 0 <= i < a.seq@.len() ==> #[trigger] f.requires((&a.seq@[i],)),\n            ensures\n                mapped.seq@.len() == a.seq@.len(),\n                forall|i: int| #![trigger mapped.seq@[i]] 0 <= i < a.seq@.len() ==> f.ensures((&a.seq@[i],), mapped.seq@[i]);"
  },
  {
    "id": 431,
    "function": "tabulate",
    "file": "Chap18/ArraySeqMtEph.rs",
    "lines": "490-496",
    "spec_strength": "unknown",
    "snippet": "        fn tabulate<F: Fn(usize) -> T>(f: &F, length: usize) -> (tab_seq: ArraySeqMtEphS<T>)\n            requires\n                length <= usize::MAX,\n                forall|i: usize| i < length ==> #[trigger] f.requires((i,)),\n            ensures\n                tab_seq.seq@.len() == length,\n                forall|i: int| #![trigger tab_seq.seq@[i]] 0 <= i < length ==> f.ensures((i as usize,), tab_seq.seq@[i]);"
  },
  {
    "id": 432,
    "function": "flatten",
    "file": "Chap18/ArraySeqMtEph.rs",
    "lines": "501-506",
    "spec_strength": "unknown",
    "snippet": "        fn flatten(a: &ArraySeqMtEphS<ArraySeqMtEphS<T>>) -> (flattened: ArraySeqMtEphS<T>)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n            ensures\n                flattened.seq@ =~= a.seq@.map_values(|inner: ArraySeqMtEphS<T>| inner.seq@).flatten();"
  },
  {
    "id": 433,
    "function": "lemma_spec_index",
    "file": "Chap18/ArraySeqMtEph.rs",
    "lines": "1069-1071",
    "spec_strength": "unknown",
    "snippet": "        broadcast proof fn lemma_spec_index(&self, i: int)\n            requires 0 <= i < self.spec_len()\n            ensures #[trigger] self.seq@[i] == self.spec_index(i)"
  },
  {
    "id": 434,
    "function": "iter",
    "file": "Chap18/ArraySeqMtEph.rs",
    "lines": "1075-1079",
    "spec_strength": "unknown",
    "snippet": "        pub fn iter(&self) -> (it: ArraySeqMtEphIter<'_, T>)\n            ensures\n                it@.0 == 0,\n                it@.1 == self.seq@,\n                iter_invariant(&it),"
  },
  {
    "id": 435,
    "function": "map_par",
    "file": "Chap18/ArraySeqMtEph.rs",
    "lines": "1086-1097",
    "spec_strength": "unknown",
    "snippet": "        pub fn map_par<U: Clone + Eq + View + Send + Sync + 'static, F: Fn(&T) -> U + Send + Sync + Clone + 'static>(\n            a: &ArraySeqMtEphS<T>,\n            f: F,\n        ) -> (mapped: ArraySeqMtEphS<U>)\n            where T: Clone + Send + Sync + Eq + 'static\n            requires\n                obeys_feq_clone::<T>(),\n                obeys_feq_clone::<U>(),\n                a.seq@.len() <= usize::MAX as int,\n                forall|i: int| 0 <= i < a.seq@.len() ==> #[trigger] f.requires((&a.seq@[i],)),\n            ensures mapped.seq@.len() == a.seq@.len()\n            decreases a.seq@.len()"
  },
  {
    "id": 436,
    "function": "filter_par",
    "file": "Chap18/ArraySeqMtEph.rs",
    "lines": "1138-1148",
    "spec_strength": "unknown",
    "snippet": "        pub fn filter_par<F: Fn(&T) -> bool + Send + Sync + Clone + 'static>(\n            a: &ArraySeqMtEphS<T>,\n            pred: F,\n        ) -> (filtered: ArraySeqMtEphS<T>)\n            where T: Clone + Send + Sync + Eq + 'static\n            requires\n                obeys_feq_clone::<T>(),\n                a.seq@.len() <= usize::MAX as int,\n                forall|i: int| 0 <= i < a.seq@.len() ==> #[trigger] pred.requires((&a.seq@[i],)),\n            ensures filtered.seq@.len() <= a.seq@.len()\n            decreases a.seq@.len()"
  },
  {
    "id": 437,
    "function": "lemma_monoid_fold_left",
    "file": "Chap18/ArraySeqMtEph.rs",
    "lines": "1192-1195",
    "spec_strength": "unknown",
    "snippet": "        proof fn lemma_monoid_fold_left(s: Seq<T>, f: spec_fn(T, T) -> T, id: T, x: T)\n            requires spec_monoid(f, id)\n            ensures f(x, s.fold_left(id, f)) == s.fold_left(x, f)\n            decreases s.len()"
  },
  {
    "id": 438,
    "function": "reduce_par",
    "file": "Chap18/ArraySeqMtEph.rs",
    "lines": "1220-1235",
    "spec_strength": "unknown",
    "snippet": "        pub fn reduce_par<F: Fn(&T, &T) -> T + Send + Sync + Clone + 'static>(\n            a: &ArraySeqMtEphS<T>,\n            f: F,\n            Ghost(spec_f): Ghost<spec_fn(T, T) -> T>,\n            id: T,\n        ) -> (reduced: T)\n            where T: Clone + Send + Sync + Eq + 'static\n            requires\n                obeys_feq_clone::<T>(),\n                spec_monoid(spec_f, id),\n                a.seq@.len() > 0,\n                forall|x: &T, y: &T| #[trigger] f.requires((x, y)),\n                forall|x: T, y: T, ret: T| f.ensures((&x, &y), ret) <==> ret == spec_f(x, y),\n            ensures\n                reduced == spec_iterate(Seq::new(a.spec_len(), |i: int| a.spec_index(i)), spec_f, id),\n            decreases a.seq@.len()"
  },
  {
    "id": 439,
    "function": "ninject_par",
    "file": "Chap18/ArraySeqMtEph.rs",
    "lines": "1308-1318",
    "spec_strength": "unknown",
    "snippet": "        pub fn ninject_par(a: &ArraySeqMtEphS<T>, updates: &Vec<(usize, T)>) -> (result: ArraySeqMtEphS<T>)\n            where T: Clone + Send + Sync + Eq + 'static\n            requires\n                obeys_feq_clone::<T>(),\n                forall|k: int| #![trigger updates@[k]] 0 <= k < updates@.len() ==>\n                    0 <= updates@[k].0 < a.seq@.len(),\n            ensures\n                spec_ninject(\n                    Seq::new(a.spec_len(), |i: int| a.spec_index(i)),\n                    updates@,\n                    Seq::new(result.spec_len(), |i: int| result.spec_index(i))),"
  },
  {
    "id": 440,
    "function": "next",
    "file": "Chap18/ArraySeqMtEph.rs",
    "lines": "1445-1461",
    "spec_strength": "unknown",
    "snippet": "        fn next(&mut self) -> (next: Option<&'a T>)\n            ensures ({\n                let (old_index, old_seq) = old(self)@;\n                match next {\n                    None => {\n                        &&& self@ == old(self)@\n                        &&& old_index >= old_seq.len()\n                    },\n                    Some(element) => {\n                        let (new_index, new_seq) = self@;\n                        &&& 0 <= old_index < old_seq.len()\n                        &&& new_seq == old_seq\n                        &&& new_index == old_index + 1\n                        &&& element == old_seq[old_index]\n                    },\n                }\n            })"
  },
  {
    "id": 441,
    "function": "eq",
    "file": "Chap18/ArraySeqMtEph.rs",
    "lines": "1564-1565",
    "spec_strength": "hole",
    "snippet": "        fn eq(&self, other: &Self) -> (equal: bool)\n            ensures equal == (self@ == other@)"
  },
  {
    "id": 442,
    "function": "new",
    "file": "Chap18/ArraySeqMtPer.rs",
    "lines": "101-108",
    "spec_strength": "unknown",
    "snippet": "        fn new(length: usize, init_value: T) -> (new_seq: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                length <= usize::MAX,\n            ensures\n                new_seq.spec_len() == length as int,\n                forall|i: int| #![trigger new_seq.spec_index(i)] 0 <= i < length ==> new_seq.spec_index(i) == init_value;"
  },
  {
    "id": 443,
    "function": "length",
    "file": "Chap18/ArraySeqMtPer.rs",
    "lines": "113-114",
    "spec_strength": "unknown",
    "snippet": "        fn length(&self) -> (len: usize)\n            ensures len as int == self.spec_len();"
  },
  {
    "id": 444,
    "function": "nth",
    "file": "Chap18/ArraySeqMtPer.rs",
    "lines": "119-121",
    "spec_strength": "unknown",
    "snippet": "        fn nth(&self, index: usize) -> (nth_elem: &T)\n            requires index < self.spec_len()\n            ensures *nth_elem == self.spec_index(index as int);"
  },
  {
    "id": 445,
    "function": "subseq_copy",
    "file": "Chap18/ArraySeqMtPer.rs",
    "lines": "126-134",
    "spec_strength": "unknown",
    "snippet": "        fn subseq_copy(&self, start: usize, length: usize) -> (subseq: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                start + length <= usize::MAX,\n                start + length <= self.spec_len(),\n            ensures\n                subseq.spec_len() == length as int,\n                forall|i: int| #![trigger subseq.spec_index(i)] 0 <= i < length ==> subseq.spec_index(i) == self.spec_index(start as int + i);"
  },
  {
    "id": 446,
    "function": "subseq",
    "file": "Chap18/ArraySeqMtPer.rs",
    "lines": "139-147",
    "spec_strength": "unknown",
    "snippet": "        fn subseq(a: &Self, start: usize, length: usize) -> (subseq: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                start + length <= usize::MAX,\n                start + length <= a.spec_len(),\n            ensures\n                subseq.spec_len() == length as int,\n                forall|i: int| #![trigger subseq.spec_index(i)] 0 <= i < length ==> subseq.spec_index(i) == a.spec_index(start as int + i);"
  },
  {
    "id": 447,
    "function": "from_vec",
    "file": "Chap18/ArraySeqMtPer.rs",
    "lines": "152-155",
    "spec_strength": "unknown",
    "snippet": "        fn from_vec(elts: Vec<T>) -> (seq: Self)\n            ensures\n                seq.spec_len() == elts@.len(),\n                forall|i: int| #![trigger seq.spec_index(i)] 0 <= i < elts@.len() ==> seq.spec_index(i) == elts@[i];"
  },
  {
    "id": 448,
    "function": "empty",
    "file": "Chap18/ArraySeqMtPer.rs",
    "lines": "164-165",
    "spec_strength": "unknown",
    "snippet": "        fn empty() -> (empty_seq: Self)\n            ensures empty_seq.spec_len() == 0;"
  },
  {
    "id": 449,
    "function": "singleton",
    "file": "Chap18/ArraySeqMtPer.rs",
    "lines": "170-173",
    "spec_strength": "unknown",
    "snippet": "        fn singleton(item: T) -> (singleton: Self)\n            ensures\n                singleton.spec_len() == 1,\n                singleton.spec_index(0) == item;"
  },
  {
    "id": 450,
    "function": "append",
    "file": "Chap18/ArraySeqMtPer.rs",
    "lines": "178-186",
    "spec_strength": "unknown",
    "snippet": "        fn append(a: &ArraySeqMtPerS<T>, b: &ArraySeqMtPerS<T>) -> (appended: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                a.seq@.len() + b.seq@.len() <= usize::MAX as int,\n            ensures\n                appended.spec_len() == a.seq@.len() + b.seq@.len(),\n                forall|i: int| #![trigger appended.spec_index(i)] 0 <= i < a.seq@.len() ==> appended.spec_index(i) == a.seq@[i],\n                forall|i: int| #![trigger b.seq@[i]] 0 <= i < b.seq@.len() ==> appended.spec_index(a.seq@.len() as int + i) == b.seq@[i];"
  },
  {
    "id": 451,
    "function": "filter",
    "file": "Chap18/ArraySeqMtPer.rs",
    "lines": "193-207",
    "spec_strength": "unknown",
    "snippet": "        fn filter<F: Fn(&T) -> bool>(a: &ArraySeqMtPerS<T>, pred: &F, Ghost(spec_pred): Ghost<spec_fn(T) -> bool>) -> (filtered: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                forall|i: int| 0 <= i < a.seq@.len() ==> #[trigger] pred.requires((&a.seq@[i],)),\n                // The biconditional bridge ties the exec closure to the spec predicate.\n                forall|v: T, keep: bool| pred.ensures((&v,), keep) ==> spec_pred(v) == keep,\n            ensures\n                filtered.spec_len() <= a.seq@.len(),\n                filtered.spec_len() == spec_filter_len(\n                    Seq::new(a.seq@.len(), |i: int| a.seq@[i]), spec_pred),\n                // The result multiset equals the input multiset filtered by the spec predicate.\n                Seq::new(filtered.spec_len(), |i: int| filtered.spec_index(i)).to_multiset()\n                    =~= Seq::new(a.seq@.len(), |i: int| a.seq@[i]).to_multiset().filter(spec_pred),\n                forall|i: int| #![trigger filtered.spec_index(i)] 0 <= i < filtered.spec_len() ==> pred.ensures((&filtered.spec_index(i),), true);"
  },
  {
    "id": 452,
    "function": "update",
    "file": "Chap18/ArraySeqMtPer.rs",
    "lines": "212-220",
    "spec_strength": "unknown",
    "snippet": "        fn update(a: &ArraySeqMtPerS<T>, index: usize, item: T) -> (updated: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                index < a.seq@.len(),\n            ensures\n                updated.spec_len() == a.seq@.len(),\n                updated.spec_index(index as int) == item,\n                forall|i: int| #![trigger updated.spec_index(i)] 0 <= i < a.seq@.len() && i != index as int ==> updated.spec_index(i) == a.seq@[i];"
  },
  {
    "id": 453,
    "function": "is_empty",
    "file": "Chap18/ArraySeqMtPer.rs",
    "lines": "225-226",
    "spec_strength": "unknown",
    "snippet": "        fn is_empty(&self) -> (empty: bool)\n            ensures empty <==> self.spec_len() == 0;"
  },
  {
    "id": 454,
    "function": "is_singleton",
    "file": "Chap18/ArraySeqMtPer.rs",
    "lines": "231-232",
    "spec_strength": "unknown",
    "snippet": "        fn is_singleton(&self) -> (single: bool)\n            ensures single <==> self.spec_len() == 1;"
  },
  {
    "id": 455,
    "function": "iterate",
    "file": "Chap18/ArraySeqMtPer.rs",
    "lines": "237-242",
    "spec_strength": "unknown",
    "snippet": "        fn iterate<A, F: Fn(&A, &T) -> A>(a: &ArraySeqMtPerS<T>, f: &F, Ghost(spec_f): Ghost<spec_fn(A, T) -> A>, seed: A) -> (accumulated: A)\n            requires\n                forall|x: &A, y: &T| #[trigger] f.requires((x, y)),\n                forall|a: A, t: T, ret: A| f.ensures((&a, &t), ret) ==> ret == spec_f(a, t),\n            ensures\n                accumulated == spec_iterate(Seq::new(a.spec_len(), |i: int| a.spec_index(i)), spec_f, seed);"
  },
  {
    "id": 456,
    "function": "reduce",
    "file": "Chap18/ArraySeqMtPer.rs",
    "lines": "247-255",
    "spec_strength": "unknown",
    "snippet": "        fn reduce<F: Fn(&T, &T) -> T>(a: &ArraySeqMtPerS<T>, f: &F, Ghost(spec_f): Ghost<spec_fn(T, T) -> T>, id: T) -> (reduced: T)\n            where T: Clone\n            requires\n                spec_monoid(spec_f, id),\n                forall|x: &T, y: &T| #[trigger] f.requires((x, y)),\n                forall|x: T, y: T, ret: T| f.ensures((&x, &y), ret) ==> ret == spec_f(x, y),\n            ensures\n                reduced == spec_iterate(\n                    Seq::new(a.spec_len(), |i: int| a.spec_index(i)), spec_f, id);"
  },
  {
    "id": 457,
    "function": "scan",
    "file": "Chap18/ArraySeqMtPer.rs",
    "lines": "260-272",
    "spec_strength": "unknown",
    "snippet": "        fn scan<F: Fn(&T, &T) -> T>(a: &ArraySeqMtPerS<T>, f: &F, Ghost(spec_f): Ghost<spec_fn(T, T) -> T>, id: T) -> (scanned: (ArraySeqMtPerS<T>, T))\n            where T: Clone + Eq\n            requires\n                spec_monoid(spec_f, id),\n                obeys_feq_clone::<T>(),\n                forall|x: &T, y: &T| #[trigger] f.requires((x, y)),\n                forall|x: T, y: T, ret: T| f.ensures((&x, &y), ret) ==> ret == spec_f(x, y),\n            ensures\n                scanned.0.spec_len() == a.spec_len(),\n                forall|i: int| #![trigger scanned.0.spec_index(i)] 0 <= i < a.spec_len() ==>\n                    scanned.0.spec_index(i) == Seq::new(a.spec_len(), |j: int| a.spec_index(j)).take(i + 1).fold_left(id, spec_f),\n                scanned.1 == spec_iterate(\n                    Seq::new(a.spec_len(), |j: int| a.spec_index(j)), spec_f, id);"
  },
  {
    "id": 458,
    "function": "map",
    "file": "Chap18/ArraySeqMtPer.rs",
    "lines": "277-282",
    "spec_strength": "unknown",
    "snippet": "        fn map<U: Clone, F: Fn(&T) -> U>(a: &ArraySeqMtPerS<T>, f: &F) -> (mapped: ArraySeqMtPerS<U>)\n            requires\n                forall|i: int| 0 <= i < a.seq@.len() ==> #[trigger] f.requires((&a.seq@[i],)),\n            ensures\n                mapped.seq@.len() == a.seq@.len(),\n                forall|i: int| #![trigger mapped.seq@[i]] 0 <= i < a.seq@.len() ==> f.ensures((&a.seq@[i],), mapped.seq@[i]);"
  },
  {
    "id": 459,
    "function": "tabulate",
    "file": "Chap18/ArraySeqMtPer.rs",
    "lines": "287-293",
    "spec_strength": "unknown",
    "snippet": "        fn tabulate<F: Fn(usize) -> T>(f: &F, length: usize) -> (tab_seq: ArraySeqMtPerS<T>)\n            requires\n                length <= usize::MAX,\n                forall|i: usize| i < length ==> #[trigger] f.requires((i,)),\n            ensures\n                tab_seq.seq@.len() == length,\n                forall|i: int| #![trigger tab_seq.seq@[i]] 0 <= i < length ==> f.ensures((i as usize,), tab_seq.seq@[i]);"
  },
  {
    "id": 460,
    "function": "flatten",
    "file": "Chap18/ArraySeqMtPer.rs",
    "lines": "298-303",
    "spec_strength": "unknown",
    "snippet": "        fn flatten(a: &ArraySeqMtPerS<ArraySeqMtPerS<T>>) -> (flattened: ArraySeqMtPerS<T>)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n            ensures\n                flattened.seq@ =~= a.seq@.map_values(|inner: ArraySeqMtPerS<T>| inner.seq@).flatten();"
  },
  {
    "id": 461,
    "function": "lemma_spec_index",
    "file": "Chap18/ArraySeqMtPer.rs",
    "lines": "761-763",
    "spec_strength": "unknown",
    "snippet": "        broadcast proof fn lemma_spec_index(&self, i: int)\n            requires 0 <= i < self.spec_len()\n            ensures #[trigger] self.seq@[i] == self.spec_index(i)"
  },
  {
    "id": 462,
    "function": "iter",
    "file": "Chap18/ArraySeqMtPer.rs",
    "lines": "767-771",
    "spec_strength": "unknown",
    "snippet": "        pub fn iter(&self) -> (it: ArraySeqMtPerIter<'_, T>)\n            ensures\n                it@.0 == 0,\n                it@.1 == self.seq@,\n                iter_invariant(&it),"
  },
  {
    "id": 463,
    "function": "map_par",
    "file": "Chap18/ArraySeqMtPer.rs",
    "lines": "779-789",
    "spec_strength": "unknown",
    "snippet": "        pub fn map_par<U: Clone + Eq + View + Send + Sync + 'static, F: Fn(&T) -> U + Send + Sync + Clone + 'static>(\n            a: &ArraySeqMtPerS<T>,\n            f: F,\n        ) -> (mapped: ArraySeqMtPerS<U>)\n            where T: Clone + Send + Sync + Eq + 'static\n            requires\n                obeys_feq_clone::<T>(),\n                obeys_feq_clone::<U>(),\n                forall|i: int| 0 <= i < a.seq@.len() ==> #[trigger] f.requires((&a.seq@[i],)),\n            ensures mapped.seq@.len() == a.seq@.len()\n            decreases a.seq@.len()"
  },
  {
    "id": 464,
    "function": "filter_par",
    "file": "Chap18/ArraySeqMtPer.rs",
    "lines": "837-846",
    "spec_strength": "unknown",
    "snippet": "        pub fn filter_par<F: Fn(&T) -> bool + Send + Sync + Clone + 'static>(\n            a: &ArraySeqMtPerS<T>,\n            pred: F,\n        ) -> (filtered: ArraySeqMtPerS<T>)\n            where T: Clone + Send + Sync + Eq + 'static\n            requires\n                obeys_feq_clone::<T>(),\n                forall|i: int| 0 <= i < a.seq@.len() ==> #[trigger] pred.requires((&a.seq@[i],)),\n            ensures filtered.seq@.len() <= a.seq@.len()\n            decreases a.seq@.len()"
  },
  {
    "id": 465,
    "function": "lemma_monoid_fold_left",
    "file": "Chap18/ArraySeqMtPer.rs",
    "lines": "894-897",
    "spec_strength": "unknown",
    "snippet": "        proof fn lemma_monoid_fold_left(s: Seq<T>, f: spec_fn(T, T) -> T, id: T, x: T)\n            requires spec_monoid(f, id)\n            ensures f(x, s.fold_left(id, f)) == s.fold_left(x, f)\n            decreases s.len()"
  },
  {
    "id": 466,
    "function": "reduce_par",
    "file": "Chap18/ArraySeqMtPer.rs",
    "lines": "934-949",
    "spec_strength": "unknown",
    "snippet": "        pub fn reduce_par<F: Fn(&T, &T) -> T + Send + Sync + Clone + 'static>(\n            a: &ArraySeqMtPerS<T>,\n            f: F,\n            Ghost(spec_f): Ghost<spec_fn(T, T) -> T>,\n            id: T,\n        ) -> (reduced: T)\n            where T: Clone + Send + Sync + Eq + 'static\n            requires\n                obeys_feq_clone::<T>(),\n                spec_monoid(spec_f, id),\n                a.seq@.len() > 0,\n                forall|x: &T, y: &T| #[trigger] f.requires((x, y)),\n                forall|x: T, y: T, ret: T| f.ensures((&x, &y), ret) <==> ret == spec_f(x, y),\n            ensures\n                reduced == spec_iterate(Seq::new(a.spec_len(), |i: int| a.spec_index(i)), spec_f, id),\n            decreases a.seq@.len()"
  },
  {
    "id": 467,
    "function": "next",
    "file": "Chap18/ArraySeqMtPer.rs",
    "lines": "1053-1069",
    "spec_strength": "unknown",
    "snippet": "        fn next(&mut self) -> (next: Option<&'a T>)\n            ensures ({\n                let (old_index, old_seq) = old(self)@;\n                match next {\n                    None => {\n                        &&& self@ == old(self)@\n                        &&& old_index >= old_seq.len()\n                    },\n                    Some(element) => {\n                        let (new_index, new_seq) = self@;\n                        &&& 0 <= old_index < old_seq.len()\n                        &&& new_seq == old_seq\n                        &&& new_index == old_index + 1\n                        &&& element == old_seq[old_index]\n                    },\n                }\n            })"
  },
  {
    "id": 468,
    "function": "eq",
    "file": "Chap18/ArraySeqMtPer.rs",
    "lines": "1172-1173",
    "spec_strength": "hole",
    "snippet": "        fn eq(&self, other: &Self) -> (equal: bool)\n            ensures equal == (self@ == other@)"
  },
  {
    "id": 469,
    "function": "new",
    "file": "Chap18/ArraySeqStEph.rs",
    "lines": "110-117",
    "spec_strength": "unknown",
    "snippet": "        fn new(length: usize, init_value: T) -> (new_seq: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                length <= usize::MAX,\n            ensures\n                new_seq.spec_len() == length as int,\n                forall|i: int| #![trigger new_seq.spec_index(i)] 0 <= i < length ==> new_seq.spec_index(i) == init_value;"
  },
  {
    "id": 470,
    "function": "set",
    "file": "Chap18/ArraySeqStEph.rs",
    "lines": "122-127",
    "spec_strength": "unknown",
    "snippet": "        fn set(&mut self, index: usize, item: T) -> (success: Result<(), &'static str>)\n            requires index < old(self).spec_len()\n            ensures\n                success.is_ok() ==> self.spec_len() == old(self).spec_len(),\n                success.is_ok() ==> self.spec_index(index as int) == item,\n                success.is_ok() ==> forall|i: int| #![trigger self.spec_index(i), old(self).spec_index(i)] 0 <= i < old(self).spec_len() && i != index ==> self.spec_index(i) == old(self).spec_index(i);"
  },
  {
    "id": 471,
    "function": "length",
    "file": "Chap18/ArraySeqStEph.rs",
    "lines": "132-133",
    "spec_strength": "unknown",
    "snippet": "        fn length(&self) -> (len: usize)\n            ensures len as int == self.spec_len();"
  },
  {
    "id": 472,
    "function": "nth",
    "file": "Chap18/ArraySeqStEph.rs",
    "lines": "138-140",
    "spec_strength": "unknown",
    "snippet": "        fn nth(&self, index: usize) -> (nth_elem: &T)\n            requires index < self.spec_len()\n            ensures *nth_elem == self.spec_index(index as int);"
  },
  {
    "id": 473,
    "function": "subseq_copy",
    "file": "Chap18/ArraySeqStEph.rs",
    "lines": "145-153",
    "spec_strength": "unknown",
    "snippet": "        fn subseq_copy(&self, start: usize, length: usize) -> (subseq: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                start + length <= usize::MAX,\n                start + length <= self.spec_len(),\n            ensures\n                subseq.spec_len() == length as int,\n                forall|i: int| #![trigger subseq.spec_index(i)] 0 <= i < length ==> subseq.spec_index(i) == self.spec_index(start as int + i);"
  },
  {
    "id": 474,
    "function": "subseq",
    "file": "Chap18/ArraySeqStEph.rs",
    "lines": "158-166",
    "spec_strength": "unknown",
    "snippet": "        fn subseq(a: &Self, start: usize, length: usize) -> (subseq: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                start + length <= usize::MAX,\n                start + length <= a.spec_len(),\n            ensures\n                subseq.spec_len() == length as int,\n                forall|i: int| #![trigger subseq.spec_index(i)] 0 <= i < length ==> subseq.spec_index(i) == a.spec_index(start as int + i);"
  },
  {
    "id": 475,
    "function": "from_vec",
    "file": "Chap18/ArraySeqStEph.rs",
    "lines": "171-174",
    "spec_strength": "unknown",
    "snippet": "        fn from_vec(elts: Vec<T>) -> (seq: Self)\n            ensures\n                seq.spec_len() == elts@.len(),\n                forall|i: int| #![trigger seq.spec_index(i)] 0 <= i < elts@.len() ==> seq.spec_index(i) == elts@[i];"
  },
  {
    "id": 476,
    "function": "empty",
    "file": "Chap18/ArraySeqStEph.rs",
    "lines": "183-184",
    "spec_strength": "unknown",
    "snippet": "        fn empty() -> (empty_seq: Self)\n            ensures empty_seq.spec_len() == 0;"
  },
  {
    "id": 477,
    "function": "singleton",
    "file": "Chap18/ArraySeqStEph.rs",
    "lines": "189-192",
    "spec_strength": "unknown",
    "snippet": "        fn singleton(item: T) -> (singleton: Self)\n            ensures\n                singleton.spec_len() == 1,\n                singleton.spec_index(0) == item;"
  },
  {
    "id": 478,
    "function": "append",
    "file": "Chap18/ArraySeqStEph.rs",
    "lines": "197-205",
    "spec_strength": "unknown",
    "snippet": "        fn append(a: &ArraySeqStEphS<T>, b: &ArraySeqStEphS<T>) -> (appended: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                a.seq@.len() + b.seq@.len() <= usize::MAX as int,\n            ensures\n                appended.spec_len() == a.seq@.len() + b.seq@.len(),\n                forall|i: int| #![trigger appended.spec_index(i)] 0 <= i < a.seq@.len() ==> appended.spec_index(i) == a.seq@[i],\n                forall|i: int| #![trigger b.seq@[i]] 0 <= i < b.seq@.len() ==> appended.spec_index(a.seq@.len() as int + i) == b.seq@[i];"
  },
  {
    "id": 479,
    "function": "filter",
    "file": "Chap18/ArraySeqStEph.rs",
    "lines": "212-226",
    "spec_strength": "unknown",
    "snippet": "        fn filter<F: Fn(&T) -> bool>(a: &ArraySeqStEphS<T>, pred: &F, Ghost(spec_pred): Ghost<spec_fn(T) -> bool>) -> (filtered: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                forall|i: int| 0 <= i < a.seq@.len() ==> #[trigger] pred.requires((&a.seq@[i],)),\n                // The biconditional bridge ties the exec closure to the spec predicate.\n                forall|v: T, keep: bool| pred.ensures((&v,), keep) ==> spec_pred(v) == keep,\n            ensures\n                filtered.spec_len() <= a.seq@.len(),\n                filtered.spec_len() == spec_filter_len(\n                    Seq::new(a.seq@.len(), |i: int| a.seq@[i]), spec_pred),\n                // The result multiset equals the input multiset filtered by the spec predicate.\n                Seq::new(filtered.spec_len(), |i: int| filtered.spec_index(i)).to_multiset()\n                    =~= Seq::new(a.seq@.len(), |i: int| a.seq@[i]).to_multiset().filter(spec_pred),\n                forall|i: int| #![trigger filtered.spec_index(i)] 0 <= i < filtered.spec_len() ==> pred.ensures((&filtered.spec_index(i),), true);"
  },
  {
    "id": 480,
    "function": "update",
    "file": "Chap18/ArraySeqStEph.rs",
    "lines": "231-239",
    "spec_strength": "unknown",
    "snippet": "        fn update(a: &ArraySeqStEphS<T>, index: usize, item: T) -> (updated: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                index < a.seq@.len(),\n            ensures\n                updated.spec_len() == a.seq@.len(),\n                updated.spec_index(index as int) == item,\n                forall|i: int| #![trigger updated.spec_index(i)] 0 <= i < a.seq@.len() && i != index as int ==> updated.spec_index(i) == a.seq@[i];"
  },
  {
    "id": 481,
    "function": "inject",
    "file": "Chap18/ArraySeqStEph.rs",
    "lines": "245-254",
    "spec_strength": "unknown",
    "snippet": "        fn inject(a: &Self, updates: &Vec<(usize, T)>) -> (injected: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n            ensures\n                injected.spec_len() == a.spec_len(),\n                Seq::new(injected.spec_len(), |i: int| injected.spec_index(i))\n                    =~= spec_inject(\n                        Seq::new(a.spec_len(), |i: int| a.spec_index(i)),\n                        updates@);"
  },
  {
    "id": 482,
    "function": "is_empty",
    "file": "Chap18/ArraySeqStEph.rs",
    "lines": "259-260",
    "spec_strength": "unknown",
    "snippet": "        fn is_empty(&self) -> (empty: bool)\n            ensures empty <==> self.spec_len() == 0;"
  },
  {
    "id": 483,
    "function": "is_singleton",
    "file": "Chap18/ArraySeqStEph.rs",
    "lines": "265-266",
    "spec_strength": "unknown",
    "snippet": "        fn is_singleton(&self) -> (single: bool)\n            ensures single <==> self.spec_len() == 1;"
  },
  {
    "id": 484,
    "function": "iterate",
    "file": "Chap18/ArraySeqStEph.rs",
    "lines": "271-276",
    "spec_strength": "unknown",
    "snippet": "        fn iterate<A, F: Fn(&A, &T) -> A>(a: &ArraySeqStEphS<T>, f: &F, Ghost(spec_f): Ghost<spec_fn(A, T) -> A>, seed: A) -> (accumulated: A)\n            requires\n                forall|x: &A, y: &T| #[trigger] f.requires((x, y)),\n                forall|a: A, t: T, ret: A| f.ensures((&a, &t), ret) <==> ret == spec_f(a, t),\n            ensures\n                accumulated == spec_iterate(Seq::new(a.spec_len(), |i: int| a.spec_index(i)), spec_f, seed);"
  },
  {
    "id": 485,
    "function": "reduce",
    "file": "Chap18/ArraySeqStEph.rs",
    "lines": "281-289",
    "spec_strength": "unknown",
    "snippet": "        fn reduce<F: Fn(&T, &T) -> T>(a: &ArraySeqStEphS<T>, f: &F, Ghost(spec_f): Ghost<spec_fn(T, T) -> T>, id: T) -> (reduced: T)\n            where T: Clone\n            requires\n                spec_monoid(spec_f, id),\n                forall|x: &T, y: &T| #[trigger] f.requires((x, y)),\n                forall|x: T, y: T, ret: T| f.ensures((&x, &y), ret) <==> ret == spec_f(x, y),\n            ensures\n                reduced == spec_iterate(\n                    Seq::new(a.spec_len(), |i: int| a.spec_index(i)), spec_f, id);"
  },
  {
    "id": 486,
    "function": "scan",
    "file": "Chap18/ArraySeqStEph.rs",
    "lines": "294-306",
    "spec_strength": "unknown",
    "snippet": "        fn scan<F: Fn(&T, &T) -> T>(a: &ArraySeqStEphS<T>, f: &F, Ghost(spec_f): Ghost<spec_fn(T, T) -> T>, id: T) -> (scanned: (ArraySeqStEphS<T>, T))\n            where T: Clone + Eq\n            requires\n                spec_monoid(spec_f, id),\n                obeys_feq_clone::<T>(),\n                forall|x: &T, y: &T| #[trigger] f.requires((x, y)),\n                forall|x: T, y: T, ret: T| f.ensures((&x, &y), ret) <==> ret == spec_f(x, y),\n            ensures\n                scanned.0.spec_len() == a.spec_len(),\n                forall|i: int| #![trigger scanned.0.spec_index(i)] 0 <= i < a.spec_len() ==>\n                    scanned.0.spec_index(i) == Seq::new(a.spec_len(), |j: int| a.spec_index(j)).take(i + 1).fold_left(id, spec_f),\n                scanned.1 == spec_iterate(\n                    Seq::new(a.spec_len(), |j: int| a.spec_index(j)), spec_f, id);"
  },
  {
    "id": 487,
    "function": "map",
    "file": "Chap18/ArraySeqStEph.rs",
    "lines": "311-316",
    "spec_strength": "unknown",
    "snippet": "        fn map<U: Clone, F: Fn(&T) -> U>(a: &ArraySeqStEphS<T>, f: &F) -> (mapped: ArraySeqStEphS<U>)\n            requires\n                forall|i: int| 0 <= i < a.seq@.len() ==> #[trigger] f.requires((&a.seq@[i],)),\n            ensures\n                mapped.seq@.len() == a.seq@.len(),\n                forall|i: int| #![trigger mapped.seq@[i]] 0 <= i < a.seq@.len() ==> f.ensures((&a.seq@[i],), mapped.seq@[i]);"
  },
  {
    "id": 488,
    "function": "tabulate",
    "file": "Chap18/ArraySeqStEph.rs",
    "lines": "321-327",
    "spec_strength": "unknown",
    "snippet": "        fn tabulate<F: Fn(usize) -> T>(f: &F, length: usize) -> (tab_seq: ArraySeqStEphS<T>)\n            requires\n                length <= usize::MAX,\n                forall|i: usize| i < length ==> #[trigger] f.requires((i,)),\n            ensures\n                tab_seq.seq@.len() == length,\n                forall|i: int| #![trigger tab_seq.seq@[i]] 0 <= i < length ==> f.ensures((i as usize,), tab_seq.seq@[i]);"
  },
  {
    "id": 489,
    "function": "flatten",
    "file": "Chap18/ArraySeqStEph.rs",
    "lines": "332-337",
    "spec_strength": "unknown",
    "snippet": "        fn flatten(a: &ArraySeqStEphS<ArraySeqStEphS<T>>) -> (flattened: ArraySeqStEphS<T>)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n            ensures\n                flattened.seq@ =~= a.seq@.map_values(|inner: ArraySeqStEphS<T>| inner.seq@).flatten();"
  },
  {
    "id": 490,
    "function": "lemma_spec_index",
    "file": "Chap18/ArraySeqStEph.rs",
    "lines": "876-878",
    "spec_strength": "unknown",
    "snippet": "        broadcast proof fn lemma_spec_index(&self, i: int)\n            requires 0 <= i < self.spec_len()\n            ensures #[trigger] self.seq@[i] == self.spec_index(i)"
  },
  {
    "id": 491,
    "function": "iter",
    "file": "Chap18/ArraySeqStEph.rs",
    "lines": "882-886",
    "spec_strength": "unknown",
    "snippet": "        pub fn iter(&self) -> (it: ArraySeqStEphIter<'_, T>)\n            ensures\n                it@.0 == 0,\n                it@.1 == self.seq@,\n                iter_invariant(&it),"
  },
  {
    "id": 492,
    "function": "next",
    "file": "Chap18/ArraySeqStEph.rs",
    "lines": "933-949",
    "spec_strength": "unknown",
    "snippet": "        fn next(&mut self) -> (next: Option<&'a T>)\n            ensures ({\n                let (old_index, old_seq) = old(self)@;\n                match next {\n                    None => {\n                        &&& self@ == old(self)@\n                        &&& old_index >= old_seq.len()\n                    },\n                    Some(element) => {\n                        let (new_index, new_seq) = self@;\n                        &&& 0 <= old_index < old_seq.len()\n                        &&& new_seq == old_seq\n                        &&& new_index == old_index + 1\n                        &&& element == old_seq[old_index]\n                    },\n                }\n            })"
  },
  {
    "id": 493,
    "function": "eq",
    "file": "Chap18/ArraySeqStEph.rs",
    "lines": "1039-1040",
    "spec_strength": "hole",
    "snippet": "        fn eq(&self, other: &Self) -> (equal: bool)\n            ensures equal == (self@ == other@)"
  },
  {
    "id": 494,
    "function": "new",
    "file": "Chap18/ArraySeqStPer.rs",
    "lines": "110-117",
    "spec_strength": "unknown",
    "snippet": "        fn new(length: usize, init_value: T) -> (new_seq: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                length <= usize::MAX,\n            ensures\n                new_seq.spec_len() == length as int,\n                forall|i: int| #![trigger new_seq.spec_index(i)] 0 <= i < length ==> new_seq.spec_index(i) == init_value;"
  },
  {
    "id": 495,
    "function": "length",
    "file": "Chap18/ArraySeqStPer.rs",
    "lines": "122-123",
    "spec_strength": "unknown",
    "snippet": "        fn length(&self) -> (len: usize)\n            ensures len as int == self.spec_len();"
  },
  {
    "id": 496,
    "function": "nth",
    "file": "Chap18/ArraySeqStPer.rs",
    "lines": "128-130",
    "spec_strength": "unknown",
    "snippet": "        fn nth(&self, index: usize) -> (nth_elem: &T)\n            requires index < self.spec_len()\n            ensures *nth_elem == self.spec_index(index as int);"
  },
  {
    "id": 497,
    "function": "subseq_copy",
    "file": "Chap18/ArraySeqStPer.rs",
    "lines": "135-143",
    "spec_strength": "unknown",
    "snippet": "        fn subseq_copy(&self, start: usize, length: usize) -> (subseq: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                start + length <= usize::MAX,\n                start + length <= self.spec_len(),\n            ensures\n                subseq.spec_len() == length as int,\n                forall|i: int| #![trigger subseq.spec_index(i)] 0 <= i < length ==> subseq.spec_index(i) == self.spec_index(start as int + i);"
  },
  {
    "id": 498,
    "function": "subseq",
    "file": "Chap18/ArraySeqStPer.rs",
    "lines": "148-156",
    "spec_strength": "unknown",
    "snippet": "        fn subseq(a: &Self, start: usize, length: usize) -> (subseq: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                start + length <= usize::MAX,\n                start + length <= a.spec_len(),\n            ensures\n                subseq.spec_len() == length as int,\n                forall|i: int| #![trigger subseq.spec_index(i)] 0 <= i < length ==> subseq.spec_index(i) == a.spec_index(start as int + i);"
  },
  {
    "id": 499,
    "function": "from_vec",
    "file": "Chap18/ArraySeqStPer.rs",
    "lines": "161-164",
    "spec_strength": "unknown",
    "snippet": "        fn from_vec(elts: Vec<T>) -> (seq: Self)\n            ensures\n                seq.spec_len() == elts@.len(),\n                forall|i: int| #![trigger seq.spec_index(i)] 0 <= i < elts@.len() ==> seq.spec_index(i) == elts@[i];"
  },
  {
    "id": 500,
    "function": "empty",
    "file": "Chap18/ArraySeqStPer.rs",
    "lines": "173-174",
    "spec_strength": "unknown",
    "snippet": "        fn empty() -> (empty_seq: Self)\n            ensures empty_seq.spec_len() == 0;"
  },
  {
    "id": 501,
    "function": "singleton",
    "file": "Chap18/ArraySeqStPer.rs",
    "lines": "179-182",
    "spec_strength": "unknown",
    "snippet": "        fn singleton(item: T) -> (singleton: Self)\n            ensures\n                singleton.spec_len() == 1,\n                singleton.spec_index(0) == item;"
  },
  {
    "id": 502,
    "function": "append",
    "file": "Chap18/ArraySeqStPer.rs",
    "lines": "187-195",
    "spec_strength": "unknown",
    "snippet": "        fn append(a: &ArraySeqStPerS<T>, b: &ArraySeqStPerS<T>) -> (appended: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                a.seq@.len() + b.seq@.len() <= usize::MAX as int,\n            ensures\n                appended.spec_len() == a.seq@.len() + b.seq@.len(),\n                forall|i: int| #![trigger appended.spec_index(i)] 0 <= i < a.seq@.len() ==> appended.spec_index(i) == a.seq@[i],\n                forall|i: int| #![trigger b.seq@[i]] 0 <= i < b.seq@.len() ==> appended.spec_index(a.seq@.len() as int + i) == b.seq@[i];"
  },
  {
    "id": 503,
    "function": "filter",
    "file": "Chap18/ArraySeqStPer.rs",
    "lines": "202-216",
    "spec_strength": "unknown",
    "snippet": "        fn filter<F: Fn(&T) -> bool>(a: &ArraySeqStPerS<T>, pred: &F, Ghost(spec_pred): Ghost<spec_fn(T) -> bool>) -> (filtered: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                forall|i: int| 0 <= i < a.seq@.len() ==> #[trigger] pred.requires((&a.seq@[i],)),\n                // The biconditional bridge ties the exec closure to the spec predicate.\n                forall|v: T, keep: bool| pred.ensures((&v,), keep) ==> spec_pred(v) == keep,\n            ensures\n                filtered.spec_len() <= a.seq@.len(),\n                filtered.spec_len() == spec_filter_len(\n                    Seq::new(a.seq@.len(), |i: int| a.seq@[i]), spec_pred),\n                // The result multiset equals the input multiset filtered by the spec predicate.\n                Seq::new(filtered.spec_len(), |i: int| filtered.spec_index(i)).to_multiset()\n                    =~= Seq::new(a.seq@.len(), |i: int| a.seq@[i]).to_multiset().filter(spec_pred),\n                forall|i: int| #![trigger filtered.spec_index(i)] 0 <= i < filtered.spec_len() ==> pred.ensures((&filtered.spec_index(i),), true);"
  },
  {
    "id": 504,
    "function": "update",
    "file": "Chap18/ArraySeqStPer.rs",
    "lines": "221-229",
    "spec_strength": "unknown",
    "snippet": "        fn update(a: &ArraySeqStPerS<T>, index: usize, item: T) -> (updated: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                index < a.seq@.len(),\n            ensures\n                updated.spec_len() == a.seq@.len(),\n                updated.spec_index(index as int) == item,\n                forall|i: int| #![trigger updated.spec_index(i)] 0 <= i < a.seq@.len() && i != index as int ==> updated.spec_index(i) == a.seq@[i];"
  },
  {
    "id": 505,
    "function": "inject",
    "file": "Chap18/ArraySeqStPer.rs",
    "lines": "235-244",
    "spec_strength": "unknown",
    "snippet": "        fn inject(a: &Self, updates: &Vec<(usize, T)>) -> (injected: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n            ensures\n                injected.spec_len() == a.spec_len(),\n                Seq::new(injected.spec_len(), |i: int| injected.spec_index(i))\n                    =~= spec_inject(\n                        Seq::new(a.spec_len(), |i: int| a.spec_index(i)),\n                        updates@);"
  },
  {
    "id": 506,
    "function": "is_empty",
    "file": "Chap18/ArraySeqStPer.rs",
    "lines": "249-250",
    "spec_strength": "unknown",
    "snippet": "        fn is_empty(&self) -> (empty: bool)\n            ensures empty <==> self.spec_len() == 0;"
  },
  {
    "id": 507,
    "function": "is_singleton",
    "file": "Chap18/ArraySeqStPer.rs",
    "lines": "255-256",
    "spec_strength": "unknown",
    "snippet": "        fn is_singleton(&self) -> (single: bool)\n            ensures single <==> self.spec_len() == 1;"
  },
  {
    "id": 508,
    "function": "iterate",
    "file": "Chap18/ArraySeqStPer.rs",
    "lines": "261-266",
    "spec_strength": "unknown",
    "snippet": "        fn iterate<A, F: Fn(&A, &T) -> A>(a: &ArraySeqStPerS<T>, f: &F, Ghost(spec_f): Ghost<spec_fn(A, T) -> A>, seed: A) -> (accumulated: A)\n            requires\n                forall|x: &A, y: &T| #[trigger] f.requires((x, y)),\n                forall|a: A, t: T, ret: A| f.ensures((&a, &t), ret) ==> ret == spec_f(a, t),\n            ensures\n                accumulated == spec_iterate(Seq::new(a.spec_len(), |i: int| a.spec_index(i)), spec_f, seed);"
  },
  {
    "id": 509,
    "function": "reduce",
    "file": "Chap18/ArraySeqStPer.rs",
    "lines": "271-279",
    "spec_strength": "unknown",
    "snippet": "        fn reduce<F: Fn(&T, &T) -> T>(a: &ArraySeqStPerS<T>, f: &F, Ghost(spec_f): Ghost<spec_fn(T, T) -> T>, id: T) -> (reduced: T)\n            where T: Clone\n            requires\n                spec_monoid(spec_f, id),\n                forall|x: &T, y: &T| #[trigger] f.requires((x, y)),\n                forall|x: T, y: T, ret: T| f.ensures((&x, &y), ret) ==> ret == spec_f(x, y),\n            ensures\n                reduced == spec_iterate(\n                    Seq::new(a.spec_len(), |i: int| a.spec_index(i)), spec_f, id);"
  },
  {
    "id": 510,
    "function": "scan",
    "file": "Chap18/ArraySeqStPer.rs",
    "lines": "284-296",
    "spec_strength": "unknown",
    "snippet": "        fn scan<F: Fn(&T, &T) -> T>(a: &ArraySeqStPerS<T>, f: &F, Ghost(spec_f): Ghost<spec_fn(T, T) -> T>, id: T) -> (scanned: (ArraySeqStPerS<T>, T))\n            where T: Clone + Eq\n            requires\n                spec_monoid(spec_f, id),\n                obeys_feq_clone::<T>(),\n                forall|x: &T, y: &T| #[trigger] f.requires((x, y)),\n                forall|x: T, y: T, ret: T| f.ensures((&x, &y), ret) ==> ret == spec_f(x, y),\n            ensures\n                scanned.0.spec_len() == a.spec_len(),\n                forall|i: int| #![trigger scanned.0.spec_index(i)] 0 <= i < a.spec_len() ==>\n                    scanned.0.spec_index(i) == Seq::new(a.spec_len(), |j: int| a.spec_index(j)).take(i + 1).fold_left(id, spec_f),\n                scanned.1 == spec_iterate(\n                    Seq::new(a.spec_len(), |j: int| a.spec_index(j)), spec_f, id);"
  },
  {
    "id": 511,
    "function": "map",
    "file": "Chap18/ArraySeqStPer.rs",
    "lines": "301-306",
    "spec_strength": "unknown",
    "snippet": "        fn map<U: Clone, F: Fn(&T) -> U>(a: &ArraySeqStPerS<T>, f: &F) -> (mapped: ArraySeqStPerS<U>)\n            requires\n                forall|i: int| 0 <= i < a.seq@.len() ==> #[trigger] f.requires((&a.seq@[i],)),\n            ensures\n                mapped.seq@.len() == a.seq@.len(),\n                forall|i: int| #![trigger mapped.seq@[i]] 0 <= i < a.seq@.len() ==> f.ensures((&a.seq@[i],), mapped.seq@[i]);"
  },
  {
    "id": 512,
    "function": "tabulate",
    "file": "Chap18/ArraySeqStPer.rs",
    "lines": "311-317",
    "spec_strength": "unknown",
    "snippet": "        fn tabulate<F: Fn(usize) -> T>(f: &F, length: usize) -> (tab_seq: ArraySeqStPerS<T>)\n            requires\n                length <= usize::MAX,\n                forall|i: usize| i < length ==> #[trigger] f.requires((i,)),\n            ensures\n                tab_seq.seq@.len() == length,\n                forall|i: int| #![trigger tab_seq.seq@[i]] 0 <= i < length ==> f.ensures((i as usize,), tab_seq.seq@[i]);"
  },
  {
    "id": 513,
    "function": "flatten",
    "file": "Chap18/ArraySeqStPer.rs",
    "lines": "322-327",
    "spec_strength": "unknown",
    "snippet": "        fn flatten(a: &ArraySeqStPerS<ArraySeqStPerS<T>>) -> (flattened: ArraySeqStPerS<T>)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n            ensures\n                flattened.seq@ =~= a.seq@.map_values(|inner: ArraySeqStPerS<T>| inner.seq@).flatten();"
  },
  {
    "id": 514,
    "function": "lemma_spec_index",
    "file": "Chap18/ArraySeqStPer.rs",
    "lines": "857-859",
    "spec_strength": "unknown",
    "snippet": "        broadcast proof fn lemma_spec_index(&self, i: int)\n            requires 0 <= i < self.spec_len()\n            ensures #[trigger] self.seq@[i] == self.spec_index(i)"
  },
  {
    "id": 515,
    "function": "iter",
    "file": "Chap18/ArraySeqStPer.rs",
    "lines": "863-867",
    "spec_strength": "unknown",
    "snippet": "        pub fn iter(&self) -> (it: ArraySeqStPerIter<'_, T>)\n            ensures\n                it@.0 == 0,\n                it@.1 == self.seq@,\n                iter_invariant(&it),"
  },
  {
    "id": 516,
    "function": "next",
    "file": "Chap18/ArraySeqStPer.rs",
    "lines": "901-917",
    "spec_strength": "unknown",
    "snippet": "        fn next(&mut self) -> (next: Option<&'a T>)\n            ensures ({\n                let (old_index, old_seq) = old(self)@;\n                match next {\n                    None => {\n                        &&& self@ == old(self)@\n                        &&& old_index >= old_seq.len()\n                    },\n                    Some(element) => {\n                        let (new_index, new_seq) = self@;\n                        &&& 0 <= old_index < old_seq.len()\n                        &&& new_seq == old_seq\n                        &&& new_index == old_index + 1\n                        &&& element == old_seq[old_index]\n                    },\n                }\n            })"
  },
  {
    "id": 517,
    "function": "eq",
    "file": "Chap18/ArraySeqStPer.rs",
    "lines": "1001-1002",
    "spec_strength": "hole",
    "snippet": "        fn eq(&self, other: &Self) -> (equal: bool)\n            ensures equal == (self@ == other@)"
  },
  {
    "id": 518,
    "function": "new",
    "file": "Chap18/LinkedListStEph.rs",
    "lines": "97-104",
    "spec_strength": "unknown",
    "snippet": "        fn new(length: usize, init_value: T) -> (new_seq: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                length <= usize::MAX,\n            ensures\n                new_seq.spec_len() == length as int,\n                forall|i: int| #![trigger new_seq.spec_index(i)] 0 <= i < length ==> new_seq.spec_index(i) == init_value;"
  },
  {
    "id": 519,
    "function": "set",
    "file": "Chap18/LinkedListStEph.rs",
    "lines": "108-113",
    "spec_strength": "unknown",
    "snippet": "        fn set(&mut self, index: usize, item: T) -> (success: Result<(), &'static str>)\n            requires index < old(self).spec_len()\n            ensures\n                success.is_ok() ==> self.spec_len() == old(self).spec_len(),\n                success.is_ok() ==> self.spec_index(index as int) == item,\n                success.is_ok() ==> forall|i: int| #![trigger self.spec_index(i), old(self).spec_index(i)] 0 <= i < old(self).spec_len() && i != index ==> self.spec_index(i) == old(self).spec_index(i);"
  },
  {
    "id": 520,
    "function": "length",
    "file": "Chap18/LinkedListStEph.rs",
    "lines": "117-118",
    "spec_strength": "unknown",
    "snippet": "        fn length(&self) -> (len: usize)\n            ensures len as int == self.spec_len();"
  },
  {
    "id": 521,
    "function": "nth",
    "file": "Chap18/LinkedListStEph.rs",
    "lines": "122-124",
    "spec_strength": "unknown",
    "snippet": "        fn nth(&self, index: usize) -> (nth_elem: &T)\n            requires index < self.spec_len()\n            ensures *nth_elem == self.spec_index(index as int);"
  },
  {
    "id": 522,
    "function": "subseq_copy",
    "file": "Chap18/LinkedListStEph.rs",
    "lines": "128-136",
    "spec_strength": "unknown",
    "snippet": "        fn subseq_copy(&self, start: usize, length: usize) -> (subseq: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                start + length <= usize::MAX,\n                start + length <= self.spec_len(),\n            ensures\n                subseq.spec_len() == length as int,\n                forall|i: int| #![trigger subseq.spec_index(i)] 0 <= i < length ==> subseq.spec_index(i) == self.spec_index(start as int + i);"
  },
  {
    "id": 523,
    "function": "from_vec",
    "file": "Chap18/LinkedListStEph.rs",
    "lines": "140-143",
    "spec_strength": "unknown",
    "snippet": "        fn from_vec(elts: Vec<T>) -> (seq: Self)\n            ensures\n                seq.spec_len() == elts@.len(),\n                forall|i: int| #![trigger seq.spec_index(i)] 0 <= i < elts@.len() ==> seq.spec_index(i) == elts@[i];"
  },
  {
    "id": 524,
    "function": "empty",
    "file": "Chap18/LinkedListStEph.rs",
    "lines": "151-152",
    "spec_strength": "unknown",
    "snippet": "        fn empty() -> (empty_seq: Self)\n            ensures empty_seq.spec_len() == 0;"
  },
  {
    "id": 525,
    "function": "singleton",
    "file": "Chap18/LinkedListStEph.rs",
    "lines": "156-159",
    "spec_strength": "unknown",
    "snippet": "        fn singleton(item: T) -> (singleton: Self)\n            ensures\n                singleton.spec_len() == 1,\n                singleton.spec_index(0) == item;"
  },
  {
    "id": 526,
    "function": "tabulate",
    "file": "Chap18/LinkedListStEph.rs",
    "lines": "163-169",
    "spec_strength": "unknown",
    "snippet": "        fn tabulate<F: Fn(usize) -> T>(f: &F, n: usize) -> (tab_seq: LinkedListStEphS<T>)\n            requires\n                n <= usize::MAX,\n                forall|i: usize| i < n ==> #[trigger] f.requires((i,)),\n            ensures\n                tab_seq.seq@.len() == n,\n                forall|i: int| #![trigger tab_seq.seq@[i]] 0 <= i < n ==> f.ensures((i as usize,), tab_seq.seq@[i]);"
  },
  {
    "id": 527,
    "function": "map",
    "file": "Chap18/LinkedListStEph.rs",
    "lines": "173-178",
    "spec_strength": "unknown",
    "snippet": "        fn map<U: Clone, F: Fn(&T) -> U>(a: &LinkedListStEphS<T>, f: &F) -> (mapped: LinkedListStEphS<U>)\n            requires\n                forall|i: int| 0 <= i < a.seq@.len() ==> #[trigger] f.requires((&a.seq@[i],)),\n            ensures\n                mapped.seq@.len() == a.seq@.len(),\n                forall|i: int| #![trigger mapped.seq@[i]] 0 <= i < a.seq@.len() ==> f.ensures((&a.seq@[i],), mapped.seq@[i]);"
  },
  {
    "id": 528,
    "function": "append",
    "file": "Chap18/LinkedListStEph.rs",
    "lines": "182-190",
    "spec_strength": "unknown",
    "snippet": "        fn append(a: &LinkedListStEphS<T>, b: &LinkedListStEphS<T>) -> (appended: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                a.seq@.len() + b.seq@.len() <= usize::MAX as int,\n            ensures\n                appended.spec_len() == a.seq@.len() + b.seq@.len(),\n                forall|i: int| #![trigger appended.spec_index(i)] 0 <= i < a.seq@.len() ==> appended.spec_index(i) == a.seq@[i],\n                forall|i: int| #![trigger b.seq@[i]] 0 <= i < b.seq@.len() ==> appended.spec_index(a.seq@.len() as int + i) == b.seq@[i];"
  },
  {
    "id": 529,
    "function": "filter",
    "file": "Chap18/LinkedListStEph.rs",
    "lines": "196-210",
    "spec_strength": "unknown",
    "snippet": "        fn filter<F: Fn(&T) -> bool>(a: &LinkedListStEphS<T>, pred: &F, Ghost(spec_pred): Ghost<spec_fn(T) -> bool>) -> (filtered: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                forall|i: int| 0 <= i < a.seq@.len() ==> #[trigger] pred.requires((&a.seq@[i],)),\n                // The biconditional bridge ties the exec closure to the spec predicate.\n                forall|v: T, keep: bool| pred.ensures((&v,), keep) ==> spec_pred(v) == keep,\n            ensures\n                filtered.spec_len() <= a.seq@.len(),\n                filtered.spec_len() == spec_filter_len(\n                    Seq::new(a.seq@.len(), |i: int| a.seq@[i]), spec_pred),\n                // The result multiset equals the input multiset filtered by the spec predicate.\n                Seq::new(filtered.spec_len(), |i: int| filtered.spec_index(i)).to_multiset()\n                    =~= Seq::new(a.seq@.len(), |i: int| a.seq@[i]).to_multiset().filter(spec_pred),\n                forall|i: int| #![trigger filtered.spec_index(i)] 0 <= i < filtered.spec_len() ==> pred.ensures((&filtered.spec_index(i),), true);"
  },
  {
    "id": 530,
    "function": "flatten",
    "file": "Chap18/LinkedListStEph.rs",
    "lines": "214-219",
    "spec_strength": "unknown",
    "snippet": "        fn flatten(a: &LinkedListStEphS<LinkedListStEphS<T>>) -> (flattened: LinkedListStEphS<T>)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n            ensures\n                flattened.seq@ =~= a.seq@.map_values(|inner: LinkedListStEphS<T>| inner.seq@).flatten();"
  },
  {
    "id": 531,
    "function": "update",
    "file": "Chap18/LinkedListStEph.rs",
    "lines": "223-231",
    "spec_strength": "unknown",
    "snippet": "        fn update(a: &LinkedListStEphS<T>, index: usize, item: T) -> (updated: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                index < a.seq@.len(),\n            ensures\n                updated.spec_len() == a.seq@.len(),\n                updated.spec_index(index as int) == item,\n                forall|i: int| #![trigger updated.spec_index(i)] 0 <= i < a.seq@.len() && i != index as int ==> updated.spec_index(i) == a.seq@[i];"
  },
  {
    "id": 532,
    "function": "is_empty",
    "file": "Chap18/LinkedListStEph.rs",
    "lines": "235-236",
    "spec_strength": "unknown",
    "snippet": "        fn is_empty(&self) -> (empty: bool)\n            ensures empty <==> self.spec_len() == 0;"
  },
  {
    "id": 533,
    "function": "is_singleton",
    "file": "Chap18/LinkedListStEph.rs",
    "lines": "240-241",
    "spec_strength": "unknown",
    "snippet": "        fn is_singleton(&self) -> (single: bool)\n            ensures single <==> self.spec_len() == 1;"
  },
  {
    "id": 534,
    "function": "iterate",
    "file": "Chap18/LinkedListStEph.rs",
    "lines": "245-250",
    "spec_strength": "unknown",
    "snippet": "        fn iterate<A, F: Fn(&A, &T) -> A>(a: &LinkedListStEphS<T>, f: &F, Ghost(spec_f): Ghost<spec_fn(A, T) -> A>, seed: A) -> (accumulated: A)\n            requires\n                forall|x: &A, y: &T| #[trigger] f.requires((x, y)),\n                forall|a: A, t: T, ret: A| f.ensures((&a, &t), ret) <==> ret == spec_f(a, t),\n            ensures\n                accumulated == spec_iterate(Seq::new(a.spec_len(), |i: int| a.spec_index(i)), spec_f, seed);"
  },
  {
    "id": 535,
    "function": "reduce",
    "file": "Chap18/LinkedListStEph.rs",
    "lines": "254-262",
    "spec_strength": "unknown",
    "snippet": "        fn reduce<F: Fn(&T, &T) -> T>(a: &LinkedListStEphS<T>, f: &F, Ghost(spec_f): Ghost<spec_fn(T, T) -> T>, id: T) -> (reduced: T)\n            where T: Clone\n            requires\n                spec_monoid(spec_f, id),\n                forall|x: &T, y: &T| #[trigger] f.requires((x, y)),\n                forall|x: T, y: T, ret: T| f.ensures((&x, &y), ret) <==> ret == spec_f(x, y),\n            ensures\n                reduced == spec_iterate(\n                    Seq::new(a.spec_len(), |i: int| a.spec_index(i)), spec_f, id);"
  },
  {
    "id": 536,
    "function": "scan",
    "file": "Chap18/LinkedListStEph.rs",
    "lines": "266-278",
    "spec_strength": "unknown",
    "snippet": "        fn scan<F: Fn(&T, &T) -> T>(a: &LinkedListStEphS<T>, f: &F, Ghost(spec_f): Ghost<spec_fn(T, T) -> T>, id: T) -> (scanned: (LinkedListStEphS<T>, T))\n            where T: Clone + Eq\n            requires\n                spec_monoid(spec_f, id),\n                obeys_feq_clone::<T>(),\n                forall|x: &T, y: &T| #[trigger] f.requires((x, y)),\n                forall|x: T, y: T, ret: T| f.ensures((&x, &y), ret) <==> ret == spec_f(x, y),\n            ensures\n                scanned.0.spec_len() == a.spec_len(),\n                forall|i: int| #![trigger scanned.0.spec_index(i)] 0 <= i < a.spec_len() ==>\n                    scanned.0.spec_index(i) == Seq::new(a.spec_len(), |j: int| a.spec_index(j)).take(i + 1).fold_left(id, spec_f),\n                scanned.1 == spec_iterate(\n                    Seq::new(a.spec_len(), |j: int| a.spec_index(j)), spec_f, id);"
  },
  {
    "id": 537,
    "function": "lemma_spec_index",
    "file": "Chap18/LinkedListStEph.rs",
    "lines": "718-720",
    "spec_strength": "unknown",
    "snippet": "        broadcast proof fn lemma_spec_index(&self, i: int)\n            requires 0 <= i < self.spec_len()\n            ensures #[trigger] self.seq@[i] == self.spec_index(i)"
  },
  {
    "id": 538,
    "function": "iter",
    "file": "Chap18/LinkedListStEph.rs",
    "lines": "726-730",
    "spec_strength": "unknown",
    "snippet": "        pub fn iter(&self) -> (it: LinkedListStEphIter<'_, T>)\n            ensures\n                it@.0 == 0,\n                it@.1 == self.seq@,\n                iter_invariant(&it),"
  },
  {
    "id": 539,
    "function": "next",
    "file": "Chap18/LinkedListStEph.rs",
    "lines": "766-782",
    "spec_strength": "unknown",
    "snippet": "        fn next(&mut self) -> (next: Option<&'a T>)\n            ensures ({\n                let (old_index, old_seq) = old(self)@;\n                match next {\n                    None => {\n                        &&& self@ == old(self)@\n                        &&& old_index >= old_seq.len()\n                    },\n                    Some(element) => {\n                        let (new_index, new_seq) = self@;\n                        &&& 0 <= old_index < old_seq.len()\n                        &&& new_seq == old_seq\n                        &&& new_index == old_index + 1\n                        &&& element == old_seq[old_index]\n                    },\n                }\n            })"
  },
  {
    "id": 540,
    "function": "eq",
    "file": "Chap18/LinkedListStEph.rs",
    "lines": "874-875",
    "spec_strength": "hole",
    "snippet": "        fn eq(&self, other: &Self) -> (equal: bool)\n            ensures equal == (self@ == other@)"
  },
  {
    "id": 541,
    "function": "new",
    "file": "Chap18/LinkedListStPer.rs",
    "lines": "98-105",
    "spec_strength": "unknown",
    "snippet": "        fn new(length: usize, init_value: T) -> (new_seq: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                length <= usize::MAX,\n            ensures\n                new_seq.spec_len() == length as int,\n                forall|i: int| #![trigger new_seq.spec_index(i)] 0 <= i < length ==> new_seq.spec_index(i) == init_value;"
  },
  {
    "id": 542,
    "function": "length",
    "file": "Chap18/LinkedListStPer.rs",
    "lines": "109-110",
    "spec_strength": "unknown",
    "snippet": "        fn length(&self) -> (len: usize)\n            ensures len as int == self.spec_len();"
  },
  {
    "id": 543,
    "function": "nth",
    "file": "Chap18/LinkedListStPer.rs",
    "lines": "114-116",
    "spec_strength": "unknown",
    "snippet": "        fn nth(&self, index: usize) -> (nth_elem: &T)\n            requires index < self.spec_len()\n            ensures *nth_elem == self.spec_index(index as int);"
  },
  {
    "id": 544,
    "function": "subseq_copy",
    "file": "Chap18/LinkedListStPer.rs",
    "lines": "120-128",
    "spec_strength": "unknown",
    "snippet": "        fn subseq_copy(&self, start: usize, length: usize) -> (subseq: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                start + length <= usize::MAX,\n                start + length <= self.spec_len(),\n            ensures\n                subseq.spec_len() == length as int,\n                forall|i: int| #![trigger subseq.spec_index(i)] 0 <= i < length ==> subseq.spec_index(i) == self.spec_index(start as int + i);"
  },
  {
    "id": 545,
    "function": "from_vec",
    "file": "Chap18/LinkedListStPer.rs",
    "lines": "132-135",
    "spec_strength": "unknown",
    "snippet": "        fn from_vec(elts: Vec<T>) -> (seq: Self)\n            ensures\n                seq.spec_len() == elts@.len(),\n                forall|i: int| #![trigger seq.spec_index(i)] 0 <= i < elts@.len() ==> seq.spec_index(i) == elts@[i];"
  },
  {
    "id": 546,
    "function": "empty",
    "file": "Chap18/LinkedListStPer.rs",
    "lines": "143-144",
    "spec_strength": "unknown",
    "snippet": "        fn empty() -> (empty_seq: Self)\n            ensures empty_seq.spec_len() == 0;"
  },
  {
    "id": 547,
    "function": "singleton",
    "file": "Chap18/LinkedListStPer.rs",
    "lines": "148-151",
    "spec_strength": "unknown",
    "snippet": "        fn singleton(item: T) -> (singleton: Self)\n            ensures\n                singleton.spec_len() == 1,\n                singleton.spec_index(0) == item;"
  },
  {
    "id": 548,
    "function": "tabulate",
    "file": "Chap18/LinkedListStPer.rs",
    "lines": "155-161",
    "spec_strength": "unknown",
    "snippet": "        fn tabulate<F: Fn(usize) -> T>(f: &F, n: usize) -> (tab_seq: LinkedListStPerS<T>)\n            requires\n                n <= usize::MAX,\n                forall|i: usize| i < n ==> #[trigger] f.requires((i,)),\n            ensures\n                tab_seq.seq@.len() == n,\n                forall|i: int| #![trigger tab_seq.seq@[i]] 0 <= i < n ==> f.ensures((i as usize,), tab_seq.seq@[i]);"
  },
  {
    "id": 549,
    "function": "map",
    "file": "Chap18/LinkedListStPer.rs",
    "lines": "165-170",
    "spec_strength": "unknown",
    "snippet": "        fn map<U: Clone, F: Fn(&T) -> U>(a: &LinkedListStPerS<T>, f: &F) -> (mapped: LinkedListStPerS<U>)\n            requires\n                forall|i: int| 0 <= i < a.seq@.len() ==> #[trigger] f.requires((&a.seq@[i],)),\n            ensures\n                mapped.seq@.len() == a.seq@.len(),\n                forall|i: int| #![trigger mapped.seq@[i]] 0 <= i < a.seq@.len() ==> f.ensures((&a.seq@[i],), mapped.seq@[i]);"
  },
  {
    "id": 550,
    "function": "append",
    "file": "Chap18/LinkedListStPer.rs",
    "lines": "174-182",
    "spec_strength": "unknown",
    "snippet": "        fn append(a: &LinkedListStPerS<T>, b: &LinkedListStPerS<T>) -> (appended: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                a.seq@.len() + b.seq@.len() <= usize::MAX as int,\n            ensures\n                appended.spec_len() == a.seq@.len() + b.seq@.len(),\n                forall|i: int| #![trigger appended.spec_index(i)] 0 <= i < a.seq@.len() ==> appended.spec_index(i) == a.seq@[i],\n                forall|i: int| #![trigger b.seq@[i]] 0 <= i < b.seq@.len() ==> appended.spec_index(a.seq@.len() as int + i) == b.seq@[i];"
  },
  {
    "id": 551,
    "function": "filter",
    "file": "Chap18/LinkedListStPer.rs",
    "lines": "188-202",
    "spec_strength": "unknown",
    "snippet": "        fn filter<F: Fn(&T) -> bool>(a: &LinkedListStPerS<T>, pred: &F, Ghost(spec_pred): Ghost<spec_fn(T) -> bool>) -> (filtered: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                forall|i: int| 0 <= i < a.seq@.len() ==> #[trigger] pred.requires((&a.seq@[i],)),\n                // The biconditional bridge ties the exec closure to the spec predicate.\n                forall|v: T, keep: bool| pred.ensures((&v,), keep) ==> spec_pred(v) == keep,\n            ensures\n                filtered.spec_len() <= a.seq@.len(),\n                filtered.spec_len() == spec_filter_len(\n                    Seq::new(a.seq@.len(), |i: int| a.seq@[i]), spec_pred),\n                // The result multiset equals the input multiset filtered by the spec predicate.\n                Seq::new(filtered.spec_len(), |i: int| filtered.spec_index(i)).to_multiset()\n                    =~= Seq::new(a.seq@.len(), |i: int| a.seq@[i]).to_multiset().filter(spec_pred),\n                forall|i: int| #![trigger filtered.spec_index(i)] 0 <= i < filtered.spec_len() ==> pred.ensures((&filtered.spec_index(i),), true);"
  },
  {
    "id": 552,
    "function": "flatten",
    "file": "Chap18/LinkedListStPer.rs",
    "lines": "206-211",
    "spec_strength": "unknown",
    "snippet": "        fn flatten(a: &LinkedListStPerS<LinkedListStPerS<T>>) -> (flattened: LinkedListStPerS<T>)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n            ensures\n                flattened.seq@ =~= a.seq@.map_values(|inner: LinkedListStPerS<T>| inner.seq@).flatten();"
  },
  {
    "id": 553,
    "function": "update",
    "file": "Chap18/LinkedListStPer.rs",
    "lines": "215-223",
    "spec_strength": "unknown",
    "snippet": "        fn update(a: &LinkedListStPerS<T>, index: usize, item: T) -> (updated: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                index < a.seq@.len(),\n            ensures\n                updated.spec_len() == a.seq@.len(),\n                updated.spec_index(index as int) == item,\n                forall|i: int| #![trigger updated.spec_index(i)] 0 <= i < a.seq@.len() && i != index as int ==> updated.spec_index(i) == a.seq@[i];"
  },
  {
    "id": 554,
    "function": "is_empty",
    "file": "Chap18/LinkedListStPer.rs",
    "lines": "227-228",
    "spec_strength": "unknown",
    "snippet": "        fn is_empty(&self) -> (empty: bool)\n            ensures empty <==> self.spec_len() == 0;"
  },
  {
    "id": 555,
    "function": "is_singleton",
    "file": "Chap18/LinkedListStPer.rs",
    "lines": "232-233",
    "spec_strength": "unknown",
    "snippet": "        fn is_singleton(&self) -> (single: bool)\n            ensures single <==> self.spec_len() == 1;"
  },
  {
    "id": 556,
    "function": "iterate",
    "file": "Chap18/LinkedListStPer.rs",
    "lines": "237-242",
    "spec_strength": "unknown",
    "snippet": "        fn iterate<A, F: Fn(&A, &T) -> A>(a: &LinkedListStPerS<T>, f: &F, Ghost(spec_f): Ghost<spec_fn(A, T) -> A>, seed: A) -> (accumulated: A)\n            requires\n                forall|x: &A, y: &T| #[trigger] f.requires((x, y)),\n                forall|a: A, t: T, ret: A| f.ensures((&a, &t), ret) <==> ret == spec_f(a, t),\n            ensures\n                accumulated == spec_iterate(Seq::new(a.spec_len(), |i: int| a.spec_index(i)), spec_f, seed);"
  },
  {
    "id": 557,
    "function": "reduce",
    "file": "Chap18/LinkedListStPer.rs",
    "lines": "246-254",
    "spec_strength": "unknown",
    "snippet": "        fn reduce<F: Fn(&T, &T) -> T>(a: &LinkedListStPerS<T>, f: &F, Ghost(spec_f): Ghost<spec_fn(T, T) -> T>, id: T) -> (reduced: T)\n            where T: Clone\n            requires\n                spec_monoid(spec_f, id),\n                forall|x: &T, y: &T| #[trigger] f.requires((x, y)),\n                forall|x: T, y: T, ret: T| f.ensures((&x, &y), ret) <==> ret == spec_f(x, y),\n            ensures\n                reduced == spec_iterate(\n                    Seq::new(a.spec_len(), |i: int| a.spec_index(i)), spec_f, id);"
  },
  {
    "id": 558,
    "function": "scan",
    "file": "Chap18/LinkedListStPer.rs",
    "lines": "258-270",
    "spec_strength": "unknown",
    "snippet": "        fn scan<F: Fn(&T, &T) -> T>(a: &LinkedListStPerS<T>, f: &F, Ghost(spec_f): Ghost<spec_fn(T, T) -> T>, id: T) -> (scanned: (LinkedListStPerS<T>, T))\n            where T: Clone + Eq\n            requires\n                spec_monoid(spec_f, id),\n                obeys_feq_clone::<T>(),\n                forall|x: &T, y: &T| #[trigger] f.requires((x, y)),\n                forall|x: T, y: T, ret: T| f.ensures((&x, &y), ret) <==> ret == spec_f(x, y),\n            ensures\n                scanned.0.spec_len() == a.spec_len(),\n                forall|i: int| #![trigger scanned.0.spec_index(i)] 0 <= i < a.spec_len() ==>\n                    scanned.0.spec_index(i) == Seq::new(a.spec_len(), |j: int| a.spec_index(j)).take(i + 1).fold_left(id, spec_f),\n                scanned.1 == spec_iterate(\n                    Seq::new(a.spec_len(), |j: int| a.spec_index(j)), spec_f, id);"
  },
  {
    "id": 559,
    "function": "lemma_spec_index",
    "file": "Chap18/LinkedListStPer.rs",
    "lines": "701-703",
    "spec_strength": "unknown",
    "snippet": "        broadcast proof fn lemma_spec_index(&self, i: int)\n            requires 0 <= i < self.spec_len()\n            ensures #[trigger] self.seq@[i] == self.spec_index(i)"
  },
  {
    "id": 560,
    "function": "iter",
    "file": "Chap18/LinkedListStPer.rs",
    "lines": "709-713",
    "spec_strength": "unknown",
    "snippet": "        pub fn iter(&self) -> (it: LinkedListStPerIter<'_, T>)\n            ensures\n                it@.0 == 0,\n                it@.1 == self.seq@,\n                iter_invariant(&it),"
  },
  {
    "id": 561,
    "function": "next",
    "file": "Chap18/LinkedListStPer.rs",
    "lines": "749-765",
    "spec_strength": "unknown",
    "snippet": "        fn next(&mut self) -> (next: Option<&'a T>)\n            ensures ({\n                let (old_index, old_seq) = old(self)@;\n                match next {\n                    None => {\n                        &&& self@ == old(self)@\n                        &&& old_index >= old_seq.len()\n                    },\n                    Some(element) => {\n                        let (new_index, new_seq) = self@;\n                        &&& 0 <= old_index < old_seq.len()\n                        &&& new_seq == old_seq\n                        &&& new_index == old_index + 1\n                        &&& element == old_seq[old_index]\n                    },\n                }\n            })"
  },
  {
    "id": 562,
    "function": "eq",
    "file": "Chap18/LinkedListStPer.rs",
    "lines": "857-858",
    "spec_strength": "hole",
    "snippet": "        fn eq(&self, other: &Self) -> (equal: bool)\n            ensures equal == (self@ == other@)"
  },
  {
    "id": 563,
    "function": "lemma_spec_inject_element",
    "file": "Chap19/ArraySeqMtEph.rs",
    "lines": "122-131",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_spec_inject_element<T>(s: Seq<T>, u: Seq<(usize, T)>, i: int)\n        requires 0 <= i < s.len(),\n        ensures ({\n            let r = spec_inject(s, u);\n            r.len() == s.len()\n            && (r[i] == s[i]\n                || exists|j: int| #![trigger u[j]] 0 <= j < u.len()\n                    && u[j].0 == i as usize && r[i] == u[j].1)\n        }),\n        decreases u.len(),"
  },
  {
    "id": 564,
    "function": "lemma_spec_inject_len",
    "file": "Chap19/ArraySeqMtEph.rs",
    "lines": "162-164",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_spec_inject_len<T>(s: Seq<T>, u: Seq<(usize, T)>)\n        ensures spec_inject(s, u).len() == s.len(),\n        decreases u.len(),"
  },
  {
    "id": 565,
    "function": "new",
    "file": "Chap19/ArraySeqMtEph.rs",
    "lines": "186-193",
    "spec_strength": "unknown",
    "snippet": "        fn new(length: usize, init_value: T) -> (new_seq: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                length <= usize::MAX,\n            ensures\n                new_seq.spec_len() == length as int,\n                forall|i: int| #![trigger new_seq.spec_index(i)] 0 <= i < length ==> new_seq.spec_index(i) == init_value;"
  },
  {
    "id": 566,
    "function": "set",
    "file": "Chap19/ArraySeqMtEph.rs",
    "lines": "198-204",
    "spec_strength": "unknown",
    "snippet": "        fn set(&mut self, index: usize, item: T) -> (success: Result<(), &'static str>)\n            requires index < old(self).spec_len()\n            ensures\n                success.is_ok(),\n                success.is_ok() ==> self.spec_len() == old(self).spec_len(),\n                success.is_ok() ==> self.spec_index(index as int) == item,\n                success.is_ok() ==> forall|i: int| #![trigger self.spec_index(i), old(self).spec_index(i)] 0 <= i < old(self).spec_len() && i != index ==> self.spec_index(i) == old(self).spec_index(i);"
  },
  {
    "id": 567,
    "function": "length",
    "file": "Chap19/ArraySeqMtEph.rs",
    "lines": "209-210",
    "spec_strength": "unknown",
    "snippet": "        fn length(&self) -> (len: usize)\n            ensures len as int == self.spec_len();"
  },
  {
    "id": 568,
    "function": "nth",
    "file": "Chap19/ArraySeqMtEph.rs",
    "lines": "215-217",
    "spec_strength": "unknown",
    "snippet": "        fn nth(&self, index: usize) -> (nth_elem: &T)\n            requires index < self.spec_len()\n            ensures *nth_elem == self.spec_index(index as int);"
  },
  {
    "id": 569,
    "function": "subseq_copy",
    "file": "Chap19/ArraySeqMtEph.rs",
    "lines": "222-230",
    "spec_strength": "unknown",
    "snippet": "        fn subseq_copy(&self, start: usize, length: usize) -> (subseq: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                start + length <= usize::MAX,\n                start + length <= self.spec_len(),\n            ensures\n                subseq.spec_len() == length as int,\n                forall|i: int| #![trigger subseq.spec_index(i)] 0 <= i < length ==> subseq.spec_index(i) == self.spec_index(start as int + i);"
  },
  {
    "id": 570,
    "function": "subseq",
    "file": "Chap19/ArraySeqMtEph.rs",
    "lines": "235-243",
    "spec_strength": "unknown",
    "snippet": "        fn subseq(a: &Self, start: usize, length: usize) -> (subseq: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                start + length <= usize::MAX,\n                start + length <= a.spec_len(),\n            ensures\n                subseq.spec_len() == length as int,\n                forall|i: int| #![trigger subseq.spec_index(i)] 0 <= i < length ==> subseq.spec_index(i) == a.spec_index(start as int + i);"
  },
  {
    "id": 571,
    "function": "from_vec",
    "file": "Chap19/ArraySeqMtEph.rs",
    "lines": "248-251",
    "spec_strength": "unknown",
    "snippet": "        fn from_vec(elts: Vec<T>) -> (seq: Self)\n            ensures\n                seq.spec_len() == elts@.len(),\n                forall|i: int| #![trigger seq.spec_index(i)] 0 <= i < elts@.len() ==> seq.spec_index(i) == elts@[i];"
  },
  {
    "id": 572,
    "function": "empty",
    "file": "Chap19/ArraySeqMtEph.rs",
    "lines": "256-257",
    "spec_strength": "unknown",
    "snippet": "        fn empty() -> (empty_seq: Self)\n            ensures empty_seq.spec_len() == 0;"
  },
  {
    "id": 573,
    "function": "singleton",
    "file": "Chap19/ArraySeqMtEph.rs",
    "lines": "262-267",
    "spec_strength": "unknown",
    "snippet": "        fn singleton(item: T) -> (singleton: Self)\n            where T: Clone + Eq\n            requires obeys_feq_clone::<T>()\n            ensures\n                singleton.spec_len() == 1,\n                singleton.spec_index(0) == item;"
  },
  {
    "id": 574,
    "function": "append",
    "file": "Chap19/ArraySeqMtEph.rs",
    "lines": "272-280",
    "spec_strength": "unknown",
    "snippet": "        fn append(a: &ArraySeqMtEphS<T>, b: &ArraySeqMtEphS<T>) -> (appended: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                a.seq@.len() + b.seq@.len() <= usize::MAX as int,\n            ensures\n                appended.spec_len() == a.seq@.len() + b.seq@.len(),\n                forall|i: int| #![trigger appended.spec_index(i)] 0 <= i < a.seq@.len() ==> appended.spec_index(i) == a.seq@[i],\n                forall|i: int| #![trigger b.seq@[i]] 0 <= i < b.seq@.len() ==> appended.spec_index(a.seq@.len() as int + i) == b.seq@[i];"
  },
  {
    "id": 575,
    "function": "filter",
    "file": "Chap19/ArraySeqMtEph.rs",
    "lines": "285-297",
    "spec_strength": "unknown",
    "snippet": "        fn filter<F: Fn(&T) -> bool>(a: &ArraySeqMtEphS<T>, pred: &F, Ghost(spec_pred): Ghost<spec_fn(T) -> bool>) -> (filtered: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                forall|i: int| 0 <= i < a.seq@.len() ==> #[trigger] pred.requires((&a.seq@[i],)),\n                forall|v: T, keep: bool| pred.ensures((&v,), keep) ==> spec_pred(v) == keep,\n            ensures\n                filtered.spec_len() <= a.seq@.len(),\n                filtered.spec_len() == spec_filter_len(\n                    Seq::new(a.seq@.len(), |i: int| a.seq@[i]), spec_pred),\n                Seq::new(filtered.spec_len(), |i: int| filtered.spec_index(i)).to_multiset()\n                    =~= Seq::new(a.seq@.len(), |i: int| a.seq@[i]).to_multiset().filter(spec_pred),\n                forall|i: int| #![trigger filtered.spec_index(i)] 0 <= i < filtered.spec_len() ==> pred.ensures((&filtered.spec_index(i),), true);"
  },
  {
    "id": 576,
    "function": "update",
    "file": "Chap19/ArraySeqMtEph.rs",
    "lines": "302-310",
    "spec_strength": "unknown",
    "snippet": "        fn update(a: &ArraySeqMtEphS<T>, index: usize, item: T) -> (updated: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                index < a.seq@.len(),\n            ensures\n                updated.spec_len() == a.seq@.len(),\n                updated.spec_index(index as int) == item,\n                forall|i: int| #![trigger updated.spec_index(i)] 0 <= i < a.seq@.len() && i != index as int ==> updated.spec_index(i) == a.seq@[i];"
  },
  {
    "id": 577,
    "function": "inject",
    "file": "Chap19/ArraySeqMtEph.rs",
    "lines": "316-325",
    "spec_strength": "unknown",
    "snippet": "        fn inject(a: &Self, updates: &Vec<(usize, T)>) -> (injected: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n            ensures\n                injected.spec_len() == a.spec_len(),\n                Seq::new(injected.spec_len(), |i: int| injected.spec_index(i))\n                    =~= spec_inject(\n                        Seq::new(a.spec_len(), |i: int| a.spec_index(i)),\n                        updates@);"
  },
  {
    "id": 578,
    "function": "ninject",
    "file": "Chap19/ArraySeqMtEph.rs",
    "lines": "331-339",
    "spec_strength": "unknown",
    "snippet": "        fn ninject(a: &Self, updates: &Vec<(usize, T)>) -> (result: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n            ensures\n                spec_ninject(\n                    Seq::new(a.spec_len(), |i: int| a.spec_index(i)),\n                    updates@,\n                    Seq::new(result.spec_len(), |i: int| result.spec_index(i)));"
  },
  {
    "id": 579,
    "function": "is_empty",
    "file": "Chap19/ArraySeqMtEph.rs",
    "lines": "344-345",
    "spec_strength": "unknown",
    "snippet": "        fn is_empty(&self) -> (empty: bool)\n            ensures empty <==> self.spec_len() == 0;"
  },
  {
    "id": 580,
    "function": "is_singleton",
    "file": "Chap19/ArraySeqMtEph.rs",
    "lines": "350-351",
    "spec_strength": "unknown",
    "snippet": "        fn is_singleton(&self) -> (single: bool)\n            ensures single <==> self.spec_len() == 1;"
  },
  {
    "id": 581,
    "function": "iterate_iter",
    "file": "Chap19/ArraySeqMtEph.rs",
    "lines": "356-357",
    "spec_strength": "unknown",
    "snippet": "        fn iterate_iter<A, F: Fn(&A, &T) -> A>(a: &ArraySeqMtEphS<T>, f: &F, seed: A) -> A\n            requires forall|x: &A, y: &T| #[trigger] f.requires((x, y));"
  },
  {
    "id": 582,
    "function": "iterate",
    "file": "Chap19/ArraySeqMtEph.rs",
    "lines": "362-366",
    "spec_strength": "unknown",
    "snippet": "        fn iterate<A, F: Fn(&A, &T) -> A>(a: &ArraySeqMtEphS<T>, f: &F, seed: A) -> A\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                forall|x: &A, y: &T| #[trigger] f.requires((x, y));"
  },
  {
    "id": 583,
    "function": "reduce_iter",
    "file": "Chap19/ArraySeqMtEph.rs",
    "lines": "371-373",
    "spec_strength": "unknown",
    "snippet": "        fn reduce_iter<F: Fn(&T, &T) -> T>(a: &ArraySeqMtEphS<T>, f: &F, id: T) -> T\n            where T: Clone\n            requires forall|x: &T, y: &T| #[trigger] f.requires((x, y));"
  },
  {
    "id": 584,
    "function": "reduce",
    "file": "Chap19/ArraySeqMtEph.rs",
    "lines": "378-382",
    "spec_strength": "unknown",
    "snippet": "        fn reduce<F: Fn(&T, &T) -> T>(a: &ArraySeqMtEphS<T>, f: &F, id: T) -> T\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                forall|x: &T, y: &T| #[trigger] f.requires((x, y));"
  },
  {
    "id": 585,
    "function": "scan",
    "file": "Chap19/ArraySeqMtEph.rs",
    "lines": "387-390",
    "spec_strength": "unknown",
    "snippet": "        fn scan<F: Fn(&T, &T) -> T>(a: &ArraySeqMtEphS<T>, f: &F, id: T) -> (scanned: (ArraySeqMtEphS<T>, T))\n            where T: Clone\n            requires forall|x: &T, y: &T| #[trigger] f.requires((x, y))\n            ensures scanned.0.seq@.len() == a.seq@.len();"
  },
  {
    "id": 586,
    "function": "map",
    "file": "Chap19/ArraySeqMtEph.rs",
    "lines": "395-400",
    "spec_strength": "unknown",
    "snippet": "        fn map<U: Clone, F: Fn(&T) -> U>(a: &ArraySeqMtEphS<T>, f: &F) -> (mapped: ArraySeqMtEphS<U>)\n            requires\n                forall|i: int| 0 <= i < a.seq@.len() ==> #[trigger] f.requires((&a.seq@[i],)),\n            ensures\n                mapped.seq@.len() == a.seq@.len(),\n                forall|i: int| #![trigger mapped.seq@[i]] 0 <= i < a.seq@.len() ==> f.ensures((&a.seq@[i],), mapped.seq@[i]);"
  },
  {
    "id": 587,
    "function": "tabulate",
    "file": "Chap19/ArraySeqMtEph.rs",
    "lines": "405-411",
    "spec_strength": "unknown",
    "snippet": "        fn tabulate<F: Fn(usize) -> T>(f: &F, length: usize) -> (tab_seq: ArraySeqMtEphS<T>)\n            requires\n                length <= usize::MAX,\n                forall|i: usize| i < length ==> #[trigger] f.requires((i,)),\n            ensures\n                tab_seq.seq@.len() == length,\n                forall|i: int| #![trigger tab_seq.seq@[i]] 0 <= i < length ==> f.ensures((i as usize,), tab_seq.seq@[i]);"
  },
  {
    "id": 588,
    "function": "flatten",
    "file": "Chap19/ArraySeqMtEph.rs",
    "lines": "416-421",
    "spec_strength": "unknown",
    "snippet": "        fn flatten(a: &ArraySeqMtEphS<ArraySeqMtEphS<T>>) -> (flattened: ArraySeqMtEphS<T>)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n            ensures\n                flattened.seq@ =~= a.seq@.map_values(|inner: ArraySeqMtEphS<T>| inner.seq@).flatten();"
  },
  {
    "id": 589,
    "function": "deflate",
    "file": "Chap19/ArraySeqMtEph.rs",
    "lines": "426-434",
    "spec_strength": "unknown",
    "snippet": "        fn deflate<F: Fn(&T) -> bool>(pred: &F, x: &T) -> (deflated: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                pred.requires((x,)),\n            ensures\n                deflated.spec_len() <= 1,\n                deflated.spec_len() == 1 ==> pred.ensures((x,), true) && deflated.spec_index(0) == *x,\n                deflated.spec_len() == 0 ==> pred.ensures((x,), false);"
  },
  {
    "id": 590,
    "function": "lemma_flatten_bounded_by_outer_len",
    "file": "Chap19/ArraySeqMtEph.rs",
    "lines": "992-995",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_flatten_bounded_by_outer_len<T>(ss: Seq<Seq<T>>)\n        requires forall|i: int| #![trigger ss[i]] 0 <= i < ss.len() ==> ss[i].len() <= 1\n        ensures ss.flatten().len() <= ss.len()\n        decreases ss.len()"
  },
  {
    "id": 591,
    "function": "lemma_flatten_all_satisfy",
    "file": "Chap19/ArraySeqMtEph.rs",
    "lines": "1007-1012",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_flatten_all_satisfy<T>(ss: Seq<Seq<T>>, p: spec_fn(T) -> bool)\n        requires\n            forall|j: int, k: int| #![trigger ss[j][k]] 0 <= j < ss.len() && 0 <= k < ss[j].len() ==> p(ss[j][k])\n        ensures\n            forall|i: int| #![trigger ss.flatten()[i]] 0 <= i < ss.flatten().len() ==> p(ss.flatten()[i])\n        decreases ss.len()"
  },
  {
    "id": 592,
    "function": "lemma_spec_index",
    "file": "Chap19/ArraySeqMtEph.rs",
    "lines": "1025-1027",
    "spec_strength": "unknown",
    "snippet": "        broadcast proof fn lemma_spec_index(&self, i: int)\n            requires 0 <= i < self.spec_len()\n            ensures #[trigger] self.seq@[i] == self.spec_index(i)"
  },
  {
    "id": 593,
    "function": "iter",
    "file": "Chap19/ArraySeqMtEph.rs",
    "lines": "1031-1035",
    "spec_strength": "unknown",
    "snippet": "        pub fn iter(&self) -> (it: ArraySeqMtEphIter<'_, T>)\n            ensures\n                it@.0 == 0,\n                it@.1 == self.seq@,\n                iter_invariant(&it),"
  },
  {
    "id": 594,
    "function": "map_par",
    "file": "Chap19/ArraySeqMtEph.rs",
    "lines": "1043-1054",
    "spec_strength": "unknown",
    "snippet": "        pub fn map_par<U: Clone + Eq + View + Send + Sync + 'static, F: Fn(&T) -> U + Send + Sync + Clone + 'static>(\n            a: &ArraySeqMtEphS<T>,\n            f: F,\n        ) -> (mapped: ArraySeqMtEphS<U>)\n            where T: Clone + Send + Sync + Eq + 'static\n            requires\n                obeys_feq_clone::<T>(),\n                obeys_feq_clone::<U>(),\n                a.seq@.len() <= usize::MAX as int,\n                forall|i: int| 0 <= i < a.seq@.len() ==> #[trigger] f.requires((&a.seq@[i],)),\n            ensures mapped.seq@.len() == a.seq@.len()\n            decreases a.seq@.len()"
  },
  {
    "id": 595,
    "function": "filter_par",
    "file": "Chap19/ArraySeqMtEph.rs",
    "lines": "1096-1106",
    "spec_strength": "unknown",
    "snippet": "        pub fn filter_par<F: Fn(&T) -> bool + Send + Sync + Clone + 'static>(\n            a: &ArraySeqMtEphS<T>,\n            pred: F,\n        ) -> (filtered: ArraySeqMtEphS<T>)\n            where T: Clone + Send + Sync + Eq + 'static\n            requires\n                obeys_feq_clone::<T>(),\n                a.seq@.len() <= usize::MAX as int,\n                forall|i: int| 0 <= i < a.seq@.len() ==> #[trigger] pred.requires((&a.seq@[i],)),\n            ensures filtered.seq@.len() <= a.seq@.len()\n            decreases a.seq@.len()"
  },
  {
    "id": 596,
    "function": "lemma_monoid_fold_left",
    "file": "Chap19/ArraySeqMtEph.rs",
    "lines": "1150-1153",
    "spec_strength": "unknown",
    "snippet": "        proof fn lemma_monoid_fold_left(s: Seq<T>, f: spec_fn(T, T) -> T, id: T, x: T)\n            requires spec_monoid(f, id)\n            ensures f(x, s.fold_left(id, f)) == s.fold_left(x, f)\n            decreases s.len()"
  },
  {
    "id": 597,
    "function": "reduce_par",
    "file": "Chap19/ArraySeqMtEph.rs",
    "lines": "1179-1194",
    "spec_strength": "unknown",
    "snippet": "        pub fn reduce_par<F: Fn(&T, &T) -> T + Send + Sync + Clone + 'static>(\n            a: &ArraySeqMtEphS<T>,\n            f: F,\n            Ghost(spec_f): Ghost<spec_fn(T, T) -> T>,\n            id: T,\n        ) -> (reduced: T)\n            where T: Clone + Send + Sync + Eq + 'static\n            requires\n                obeys_feq_clone::<T>(),\n                spec_monoid(spec_f, id),\n                a.seq@.len() > 0,\n                forall|x: &T, y: &T| #[trigger] f.requires((x, y)),\n                forall|x: T, y: T, ret: T| f.ensures((&x, &y), ret) <==> ret == spec_f(x, y),\n            ensures\n                reduced == spec_iterate(Seq::new(a.spec_len(), |i: int| a.spec_index(i)), spec_f, id),\n            decreases a.seq@.len()"
  },
  {
    "id": 598,
    "function": "next",
    "file": "Chap19/ArraySeqMtEph.rs",
    "lines": "1290-1306",
    "spec_strength": "unknown",
    "snippet": "        fn next(&mut self) -> (next: Option<&'a T>)\n            ensures ({\n                let (old_index, old_seq) = old(self)@;\n                match next {\n                    None => {\n                        &&& self@ == old(self)@\n                        &&& old_index >= old_seq.len()\n                    },\n                    Some(element) => {\n                        let (new_index, new_seq) = self@;\n                        &&& 0 <= old_index < old_seq.len()\n                        &&& new_seq == old_seq\n                        &&& new_index == old_index + 1\n                        &&& element == old_seq[old_index]\n                    },\n                }\n            })"
  },
  {
    "id": 599,
    "function": "eq",
    "file": "Chap19/ArraySeqMtEph.rs",
    "lines": "1409-1410",
    "spec_strength": "hole",
    "snippet": "        fn eq(&self, other: &Self) -> (equal: bool)\n            ensures equal == (self@ == other@)"
  },
  {
    "id": 600,
    "function": "length",
    "file": "Chap19/ArraySeqMtEphSlice.rs",
    "lines": "88-90",
    "spec_strength": "unknown",
    "snippet": "        fn length(&self) -> (len: usize)\n            requires self.slice_wf(),\n            ensures len as int == self.spec_len();"
  },
  {
    "id": 601,
    "function": "nth_cloned",
    "file": "Chap19/ArraySeqMtEphSlice.rs",
    "lines": "92-97",
    "spec_strength": "unknown",
    "snippet": "        fn nth_cloned(&self, index: usize) -> (elem: T)\n            requires\n                self.slice_wf(),\n                index < self.spec_len(),\n                obeys_feq_clone::<T>(),\n            ensures elem == self.spec_index(index as int);"
  },
  {
    "id": 602,
    "function": "slice",
    "file": "Chap19/ArraySeqMtEphSlice.rs",
    "lines": "100-109",
    "spec_strength": "unknown",
    "snippet": "        fn slice(&self, start: usize, length: usize) -> (sliced: Self)\n            requires\n                self.slice_wf(),\n                start + length <= usize::MAX,\n                start + length <= self.spec_len(),\n            ensures\n                sliced.slice_wf(),\n                sliced.spec_len() == length as int,\n                forall|i: int| #![trigger sliced.spec_index(i)]\n                    0 <= i < length ==> sliced.spec_index(i) == self.spec_index(start as int + i);"
  },
  {
    "id": 603,
    "function": "subseq_copy",
    "file": "Chap19/ArraySeqMtEphSlice.rs",
    "lines": "112-121",
    "spec_strength": "unknown",
    "snippet": "        fn subseq_copy(&self, start: usize, length: usize) -> (subseq: Self)\n            requires\n                self.slice_wf(),\n                start + length <= usize::MAX,\n                start + length <= self.spec_len(),\n            ensures\n                subseq.slice_wf(),\n                subseq.spec_len() == length as int,\n                forall|i: int| #![trigger subseq.spec_index(i)]\n                    0 <= i < length ==> subseq.spec_index(i) == self.spec_index(start as int + i);"
  },
  {
    "id": 604,
    "function": "from_vec",
    "file": "Chap19/ArraySeqMtEphSlice.rs",
    "lines": "123-128",
    "spec_strength": "unknown",
    "snippet": "        fn from_vec(data: Vec<T>) -> (seq: Self)\n            ensures\n                seq.slice_wf(),\n                seq.spec_len() == data@.len(),\n                forall|i: int| #![trigger seq.spec_index(i)]\n                    0 <= i < data@.len() ==> seq.spec_index(i) == data@[i];"
  },
  {
    "id": 605,
    "function": "empty",
    "file": "Chap19/ArraySeqMtEphSlice.rs",
    "lines": "130-133",
    "spec_strength": "unknown",
    "snippet": "        fn empty() -> (empty_seq: Self)\n            ensures\n                empty_seq.slice_wf(),\n                empty_seq.spec_len() == 0;"
  },
  {
    "id": 606,
    "function": "singleton",
    "file": "Chap19/ArraySeqMtEphSlice.rs",
    "lines": "135-140",
    "spec_strength": "unknown",
    "snippet": "        fn singleton(item: T) -> (s: Self)\n            requires obeys_feq_clone::<T>(),\n            ensures\n                s.slice_wf(),\n                s.spec_len() == 1,\n                s.spec_index(0) == item;"
  },
  {
    "id": 607,
    "function": "new",
    "file": "Chap19/ArraySeqMtEphSlice.rs",
    "lines": "142-150",
    "spec_strength": "unknown",
    "snippet": "        fn new(length: usize, init_value: T) -> (new_seq: Self)\n            requires\n                length <= usize::MAX,\n                obeys_feq_clone::<T>(),\n            ensures\n                new_seq.slice_wf(),\n                new_seq.spec_len() == length as int,\n                forall|i: int| #![trigger new_seq.spec_index(i)]\n                    0 <= i < length ==> new_seq.spec_index(i) == init_value;"
  },
  {
    "id": 608,
    "function": "iter",
    "file": "Chap19/ArraySeqMtEphSlice.rs",
    "lines": "247-253",
    "spec_strength": "unknown",
    "snippet": "        pub fn iter(&'a self) -> (it: std::slice::Iter<'a, T>)\n            requires self.slice_wf(),\n            ensures\n                it@.0 == 0,\n                it@.1.len() == self.spec_len(),\n                forall|i: int| #![trigger it@.1[i]]\n                    0 <= i < self.spec_len() ==> it@.1[i] == self.spec_index(i),"
  },
  {
    "id": 609,
    "function": "lemma_flatten_bounded_by_outer_len",
    "file": "Chap19/ArraySeqStEph.rs",
    "lines": "116-119",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_flatten_bounded_by_outer_len<T>(ss: Seq<Seq<T>>)\n        requires forall|i: int| #![trigger ss[i]] 0 <= i < ss.len() ==> ss[i].len() <= 1\n        ensures ss.flatten().len() <= ss.len()\n        decreases ss.len()"
  },
  {
    "id": 610,
    "function": "lemma_flatten_all_satisfy",
    "file": "Chap19/ArraySeqStEph.rs",
    "lines": "131-136",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_flatten_all_satisfy<T>(ss: Seq<Seq<T>>, p: spec_fn(T) -> bool)\n        requires\n            forall|j: int, k: int| #![trigger ss[j][k]] 0 <= j < ss.len() && 0 <= k < ss[j].len() ==> p(ss[j][k])\n        ensures\n            forall|i: int| #![trigger ss.flatten()[i]] 0 <= i < ss.flatten().len() ==> p(ss.flatten()[i])\n        decreases ss.len()"
  },
  {
    "id": 611,
    "function": "new",
    "file": "Chap19/ArraySeqStEph.rs",
    "lines": "164-171",
    "spec_strength": "unknown",
    "snippet": "        fn new(length: usize, init_value: T) -> (new_seq: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                length <= usize::MAX,\n            ensures\n                new_seq.spec_len() == length as int,\n                forall|i: int| #![trigger new_seq.spec_index(i)] 0 <= i < length ==> new_seq.spec_index(i) == init_value;"
  },
  {
    "id": 612,
    "function": "set",
    "file": "Chap19/ArraySeqStEph.rs",
    "lines": "176-182",
    "spec_strength": "unknown",
    "snippet": "        fn set(&mut self, index: usize, item: T) -> (success: Result<(), &'static str>)\n            requires index < old(self).spec_len()\n            ensures\n                success.is_ok(),\n                success.is_ok() ==> self.spec_len() == old(self).spec_len(),\n                success.is_ok() ==> self.spec_index(index as int) == item,\n                success.is_ok() ==> forall|i: int| #![trigger self.spec_index(i), old(self).spec_index(i)] 0 <= i < old(self).spec_len() && i != index ==> self.spec_index(i) == old(self).spec_index(i);"
  },
  {
    "id": 613,
    "function": "length",
    "file": "Chap19/ArraySeqStEph.rs",
    "lines": "187-188",
    "spec_strength": "unknown",
    "snippet": "        fn length(&self) -> (len: usize)\n            ensures len as int == self.spec_len();"
  },
  {
    "id": 614,
    "function": "nth",
    "file": "Chap19/ArraySeqStEph.rs",
    "lines": "193-195",
    "spec_strength": "unknown",
    "snippet": "        fn nth(&self, index: usize) -> (nth_elem: &T)\n            requires index < self.spec_len()\n            ensures *nth_elem == self.spec_index(index as int);"
  },
  {
    "id": 615,
    "function": "subseq_copy",
    "file": "Chap19/ArraySeqStEph.rs",
    "lines": "200-208",
    "spec_strength": "unknown",
    "snippet": "        fn subseq_copy(&self, start: usize, length: usize) -> (subseq: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                start + length <= usize::MAX,\n                start + length <= self.spec_len(),\n            ensures\n                subseq.spec_len() == length as int,\n                forall|i: int| #![trigger subseq.spec_index(i)] 0 <= i < length ==> subseq.spec_index(i) == self.spec_index(start as int + i);"
  },
  {
    "id": 616,
    "function": "subseq",
    "file": "Chap19/ArraySeqStEph.rs",
    "lines": "213-221",
    "spec_strength": "unknown",
    "snippet": "        fn subseq(a: &Self, start: usize, length: usize) -> (subseq: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                start + length <= usize::MAX,\n                start + length <= a.spec_len(),\n            ensures\n                subseq.spec_len() == length as int,\n                forall|i: int| #![trigger subseq.spec_index(i)] 0 <= i < length ==> subseq.spec_index(i) == a.spec_index(start as int + i);"
  },
  {
    "id": 617,
    "function": "from_vec",
    "file": "Chap19/ArraySeqStEph.rs",
    "lines": "226-229",
    "spec_strength": "unknown",
    "snippet": "        fn from_vec(elts: Vec<T>) -> (seq: Self)\n            ensures\n                seq.spec_len() == elts@.len(),\n                forall|i: int| #![trigger seq.spec_index(i)] 0 <= i < elts@.len() ==> seq.spec_index(i) == elts@[i];"
  },
  {
    "id": 618,
    "function": "empty",
    "file": "Chap19/ArraySeqStEph.rs",
    "lines": "234-235",
    "spec_strength": "unknown",
    "snippet": "        fn empty() -> (empty_seq: Self)\n            ensures empty_seq.spec_len() == 0;"
  },
  {
    "id": 619,
    "function": "singleton",
    "file": "Chap19/ArraySeqStEph.rs",
    "lines": "240-245",
    "spec_strength": "unknown",
    "snippet": "        fn singleton(item: T) -> (singleton: Self)\n            where T: Clone + Eq\n            requires obeys_feq_clone::<T>()\n            ensures\n                singleton.spec_len() == 1,\n                singleton.spec_index(0) == item;"
  },
  {
    "id": 620,
    "function": "append",
    "file": "Chap19/ArraySeqStEph.rs",
    "lines": "250-258",
    "spec_strength": "unknown",
    "snippet": "        fn append(a: &ArraySeqStEphS<T>, b: &ArraySeqStEphS<T>) -> (appended: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                a.seq@.len() + b.seq@.len() <= usize::MAX as int,\n            ensures\n                appended.spec_len() == a.seq@.len() + b.seq@.len(),\n                forall|i: int| #![trigger appended.spec_index(i)] 0 <= i < a.seq@.len() ==> appended.spec_index(i) == a.seq@[i],\n                forall|i: int| #![trigger b.seq@[i]] 0 <= i < b.seq@.len() ==> appended.spec_index(a.seq@.len() as int + i) == b.seq@[i];"
  },
  {
    "id": 621,
    "function": "filter",
    "file": "Chap19/ArraySeqStEph.rs",
    "lines": "263-275",
    "spec_strength": "unknown",
    "snippet": "        fn filter<F: Fn(&T) -> bool>(a: &ArraySeqStEphS<T>, pred: &F, Ghost(spec_pred): Ghost<spec_fn(T) -> bool>) -> (filtered: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                forall|i: int| 0 <= i < a.seq@.len() ==> #[trigger] pred.requires((&a.seq@[i],)),\n                forall|v: T, keep: bool| pred.ensures((&v,), keep) ==> spec_pred(v) == keep,\n            ensures\n                filtered.spec_len() <= a.seq@.len(),\n                filtered.spec_len() == spec_filter_len(\n                    Seq::new(a.seq@.len(), |i: int| a.seq@[i]), spec_pred),\n                Seq::new(filtered.spec_len(), |i: int| filtered.spec_index(i)).to_multiset()\n                    =~= Seq::new(a.seq@.len(), |i: int| a.seq@[i]).to_multiset().filter(spec_pred),\n                forall|i: int| #![trigger filtered.spec_index(i)] 0 <= i < filtered.spec_len() ==> pred.ensures((&filtered.spec_index(i),), true);"
  },
  {
    "id": 622,
    "function": "update",
    "file": "Chap19/ArraySeqStEph.rs",
    "lines": "280-288",
    "spec_strength": "unknown",
    "snippet": "        fn update(a: &ArraySeqStEphS<T>, index: usize, item: T) -> (updated: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                index < a.seq@.len(),\n            ensures\n                updated.spec_len() == a.seq@.len(),\n                updated.spec_index(index as int) == item,\n                forall|i: int| #![trigger updated.spec_index(i)] 0 <= i < a.seq@.len() && i != index as int ==> updated.spec_index(i) == a.seq@[i];"
  },
  {
    "id": 623,
    "function": "inject",
    "file": "Chap19/ArraySeqStEph.rs",
    "lines": "294-303",
    "spec_strength": "unknown",
    "snippet": "        fn inject(a: &Self, updates: &Vec<(usize, T)>) -> (injected: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n            ensures\n                injected.spec_len() == a.spec_len(),\n                Seq::new(injected.spec_len(), |i: int| injected.spec_index(i))\n                    =~= spec_inject(\n                        Seq::new(a.spec_len(), |i: int| a.spec_index(i)),\n                        updates@);"
  },
  {
    "id": 624,
    "function": "is_empty",
    "file": "Chap19/ArraySeqStEph.rs",
    "lines": "308-309",
    "spec_strength": "unknown",
    "snippet": "        fn is_empty(&self) -> (empty: bool)\n            ensures empty <==> self.spec_len() == 0;"
  },
  {
    "id": 625,
    "function": "is_singleton",
    "file": "Chap19/ArraySeqStEph.rs",
    "lines": "314-315",
    "spec_strength": "unknown",
    "snippet": "        fn is_singleton(&self) -> (single: bool)\n            ensures single <==> self.spec_len() == 1;"
  },
  {
    "id": 626,
    "function": "iterate_iter",
    "file": "Chap19/ArraySeqStEph.rs",
    "lines": "320-321",
    "spec_strength": "unknown",
    "snippet": "        fn iterate_iter<A, F: Fn(&A, &T) -> A>(a: &ArraySeqStEphS<T>, f: &F, seed: A) -> A\n            requires forall|x: &A, y: &T| #[trigger] f.requires((x, y));"
  },
  {
    "id": 627,
    "function": "iterate",
    "file": "Chap19/ArraySeqStEph.rs",
    "lines": "326-330",
    "spec_strength": "unknown",
    "snippet": "        fn iterate<A, F: Fn(&A, &T) -> A>(a: &ArraySeqStEphS<T>, f: &F, seed: A) -> A\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                forall|x: &A, y: &T| #[trigger] f.requires((x, y));"
  },
  {
    "id": 628,
    "function": "reduce_iter",
    "file": "Chap19/ArraySeqStEph.rs",
    "lines": "335-337",
    "spec_strength": "unknown",
    "snippet": "        fn reduce_iter<F: Fn(&T, &T) -> T>(a: &ArraySeqStEphS<T>, f: &F, id: T) -> T\n            where T: Clone\n            requires forall|x: &T, y: &T| #[trigger] f.requires((x, y));"
  },
  {
    "id": 629,
    "function": "reduce",
    "file": "Chap19/ArraySeqStEph.rs",
    "lines": "342-346",
    "spec_strength": "unknown",
    "snippet": "        fn reduce<F: Fn(&T, &T) -> T>(a: &ArraySeqStEphS<T>, f: &F, id: T) -> T\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                forall|x: &T, y: &T| #[trigger] f.requires((x, y));"
  },
  {
    "id": 630,
    "function": "scan",
    "file": "Chap19/ArraySeqStEph.rs",
    "lines": "351-354",
    "spec_strength": "unknown",
    "snippet": "        fn scan<F: Fn(&T, &T) -> T>(a: &ArraySeqStEphS<T>, f: &F, id: T) -> (scanned: (ArraySeqStEphS<T>, T))\n            where T: Clone\n            requires forall|x: &T, y: &T| #[trigger] f.requires((x, y))\n            ensures scanned.0.seq@.len() == a.seq@.len();"
  },
  {
    "id": 631,
    "function": "map",
    "file": "Chap19/ArraySeqStEph.rs",
    "lines": "359-364",
    "spec_strength": "unknown",
    "snippet": "        fn map<U: Clone, F: Fn(&T) -> U>(a: &ArraySeqStEphS<T>, f: &F) -> (mapped: ArraySeqStEphS<U>)\n            requires\n                forall|i: int| 0 <= i < a.seq@.len() ==> #[trigger] f.requires((&a.seq@[i],)),\n            ensures\n                mapped.seq@.len() == a.seq@.len(),\n                forall|i: int| #![trigger mapped.seq@[i]] 0 <= i < a.seq@.len() ==> f.ensures((&a.seq@[i],), mapped.seq@[i]);"
  },
  {
    "id": 632,
    "function": "tabulate",
    "file": "Chap19/ArraySeqStEph.rs",
    "lines": "369-375",
    "spec_strength": "unknown",
    "snippet": "        fn tabulate<F: Fn(usize) -> T>(f: &F, length: usize) -> (tab_seq: ArraySeqStEphS<T>)\n            requires\n                length <= usize::MAX,\n                forall|i: usize| i < length ==> #[trigger] f.requires((i,)),\n            ensures\n                tab_seq.seq@.len() == length,\n                forall|i: int| #![trigger tab_seq.seq@[i]] 0 <= i < length ==> f.ensures((i as usize,), tab_seq.seq@[i]);"
  },
  {
    "id": 633,
    "function": "flatten",
    "file": "Chap19/ArraySeqStEph.rs",
    "lines": "380-385",
    "spec_strength": "unknown",
    "snippet": "        fn flatten(a: &ArraySeqStEphS<ArraySeqStEphS<T>>) -> (flattened: ArraySeqStEphS<T>)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n            ensures\n                flattened.seq@ =~= a.seq@.map_values(|inner: ArraySeqStEphS<T>| inner.seq@).flatten();"
  },
  {
    "id": 634,
    "function": "deflate",
    "file": "Chap19/ArraySeqStEph.rs",
    "lines": "390-398",
    "spec_strength": "unknown",
    "snippet": "        fn deflate<F: Fn(&T) -> bool>(pred: &F, x: &T) -> (deflated: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                pred.requires((x,)),\n            ensures\n                deflated.spec_len() <= 1,\n                deflated.spec_len() == 1 ==> pred.ensures((x,), true) && deflated.spec_index(0) == *x,\n                deflated.spec_len() == 0 ==> pred.ensures((x,), false);"
  },
  {
    "id": 635,
    "function": "lemma_spec_index",
    "file": "Chap19/ArraySeqStEph.rs",
    "lines": "943-945",
    "spec_strength": "unknown",
    "snippet": "        broadcast proof fn lemma_spec_index(&self, i: int)\n            requires 0 <= i < self.spec_len()\n            ensures #[trigger] self.seq@[i] == self.spec_index(i)"
  },
  {
    "id": 636,
    "function": "iter",
    "file": "Chap19/ArraySeqStEph.rs",
    "lines": "949-953",
    "spec_strength": "unknown",
    "snippet": "        pub fn iter(&self) -> (it: ArraySeqStEphIter<'_, T>)\n            ensures\n                it@.0 == 0,\n                it@.1 == self.seq@,\n                iter_invariant(&it),"
  },
  {
    "id": 637,
    "function": "next",
    "file": "Chap19/ArraySeqStEph.rs",
    "lines": "989-1005",
    "spec_strength": "unknown",
    "snippet": "        fn next(&mut self) -> (next: Option<&'a T>)\n            ensures ({\n                let (old_index, old_seq) = old(self)@;\n                match next {\n                    None => {\n                        &&& self@ == old(self)@\n                        &&& old_index >= old_seq.len()\n                    },\n                    Some(element) => {\n                        let (new_index, new_seq) = self@;\n                        &&& 0 <= old_index < old_seq.len()\n                        &&& new_seq == old_seq\n                        &&& new_index == old_index + 1\n                        &&& element == old_seq[old_index]\n                    },\n                }\n            })"
  },
  {
    "id": 638,
    "function": "eq",
    "file": "Chap19/ArraySeqStEph.rs",
    "lines": "1113-1114",
    "spec_strength": "hole",
    "snippet": "        fn eq(&self, other: &Self) -> (equal: bool)\n            ensures equal == (self@ == other@)"
  },
  {
    "id": 639,
    "function": "lemma_flatten_bounded_by_outer_len",
    "file": "Chap19/ArraySeqStPer.rs",
    "lines": "115-118",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_flatten_bounded_by_outer_len<T>(ss: Seq<Seq<T>>)\n        requires forall|i: int| #![trigger ss[i]] 0 <= i < ss.len() ==> ss[i].len() <= 1\n        ensures ss.flatten().len() <= ss.len()\n        decreases ss.len()"
  },
  {
    "id": 640,
    "function": "lemma_flatten_all_satisfy",
    "file": "Chap19/ArraySeqStPer.rs",
    "lines": "130-135",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_flatten_all_satisfy<T>(ss: Seq<Seq<T>>, p: spec_fn(T) -> bool)\n        requires\n            forall|j: int, k: int| #![trigger ss[j][k]] 0 <= j < ss.len() && 0 <= k < ss[j].len() ==> p(ss[j][k])\n        ensures\n            forall|i: int| #![trigger ss.flatten()[i]] 0 <= i < ss.flatten().len() ==> p(ss.flatten()[i])\n        decreases ss.len()"
  },
  {
    "id": 641,
    "function": "new",
    "file": "Chap19/ArraySeqStPer.rs",
    "lines": "162-169",
    "spec_strength": "unknown",
    "snippet": "        fn new(length: usize, init_value: T) -> (new_seq: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                length <= usize::MAX,\n            ensures\n                new_seq.spec_len() == length as int,\n                forall|i: int| #![trigger new_seq.spec_index(i)] 0 <= i < length ==> new_seq.spec_index(i) == init_value;"
  },
  {
    "id": 642,
    "function": "length",
    "file": "Chap19/ArraySeqStPer.rs",
    "lines": "174-175",
    "spec_strength": "unknown",
    "snippet": "        fn length(&self) -> (len: usize)\n            ensures len as int == self.spec_len();"
  },
  {
    "id": 643,
    "function": "nth",
    "file": "Chap19/ArraySeqStPer.rs",
    "lines": "180-182",
    "spec_strength": "unknown",
    "snippet": "        fn nth(&self, index: usize) -> (nth_elem: &T)\n            requires index < self.spec_len()\n            ensures *nth_elem == self.spec_index(index as int);"
  },
  {
    "id": 644,
    "function": "subseq_copy",
    "file": "Chap19/ArraySeqStPer.rs",
    "lines": "187-195",
    "spec_strength": "unknown",
    "snippet": "        fn subseq_copy(&self, start: usize, length: usize) -> (subseq: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                start + length <= usize::MAX,\n                start + length <= self.spec_len(),\n            ensures\n                subseq.spec_len() == length as int,\n                forall|i: int| #![trigger subseq.spec_index(i)] 0 <= i < length ==> subseq.spec_index(i) == self.spec_index(start as int + i);"
  },
  {
    "id": 645,
    "function": "subseq",
    "file": "Chap19/ArraySeqStPer.rs",
    "lines": "200-208",
    "spec_strength": "unknown",
    "snippet": "        fn subseq(a: &Self, start: usize, length: usize) -> (subseq: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                start + length <= usize::MAX,\n                start + length <= a.spec_len(),\n            ensures\n                subseq.spec_len() == length as int,\n                forall|i: int| #![trigger subseq.spec_index(i)] 0 <= i < length ==> subseq.spec_index(i) == a.spec_index(start as int + i);"
  },
  {
    "id": 646,
    "function": "from_vec",
    "file": "Chap19/ArraySeqStPer.rs",
    "lines": "213-216",
    "spec_strength": "unknown",
    "snippet": "        fn from_vec(elts: Vec<T>) -> (seq: Self)\n            ensures\n                seq.spec_len() == elts@.len(),\n                forall|i: int| #![trigger seq.spec_index(i)] 0 <= i < elts@.len() ==> seq.spec_index(i) == elts@[i];"
  },
  {
    "id": 647,
    "function": "empty",
    "file": "Chap19/ArraySeqStPer.rs",
    "lines": "221-222",
    "spec_strength": "unknown",
    "snippet": "        fn empty() -> (empty_seq: Self)\n            ensures empty_seq.spec_len() == 0;"
  },
  {
    "id": 648,
    "function": "singleton",
    "file": "Chap19/ArraySeqStPer.rs",
    "lines": "227-232",
    "spec_strength": "unknown",
    "snippet": "        fn singleton(item: T) -> (singleton: Self)\n            where T: Clone + Eq\n            requires obeys_feq_clone::<T>()\n            ensures\n                singleton.spec_len() == 1,\n                singleton.spec_index(0) == item;"
  },
  {
    "id": 649,
    "function": "append",
    "file": "Chap19/ArraySeqStPer.rs",
    "lines": "237-245",
    "spec_strength": "unknown",
    "snippet": "        fn append(a: &ArraySeqStPerS<T>, b: &ArraySeqStPerS<T>) -> (appended: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                a.seq@.len() + b.seq@.len() <= usize::MAX as int,\n            ensures\n                appended.spec_len() == a.seq@.len() + b.seq@.len(),\n                forall|i: int| #![trigger appended.spec_index(i)] 0 <= i < a.seq@.len() ==> appended.spec_index(i) == a.seq@[i],\n                forall|i: int| #![trigger b.seq@[i]] 0 <= i < b.seq@.len() ==> appended.spec_index(a.seq@.len() as int + i) == b.seq@[i];"
  },
  {
    "id": 650,
    "function": "filter",
    "file": "Chap19/ArraySeqStPer.rs",
    "lines": "250-262",
    "spec_strength": "unknown",
    "snippet": "        fn filter<F: Fn(&T) -> bool>(a: &ArraySeqStPerS<T>, pred: &F, Ghost(spec_pred): Ghost<spec_fn(T) -> bool>) -> (filtered: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                forall|i: int| 0 <= i < a.seq@.len() ==> #[trigger] pred.requires((&a.seq@[i],)),\n                forall|v: T, keep: bool| pred.ensures((&v,), keep) ==> spec_pred(v) == keep,\n            ensures\n                filtered.spec_len() <= a.seq@.len(),\n                filtered.spec_len() == spec_filter_len(\n                    Seq::new(a.seq@.len(), |i: int| a.seq@[i]), spec_pred),\n                Seq::new(filtered.spec_len(), |i: int| filtered.spec_index(i)).to_multiset()\n                    =~= Seq::new(a.seq@.len(), |i: int| a.seq@[i]).to_multiset().filter(spec_pred),\n                forall|i: int| #![trigger filtered.spec_index(i)] 0 <= i < filtered.spec_len() ==> pred.ensures((&filtered.spec_index(i),), true);"
  },
  {
    "id": 651,
    "function": "update",
    "file": "Chap19/ArraySeqStPer.rs",
    "lines": "267-275",
    "spec_strength": "unknown",
    "snippet": "        fn update(a: &ArraySeqStPerS<T>, index: usize, item: T) -> (updated: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                index < a.seq@.len(),\n            ensures\n                updated.spec_len() == a.seq@.len(),\n                updated.spec_index(index as int) == item,\n                forall|i: int| #![trigger updated.spec_index(i)] 0 <= i < a.seq@.len() && i != index as int ==> updated.spec_index(i) == a.seq@[i];"
  },
  {
    "id": 652,
    "function": "inject",
    "file": "Chap19/ArraySeqStPer.rs",
    "lines": "281-290",
    "spec_strength": "unknown",
    "snippet": "        fn inject(a: &Self, updates: &Vec<(usize, T)>) -> (injected: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n            ensures\n                injected.spec_len() == a.spec_len(),\n                Seq::new(injected.spec_len(), |i: int| injected.spec_index(i))\n                    =~= spec_inject(\n                        Seq::new(a.spec_len(), |i: int| a.spec_index(i)),\n                        updates@);"
  },
  {
    "id": 653,
    "function": "is_empty",
    "file": "Chap19/ArraySeqStPer.rs",
    "lines": "295-296",
    "spec_strength": "unknown",
    "snippet": "        fn is_empty(&self) -> (empty: bool)\n            ensures empty <==> self.spec_len() == 0;"
  },
  {
    "id": 654,
    "function": "is_singleton",
    "file": "Chap19/ArraySeqStPer.rs",
    "lines": "301-302",
    "spec_strength": "unknown",
    "snippet": "        fn is_singleton(&self) -> (single: bool)\n            ensures single <==> self.spec_len() == 1;"
  },
  {
    "id": 655,
    "function": "iterate_iter",
    "file": "Chap19/ArraySeqStPer.rs",
    "lines": "307-308",
    "spec_strength": "unknown",
    "snippet": "        fn iterate_iter<A, F: Fn(&A, &T) -> A>(a: &ArraySeqStPerS<T>, f: &F, seed: A) -> A\n            requires forall|x: &A, y: &T| #[trigger] f.requires((x, y));"
  },
  {
    "id": 656,
    "function": "iterate",
    "file": "Chap19/ArraySeqStPer.rs",
    "lines": "313-317",
    "spec_strength": "unknown",
    "snippet": "        fn iterate<A, F: Fn(&A, &T) -> A>(a: &ArraySeqStPerS<T>, f: &F, seed: A) -> A\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                forall|x: &A, y: &T| #[trigger] f.requires((x, y));"
  },
  {
    "id": 657,
    "function": "reduce_iter",
    "file": "Chap19/ArraySeqStPer.rs",
    "lines": "322-324",
    "spec_strength": "unknown",
    "snippet": "        fn reduce_iter<F: Fn(&T, &T) -> T>(a: &ArraySeqStPerS<T>, f: &F, id: T) -> T\n            where T: Clone\n            requires forall|x: &T, y: &T| #[trigger] f.requires((x, y));"
  },
  {
    "id": 658,
    "function": "reduce",
    "file": "Chap19/ArraySeqStPer.rs",
    "lines": "329-333",
    "spec_strength": "unknown",
    "snippet": "        fn reduce<F: Fn(&T, &T) -> T>(a: &ArraySeqStPerS<T>, f: &F, id: T) -> T\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                forall|x: &T, y: &T| #[trigger] f.requires((x, y));"
  },
  {
    "id": 659,
    "function": "scan",
    "file": "Chap19/ArraySeqStPer.rs",
    "lines": "338-341",
    "spec_strength": "unknown",
    "snippet": "        fn scan<F: Fn(&T, &T) -> T>(a: &ArraySeqStPerS<T>, f: &F, id: T) -> (scanned: (ArraySeqStPerS<T>, T))\n            where T: Clone\n            requires forall|x: &T, y: &T| #[trigger] f.requires((x, y))\n            ensures scanned.0.seq@.len() == a.seq@.len();"
  },
  {
    "id": 660,
    "function": "map",
    "file": "Chap19/ArraySeqStPer.rs",
    "lines": "346-351",
    "spec_strength": "unknown",
    "snippet": "        fn map<U: Clone, F: Fn(&T) -> U>(a: &ArraySeqStPerS<T>, f: &F) -> (mapped: ArraySeqStPerS<U>)\n            requires\n                forall|i: int| 0 <= i < a.seq@.len() ==> #[trigger] f.requires((&a.seq@[i],)),\n            ensures\n                mapped.seq@.len() == a.seq@.len(),\n                forall|i: int| #![trigger mapped.seq@[i]] 0 <= i < a.seq@.len() ==> f.ensures((&a.seq@[i],), mapped.seq@[i]);"
  },
  {
    "id": 661,
    "function": "tabulate",
    "file": "Chap19/ArraySeqStPer.rs",
    "lines": "356-362",
    "spec_strength": "unknown",
    "snippet": "        fn tabulate<F: Fn(usize) -> T>(f: &F, length: usize) -> (tab_seq: ArraySeqStPerS<T>)\n            requires\n                length <= usize::MAX,\n                forall|i: usize| i < length ==> #[trigger] f.requires((i,)),\n            ensures\n                tab_seq.seq@.len() == length,\n                forall|i: int| #![trigger tab_seq.seq@[i]] 0 <= i < length ==> f.ensures((i as usize,), tab_seq.seq@[i]);"
  },
  {
    "id": 662,
    "function": "flatten",
    "file": "Chap19/ArraySeqStPer.rs",
    "lines": "367-372",
    "spec_strength": "unknown",
    "snippet": "        fn flatten(a: &ArraySeqStPerS<ArraySeqStPerS<T>>) -> (flattened: ArraySeqStPerS<T>)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n            ensures\n                flattened.seq@ =~= a.seq@.map_values(|inner: ArraySeqStPerS<T>| inner.seq@).flatten();"
  },
  {
    "id": 663,
    "function": "deflate",
    "file": "Chap19/ArraySeqStPer.rs",
    "lines": "377-385",
    "spec_strength": "unknown",
    "snippet": "        fn deflate<F: Fn(&T) -> bool>(pred: &F, x: &T) -> (deflated: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                pred.requires((x,)),\n            ensures\n                deflated.spec_len() <= 1,\n                deflated.spec_len() == 1 ==> pred.ensures((x,), true) && deflated.spec_index(0) == *x,\n                deflated.spec_len() == 0 ==> pred.ensures((x,), false);"
  },
  {
    "id": 664,
    "function": "lemma_spec_index",
    "file": "Chap19/ArraySeqStPer.rs",
    "lines": "952-954",
    "spec_strength": "unknown",
    "snippet": "        broadcast proof fn lemma_spec_index(&self, i: int)\n            requires 0 <= i < self.spec_len()\n            ensures #[trigger] self.seq@[i] == self.spec_index(i)"
  },
  {
    "id": 665,
    "function": "iter",
    "file": "Chap19/ArraySeqStPer.rs",
    "lines": "958-962",
    "spec_strength": "unknown",
    "snippet": "        pub fn iter(&self) -> (it: ArraySeqStPerIter<'_, T>)\n            ensures\n                it@.0 == 0,\n                it@.1 == self.seq@,\n                iter_invariant(&it),"
  },
  {
    "id": 666,
    "function": "next",
    "file": "Chap19/ArraySeqStPer.rs",
    "lines": "998-1014",
    "spec_strength": "unknown",
    "snippet": "        fn next(&mut self) -> (next: Option<&'a T>)\n            ensures ({\n                let (old_index, old_seq) = old(self)@;\n                match next {\n                    None => {\n                        &&& self@ == old(self)@\n                        &&& old_index >= old_seq.len()\n                    },\n                    Some(element) => {\n                        let (new_index, new_seq) = self@;\n                        &&& 0 <= old_index < old_seq.len()\n                        &&& new_seq == old_seq\n                        &&& new_index == old_index + 1\n                        &&& element == old_seq[old_index]\n                    },\n                }\n            })"
  },
  {
    "id": 667,
    "function": "eq",
    "file": "Chap19/ArraySeqStPer.rs",
    "lines": "1122-1123",
    "spec_strength": "hole",
    "snippet": "        fn eq(&self, other: &Self) -> (equal: bool)\n            ensures equal == (self@ == other@)"
  },
  {
    "id": 668,
    "function": "lemma_sum_inner_lens_mono",
    "file": "Chap21/Algorithm21_1.rs",
    "lines": "45-48",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_sum_inner_lens_mono<T>(ss: Seq<ArraySeqStPerS<T>>, a: int, b: int)\n        requires 0 <= a <= b <= ss.len()\n        ensures sum_inner_lens(ss, a) <= sum_inner_lens(ss, b)\n        decreases b - a"
  },
  {
    "id": 669,
    "function": "lemma_sum_inner_lens_uniform",
    "file": "Chap21/Algorithm21_1.rs",
    "lines": "58-64",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_sum_inner_lens_uniform<T>(ss: Seq<ArraySeqStPerS<T>>, k: int, m: int)\n        requires\n            0 <= k <= ss.len(),\n            forall|i: int| 0 <= i < k ==> (#[trigger] ss[i]).seq@.len() == m,\n        ensures\n            sum_inner_lens(ss, k) == k * m\n        decreases k"
  },
  {
    "id": 670,
    "function": "flatten_inner",
    "file": "Chap21/Algorithm21_1.rs",
    "lines": "85-89",
    "spec_strength": "unknown",
    "snippet": "    fn flatten_inner<T: View + Clone>(ss: &ArraySeqStPerS<ArraySeqStPerS<T>>) -> (result: ArraySeqStPerS<T>)\n        requires\n            sum_inner_lens(ss.seq@, ss.seq@.len() as int) <= usize::MAX as int,\n        ensures\n            result.seq@.len() == sum_inner_lens(ss.seq@, ss.seq@.len() as int),"
  },
  {
    "id": 671,
    "function": "points2d_tab_flat",
    "file": "Chap21/Algorithm21_1.rs",
    "lines": "145-151",
    "spec_strength": "unknown",
    "snippet": "    pub fn points2d_tab_flat(n: N) -> (result: ArraySeqStPerS<Pair<N, N>>)\n        requires\n            n <= usize::MAX,\n            n as int * (n as int - 1) <= usize::MAX as int,\n        ensures\n            n == 0 ==> result.seq@.len() == 0,\n            n > 0 ==> result.seq@.len() == n as int * (n as int - 1),"
  },
  {
    "id": 672,
    "function": "points3d_tab_flat",
    "file": "Chap21/Algorithm21_2.rs",
    "lines": "46-53",
    "spec_strength": "unknown",
    "snippet": "    pub fn points3d_tab_flat(n: N) -> (result: ArraySeqStPerS<Pair<N, Pair<N, N>>>)\n        requires\n            n + 2 <= usize::MAX,\n            pow(n as int, 2) <= usize::MAX as int,\n            pow(n as int, 3) <= usize::MAX as int,\n        ensures\n            n == 0 ==> result.seq@.len() == 0,\n            n > 0  ==> result.seq@.len() == pow(n as int, 3),"
  },
  {
    "id": 673,
    "function": "primes_bf",
    "file": "Chap21/Algorithm21_5.rs",
    "lines": "46-54",
    "spec_strength": "unknown",
    "snippet": "    pub fn primes_bf(n: N) -> (primes: ArraySeqStPerS<N>)\n        ensures\n            n <= 2 ==> primes.spec_len() == 0,\n            n > 2  ==> primes.spec_len() <= n - 2,\n            forall|i: int| 0 <= i < primes.spec_len()\n                ==> spec_is_prime(#[trigger] primes.spec_index(i) as int),\n            forall|p: int| 2 <= p < n as int && spec_is_prime(p) ==>\n                Seq::new(primes.spec_len(), |i: int| primes.spec_index(i))\n                    .contains(#[trigger] (p as N)),"
  },
  {
    "id": 674,
    "function": "lemma_product_not_prime",
    "file": "Chap21/Algorithm21_6.rs",
    "lines": "37-39",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_product_not_prime(a: int, b: int)\n        requires a >= 2, b >= 2,\n        ensures !spec_is_prime(a * b)"
  },
  {
    "id": 675,
    "function": "prime_sieve",
    "file": "Chap21/Algorithm21_6.rs",
    "lines": "62-68",
    "spec_strength": "unknown",
    "snippet": "    pub fn prime_sieve(n: N) -> (result: ArraySeqStPerS<N>)\n        requires n < usize::MAX,\n        ensures\n            n <= 2 ==> result.spec_len() == 0,\n            n > 2  ==> result.spec_len() <= n - 1,\n            forall|i: int| 0 <= i < result.spec_len() ==>\n                2 <= #[trigger] result.spec_index(i) && result.spec_index(i) <= n,"
  },
  {
    "id": 676,
    "function": "lemma_inner_lens_sum_triangular",
    "file": "Chap21/Exercise21_5.rs",
    "lines": "40-47",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_inner_lens_sum_triangular<A>(ss: Seq<Seq<A>>, n: int)\n        requires\n            ss.len() == n,\n            n >= 0,\n            forall|i: int| 0 <= i < n ==> (#[trigger] ss[i]).len() == n - i,\n        ensures\n            spec_inner_lens_sum(ss) * 2 == n * (n + 1),\n        decreases n"
  },
  {
    "id": 677,
    "function": "all_contiguous_subseqs",
    "file": "Chap21/Exercise21_5.rs",
    "lines": "68-72",
    "spec_strength": "unknown",
    "snippet": "    pub fn all_contiguous_subseqs(a: &ArraySeqStPerS<N>) -> (result: ArraySeqStPerS<ArraySeqStPerS<N>>)\n         requires obeys_feq_clone::<ArraySeqStPerS<N>>()\n         ensures\n            a.spec_len() == 0 ==> result.spec_len() == 0,\n            a.spec_len() > 0 ==> result.spec_len() * 2 == a.spec_len() * (a.spec_len() + 1),"
  },
  {
    "id": 678,
    "function": "is_even",
    "file": "Chap21/Exercise21_7.rs",
    "lines": "47-48",
    "spec_strength": "unknown",
    "snippet": "    pub fn is_even(x: &N) -> (r: B)\n        ensures r == spec_is_even(*x as int)"
  },
  {
    "id": 679,
    "function": "is_vowel",
    "file": "Chap21/Exercise21_7.rs",
    "lines": "60-61",
    "spec_strength": "unknown",
    "snippet": "    pub fn is_vowel(c: &char) -> (r: B)\n        ensures r == spec_is_vowel(*c)"
  },
  {
    "id": 680,
    "function": "pair_even_with_vowels",
    "file": "Chap21/Exercise21_7.rs",
    "lines": "75-84",
    "spec_strength": "unknown",
    "snippet": "    pub fn pair_even_with_vowels(\n        a: &ArraySeqStPerS<N>,\n        b: &ArraySeqStPerS<char>,\n    ) -> (result: ArraySeqStPerS<Pair<N, char>>)\n       requires \n            obeys_feq_clone::<char>(),\n            obeys_feq_clone::<Pair<N, char>>(),\n            a.seq@.len() as int * b.seq@.len() as int <= usize::MAX as int,\n       ensures\n            result.seq@.len() <= a.seq@.len() as int * b.seq@.len() as int,"
  },
  {
    "id": 681,
    "function": "lemma_zero_count_means_no_divisors",
    "file": "Chap21/Exercise21_8.rs",
    "lines": "55-62",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_zero_count_means_no_divisors(n: int, from: int, to: int)\n        requires\n            from <= to,\n            from > 0,\n            spec_divisor_count(n, from, to) == 0,\n        ensures\n            forall|i: int| from <= i < to ==> #[trigger] (n % i) != 0,\n        decreases to - from,"
  },
  {
    "id": 682,
    "function": "lemma_no_divisors_means_zero_count",
    "file": "Chap21/Exercise21_8.rs",
    "lines": "81-88",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_no_divisors_means_zero_count(n: int, from: int, to: int)\n        requires\n            from <= to,\n            from > 0,\n            forall|i: int| from <= i < to ==> #[trigger] (n % i) != 0,\n        ensures\n            spec_divisor_count(n, from, to) == 0,\n        decreases to - from,"
  },
  {
    "id": 683,
    "function": "lemma_divisor_count_nonneg",
    "file": "Chap21/Exercise21_8.rs",
    "lines": "99-101",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_divisor_count_nonneg(n: int, from: int, to: int)\n        ensures spec_divisor_count(n, from, to) >= 0,\n        decreases (if to > from { to - from } else { 0 }),"
  },
  {
    "id": 684,
    "function": "lemma_filter_len_eq_divisor_count",
    "file": "Chap21/Exercise21_8.rs",
    "lines": "109-115",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_filter_len_eq_divisor_count(n: int, k: int)\n        requires k >= 0, n >= 2,\n        ensures spec_filter_len(\n            Seq::new(k as nat, |i: int| (n % (i + 1) == 0)),\n            |v: B| v,\n        ) == spec_divisor_count(n, 1, k + 1),\n        decreases k,"
  },
  {
    "id": 685,
    "function": "lemma_divisor_count_split_last",
    "file": "Chap21/Exercise21_8.rs",
    "lines": "135-140",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_divisor_count_split_last(n: int, from: int, to: int)\n        requires from > 0, from < to,\n        ensures spec_divisor_count(n, from, to) ==\n            spec_divisor_count(n, from, to - 1) +\n            if n % (to - 1) == 0 { 1int } else { 0int },\n        decreases to - from,"
  },
  {
    "id": 686,
    "function": "is_divisible",
    "file": "Chap21/Exercise21_8.rs",
    "lines": "164-166",
    "spec_strength": "unknown",
    "snippet": "    pub fn is_divisible(n: N, i: N) -> (divides: B)\n        requires i > 0\n        ensures divides == (n as int % i as int == 0)"
  },
  {
    "id": 687,
    "function": "is_prime",
    "file": "Chap21/Exercise21_8.rs",
    "lines": "176-177",
    "spec_strength": "unknown",
    "snippet": "    pub fn is_prime(n: N) -> (prime: B)\n        ensures prime == spec_is_prime(n as int)"
  },
  {
    "id": 688,
    "function": "lemma_div_exact",
    "file": "Chap21/Exercise21_9.rs",
    "lines": "28-30",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_div_exact(m: int, d: int)\n        requires d > 0, m % d == 0, m >= 0,\n        ensures m == d * (m / d),"
  },
  {
    "id": 689,
    "function": "lemma_composite_has_small_divisor",
    "file": "Chap21/Exercise21_9.rs",
    "lines": "38-43",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_composite_has_small_divisor(m: int)\n        requires\n            m > 1,\n            spec_is_composite(m),\n        ensures\n            exists|d: int| 2 <= d && d * d <= m && #[trigger] (m % d) == 0,"
  },
  {
    "id": 690,
    "function": "lemma_composites_covered_by_small_multiples",
    "file": "Chap21/Exercise21_9.rs",
    "lines": "75-82",
    "spec_strength": "unknown",
    "snippet": "    pub proof fn lemma_composites_covered_by_small_multiples(m: int, n: int)\n        requires\n            n >= 2,\n            2 <= m <= n,\n            spec_is_composite(m),\n        ensures\n            exists|i: int, j: int|\n                2 <= i && i * i <= n && j >= 2 && #[trigger] (i * j) == m,"
  },
  {
    "id": 691,
    "function": "points2d",
    "file": "Chap21/Problem21_1.rs",
    "lines": "34-43",
    "spec_strength": "unknown",
    "snippet": "    pub fn points2d(n: N) -> (points: ArraySeqStPerS<Pair<N, N>>)\n        requires\n            n as int * (n as int - 1) <= usize::MAX as int,\n        ensures\n            n == 0 ==> points.seq@.len() == 0,\n            n > 0  ==> points.seq@.len() == n as int * (n as int - 1),\n            forall|k: int| 0 <= k < points.seq@.len() ==>\n                (#[trigger] points.seq@[k]).0 < n\n                && 1 <= points.seq@[k].1\n                && points.seq@[k].1 < n,"
  },
  {
    "id": 692,
    "function": "points3d_loops",
    "file": "Chap21/Problem21_3.rs",
    "lines": "37-48",
    "spec_strength": "unknown",
    "snippet": "    pub fn points3d_loops(n: N) -> (result: ArraySeqStPerS<Pair<N, Pair<N, N>>>)\n        requires\n            n + 2 <= usize::MAX,\n            n as int * n as int <= usize::MAX as int,\n            n as int * n as int * n as int <= usize::MAX as int,\n        ensures\n            n == 0 ==> result.seq@.len() == 0,\n            n > 0  ==> result.seq@.len() == n as int * n as int * n as int,\n            forall|k: int| 0 <= k < result.seq@.len() ==>\n                (#[trigger] result.seq@[k]).0 < n\n                && 1 <= result.seq@[k].1.0 && result.seq@[k].1.0 <= n\n                && 2 <= result.seq@[k].1.1 && result.seq@[k].1.1 <= n + 1,"
  },
  {
    "id": 693,
    "function": "cartesian_loops",
    "file": "Chap21/Problem21_4.rs",
    "lines": "40-47",
    "spec_strength": "unknown",
    "snippet": "    pub fn cartesian_loops(\n        a: &ArraySeqStPerS<N>,\n        b: &ArraySeqStPerS<N>,\n    ) -> (result: ArraySeqStPerS<Pair<N, N>>)\n        requires\n            a.seq@.len() as int * b.seq@.len() as int <= usize::MAX as int,\n        ensures\n            result.seq@.len() == a.seq@.len() as int * b.seq@.len() as int,"
  },
  {
    "id": 694,
    "function": "cartesian_tab_flat",
    "file": "Chap21/Problem21_4.rs",
    "lines": "92-103",
    "spec_strength": "unknown",
    "snippet": "    pub fn cartesian_tab_flat(\n        a: &ArraySeqStPerS<N>,\n        b: &ArraySeqStPerS<N>,\n    ) -> (result: ArraySeqStPerS<Pair<N, N>>)\n        requires\n            a.seq@.len() as int * b.seq@.len() as int <= usize::MAX as int,\n        ensures\n            result.seq@.len() == a.seq@.len() as int * b.seq@.len() as int,\n            forall|k: int| 0 <= k < result.seq@.len() ==> (\n                a.seq@.contains((#[trigger] result.seq@[k]).0)\n                && b.seq@.contains(result.seq@[k].1)\n            ),"
  },
  {
    "id": 695,
    "function": "lemma_in_order_pre_order_permutation",
    "file": "Chap23/BalBinTreeStEph.rs",
    "lines": "92-94",
    "spec_strength": "unknown",
    "snippet": "    pub proof fn lemma_in_order_pre_order_permutation<T>(tree: BalBinTree<T>)\n        ensures tree.spec_in_order().to_multiset() =~= tree.spec_pre_order().to_multiset()\n        decreases tree,"
  },
  {
    "id": 696,
    "function": "lemma_pre_order_post_order_permutation",
    "file": "Chap23/BalBinTreeStEph.rs",
    "lines": "137-139",
    "spec_strength": "unknown",
    "snippet": "    pub proof fn lemma_pre_order_post_order_permutation<T>(tree: BalBinTree<T>)\n        ensures tree.spec_pre_order().to_multiset() =~= tree.spec_post_order().to_multiset()\n        decreases tree,"
  },
  {
    "id": 697,
    "function": "leaf",
    "file": "Chap23/BalBinTreeStEph.rs",
    "lines": "189-194",
    "spec_strength": "unknown",
    "snippet": "        fn leaf() -> (l: Self)\n            ensures l.spec_size() == 0,\n                    l.spec_height() == 0,\n                    l.spec_in_order() == Seq::<T>::empty(),\n                    l.spec_pre_order() == Seq::<T>::empty(),\n                    l.spec_post_order() == Seq::<T>::empty();"
  },
  {
    "id": 698,
    "function": "node",
    "file": "Chap23/BalBinTreeStEph.rs",
    "lines": "198-204",
    "spec_strength": "unknown",
    "snippet": "        fn node(left: Self, value: T, right: Self) -> (n: Self)\n            ensures n.spec_size() == 1 + left.spec_size() + right.spec_size(),\n                    n.spec_height() == 1 + if left.spec_height() >= right.spec_height()\n                                            { left.spec_height() } else { right.spec_height() },\n                    n.spec_in_order() == left.spec_in_order() + seq![value] + right.spec_in_order(),\n                    n.spec_pre_order() == seq![value] + left.spec_pre_order() + right.spec_pre_order(),\n                    n.spec_post_order() == left.spec_post_order() + right.spec_post_order() + seq![value];"
  },
  {
    "id": 699,
    "function": "is_leaf",
    "file": "Chap23/BalBinTreeStEph.rs",
    "lines": "208-209",
    "spec_strength": "unknown",
    "snippet": "        fn is_leaf(&self) -> (b: bool)\n            ensures b == (self.spec_size() == 0);"
  },
  {
    "id": 700,
    "function": "size",
    "file": "Chap23/BalBinTreeStEph.rs",
    "lines": "213-215",
    "spec_strength": "unknown",
    "snippet": "        fn size(&self) -> (count: usize)\n            requires self.spec_size() <= usize::MAX,\n            ensures count == self.spec_size();"
  },
  {
    "id": 701,
    "function": "height",
    "file": "Chap23/BalBinTreeStEph.rs",
    "lines": "219-221",
    "spec_strength": "unknown",
    "snippet": "        fn height(&self) -> (h: usize)\n            requires self.spec_height() <= usize::MAX,\n            ensures h == self.spec_height();"
  },
  {
    "id": 702,
    "function": "in_order",
    "file": "Chap23/BalBinTreeStEph.rs",
    "lines": "226-230",
    "spec_strength": "unknown",
    "snippet": "        fn in_order(&self) -> (traversal: Vec<T>)\n            where T: Clone + Eq\n            requires self.spec_size() <= usize::MAX,\n                     obeys_feq_clone::<T>(),\n            ensures traversal@ =~= self.spec_in_order();"
  },
  {
    "id": 703,
    "function": "pre_order",
    "file": "Chap23/BalBinTreeStEph.rs",
    "lines": "235-239",
    "spec_strength": "unknown",
    "snippet": "        fn pre_order(&self) -> (traversal: Vec<T>)\n            where T: Clone + Eq\n            requires self.spec_size() <= usize::MAX,\n                     obeys_feq_clone::<T>(),\n            ensures traversal@ =~= self.spec_pre_order();"
  },
  {
    "id": 704,
    "function": "post_order",
    "file": "Chap23/BalBinTreeStEph.rs",
    "lines": "244-248",
    "spec_strength": "unknown",
    "snippet": "        fn post_order(&self) -> (traversal: Vec<T>)\n            where T: Clone + Eq\n            requires self.spec_size() <= usize::MAX,\n                     obeys_feq_clone::<T>(),\n            ensures traversal@ =~= self.spec_post_order();"
  },
  {
    "id": 705,
    "function": "iter_in_order",
    "file": "Chap23/BalBinTreeStEph.rs",
    "lines": "428-434",
    "spec_strength": "unknown",
    "snippet": "        pub fn iter_in_order(&self) -> (it: InOrderIter<T>)\n            requires self.spec_size() <= usize::MAX,\n                     obeys_feq_clone::<T>(),\n            ensures\n                it@.0 == 0,\n                it@.1 =~= self.spec_in_order(),\n                in_order_iter_invariant(&it),"
  },
  {
    "id": 706,
    "function": "iter_pre_order",
    "file": "Chap23/BalBinTreeStEph.rs",
    "lines": "442-448",
    "spec_strength": "unknown",
    "snippet": "        pub fn iter_pre_order(&self) -> (it: PreOrderIter<T>)\n            requires self.spec_size() <= usize::MAX,\n                     obeys_feq_clone::<T>(),\n            ensures\n                it@.0 == 0,\n                it@.1 =~= self.spec_pre_order(),\n                pre_order_iter_invariant(&it),"
  },
  {
    "id": 707,
    "function": "iter_post_order",
    "file": "Chap23/BalBinTreeStEph.rs",
    "lines": "456-462",
    "spec_strength": "unknown",
    "snippet": "        pub fn iter_post_order(&self) -> (it: PostOrderIter<T>)\n            requires self.spec_size() <= usize::MAX,\n                     obeys_feq_clone::<T>(),\n            ensures\n                it@.0 == 0,\n                it@.1 =~= self.spec_post_order(),\n                post_order_iter_invariant(&it),"
  },
  {
    "id": 708,
    "function": "next`",
    "file": "Chap23/BalBinTreeStEph.rs",
    "lines": "546-562",
    "spec_strength": "unknown",
    "snippet": "        fn next(&mut self) -> (next: Option<T>)\n            ensures ({\n                let (old_index, old_seq) = old(self)@;\n                match next {\n                    None => {\n                        &&& self@ == old(self)@\n                        &&& old_index >= old_seq.len()\n                    },\n                    Some(element) => {\n                        let (new_index, new_seq) = self@;\n                        &&& 0 <= old_index < old_seq.len()\n                        &&& new_seq == old_seq\n                        &&& new_index == old_index + 1\n                        &&& element == old_seq[old_index]\n                    },\n                }\n            })"
  },
  {
    "id": 709,
    "function": "eq`",
    "file": "Chap23/BalBinTreeStEph.rs",
    "lines": "761-763",
    "spec_strength": "hole",
    "snippet": "        fn eq(&self, other: &Self) -> (equal: bool)\n            ensures equal == (*self == *other)\n            decreases self,"
  },
  {
    "id": 710,
    "function": "clone_tree",
    "file": "Chap23/BalBinTreeStEph.rs",
    "lines": "790-792",
    "spec_strength": "hole",
    "snippet": "    fn clone_tree<T: Clone>(t: &BalBinTree<T>) -> (c: BalBinTree<T>)\n        ensures c == *t\n        decreases t,"
  },
  {
    "id": 711,
    "function": "empty",
    "file": "Chap23/PrimTreeSeqStPer.rs",
    "lines": "124-125",
    "spec_strength": "unknown",
    "snippet": "        fn empty() -> (empty_seq: Self)\n            ensures empty_seq.spec_len() == 0;"
  },
  {
    "id": 712,
    "function": "singleton",
    "file": "Chap23/PrimTreeSeqStPer.rs",
    "lines": "130-133",
    "spec_strength": "unknown",
    "snippet": "        fn singleton(value: T) -> (single: Self)\n            ensures\n                single.spec_len() == 1,\n                single.spec_index(0) == value;"
  },
  {
    "id": 713,
    "function": "from_vec",
    "file": "Chap23/PrimTreeSeqStPer.rs",
    "lines": "138-141",
    "spec_strength": "unknown",
    "snippet": "        fn from_vec(vec: Vec<T>) -> (seq: Self)\n            ensures\n                seq.spec_len() == vec@.len(),\n                forall|i: int| #![trigger seq.spec_index(i)] 0 <= i < vec@.len() ==> seq.spec_index(i) == vec@[i];"
  },
  {
    "id": 714,
    "function": "length",
    "file": "Chap23/PrimTreeSeqStPer.rs",
    "lines": "146-147",
    "spec_strength": "unknown",
    "snippet": "        fn length(&self) -> (len: usize)\n            ensures len == self.spec_len();"
  },
  {
    "id": 715,
    "function": "nth",
    "file": "Chap23/PrimTreeSeqStPer.rs",
    "lines": "152-154",
    "spec_strength": "unknown",
    "snippet": "        fn nth(&self, index: usize) -> (nth_elem: &T)\n            requires index < self.spec_len()\n            ensures *nth_elem == self.spec_index(index as int);"
  },
  {
    "id": 716,
    "function": "expose",
    "file": "Chap23/PrimTreeSeqStPer.rs",
    "lines": "159-166",
    "spec_strength": "unknown",
    "snippet": "        fn expose(&self) -> (tree: PrimTreeSeqStTree<T>)\n            where T: Clone + Eq\n            requires\n                self.spec_len() <= usize::MAX,\n                obeys_feq_clone::<T>(),\n            ensures\n                self.spec_len() == 0 <==> tree@ is Zero,\n                self.spec_len() == 1 <==> {"
  },
  {
    "id": 717,
    "function": "join",
    "file": "Chap23/PrimTreeSeqStPer.rs",
    "lines": "181-185",
    "spec_strength": "unknown",
    "snippet": "        fn join(tree: PrimTreeSeqStTree<T>) -> (joined: Self)\n            ensures\n                tree@ is Zero ==> joined@ =~= Seq::<T>::empty(),\n                tree@ is One ==> joined@ =~= seq![tree@->One_0],\n                tree@ is Two ==> joined@ =~= tree@->Two_0 + tree@->Two_1;"
  },
  {
    "id": 718,
    "function": "append",
    "file": "Chap23/PrimTreeSeqStPer.rs",
    "lines": "190-198",
    "spec_strength": "unknown",
    "snippet": "        fn append(a: &Self, b: &Self) -> (appended: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                a.spec_len() + b.spec_len() <= usize::MAX as nat,\n            ensures\n                appended.spec_len() == a.spec_len() + b.spec_len(),\n                forall|i: int| #![trigger appended.spec_index(i)] 0 <= i < a.spec_len() ==> appended.spec_index(i) == a.spec_index(i),\n                forall|i: int| #![trigger b.spec_index(i)] 0 <= i < b.spec_len() ==> appended.spec_index(a.spec_len() as int + i) == b.spec_index(i);"
  },
  {
    "id": 719,
    "function": "subseq",
    "file": "Chap23/PrimTreeSeqStPer.rs",
    "lines": "203-211",
    "spec_strength": "unknown",
    "snippet": "        fn subseq(&self, start: usize, length: usize) -> (subseq: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                start + length <= usize::MAX,\n                start + length <= self.spec_len(),\n            ensures\n                subseq.spec_len() == length as int,\n                forall|i: int| #![trigger subseq.spec_index(i)] 0 <= i < length ==> subseq.spec_index(i) == self.spec_index(start as int + i);"
  },
  {
    "id": 720,
    "function": "update",
    "file": "Chap23/PrimTreeSeqStPer.rs",
    "lines": "216-224",
    "spec_strength": "unknown",
    "snippet": "        fn update(a: &Self, index: usize, item: T) -> (updated: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                index < a.spec_len(),\n            ensures\n                updated.spec_len() == a.spec_len(),\n                updated.spec_index(index as int) == item,\n                forall|i: int| #![trigger updated.spec_index(i)] 0 <= i < a.spec_len() && i != index as int ==> updated.spec_index(i) == a.spec_index(i);"
  },
  {
    "id": 721,
    "function": "map",
    "file": "Chap23/PrimTreeSeqStPer.rs",
    "lines": "229-234",
    "spec_strength": "unknown",
    "snippet": "        fn map<U: Clone, F: Fn(&T) -> U>(a: &PrimTreeSeqStS<T>, f: &F) -> (mapped: PrimTreeSeqStS<U>)\n            requires\n                forall|i: int| 0 <= i < a.spec_len() ==> #[trigger] f.requires((&a.spec_index(i),)),\n            ensures\n                mapped.spec_len() == a.spec_len(),\n                forall|i: int| #![trigger mapped.spec_index(i)] 0 <= i < a.spec_len() ==> f.ensures((&a.spec_index(i),), mapped.spec_index(i));"
  },
  {
    "id": 722,
    "function": "tabulate",
    "file": "Chap23/PrimTreeSeqStPer.rs",
    "lines": "239-245",
    "spec_strength": "unknown",
    "snippet": "        fn tabulate<F: Fn(usize) -> T>(f: &F, length: usize) -> (tab_seq: Self)\n            requires\n                length <= usize::MAX,\n                forall|i: usize| i < length ==> #[trigger] f.requires((i,)),\n            ensures\n                tab_seq.spec_len() == length,\n                forall|i: int| #![trigger tab_seq.spec_index(i)] 0 <= i < length ==> f.ensures((i as usize,), tab_seq.spec_index(i));"
  },
  {
    "id": 723,
    "function": "filter",
    "file": "Chap23/PrimTreeSeqStPer.rs",
    "lines": "250-262",
    "spec_strength": "unknown",
    "snippet": "        fn filter<F: Fn(&T) -> bool>(a: &PrimTreeSeqStS<T>, pred: &F, Ghost(spec_pred): Ghost<spec_fn(T) -> bool>) -> (filtered: PrimTreeSeqStS<T>)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                forall|i: int| 0 <= i < a.spec_len() ==> #[trigger] pred.requires((&a.spec_index(i),)),\n                forall|v: T, keep: bool| pred.ensures((&v,), keep) ==> spec_pred(v) == keep,\n            ensures\n                filtered.spec_len() <= a.spec_len(),\n                filtered.spec_len() == spec_filter_len(\n                    Seq::new(a.spec_len(), |i: int| a.spec_index(i)), spec_pred),\n                Seq::new(filtered.spec_len(), |i: int| filtered.spec_index(i)).to_multiset()\n                    =~= Seq::new(a.spec_len(), |i: int| a.spec_index(i)).to_multiset().filter(spec_pred),\n                forall|i: int| #![trigger filtered.spec_index(i)] 0 <= i < filtered.spec_len() ==> pred.ensures((&filtered.spec_index(i),), true);"
  },
  {
    "id": 724,
    "function": "drop",
    "file": "Chap23/PrimTreeSeqStPer.rs",
    "lines": "267-275",
    "spec_strength": "unknown",
    "snippet": "        fn drop(&self, n: usize) -> (dropped: Self)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n                n <= self.spec_len(),\n                self.spec_len() <= usize::MAX,\n            ensures\n                dropped.spec_len() == self.spec_len() - n,\n                forall|i: int| #![trigger dropped.spec_index(i)] 0 <= i < dropped.spec_len() ==> dropped.spec_index(i) == self.spec_index(n as int + i);"
  },
  {
    "id": 725,
    "function": "flatten",
    "file": "Chap23/PrimTreeSeqStPer.rs",
    "lines": "280-285",
    "spec_strength": "unknown",
    "snippet": "        fn flatten(a: &PrimTreeSeqStS<PrimTreeSeqStS<T>>) -> (flattened: PrimTreeSeqStS<T>)\n            where T: Clone + Eq\n            requires\n                obeys_feq_clone::<T>(),\n            ensures\n                flattened.seq@ =~= a.seq@.map_values(|inner: PrimTreeSeqStS<T>| inner.seq@).flatten();"
  },
  {
    "id": 726,
    "function": "as_slice",
    "file": "Chap23/PrimTreeSeqStPer.rs",
    "lines": "290-291",
    "spec_strength": "unknown",
    "snippet": "        fn as_slice(&self) -> (slice: &[T])\n            ensures slice@ =~= self@;"
  },
  {
    "id": 727,
    "function": "into_vec",
    "file": "Chap23/PrimTreeSeqStPer.rs",
    "lines": "296-297",
    "spec_strength": "unknown",
    "snippet": "        fn into_vec(self) -> (vec: Vec<T>)\n            ensures vec@ =~= self@;"
  },
  {
    "id": 728,
    "function": "iter",
    "file": "Chap23/PrimTreeSeqStPer.rs",
    "lines": "317-321",
    "spec_strength": "unknown",
    "snippet": "        pub fn iter(&self) -> (it: PrimTreeSeqStIter<'_, T>)\n            ensures\n                it@.0 == 0,\n                it@.1 == self.seq@,\n                prim_tree_seq_iter_invariant(&it),"
  },
  {
    "id": 729,
    "function": "next",
    "file": "Chap23/PrimTreeSeqStPer.rs",
    "lines": "757-773",
    "spec_strength": "unknown",
    "snippet": "        fn next(&mut self) -> (next: Option<&'a T>)\n            ensures ({\n                let (old_index, old_seq) = old(self)@;\n                match next {\n                    None => {\n                        &&& self@ == old(self)@\n                        &&& old_index >= old_seq.len()\n                    },\n                    Some(element) => {\n                        let (new_index, new_seq) = self@;\n                        &&& 0 <= old_index < old_seq.len()\n                        &&& new_seq == old_seq\n                        &&& new_index == old_index + 1\n                        &&& element == old_seq[old_index]\n                    },\n                }\n            })"
  },
  {
    "id": 730,
    "function": "eq`",
    "file": "Chap23/PrimTreeSeqStPer.rs",
    "lines": "859-860",
    "spec_strength": "hole",
    "snippet": "        fn eq(&self, other: &Self) -> (equal: bool)\n            ensures equal == (self@ == other@)"
  },
  {
    "id": 731,
    "function": "lemma_fold_left_step",
    "file": "Chap26/DivConReduceMtPer.rs",
    "lines": "80-84",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_fold_left_step(s: Seq<N>, acc: N)\n        requires s.len() > 0,\n        ensures s.fold_left(acc, spec_max_fn())\n            == s.subrange(1, s.len() as int).fold_left(\n                spec_max_fn()(acc, s[0]), spec_max_fn()),"
  },
  {
    "id": 732,
    "function": "lemma_max_fold_left_bound",
    "file": "Chap26/DivConReduceMtPer.rs",
    "lines": "93-98",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_max_fold_left_bound(s: Seq<N>, acc: N)\n        ensures\n            s.fold_left(acc, spec_max_fn()) >= acc,\n            forall|i: int| #![trigger s[i]] 0 <= i < s.len()\n                ==> s[i] <= s.fold_left(acc, spec_max_fn()),\n        decreases s.len(),"
  },
  {
    "id": 733,
    "function": "lemma_max_fold_left_achievable",
    "file": "Chap26/DivConReduceMtPer.rs",
    "lines": "118-123",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_max_fold_left_achievable(s: Seq<N>, acc: N)\n        ensures\n            s.fold_left(acc, spec_max_fn()) == acc\n            || exists|i: int| #![trigger s[i]] 0 <= i < s.len()\n                && s[i] == s.fold_left(acc, spec_max_fn()),\n        decreases s.len(),"
  },
  {
    "id": 734,
    "function": "max_element_parallel",
    "file": "Chap26/DivConReduceMtPer.rs",
    "lines": "155-159",
    "spec_strength": "unknown",
    "snippet": "        fn max_element_parallel(a: &ArraySeqMtPerS<N>) -> (max: Option<N>)\n            requires a.spec_len() <= usize::MAX,\n            ensures\n                a.spec_len() == 0 ==> max is None,\n                a.spec_len() > 0 ==> {"
  },
  {
    "id": 735,
    "function": "sum_parallel",
    "file": "Chap26/DivConReduceMtPer.rs",
    "lines": "171-177",
    "spec_strength": "unknown",
    "snippet": "        fn sum_parallel(a: &ArraySeqMtPerS<N>) -> (total: N)\n            requires\n                a.spec_len() <= usize::MAX,\n                spec_monoid(spec_sum_fn(), 0),\n            ensures\n                total == spec_iterate(\n                    Seq::new(a.spec_len(), |i: int| a.spec_index(i)), spec_sum_fn(), 0);"
  },
  {
    "id": 736,
    "function": "product_parallel",
    "file": "Chap26/DivConReduceMtPer.rs",
    "lines": "183-189",
    "spec_strength": "unknown",
    "snippet": "        fn product_parallel(a: &ArraySeqMtPerS<N>) -> (total: N)\n            requires\n                a.spec_len() <= usize::MAX,\n                spec_monoid(spec_product_fn(), 1),\n            ensures\n                total == spec_iterate(\n                    Seq::new(a.spec_len(), |i: int| a.spec_index(i)), spec_product_fn(), 1);"
  },
  {
    "id": 737,
    "function": "any_parallel",
    "file": "Chap26/DivConReduceMtPer.rs",
    "lines": "195-201",
    "spec_strength": "unknown",
    "snippet": "        fn any_parallel(a: &ArraySeqMtPerS<B>) -> (found: B)\n            requires\n                a.spec_len() <= usize::MAX,\n                spec_monoid(spec_or_fn(), false),\n            ensures\n                found == spec_iterate(\n                    Seq::new(a.spec_len(), |i: int| a.spec_index(i)), spec_or_fn(), false);"
  },
  {
    "id": 738,
    "function": "all_parallel",
    "file": "Chap26/DivConReduceMtPer.rs",
    "lines": "207-213",
    "spec_strength": "unknown",
    "snippet": "        fn all_parallel(a: &ArraySeqMtPerS<B>) -> (all_true: B)\n            requires\n                a.spec_len() <= usize::MAX,\n                spec_monoid(spec_and_fn(), true),\n            ensures\n                all_true == spec_iterate(\n                    Seq::new(a.spec_len(), |i: int| a.spec_index(i)), spec_and_fn(), true);"
  },
  {
    "id": 739,
    "function": "max_element",
    "file": "Chap26/DivConReduceStPer.rs",
    "lines": "63-67",
    "spec_strength": "unknown",
    "snippet": "        fn max_element(a: &ArraySeqStPerS<N>) -> (max: Option<N>)\n            requires a.spec_len() <= usize::MAX,\n            ensures\n                a.spec_len() == 0 ==> max is None,\n                a.spec_len() > 0 ==> {"
  },
  {
    "id": 740,
    "function": "sum",
    "file": "Chap26/DivConReduceStPer.rs",
    "lines": "79-85",
    "spec_strength": "unknown",
    "snippet": "        fn sum(a: &ArraySeqStPerS<N>) -> (total: N)\n            requires\n                a.spec_len() <= usize::MAX,\n                spec_monoid(spec_sum_fn(), 0),\n            ensures\n                total == spec_iterate(\n                    Seq::new(a.spec_len(), |i: int| a.spec_index(i)), spec_sum_fn(), 0);"
  },
  {
    "id": 741,
    "function": "product",
    "file": "Chap26/DivConReduceStPer.rs",
    "lines": "91-97",
    "spec_strength": "unknown",
    "snippet": "        fn product(a: &ArraySeqStPerS<N>) -> (total: N)\n            requires\n                a.spec_len() <= usize::MAX,\n                spec_monoid(spec_product_fn(), 1),\n            ensures\n                total == spec_iterate(\n                    Seq::new(a.spec_len(), |i: int| a.spec_index(i)), spec_product_fn(), 1);"
  },
  {
    "id": 742,
    "function": "any",
    "file": "Chap26/DivConReduceStPer.rs",
    "lines": "103-109",
    "spec_strength": "unknown",
    "snippet": "        fn any(a: &ArraySeqStPerS<B>) -> (found: B)\n            requires\n                a.spec_len() <= usize::MAX,\n                spec_monoid(spec_or_fn(), false),\n            ensures\n                found == spec_iterate(\n                    Seq::new(a.spec_len(), |i: int| a.spec_index(i)), spec_or_fn(), false);"
  },
  {
    "id": 743,
    "function": "all",
    "file": "Chap26/DivConReduceStPer.rs",
    "lines": "115-121",
    "spec_strength": "unknown",
    "snippet": "        fn all(a: &ArraySeqStPerS<B>) -> (all_true: B)\n            requires\n                a.spec_len() <= usize::MAX,\n                spec_monoid(spec_and_fn(), true),\n            ensures\n                all_true == spec_iterate(\n                    Seq::new(a.spec_len(), |i: int| a.spec_index(i)), spec_and_fn(), true);"
  },
  {
    "id": 744,
    "function": "lemma_point_in_seq_transitive",
    "file": "Chap26/ETSPMtEph.rs",
    "lines": "123-129",
    "spec_strength": "unknown",
    "snippet": "    pub proof fn lemma_point_in_seq_transitive(p: Point, sub: Seq<Point>, sup: Seq<Point>)\n        requires\n            spec_point_in_seq(p, sub),\n            forall|i: int| #![trigger sub[i]] 0 <= i < sub.len() ==>\n                spec_point_in_seq(sub[i], sup),\n        ensures\n            spec_point_in_seq(p, sup),"
  },
  {
    "id": 745,
    "function": "lemma_edge_valid_transitive",
    "file": "Chap26/ETSPMtEph.rs",
    "lines": "139-151",
    "spec_strength": "unknown",
    "snippet": "    pub proof fn lemma_edge_valid_transitive(\n        edge: Edge,\n        sub_points: Seq<Point>,\n        points: Seq<Point>,\n    )\n        requires\n            spec_point_in_seq(edge.from, sub_points),\n            spec_point_in_seq(edge.to, sub_points),\n            forall|i: int| #![trigger sub_points[i]] 0 <= i < sub_points.len() ==>\n                spec_point_in_seq(sub_points[i], points),\n        ensures\n            spec_point_in_seq(edge.from, points),\n            spec_point_in_seq(edge.to, points),"
  },
  {
    "id": 746,
    "function": "lemma_mod_successor",
    "file": "Chap26/ETSPMtEph.rs",
    "lines": "158-160",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_mod_successor(a: int, n: int)\n        requires n > 0,\n        ensures ((a % n) + 1) % n == (a + 1) % n,"
  },
  {
    "id": 747,
    "function": "lemma_combined_cycle",
    "file": "Chap26/ETSPMtEph.rs",
    "lines": "168-192",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_combined_cycle(\n        combined: Seq<Edge>, lt: Seq<Edge>, rt: Seq<Edge>,\n        ln_i: int, rn_i: int, best_li: int, best_ri: int,\n        el_from: Point, el_to: Point, er_from: Point, er_to: Point,\n    )\n        requires\n            combined.len() == ln_i + rn_i,\n            ln_i >= 2, rn_i >= 2,\n            0 <= best_li < ln_i,\n            0 <= best_ri < rn_i,\n            lt.len() == ln_i, rt.len() == rn_i,\n            spec_edges_form_cycle(lt),\n            spec_edges_form_cycle(rt),\n            el_from == lt[best_li].from,\n            el_to == lt[best_li].to,\n            er_from == rt[best_ri].from,\n            er_to == rt[best_ri].to,\n            forall|k: int| #![trigger combined[k]] 0 <= k < ln_i - 1 ==>\n                combined[k] == lt[((best_li + 1 + k) % ln_i)],\n            combined[ln_i - 1] == (Edge { from: el_from, to: er_to }),\n            forall|m: int| #![trigger combined[(ln_i + m)]] 0 <= m < rn_i - 1 ==>\n                combined[(ln_i + m)] == rt[((best_ri + 1 + m) % rn_i)],\n            combined[ln_i + rn_i - 1] == (Edge { from: er_from, to: el_to }),\n        ensures\n            spec_edges_form_cycle(combined),"
  },
  {
    "id": 748,
    "function": "etsp_parallel",
    "file": "Chap26/ETSPMtEph.rs",
    "lines": "302-306",
    "spec_strength": "unknown",
    "snippet": "        fn etsp_parallel(points: &Vec<Point>) -> (tour: Vec<Edge>)\n            requires\n                points@.len() >= 2,\n                points@.len() < usize::MAX / 2,\n            ensures spec_etsp(tour@, points@);"
  },
  {
    "id": 749,
    "function": "etsp_parallel_inner",
    "file": "Chap26/ETSPMtEph.rs",
    "lines": "318-323",
    "spec_strength": "unknown",
    "snippet": "    fn etsp_parallel_inner(points: &Vec<Point>) -> (tour: Vec<Edge>)\n        requires\n            points@.len() >= 2,\n            points@.len() < usize::MAX / 2,\n        ensures spec_etsp(tour@, points@),\n        decreases points@.len(),"
  },
  {
    "id": 750,
    "function": "sort_and_split",
    "file": "Chap26/ETSPMtEph.rs",
    "lines": "504-515",
    "spec_strength": "hole",
    "snippet": "    pub fn sort_and_split(points: &Vec<Point>) -> (halves: (Vec<Point>, Vec<Point>))\n        requires points@.len() >= 4,\n        ensures\n            halves.0@.len() >= 2,\n            halves.1@.len() >= 2,\n            halves.0@.len() + halves.1@.len() == points@.len(),\n            halves.0@.len() < points@.len(),\n            halves.1@.len() < points@.len(),\n            forall|i: int| #![trigger halves.0@[i]] 0 <= i < halves.0@.len() ==>\n                spec_point_in_seq(halves.0@[i], points@),\n            forall|i: int| #![trigger halves.1@[i]] 0 <= i < halves.1@.len() ==>\n                spec_point_in_seq(halves.1@[i], points@),"
  },
  {
    "id": 751,
    "function": "find_best_swap",
    "file": "Chap26/ETSPMtEph.rs",
    "lines": "522-528",
    "spec_strength": "hole",
    "snippet": "    pub fn find_best_swap(left_tour: &Vec<Edge>, right_tour: &Vec<Edge>) -> (swap_indices: (usize, usize))\n        requires\n            left_tour@.len() >= 2,\n            right_tour@.len() >= 2,\n        ensures\n            (swap_indices.0 as int) < left_tour@.len(),\n            (swap_indices.1 as int) < right_tour@.len(),"
  },
  {
    "id": 752,
    "function": "distance",
    "file": "Chap26/ETSPMtEph.rs",
    "lines": "552",
    "spec_strength": "",
    "snippet": "        fn distance(&self, other: &Point) -> f64;"
  },
  {
    "id": 753,
    "function": "sort_and_split_impl",
    "file": "Chap26/ETSPMtEph.rs",
    "lines": "563-585",
    "spec_strength": "",
    "snippet": "    /// Sort points by longest-spread dimension and split at median. (f64 arithmetic.)\n    pub fn sort_and_split_impl(points: &Vec<Point>) -> (Vec<Point>, Vec<Point>) {\n        let n = points.len();\n        let (mut min_x, mut max_x, mut min_y, mut max_y) =\n            (points[0].x, points[0].x, points[0].y, points[0].y);\n        for i in 1..n {\n            if points[i].x < min_x { min_x = points[i].x; }\n            if points[i].x > max_x { max_x = points[i].x; }\n            if points[i].y < min_y { min_y = points[i].y; }\n            if points[i].y > max_y { max_y = points[i].y; }\n        }\n        let split_on_x = (max_x - min_x) >= (max_y - min_y);\n        let mut sorted_points = points.clone();\n        if split_on_x {\n            sorted_points.sort_by(|a, b| a.x.partial_cmp(&b.x).unwrap_or(std::cmp::Ordering::Equal));\n        } else {\n            sorted_points.sort_by(|a, b| a.y.partial_cmp(&b.y).unwrap_or(std::cmp::Ordering::Equal));\n        }\n        let mid = (n / 2).max(2);\n        let left: Vec<Point> = sorted_points[..mid].to_vec();\n        let right: Vec<Point> = sorted_points[mid..].to_vec();\n        (left, right)\n    }"
  },
  {
    "id": 754,
    "function": "find_best_swap_impl",
    "file": "Chap26/ETSPMtEph.rs",
    "lines": "587-593",
    "spec_strength": "",
    "snippet": "    /// Parallel find-best-swap: recursively splits the outer loop over left_tour\n    /// and runs both halves in parallel via std::thread::scope.\n    /// Work (nm), Span (mlg n) where n = left_tour.len(), m = right_tour.len().\n    pub fn find_best_swap_impl(left_tour: &Vec<Edge>, right_tour: &Vec<Edge>) -> (usize, usize) {\n        let (li, ri, _) = find_best_swap_par(left_tour, right_tour, 0, left_tour.len());\n        (li, ri)\n    }"
  },
  {
    "id": 755,
    "function": "find_best_swap_par",
    "file": "Chap26/ETSPMtEph.rs",
    "lines": "595-629",
    "spec_strength": "",
    "snippet": "    fn find_best_swap_par(\n        left_tour: &Vec<Edge>, right_tour: &Vec<Edge>, lo: usize, hi: usize,\n    ) -> (usize, usize, f64) {\n        const THRESHOLD: usize = 16;\n        if hi <= lo {\n            return (0, 0, f64::MAX);\n        }\n        if hi - lo <= THRESHOLD {\n            let mut best_cost = f64::MAX;\n            let mut best_li = 0usize;\n            let mut best_ri = 0usize;\n            for li in lo..hi {\n                for ri in 0..right_tour.len() {\n                    let el = &left_tour[li];\n                    let er = &right_tour[ri];\n                    let cost = el.from.distance(&er.to) + er.from.distance(&el.to)\n                             - el.from.distance(&el.to) - er.from.distance(&er.to);\n                    if cost < best_cost {\n                        best_cost = cost;\n                        best_li = li;\n                        best_ri = ri;\n                    }\n                }\n            }\n            (best_li, best_ri, best_cost)\n        } else {\n            let mid = lo + (hi - lo) / 2;\n            std::thread::scope(|s| {\n                let left_half = s.spawn(|| find_best_swap_par(left_tour, right_tour, lo, mid));\n                let right_res = find_best_swap_par(left_tour, right_tour, mid, hi);\n                let left_res = left_half.join().unwrap();\n                if left_res.2 <= right_res.2 { left_res } else { right_res }\n            })\n        }\n    }"
  },
  {
    "id": 756,
    "function": "lemma_point_in_seq_transitive",
    "file": "Chap26/ETSPStEph.rs",
    "lines": "116-122",
    "spec_strength": "unknown",
    "snippet": "    pub proof fn lemma_point_in_seq_transitive(p: Point, sub: Seq<Point>, sup: Seq<Point>)\n        requires\n            spec_point_in_seq(p, sub),\n            forall|i: int| #![trigger sub[i]] 0 <= i < sub.len() ==>\n                spec_point_in_seq(sub[i], sup),\n        ensures\n            spec_point_in_seq(p, sup),"
  },
  {
    "id": 757,
    "function": "lemma_edge_valid_transitive",
    "file": "Chap26/ETSPStEph.rs",
    "lines": "132-144",
    "spec_strength": "unknown",
    "snippet": "    pub proof fn lemma_edge_valid_transitive(\n        edge: Edge,\n        sub_points: Seq<Point>,\n        points: Seq<Point>,\n    )\n        requires\n            spec_point_in_seq(edge.from, sub_points),\n            spec_point_in_seq(edge.to, sub_points),\n            forall|i: int| #![trigger sub_points[i]] 0 <= i < sub_points.len() ==>\n                spec_point_in_seq(sub_points[i], points),\n        ensures\n            spec_point_in_seq(edge.from, points),\n            spec_point_in_seq(edge.to, points),"
  },
  {
    "id": 758,
    "function": "lemma_combined_cycle",
    "file": "Chap26/ETSPStEph.rs",
    "lines": "151-175",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_combined_cycle(\n        combined: Seq<Edge>, lt: Seq<Edge>, rt: Seq<Edge>,\n        ln_i: int, rn_i: int, best_li: int, best_ri: int,\n        el_from: Point, el_to: Point, er_from: Point, er_to: Point,\n    )\n        requires\n            combined.len() == ln_i + rn_i,\n            ln_i >= 2, rn_i >= 2,\n            0 <= best_li < ln_i,\n            0 <= best_ri < rn_i,\n            lt.len() == ln_i, rt.len() == rn_i,\n            spec_edges_form_cycle(lt),\n            spec_edges_form_cycle(rt),\n            el_from == lt[best_li].from,\n            el_to == lt[best_li].to,\n            er_from == rt[best_ri].from,\n            er_to == rt[best_ri].to,\n            forall|k: int| #![trigger combined[k]] 0 <= k < ln_i - 1 ==>\n                combined[k] == lt[((best_li + 1 + k) % ln_i)],\n            combined[ln_i - 1] == (Edge { from: el_from, to: er_to }),\n            forall|m: int| #![trigger combined[(ln_i + m)]] 0 <= m < rn_i - 1 ==>\n                combined[(ln_i + m)] == rt[((best_ri + 1 + m) % rn_i)],\n            combined[ln_i + rn_i - 1] == (Edge { from: er_from, to: el_to }),\n        ensures\n            spec_edges_form_cycle(combined),"
  },
  {
    "id": 759,
    "function": "etsp",
    "file": "Chap26/ETSPStEph.rs",
    "lines": "290-294",
    "spec_strength": "unknown",
    "snippet": "        fn etsp(points: &Vec<Point>) -> (tour: Vec<Edge>)\n            requires\n                points@.len() >= 2,\n                points@.len() < usize::MAX / 2,\n            ensures spec_etsp(tour@, points@);"
  },
  {
    "id": 760,
    "function": "etsp_inner",
    "file": "Chap26/ETSPStEph.rs",
    "lines": "309-314",
    "spec_strength": "unknown",
    "snippet": "    fn etsp_inner(points: &Vec<Point>) -> (tour: Vec<Edge>)\n        requires\n            points@.len() >= 2,\n            points@.len() < usize::MAX / 2,\n        ensures spec_etsp(tour@, points@),\n        decreases points@.len(),"
  },
  {
    "id": 761,
    "function": "sort_and_split",
    "file": "Chap26/ETSPStEph.rs",
    "lines": "481-492",
    "spec_strength": "hole",
    "snippet": "    pub fn sort_and_split(points: &Vec<Point>) -> (halves: (Vec<Point>, Vec<Point>))\n        requires points@.len() >= 4,\n        ensures\n            halves.0@.len() >= 2,\n            halves.1@.len() >= 2,\n            halves.0@.len() + halves.1@.len() == points@.len(),\n            halves.0@.len() < points@.len(),\n            halves.1@.len() < points@.len(),\n            forall|i: int| #![trigger halves.0@[i]] 0 <= i < halves.0@.len() ==>\n                spec_point_in_seq(halves.0@[i], points@),\n            forall|i: int| #![trigger halves.1@[i]] 0 <= i < halves.1@.len() ==>\n                spec_point_in_seq(halves.1@[i], points@),"
  },
  {
    "id": 762,
    "function": "find_best_swap",
    "file": "Chap26/ETSPStEph.rs",
    "lines": "499-505",
    "spec_strength": "hole",
    "snippet": "    pub fn find_best_swap(left_tour: &Vec<Edge>, right_tour: &Vec<Edge>) -> (swap_indices: (usize, usize))\n        requires\n            left_tour@.len() >= 2,\n            right_tour@.len() >= 2,\n        ensures\n            (swap_indices.0 as int) < left_tour@.len(),\n            (swap_indices.1 as int) < right_tour@.len(),"
  },
  {
    "id": 763,
    "function": "distance",
    "file": "Chap26/ETSPStEph.rs",
    "lines": "528",
    "spec_strength": "",
    "snippet": "        fn distance(&self, other: &Point) -> f64;"
  },
  {
    "id": 764,
    "function": "sort_and_split_impl",
    "file": "Chap26/ETSPStEph.rs",
    "lines": "539-561",
    "spec_strength": "",
    "snippet": "    /// Sort points by longest-spread dimension and split at median. (f64 arithmetic.)\n    pub fn sort_and_split_impl(points: &Vec<Point>) -> (Vec<Point>, Vec<Point>) {\n        let n = points.len();\n        let (mut min_x, mut max_x, mut min_y, mut max_y) =\n            (points[0].x, points[0].x, points[0].y, points[0].y);\n        for i in 1..n {\n            if points[i].x < min_x { min_x = points[i].x; }\n            if points[i].x > max_x { max_x = points[i].x; }\n            if points[i].y < min_y { min_y = points[i].y; }\n            if points[i].y > max_y { max_y = points[i].y; }\n        }\n        let split_on_x = (max_x - min_x) >= (max_y - min_y);\n        let mut sorted_points = points.clone();\n        if split_on_x {\n            sorted_points.sort_by(|a, b| a.x.partial_cmp(&b.x).unwrap_or(std::cmp::Ordering::Equal));\n        } else {\n            sorted_points.sort_by(|a, b| a.y.partial_cmp(&b.y).unwrap_or(std::cmp::Ordering::Equal));\n        }\n        let mid = (n / 2).max(2);\n        let left: Vec<Point> = sorted_points[..mid].to_vec();\n        let right: Vec<Point> = sorted_points[mid..].to_vec();\n        (left, right)\n    }"
  },
  {
    "id": 765,
    "function": "find_best_swap_impl",
    "file": "Chap26/ETSPStEph.rs",
    "lines": "563-582",
    "spec_strength": "",
    "snippet": "    /// Find best swap indices by exhaustive O(n) search. (f64 arithmetic.)\n    pub fn find_best_swap_impl(left_tour: &Vec<Edge>, right_tour: &Vec<Edge>) -> (usize, usize) {\n        let mut best_cost = f64::MAX;\n        let mut best_li = 0usize;\n        let mut best_ri = 0usize;\n        for li in 0..left_tour.len() {\n            for ri in 0..right_tour.len() {\n                let el = &left_tour[li];\n                let er = &right_tour[ri];\n                let cost = el.from.distance(&er.to) + er.from.distance(&el.to)\n                         - el.from.distance(&el.to) - er.from.distance(&er.to);\n                if cost < best_cost {\n                    best_cost = cost;\n                    best_li = li;\n                    best_ri = ri;\n                }\n            }\n        }\n        (best_li, best_ri)\n    }"
  },
  {
    "id": 766,
    "function": "lemma_multiset_count_positive_implies_exists",
    "file": "Chap26/MergeSortMtPer.rs",
    "lines": "86-89",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_multiset_count_positive_implies_exists(s: Seq<N>, x: N)\n        requires s.to_multiset().count(x) > 0,\n        ensures exists|j: int| #![trigger s[j]] 0 <= j < s.len() && s[j] == x,\n        decreases s.len(),"
  },
  {
    "id": 767,
    "function": "lemma_all_le_preserved_by_permutation",
    "file": "Chap26/MergeSortMtPer.rs",
    "lines": "105-110",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_all_le_preserved_by_permutation(a: Seq<N>, b: Seq<N>, bound: N)\n        requires\n            a.to_multiset() =~= b.to_multiset(),\n            forall|i: int| #![trigger b[i]] 0 <= i < b.len() ==> b[i] <= bound,\n        ensures\n            forall|i: int| #![trigger a[i]] 0 <= i < a.len() ==> a[i] <= bound,"
  },
  {
    "id": 768,
    "function": "lemma_all_ge_preserved_by_permutation",
    "file": "Chap26/MergeSortMtPer.rs",
    "lines": "122-127",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_all_ge_preserved_by_permutation(a: Seq<N>, b: Seq<N>, bound: N)\n        requires\n            a.to_multiset() =~= b.to_multiset(),\n            forall|i: int| #![trigger b[i]] 0 <= i < b.len() ==> b[i] >= bound,\n        ensures\n            forall|i: int| #![trigger a[i]] 0 <= i < a.len() ==> a[i] >= bound,"
  },
  {
    "id": 769,
    "function": "lemma_sorted_concat_pivot",
    "file": "Chap26/MergeSortMtPer.rs",
    "lines": "140-147",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_sorted_concat_pivot(a: Seq<N>, pivot: N, c: Seq<N>)\n        requires\n            spec_sorted(a),\n            spec_sorted(c),\n            forall|i: int| #![trigger a[i]] 0 <= i < a.len() ==> a[i] <= pivot,\n            forall|i: int| #![trigger c[i]] 0 <= i < c.len() ==> c[i] >= pivot,\n        ensures\n            spec_sorted(a.push(pivot) + c),"
  },
  {
    "id": 770,
    "function": "merge_parallel",
    "file": "Chap26/MergeSortMtPer.rs",
    "lines": "176-185",
    "spec_strength": "unknown",
    "snippet": "        fn merge_parallel(left: &ArraySeqMtPerS<N>, right: &ArraySeqMtPerS<N>) -> (merged: ArraySeqMtPerS<N>)\n            requires\n                spec_sorted(Seq::new(left.spec_len(), |i: int| left.spec_index(i))),\n                spec_sorted(Seq::new(right.spec_len(), |i: int| right.spec_index(i))),\n                left.spec_len() + right.spec_len() <= usize::MAX,\n            ensures\n                spec_merge_post(\n                    Seq::new(left.spec_len(), |i: int| left.spec_index(i)),\n                    Seq::new(right.spec_len(), |i: int| right.spec_index(i)),\n                    Seq::new(merged.spec_len(), |i: int| merged.spec_index(i)));"
  },
  {
    "id": 771,
    "function": "merge_sort_parallel",
    "file": "Chap26/MergeSortMtPer.rs",
    "lines": "190-195",
    "spec_strength": "unknown",
    "snippet": "        fn merge_sort_parallel(a: &ArraySeqMtPerS<N>) -> (sorted: ArraySeqMtPerS<N>)\n            requires a.spec_len() <= usize::MAX,\n            ensures\n                spec_sort_post(\n                    Seq::new(a.spec_len(), |i: int| a.spec_index(i)),\n                    Seq::new(sorted.spec_len(), |i: int| sorted.spec_index(i)));"
  },
  {
    "id": 772,
    "function": "binary_search_upper_bound",
    "file": "Chap26/MergeSortMtPer.rs",
    "lines": "204-211",
    "spec_strength": "unknown",
    "snippet": "    fn binary_search_upper_bound(arr: &ArraySeqMtPerS<N>, pivot: N) -> (pos: usize)\n        requires spec_sorted(Seq::new(arr.spec_len(), |i: int| arr.spec_index(i))),\n        ensures\n            pos as int <= arr.spec_len(),\n            forall|j: int| #![trigger arr.spec_index(j)]\n                0 <= j < pos as int ==> arr.spec_index(j) <= pivot,\n            forall|j: int| #![trigger arr.spec_index(j)]\n                pos as int <= j < arr.spec_len() ==> arr.spec_index(j) > pivot,"
  },
  {
    "id": 773,
    "function": "merge_dc",
    "file": "Chap26/MergeSortMtPer.rs",
    "lines": "261-271",
    "spec_strength": "unknown",
    "snippet": "    fn merge_dc(left: &ArraySeqMtPerS<N>, right: &ArraySeqMtPerS<N>) -> (merged: ArraySeqMtPerS<N>)\n        requires\n            spec_sorted(Seq::new(left.spec_len(), |i: int| left.spec_index(i))),\n            spec_sorted(Seq::new(right.spec_len(), |i: int| right.spec_index(i))),\n            left.spec_len() + right.spec_len() <= usize::MAX,\n        ensures\n            spec_merge_post(\n                Seq::new(left.spec_len(), |i: int| left.spec_index(i)),\n                Seq::new(right.spec_len(), |i: int| right.spec_index(i)),\n                Seq::new(merged.spec_len(), |i: int| merged.spec_index(i))),\n        decreases left.spec_len() + right.spec_len(),"
  },
  {
    "id": 774,
    "function": "lemma_push_sorted",
    "file": "Chap26/MergeSortStPer.rs",
    "lines": "82-87",
    "spec_strength": "unknown",
    "snippet": "    pub proof fn lemma_push_sorted(s: Seq<N>, v: N)\n        requires\n            spec_sorted(s),\n            s.len() > 0 ==> s.last() <= v,\n        ensures\n            spec_sorted(s.push(v)),"
  },
  {
    "id": 775,
    "function": "merge",
    "file": "Chap26/MergeSortStPer.rs",
    "lines": "113-122",
    "spec_strength": "unknown",
    "snippet": "        fn merge(left: &ArraySeqStPerS<N>, right: &ArraySeqStPerS<N>) -> (merged: ArraySeqStPerS<N>)\n            requires\n                spec_sorted(Seq::new(left.spec_len(), |i: int| left.spec_index(i))),\n                spec_sorted(Seq::new(right.spec_len(), |i: int| right.spec_index(i))),\n                left.spec_len() + right.spec_len() <= usize::MAX,\n            ensures\n                spec_merge_post(\n                    Seq::new(left.spec_len(), |i: int| left.spec_index(i)),\n                    Seq::new(right.spec_len(), |i: int| right.spec_index(i)),\n                    Seq::new(merged.spec_len(), |i: int| merged.spec_index(i)));"
  },
  {
    "id": 776,
    "function": "merge_sort",
    "file": "Chap26/MergeSortStPer.rs",
    "lines": "127-132",
    "spec_strength": "unknown",
    "snippet": "        fn merge_sort(a: &ArraySeqStPerS<N>) -> (sorted: ArraySeqStPerS<N>)\n            requires a.spec_len() <= usize::MAX,\n            ensures\n                spec_sort_post(\n                    Seq::new(a.spec_len(), |i: int| a.spec_index(i)),\n                    Seq::new(sorted.spec_len(), |i: int| sorted.spec_index(i)));"
  },
  {
    "id": 777,
    "function": "lemma_fold_left_monoid",
    "file": "Chap26/ScanDCMtPer.rs",
    "lines": "71-74",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_fold_left_monoid(s: Seq<N>, x: N, f: spec_fn(N, N) -> N, id: N)\n        requires spec_monoid(f, id),\n        ensures s.fold_left(x, f) == f(x, s.fold_left(id, f)),\n        decreases s.len(),"
  },
  {
    "id": 778,
    "function": "prefix_sums_dc_parallel",
    "file": "Chap26/ScanDCMtPer.rs",
    "lines": "91-98",
    "spec_strength": "unknown",
    "snippet": "        fn prefix_sums_dc_parallel(a: &ArraySeqMtPerS<N>) -> (sums: (ArraySeqMtPerS<N>, N))\n            requires a.spec_len() <= usize::MAX,\n            ensures\n                spec_scan_post(\n                    Seq::new(a.spec_len(), |i: int| a.spec_index(i)),\n                    spec_sum_fn(), 0,\n                    Seq::new(sums.0.spec_len(), |i: int| sums.0.spec_index(i)),\n                    sums.1);"
  },
  {
    "id": 779,
    "function": "prefix_sums_dc_inner",
    "file": "Chap26/ScanDCMtPer.rs",
    "lines": "104-112",
    "spec_strength": "unknown",
    "snippet": "    fn prefix_sums_dc_inner(a: &ArraySeqMtPerS<N>) -> (sums: (ArraySeqMtPerS<N>, N))\n        requires a.spec_len() <= usize::MAX,\n        ensures\n            spec_scan_post(\n                Seq::new(a.spec_len(), |i: int| a.spec_index(i)),\n                spec_sum_fn(), 0,\n                Seq::new(sums.0.spec_len(), |i: int| sums.0.spec_index(i)),\n                sums.1),\n        decreases a.spec_len(),"
  },
  {
    "id": 780,
    "function": "lemma_fold_left_monoid",
    "file": "Chap26/ScanDCStPer.rs",
    "lines": "76-79",
    "spec_strength": "unknown",
    "snippet": "    pub proof fn lemma_fold_left_monoid(s: Seq<N>, x: N, f: spec_fn(N, N) -> N, id: N)\n        requires spec_monoid(f, id),\n        ensures s.fold_left(x, f) == f(x, s.fold_left(id, f)),\n        decreases s.len(),"
  },
  {
    "id": 781,
    "function": "scan_dc",
    "file": "Chap26/ScanDCStPer.rs",
    "lines": "99-110",
    "spec_strength": "unknown",
    "snippet": "        fn scan_dc<F: Fn(&N, &N) -> N>(a: &ArraySeqStPerS<N>, f: &F, Ghost(spec_f): Ghost<spec_fn(N, N) -> N>, id: N) -> (scanned: (ArraySeqStPerS<N>, N))\n            requires\n                a.spec_len() <= usize::MAX,\n                spec_monoid(spec_f, id),\n                forall|x: &N, y: &N| #[trigger] f.requires((x, y)),\n                forall|x: N, y: N, ret: N| f.ensures((&x, &y), ret) ==> ret == spec_f(x, y),\n            ensures\n                spec_scan_post(\n                    Seq::new(a.spec_len(), |i: int| a.spec_index(i)),\n                    spec_f, id,\n                    Seq::new(scanned.0.spec_len(), |i: int| scanned.0.spec_index(i)),\n                    scanned.1);"
  },
  {
    "id": 782,
    "function": "prefix_sums_dc",
    "file": "Chap26/ScanDCStPer.rs",
    "lines": "116-123",
    "spec_strength": "unknown",
    "snippet": "        fn prefix_sums_dc(a: &ArraySeqStPerS<N>) -> (sums: (ArraySeqStPerS<N>, N))\n            requires a.spec_len() <= usize::MAX,\n            ensures\n                spec_scan_post(\n                    Seq::new(a.spec_len(), |i: int| a.spec_index(i)),\n                    spec_sum_fn(), 0,\n                    Seq::new(sums.0.spec_len(), |i: int| sums.0.spec_index(i)),\n                    sums.1);"
  },
  {
    "id": 783,
    "function": "reduce_contract_parallel",
    "file": "Chap27/ReduceContractMtEph.rs",
    "lines": "59-72",
    "spec_strength": "unknown",
    "snippet": "        fn reduce_contract_parallel<F: Fn(&T, &T) -> T + Send + Sync + 'static>(\n            a: &ArraySeqMtEphS<T>,\n            f: Arc<F>,\n            Ghost(spec_f): Ghost<spec_fn(T, T) -> T>,\n            id: T,\n        ) -> (reduced: T)\n            requires\n                a.spec_len() <= usize::MAX,\n                obeys_feq_clone::<T>(),\n                spec_monoid(spec_f, id),\n                forall|x: &T, y: &T| #[trigger] f.requires((x, y)),\n                forall|x: T, y: T, ret: T| f.ensures((&x, &y), ret) ==> ret == spec_f(x, y),\n            ensures\n                reduced == Seq::new(a.spec_len(), |i: int| a.spec_index(i)).fold_left(id, spec_f);"
  },
  {
    "id": 784,
    "function": "contract_parallel",
    "file": "Chap27/ReduceContractMtEph.rs",
    "lines": "84-99",
    "spec_strength": "unknown",
    "snippet": "    pub fn contract_parallel<T: StTInMtT + Clone + 'static, F: Fn(&T, &T) -> T + Send + Sync + 'static>(\n        a: &ArraySeqMtEphS<T>,\n        f: &Arc<F>,\n        Ghost(spec_f): Ghost<spec_fn(T, T) -> T>,\n        half: usize,\n    ) -> (b: ArraySeqMtEphS<T>)\n        requires\n            half == a.spec_len() / 2,\n            a.spec_len() >= 2,\n            half <= usize::MAX,\n            obeys_feq_clone::<T>(),\n            forall|x: &T, y: &T| #[trigger] f.requires((x, y)),\n            forall|x: T, y: T, ret: T| f.ensures((&x, &y), ret) ==> ret == spec_f(x, y),\n        ensures\n            b.spec_len() == half as nat,\n            forall|j: int| #![trigger b.spec_index(j)] 0 <= j < half as int ==> {"
  },
  {
    "id": 785,
    "function": "reduce_contract_verified",
    "file": "Chap27/ReduceContractMtEph.rs",
    "lines": "254-268",
    "spec_strength": "unknown",
    "snippet": "    fn reduce_contract_verified<T: StTInMtT + Clone + 'static, F: Fn(&T, &T) -> T + Send + Sync + 'static>(\n        a: &ArraySeqMtEphS<T>,\n        f: &Arc<F>,\n        Ghost(spec_f): Ghost<spec_fn(T, T) -> T>,\n        id: T,\n    ) -> (reduced: T)\n        requires\n            a.spec_len() <= usize::MAX,\n            obeys_feq_clone::<T>(),\n            spec_monoid(spec_f, id),\n            forall|x: &T, y: &T| #[trigger] f.requires((x, y)),\n            forall|x: T, y: T, ret: T| f.ensures((&x, &y), ret) ==> ret == spec_f(x, y),\n        ensures\n            reduced == Seq::new(a.spec_len(), |i: int| a.spec_index(i)).fold_left(id, spec_f),\n        decreases a.spec_len(),"
  },
  {
    "id": 786,
    "function": "lemma_fold_left_monoid",
    "file": "Chap27/ReduceContractStEph.rs",
    "lines": "40-43",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_fold_left_monoid<T>(s: Seq<T>, x: T, f: spec_fn(T, T) -> T, id: T)\n        requires spec_monoid(f, id),\n        ensures s.fold_left(x, f) == f(x, s.fold_left(id, f)),\n        decreases s.len(),"
  },
  {
    "id": 787,
    "function": "lemma_fold_left_pair",
    "file": "Chap27/ReduceContractStEph.rs",
    "lines": "56-58",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_fold_left_pair<T>(a: T, b: T, f: spec_fn(T, T) -> T, id: T)\n        requires spec_monoid(f, id),\n        ensures seq![a, b].fold_left(id, f) == f(a, b),"
  },
  {
    "id": 788,
    "function": "lemma_fold_left_singleton",
    "file": "Chap27/ReduceContractStEph.rs",
    "lines": "72-74",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_fold_left_singleton<T>(a: T, f: spec_fn(T, T) -> T, id: T)\n        requires spec_monoid(f, id),\n        ensures seq![a].fold_left(id, f) == a,"
  },
  {
    "id": 789,
    "function": "lemma_contraction_even",
    "file": "Chap27/ReduceContractStEph.rs",
    "lines": "84-94",
    "spec_strength": "unknown",
    "snippet": "    pub proof fn lemma_contraction_even<T>(s: Seq<T>, f: spec_fn(T, T) -> T, id: T)\n        requires\n            spec_monoid(f, id),\n            s.len() >= 2,\n            s.len() % 2 == 0,\n        ensures\n            s.fold_left(id, f) == Seq::new(\n                (s.len() / 2) as nat,\n                |i: int| f(s[2 * i], s[2 * i + 1]),\n            ).fold_left(id, f),\n        decreases s.len(),"
  },
  {
    "id": 790,
    "function": "reduce_contract",
    "file": "Chap27/ReduceContractStEph.rs",
    "lines": "164-176",
    "spec_strength": "unknown",
    "snippet": "        fn reduce_contract<F: Fn(&T, &T) -> T>(\n            a: &ArraySeqStEphS<T>,\n            f: &F,\n            Ghost(spec_f): Ghost<spec_fn(T, T) -> T>,\n            id: T,\n        ) -> (reduced: T)\n            requires\n                a.spec_len() <= usize::MAX,\n                spec_monoid(spec_f, id),\n                forall|x: &T, y: &T| #[trigger] f.requires((x, y)),\n                forall|x: T, y: T, ret: T| f.ensures((&x, &y), ret) ==> ret == spec_f(x, y),\n            ensures\n                reduced == Seq::new(a.spec_len(), |i: int| a.spec_index(i)).fold_left(id, spec_f);"
  },
  {
    "id": 791,
    "function": "scan_contract_parallel",
    "file": "Chap27/ScanContractMtEph.rs",
    "lines": "50-66",
    "spec_strength": "unknown",
    "snippet": "        fn scan_contract_parallel<F: Fn(&T, &T) -> T + Send + Sync + 'static>(\n            a: &ArraySeqMtEphS<T>,\n            f: Arc<F>,\n            Ghost(spec_f): Ghost<spec_fn(T, T) -> T>,\n            id: T,\n        ) -> (scanned: ArraySeqMtEphS<T>)\n            requires\n                a.spec_len() <= usize::MAX,\n                obeys_feq_clone::<T>(),\n                spec_monoid(spec_f, id),\n                forall|x: &T, y: &T| #[trigger] f.requires((x, y)),\n                forall|x: T, y: T, ret: T| f.ensures((&x, &y), ret) ==> ret == spec_f(x, y),\n            ensures\n                scanned.spec_len() == a.spec_len(),\n                forall|i: int| #![trigger scanned.spec_index(i)]\n                    0 <= i < a.spec_len() ==>\n                        scanned.spec_index(i) == Seq::new(a.spec_len(), |j: int| a.spec_index(j)).take(i).fold_left(id, spec_f);"
  },
  {
    "id": 792,
    "function": "scan_contract_verified",
    "file": "Chap27/ScanContractMtEph.rs",
    "lines": "75-92",
    "spec_strength": "unknown",
    "snippet": "    fn scan_contract_verified<T: StTInMtT + Clone + 'static, F: Fn(&T, &T) -> T + Send + Sync + 'static>(\n        a: &ArraySeqMtEphS<T>,\n        f: &Arc<F>,\n        Ghost(spec_f): Ghost<spec_fn(T, T) -> T>,\n        id: T,\n    ) -> (scanned: ArraySeqMtEphS<T>)\n        requires\n            a.spec_len() <= usize::MAX,\n            obeys_feq_clone::<T>(),\n            spec_monoid(spec_f, id),\n            forall|x: &T, y: &T| #[trigger] f.requires((x, y)),\n            forall|x: T, y: T, ret: T| f.ensures((&x, &y), ret) ==> ret == spec_f(x, y),\n        ensures\n            scanned.spec_len() == a.spec_len(),\n            forall|i: int| #![trigger scanned.spec_index(i)]\n                0 <= i < a.spec_len() ==>\n                    scanned.spec_index(i) == Seq::new(a.spec_len(), |j: int| a.spec_index(j)).take(i).fold_left(id, spec_f),\n        decreases a.spec_len(),"
  },
  {
    "id": 793,
    "function": "lemma_prefix_contraction",
    "file": "Chap27/ScanContractStEph.rs",
    "lines": "42-50",
    "spec_strength": "unknown",
    "snippet": "    pub proof fn lemma_prefix_contraction<T>(s: Seq<T>, b: Seq<T>, f: spec_fn(T, T) -> T, id: T, k: int)\n        requires\n            spec_monoid(f, id),\n            k >= 1,\n            2 * k <= s.len(),\n            b.len() >= k,\n            forall|i: int| #![trigger b[i]] 0 <= i < b.len() ==> b[i] == f(s[2 * i], s[2 * i + 1]),\n        ensures\n            s.take(2 * k).fold_left(id, f) == b.take(k).fold_left(id, f),"
  },
  {
    "id": 794,
    "function": "scan_contract",
    "file": "Chap27/ScanContractStEph.rs",
    "lines": "68-83",
    "spec_strength": "unknown",
    "snippet": "        fn scan_contract<F: Fn(&T, &T) -> T>(\n            a: &ArraySeqStEphS<T>,\n            f: &F,\n            Ghost(spec_f): Ghost<spec_fn(T, T) -> T>,\n            id: T,\n        ) -> (scanned: ArraySeqStEphS<T>)\n            requires\n                a.spec_len() <= usize::MAX,\n                spec_monoid(spec_f, id),\n                forall|x: &T, y: &T| #[trigger] f.requires((x, y)),\n                forall|x: T, y: T, ret: T| f.ensures((&x, &y), ret) ==> ret == spec_f(x, y),\n            ensures\n                scanned.spec_len() == a.spec_len(),\n                forall|i: int| #![trigger scanned.spec_index(i)]\n                    0 <= i < a.spec_len() ==>\n                        scanned.spec_index(i) == Seq::new(a.spec_len(), |j: int| a.spec_index(j)).take(i).fold_left(id, spec_f);"
  },
  {
    "id": 795,
    "function": "lemma_range_sum_snoc",
    "file": "Chap28/MCSSSpec.rs",
    "lines": "136-143",
    "spec_strength": "unknown",
    "snippet": "    pub proof fn lemma_range_sum_snoc(s: Seq<i32>, lo: int, hi: int)\n        requires\n            0 <= lo,\n            lo < hi,\n            hi <= s.len(),\n        ensures\n            spec_range_sum(s, lo, hi) == spec_range_sum(s, lo, hi - 1) + s[hi - 1] as int,\n        decreases hi - lo,"
  },
  {
    "id": 796,
    "function": "lemma_range_sum_single",
    "file": "Chap28/MCSSSpec.rs",
    "lines": "152-156",
    "spec_strength": "unknown",
    "snippet": "    pub proof fn lemma_range_sum_single(s: Seq<i32>, i: int)\n        requires\n            0 <= i < s.len(),\n        ensures\n            spec_range_sum(s, i, i + 1) == s[i] as int,"
  },
  {
    "id": 797,
    "function": "lemma_range_sum_empty",
    "file": "Chap28/MCSSSpec.rs",
    "lines": "162-164",
    "spec_strength": "unknown",
    "snippet": "    pub proof fn lemma_range_sum_empty(s: Seq<i32>, lo: int, hi: int)\n        requires lo >= hi,\n        ensures spec_range_sum(s, lo, hi) == 0,"
  },
  {
    "id": 798,
    "function": "lemma_range_sum_split",
    "file": "Chap28/MCSSSpec.rs",
    "lines": "169-174",
    "spec_strength": "unknown",
    "snippet": "    pub proof fn lemma_range_sum_split(s: Seq<i32>, lo: int, mid: int, hi: int)\n        requires\n            0 <= lo <= mid <= hi <= s.len(),\n        ensures\n            spec_range_sum(s, lo, hi) == spec_range_sum(s, lo, mid) + spec_range_sum(s, mid, hi),\n        decreases mid - lo,"
  },
  {
    "id": 799,
    "function": "lemma_range_sum_via_prefix",
    "file": "Chap28/MCSSSpec.rs",
    "lines": "183-187",
    "spec_strength": "unknown",
    "snippet": "    pub proof fn lemma_range_sum_via_prefix(s: Seq<i32>, lo: int, hi: int)\n        requires\n            0 <= lo <= hi <= s.len(),\n        ensures\n            spec_range_sum(s, lo, hi) == spec_prefix_sum(s, hi) - spec_prefix_sum(s, lo),"
  },
  {
    "id": 800,
    "function": "lemma_min_prefix_sum_is_min",
    "file": "Chap28/MCSSSpec.rs",
    "lines": "193-198",
    "spec_strength": "unknown",
    "snippet": "    pub proof fn lemma_min_prefix_sum_is_min(s: Seq<i32>, k: int, j: int)\n        requires\n            0 <= j <= k,\n        ensures\n            spec_min_prefix_sum(s, k) <= spec_prefix_sum(s, j),\n        decreases k,"
  },
  {
    "id": 801,
    "function": "lemma_min_prefix_sum_achieved",
    "file": "Chap28/MCSSSpec.rs",
    "lines": "207-212",
    "spec_strength": "unknown",
    "snippet": "    pub proof fn lemma_min_prefix_sum_achieved(s: Seq<i32>, k: int)\n        requires k >= 0,\n        ensures\n            exists|j: int| #![trigger spec_prefix_sum(s, j)]\n                0 <= j <= k && spec_prefix_sum(s, j) == spec_min_prefix_sum(s, k),\n        decreases k,"
  },
  {
    "id": 802,
    "function": "lemma_range_sum_subseq",
    "file": "Chap28/MCSSSpec.rs",
    "lines": "229-237",
    "spec_strength": "unknown",
    "snippet": "    pub proof fn lemma_range_sum_subseq(full: Seq<i32>, sub: Seq<i32>, offset: int, lo: int, hi: int)\n        requires\n            0 <= offset,\n            0 <= lo <= hi <= sub.len(),\n            offset + hi <= full.len(),\n            forall|i: int| #![trigger sub[i]] 0 <= i < sub.len() ==> sub[i] == full[offset + i],\n        ensures\n            spec_range_sum(sub, lo, hi) == spec_range_sum(full, offset + lo, offset + hi),\n        decreases hi - lo,"
  },
  {
    "id": 803,
    "function": "lemma_crossing_decompose",
    "file": "Chap28/MCSSSpec.rs",
    "lines": "248-252",
    "spec_strength": "unknown",
    "snippet": "    pub proof fn lemma_crossing_decompose(s: Seq<i32>, lo: int, mid: int, hi: int)\n        requires\n            0 <= lo < mid < hi <= s.len(),\n        ensures\n            spec_range_sum(s, lo, hi) == spec_range_sum(s, lo, mid) + spec_range_sum(s, mid, hi),"
  },
  {
    "id": 804,
    "function": "lemma_sums_fit_subseq",
    "file": "Chap28/MCSSSpec.rs",
    "lines": "258-265",
    "spec_strength": "unknown",
    "snippet": "    pub proof fn lemma_sums_fit_subseq(full: Seq<i32>, sub: Seq<i32>, offset: int)\n        requires\n            sums_fit_i32(full),\n            0 <= offset,\n            offset + sub.len() <= full.len(),\n            forall|i: int| #![trigger sub[i]] 0 <= i < sub.len() ==> sub[i] == full[offset + i],\n        ensures\n            sums_fit_i32(sub),"
  },
  {
    "id": 805,
    "function": "max_contig_sub_sum_brute",
    "file": "Chap28/MaxContigSubSumBruteStEph.rs",
    "lines": "53-59",
    "spec_strength": "unknown",
    "snippet": "        fn max_contig_sub_sum_brute(a: &ArraySeqStEphS<i32>) -> (mcss: Option<i32>)\n            requires\n                sums_fit_i32(a.seq@),\n            ensures\n                a.seq@.len() == 0 ==> mcss.is_none(),\n                a.seq@.len() > 0 ==> mcss.is_some(),\n                mcss.is_some() ==> is_mcss_of(a.seq@, mcss.unwrap() as int);"
  },
  {
    "id": 806,
    "function": "max_with_neginf",
    "file": "Chap28/MaxContigSubSumBruteStEph.rs",
    "lines": "69-71",
    "spec_strength": "unknown",
    "snippet": "    fn max_with_neginf(a: Option<i32>, b: Option<i32>) -> (max: Option<i32>)\n        ensures\n            max == spec_max_opt_i32(a, b),"
  },
  {
    "id": 807,
    "function": "max_contig_sub_sum_divcon_mt",
    "file": "Chap28/MaxContigSubSumDivConMtEph.rs",
    "lines": "48-55",
    "spec_strength": "unknown",
    "snippet": "        fn max_contig_sub_sum_divcon_mt(a: &ArraySeqMtEphS<i32>) -> (mcss: Option<i32>)\n            requires\n                sums_fit_i32(a.seq@),\n                obeys_feq_clone::<i32>(),\n            ensures\n                a.seq@.len() == 0 ==> mcss.is_none(),\n                a.seq@.len() > 0 ==> mcss.is_some(),\n                mcss.is_some() ==> is_mcss_of(a.seq@, mcss.unwrap() as int);"
  },
  {
    "id": 808,
    "function": "max_with_neginf",
    "file": "Chap28/MaxContigSubSumDivConMtEph.rs",
    "lines": "61-62",
    "spec_strength": "unknown",
    "snippet": "    fn max_with_neginf(a: Option<i32>, b: Option<i32>) -> (max: Option<i32>)\n        ensures max == spec_max_opt_i32(a, b),"
  },
  {
    "id": 809,
    "function": "max_suffix_sum",
    "file": "Chap28/MaxContigSubSumDivConMtEph.rs",
    "lines": "72-74",
    "spec_strength": "unknown",
    "snippet": "    fn max_suffix_sum(a: &ArraySeqMtEphS<i32>) -> (mss: i32)\n        requires a.seq@.len() > 0, sums_fit_i32(a.seq@),\n        ensures is_max_suffix_sum(a.seq@, mss as int),"
  },
  {
    "id": 810,
    "function": "max_prefix_sum",
    "file": "Chap28/MaxContigSubSumDivConMtEph.rs",
    "lines": "122-124",
    "spec_strength": "unknown",
    "snippet": "    fn max_prefix_sum(a: &ArraySeqMtEphS<i32>) -> (mps: i32)\n        requires a.seq@.len() > 0, sums_fit_i32(a.seq@),\n        ensures is_max_prefix_sum(a.seq@, mps as int),"
  },
  {
    "id": 811,
    "function": "max_contig_sub_sum_divcon_opt_mt",
    "file": "Chap28/MaxContigSubSumDivConOptMtEph.rs",
    "lines": "54-61",
    "spec_strength": "unknown",
    "snippet": "        fn max_contig_sub_sum_divcon_opt_mt(a: &ArraySeqMtEphS<i32>) -> (mcss: Option<i32>)\n            requires\n                sums_fit_i32(a.seq@),\n                obeys_feq_clone::<i32>(),\n            ensures\n                a.seq@.len() == 0 ==> mcss.is_none(),\n                a.seq@.len() > 0 ==> mcss.is_some(),\n                mcss.is_some() ==> is_mcss_of(a.seq@, mcss.unwrap() as int);"
  },
  {
    "id": 812,
    "function": "max_with_neginf",
    "file": "Chap28/MaxContigSubSumDivConOptMtEph.rs",
    "lines": "67-68",
    "spec_strength": "unknown",
    "snippet": "    fn max_with_neginf(a: Option<i32>, b: Option<i32>) -> (max: Option<i32>)\n        ensures max == spec_max_opt_i32(a, b),"
  },
  {
    "id": 813,
    "function": "max_contig_sub_sum_aux",
    "file": "Chap28/MaxContigSubSumDivConOptMtEph.rs",
    "lines": "78-86",
    "spec_strength": "unknown",
    "snippet": "    fn max_contig_sub_sum_aux(a: &ArraySeqMtEphS<i32>) -> (mcss: StrengthResult)\n        requires a.seq@.len() > 0, sums_fit_i32(a.seq@), obeys_feq_clone::<i32>(),\n        ensures\n            mcss.0.is_some(),\n            is_mcss_of(a.seq@, mcss.0.unwrap() as int),\n            is_max_prefix_sum(a.seq@, mcss.1 as int),\n            is_max_suffix_sum(a.seq@, mcss.2 as int),\n            mcss.3 as int == spec_range_sum(a.seq@, 0, a.seq@.len() as int),\n        decreases a.seq@.len(),"
  },
  {
    "id": 814,
    "function": "lemma_strength_combine",
    "file": "Chap28/MaxContigSubSumDivConOptStEph.rs",
    "lines": "61-110",
    "spec_strength": "unknown",
    "snippet": "    pub proof fn lemma_strength_combine(\n        s: Seq<i32>,\n        left: Seq<i32>,\n        right: Seq<i32>,\n        mid: int,\n        m_left: int,\n        p_left: int,\n        s_left: int,\n        t_left: int,\n        m_right: int,\n        p_right: int,\n        s_right: int,\n        t_right: int,\n    )\n        requires\n            s.len() > 1,\n            0 < mid < s.len() as int,\n            left.len() == mid,\n            right.len() == s.len() - mid,\n            forall|i: int| #![trigger left[i]] 0 <= i < left.len() ==> left[i] == s[i],\n            forall|i: int| #![trigger right[i]] 0 <= i < right.len() ==> right[i] == s[mid + i],\n            is_mcss_of(left, m_left),\n            is_max_prefix_sum(left, p_left),\n            is_max_suffix_sum(left, s_left),\n            t_left == spec_range_sum(left, 0, left.len() as int),\n            is_mcss_of(right, m_right),\n            is_max_prefix_sum(right, p_right),\n            is_max_suffix_sum(right, s_right),\n            t_right == spec_range_sum(right, 0, right.len() as int),\n        ensures\n            // mcss of whole\n            ({\n                let crossing = s_left + p_right;\n                let m = if m_left >= m_right && m_left >= crossing { m_left }\n                        else if m_right >= crossing { m_right }\n                        else { crossing };\n                is_mcss_of(s, m)\n            }),\n            // max prefix of whole\n            ({\n                let p = if p_left >= t_left + p_right { p_left } else { t_left + p_right };\n                is_max_prefix_sum(s, p)\n            }),\n            // max suffix of whole\n            ({\n                let ss = if s_right >= s_left + t_right { s_right } else { s_left + t_right };\n                is_max_suffix_sum(s, ss)\n            }),\n            // total\n            t_left + t_right == spec_range_sum(s, 0, s.len() as int),"
  },
  {
    "id": 815,
    "function": "max_contig_sub_sum_divcon_opt",
    "file": "Chap28/MaxContigSubSumDivConOptStEph.rs",
    "lines": "255-261",
    "spec_strength": "unknown",
    "snippet": "        fn max_contig_sub_sum_divcon_opt(a: &ArraySeqStEphS<i32>) -> (mcss: Option<i32>)\n            requires\n                sums_fit_i32(a.seq@),\n            ensures\n                a.seq@.len() == 0 ==> mcss.is_none(),\n                a.seq@.len() > 0 ==> mcss.is_some(),\n                mcss.is_some() ==> is_mcss_of(a.seq@, mcss.unwrap() as int);"
  },
  {
    "id": 816,
    "function": "max_with_neginf",
    "file": "Chap28/MaxContigSubSumDivConOptStEph.rs",
    "lines": "269-270",
    "spec_strength": "unknown",
    "snippet": "    fn max_with_neginf(a: Option<i32>, b: Option<i32>) -> (max: Option<i32>)\n        ensures max == spec_max_opt_i32(a, b),"
  },
  {
    "id": 817,
    "function": "max_contig_sub_sum_aux",
    "file": "Chap28/MaxContigSubSumDivConOptStEph.rs",
    "lines": "283-293",
    "spec_strength": "unknown",
    "snippet": "    fn max_contig_sub_sum_aux(a: &ArraySeqStEphS<i32>) -> (mcss: StrengthResult)\n        requires\n            a.seq@.len() > 0,\n            sums_fit_i32(a.seq@),\n        ensures\n            mcss.0.is_some(),\n            is_mcss_of(a.seq@, mcss.0.unwrap() as int),\n            is_max_prefix_sum(a.seq@, mcss.1 as int),\n            is_max_suffix_sum(a.seq@, mcss.2 as int),\n            mcss.3 as int == spec_range_sum(a.seq@, 0, a.seq@.len() as int),\n        decreases a.seq@.len(),"
  },
  {
    "id": 818,
    "function": "lemma_divcon_combine",
    "file": "Chap28/MaxContigSubSumDivConStEph.rs",
    "lines": "53-80",
    "spec_strength": "unknown",
    "snippet": "    pub proof fn lemma_divcon_combine(\n        s: Seq<i32>,\n        left: Seq<i32>,\n        right: Seq<i32>,\n        mid: int,\n        m_left: int,\n        m_right: int,\n        s_left: int,\n        p_right: int,\n    )\n        requires\n            s.len() > 1,\n            0 < mid < s.len() as int,\n            left.len() == mid,\n            right.len() == s.len() - mid,\n            forall|i: int| #![trigger left[i]] 0 <= i < left.len() ==> left[i] == s[i],\n            forall|i: int| #![trigger right[i]] 0 <= i < right.len() ==> right[i] == s[mid + i],\n            is_mcss_of(left, m_left),\n            is_mcss_of(right, m_right),\n            is_max_suffix_sum(left, s_left),\n            is_max_prefix_sum(right, p_right),\n        ensures\n            is_mcss_of(s, ({\n                let crossing = s_left + p_right;\n                if m_left >= m_right && m_left >= crossing { m_left }\n                else if m_right >= crossing { m_right }\n                else { crossing }\n            })),"
  },
  {
    "id": 819,
    "function": "max_contig_sub_sum_divcon",
    "file": "Chap28/MaxContigSubSumDivConStEph.rs",
    "lines": "146-152",
    "spec_strength": "unknown",
    "snippet": "        fn max_contig_sub_sum_divcon(a: &ArraySeqStEphS<i32>) -> (mcss: Option<i32>)\n            requires\n                sums_fit_i32(a.seq@),\n            ensures\n                a.seq@.len() == 0 ==> mcss.is_none(),\n                a.seq@.len() > 0 ==> mcss.is_some(),\n                mcss.is_some() ==> is_mcss_of(a.seq@, mcss.unwrap() as int);"
  },
  {
    "id": 820,
    "function": "max_with_neginf",
    "file": "Chap28/MaxContigSubSumDivConStEph.rs",
    "lines": "160-161",
    "spec_strength": "unknown",
    "snippet": "    fn max_with_neginf(a: Option<i32>, b: Option<i32>) -> (max: Option<i32>)\n        ensures max == spec_max_opt_i32(a, b),"
  },
  {
    "id": 821,
    "function": "max_suffix_sum",
    "file": "Chap28/MaxContigSubSumDivConStEph.rs",
    "lines": "176-181",
    "spec_strength": "unknown",
    "snippet": "    fn max_suffix_sum(a: &ArraySeqStEphS<i32>) -> (mss: i32)\n        requires\n            a.seq@.len() > 0,\n            sums_fit_i32(a.seq@),\n        ensures\n            is_max_suffix_sum(a.seq@, mss as int),"
  },
  {
    "id": 822,
    "function": "max_prefix_sum",
    "file": "Chap28/MaxContigSubSumDivConStEph.rs",
    "lines": "252-257",
    "spec_strength": "unknown",
    "snippet": "    fn max_prefix_sum(a: &ArraySeqStEphS<i32>) -> (mps: i32)\n        requires\n            a.seq@.len() > 0,\n            sums_fit_i32(a.seq@),\n        ensures\n            is_max_prefix_sum(a.seq@, mps as int),"
  },
  {
    "id": 823,
    "function": "lemma_max_ending_at_is_max",
    "file": "Chap28/MaxContigSubSumIterStEph.rs",
    "lines": "66-72",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_max_ending_at_is_max(s: Seq<i32>, j: int, lo: int)\n        requires\n            0 <= lo <= j,\n            j < s.len(),\n        ensures\n            spec_range_sum(s, lo, j + 1) <= spec_max_ending_at(s, j),\n        decreases j,"
  },
  {
    "id": 824,
    "function": "lemma_max_ending_at_achieved",
    "file": "Chap28/MaxContigSubSumIterStEph.rs",
    "lines": "89-96",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_max_ending_at_achieved(s: Seq<i32>, j: int)\n        requires\n            0 <= j < s.len(),\n        ensures\n            exists|lo: int|\n                #![trigger spec_range_sum(s, lo, j + 1)]\n                0 <= lo <= j && spec_range_sum(s, lo, j + 1) == spec_max_ending_at(s, j),\n        decreases j,"
  },
  {
    "id": 825,
    "function": "max_contig_sub_sum_iter",
    "file": "Chap28/MaxContigSubSumIterStEph.rs",
    "lines": "125-131",
    "spec_strength": "unknown",
    "snippet": "        fn max_contig_sub_sum_iter(a: &ArraySeqStEphS<i32>) -> (mcss: Option<i32>)\n            requires\n                sums_fit_i32(a.seq@),\n            ensures\n                a.seq@.len() == 0 ==> mcss.is_none(),\n                a.seq@.len() > 0 ==> mcss.is_some(),\n                mcss.is_some() ==> is_mcss_of(a.seq@, mcss.unwrap() as int);"
  },
  {
    "id": 826,
    "function": "max_with_neginf",
    "file": "Chap28/MaxContigSubSumIterStEph.rs",
    "lines": "139-140",
    "spec_strength": "unknown",
    "snippet": "    fn max_with_neginf(a: Option<i32>, b: Option<i32>) -> (max: Option<i32>)\n        ensures max == spec_max_opt_i32(a, b),"
  },
  {
    "id": 827,
    "function": "max_contig_sub_sum_opt_mt",
    "file": "Chap28/MaxContigSubSumOptMtEph.rs",
    "lines": "22-29",
    "spec_strength": "unknown",
    "snippet": "        fn max_contig_sub_sum_opt_mt(a: &ArraySeqMtEphS<i32>) -> (mcss: Option<i32>)\n            requires\n                sums_fit_i32(a.seq@),\n                a.seq@.len() < usize::MAX,\n            ensures\n                a.seq@.len() == 0 ==> mcss.is_none(),\n                a.seq@.len() > 0 ==> mcss.is_some(),\n                mcss.is_some() ==> is_mcss_of(a.seq@, mcss.unwrap() as int);"
  },
  {
    "id": 828,
    "function": "lemma_prefix_opt_is_mcss",
    "file": "Chap28/MaxContigSubSumOptStEph.rs",
    "lines": "22-38",
    "spec_strength": "unknown",
    "snippet": "    pub proof fn lemma_prefix_opt_is_mcss(s: Seq<i32>, m: int, n: int)\n        requires\n            n == s.len(),\n            n > 0,\n            sums_fit_i32(s),\n            // m is achieved by some hi\n            exists|hi: int|\n                #![trigger spec_prefix_sum(s, hi)]\n                1 <= hi <= n &&\n                m == spec_prefix_sum(s, hi) - spec_min_prefix_sum(s, hi - 1),\n            // m is maximal over all hi\n            forall|hi: int|\n                #![trigger spec_prefix_sum(s, hi)]\n                1 <= hi <= n ==>\n                m >= spec_prefix_sum(s, hi) - spec_min_prefix_sum(s, hi - 1),\n        ensures\n            is_mcss_of(s, m),"
  },
  {
    "id": 829,
    "function": "max_contig_sub_sum_opt",
    "file": "Chap28/MaxContigSubSumOptStEph.rs",
    "lines": "71-78",
    "spec_strength": "unknown",
    "snippet": "        fn max_contig_sub_sum_opt(a: &ArraySeqStEphS<i32>) -> (mcss: Option<i32>)\n            requires\n                sums_fit_i32(a.seq@),\n                a.seq@.len() < usize::MAX,\n            ensures\n                a.seq@.len() == 0 ==> mcss.is_none(),\n                a.seq@.len() > 0 ==> mcss.is_some(),\n                mcss.is_some() ==> is_mcss_of(a.seq@, mcss.unwrap() as int);"
  },
  {
    "id": 830,
    "function": "max_contig_sub_sum_reduced_mcsse",
    "file": "Chap28/MaxContigSubSumReducedMcsseStEph.rs",
    "lines": "52-58",
    "spec_strength": "unknown",
    "snippet": "        fn max_contig_sub_sum_reduced_mcsse(a: &ArraySeqStEphS<i32>) -> (mcss: Option<i32>)\n            requires\n                sums_fit_i32(a.seq@),\n            ensures\n                a.seq@.len() == 0 ==> mcss.is_none(),\n                a.seq@.len() > 0 ==> mcss.is_some(),\n                mcss.is_some() ==> is_mcss_of(a.seq@, mcss.unwrap() as int);"
  },
  {
    "id": 831,
    "function": "max_with_neginf",
    "file": "Chap28/MaxContigSubSumReducedMcsseStEph.rs",
    "lines": "68-69",
    "spec_strength": "unknown",
    "snippet": "    fn max_with_neginf(a: Option<i32>, b: Option<i32>) -> (max: Option<i32>)\n        ensures max == spec_max_opt_i32(a, b),"
  },
  {
    "id": 832,
    "function": "max_contig_sub_sum_reduced",
    "file": "Chap28/MaxContigSubSumReducedStEph.rs",
    "lines": "49-55",
    "spec_strength": "unknown",
    "snippet": "        fn max_contig_sub_sum_reduced(a: &ArraySeqStEphS<i32>) -> (mcss: Option<i32>)\n            requires\n                sums_fit_i32(a.seq@),\n            ensures\n                a.seq@.len() == 0 ==> mcss.is_none(),\n                a.seq@.len() > 0 ==> mcss.is_some(),\n                mcss.is_some() ==> is_mcss_of(a.seq@, mcss.unwrap() as int);"
  },
  {
    "id": 833,
    "function": "max_with_neginf",
    "file": "Chap28/MaxContigSubSumReducedStEph.rs",
    "lines": "65-66",
    "spec_strength": "unknown",
    "snippet": "    fn max_with_neginf(a: Option<i32>, b: Option<i32>) -> (max: Option<i32>)\n        ensures max == spec_max_opt_i32(a, b),"
  },
  {
    "id": 834,
    "function": "select",
    "file": "Chap35/OrderStatSelectMtEph.rs",
    "lines": "49-54",
    "spec_strength": "unknown",
    "snippet": "        fn select(a: &ArraySeqMtEphS<T>, k: usize) -> (result: Option<T>)\n            requires a.spec_len() <= usize::MAX,\n            ensures\n                k >= a.spec_len() ==> result is None,\n                k < a.spec_len() ==> result == Some(spec_kth::<T>(\n                    Seq::new(a.spec_len(), |i: int| a.spec_index(i)), k as int));"
  },
  {
    "id": 835,
    "function": "parallel_three_way_partition",
    "file": "Chap35/OrderStatSelectMtEph.rs",
    "lines": "62-84",
    "spec_strength": "hole",
    "snippet": "    fn parallel_three_way_partition<T: TotalOrder + Copy + Send + Sync + Eq + 'static>(\n        a: &ArraySeqMtEphS<T>, pivot: T, pivot_idx: usize, n: usize,\n    ) -> (result: (Vec<T>, usize, Vec<T>))\n        requires\n            n == a.spec_len(),\n            n <= usize::MAX,\n            n >= 2,\n            pivot_idx < n,\n            pivot == a.spec_index(pivot_idx as int),\n        ensures\n            forall|j: int| 0 <= j < result.0@.len() ==>\n                (#[trigger] T::le(result.0@[j], pivot)) && result.0@[j] != pivot,\n            forall|j: int| 0 <= j < result.2@.len() ==>\n                (#[trigger] T::le(pivot, result.2@[j])) && result.2@[j] != pivot,\n            result.0@.len() + result.1 + result.2@.len() == n,\n            result.0@.len() + result.2@.len() < n,\n            ({\n                let s = Seq::new(n as nat, |i: int| a.spec_index(i));\n                let eq_seq = Seq::new(result.1 as nat, |i: int| pivot);\n                s.to_multiset() =~=\n                    result.0@.to_multiset().add(result.2@.to_multiset()).add(eq_seq.to_multiset())\n            }),\n            result.1 >= 1,"
  },
  {
    "id": 836,
    "function": "select_inner",
    "file": "Chap35/OrderStatSelectMtEph.rs",
    "lines": "125-134",
    "spec_strength": "unknown",
    "snippet": "    fn select_inner<T: TotalOrder + Copy + Send + Sync + Eq + 'static>(\n        a: &ArraySeqMtEphS<T>, k: usize,\n    ) -> (result: Option<T>)\n        requires\n            a.spec_len() <= usize::MAX,\n            0 <= k < a.spec_len(),\n        ensures\n            result == Some(spec_kth::<T>(\n                Seq::new(a.spec_len(), |i: int| a.spec_index(i)), k as int)),\n        decreases a.spec_len(),"
  },
  {
    "id": 837,
    "function": "select",
    "file": "Chap35/OrderStatSelectMtPer.rs",
    "lines": "49-54",
    "spec_strength": "unknown",
    "snippet": "        fn select(a: &ArraySeqMtPerS<T>, k: usize) -> (result: Option<T>)\n            requires a.spec_len() <= usize::MAX,\n            ensures\n                k >= a.spec_len() ==> result is None,\n                k < a.spec_len() ==> result == Some(spec_kth::<T>(\n                    Seq::new(a.spec_len(), |i: int| a.spec_index(i)), k as int));"
  },
  {
    "id": 838,
    "function": "parallel_three_way_partition",
    "file": "Chap35/OrderStatSelectMtPer.rs",
    "lines": "60-82",
    "spec_strength": "hole",
    "snippet": "    fn parallel_three_way_partition<T: TotalOrder + Copy + Send + Sync + Eq + 'static>(\n        a: &ArraySeqMtPerS<T>, pivot: T, pivot_idx: usize, n: usize,\n    ) -> (result: (Vec<T>, usize, Vec<T>))\n        requires\n            n == a.spec_len(),\n            n <= usize::MAX,\n            n >= 2,\n            pivot_idx < n,\n            pivot == a.spec_index(pivot_idx as int),\n        ensures\n            forall|j: int| 0 <= j < result.0@.len() ==>\n                (#[trigger] T::le(result.0@[j], pivot)) && result.0@[j] != pivot,\n            forall|j: int| 0 <= j < result.2@.len() ==>\n                (#[trigger] T::le(pivot, result.2@[j])) && result.2@[j] != pivot,\n            result.0@.len() + result.1 + result.2@.len() == n,\n            result.0@.len() + result.2@.len() < n,\n            ({\n                let s = Seq::new(n as nat, |i: int| a.spec_index(i));\n                let eq_seq = Seq::new(result.1 as nat, |i: int| pivot);\n                s.to_multiset() =~=\n                    result.0@.to_multiset().add(result.2@.to_multiset()).add(eq_seq.to_multiset())\n            }),\n            result.1 >= 1,"
  },
  {
    "id": 839,
    "function": "select_inner",
    "file": "Chap35/OrderStatSelectMtPer.rs",
    "lines": "123-132",
    "spec_strength": "unknown",
    "snippet": "    fn select_inner<T: TotalOrder + Copy + Send + Sync + Eq + 'static>(\n        a: &ArraySeqMtPerS<T>, k: usize,\n    ) -> (result: Option<T>)\n        requires\n            a.spec_len() <= usize::MAX,\n            0 <= k < a.spec_len(),\n        ensures\n            result == Some(spec_kth::<T>(\n                Seq::new(a.spec_len(), |i: int| a.spec_index(i)), k as int)),\n        decreases a.spec_len(),"
  },
  {
    "id": 840,
    "function": "lemma_total_ordering",
    "file": "Chap35/OrderStatSelectStEph.rs",
    "lines": "57-58",
    "spec_strength": "unknown",
    "snippet": "    pub proof fn lemma_total_ordering<T: TotalOrder>()\n        ensures total_ordering(spec_leq::<T>())"
  },
  {
    "id": 841,
    "function": "select",
    "file": "Chap35/OrderStatSelectStEph.rs",
    "lines": "87-92",
    "spec_strength": "unknown",
    "snippet": "        fn select(a: &ArraySeqStEphS<T>, k: usize) -> (result: Option<T>)\n            requires a.spec_len() <= usize::MAX,\n            ensures\n                k >= a.spec_len() ==> result is None,\n                k < a.spec_len() ==> result == Some(spec_kth::<T>(\n                    Seq::new(a.spec_len(), |i: int| a.spec_index(i)), k as int));"
  },
  {
    "id": 842,
    "function": "select_inner",
    "file": "Chap35/OrderStatSelectStEph.rs",
    "lines": "110-117",
    "spec_strength": "unknown",
    "snippet": "    fn select_inner<T: TotalOrder + Copy>(a: &ArraySeqStEphS<T>, k: usize) -> (result: Option<T>)\n        requires\n            a.spec_len() <= usize::MAX,\n            0 <= k < a.spec_len(),\n        ensures\n            result == Some(spec_kth::<T>(\n                Seq::new(a.spec_len(), |i: int| a.spec_index(i)), k as int)),\n        decreases a.spec_len(),"
  },
  {
    "id": 843,
    "function": "select",
    "file": "Chap35/OrderStatSelectStPer.rs",
    "lines": "46-51",
    "spec_strength": "unknown",
    "snippet": "        fn select(a: &ArraySeqStPerS<T>, k: usize) -> (result: Option<T>)\n            requires a.spec_len() <= usize::MAX,\n            ensures\n                k >= a.spec_len() ==> result is None,\n                k < a.spec_len() ==> result == Some(spec_kth::<T>(\n                    Seq::new(a.spec_len(), |i: int| a.spec_index(i)), k as int));"
  },
  {
    "id": 844,
    "function": "select_inner",
    "file": "Chap35/OrderStatSelectStPer.rs",
    "lines": "69-76",
    "spec_strength": "unknown",
    "snippet": "    fn select_inner<T: TotalOrder + Copy>(a: &ArraySeqStPerS<T>, k: usize) -> (result: Option<T>)\n        requires\n            a.spec_len() <= usize::MAX,\n            0 <= k < a.spec_len(),\n        ensures\n            result == Some(spec_kth::<T>(\n                Seq::new(a.spec_len(), |i: int| a.spec_index(i)), k as int)),\n        decreases a.spec_len(),"
  },
  {
    "id": 845,
    "function": "sort_vec",
    "file": "Chap36/QuickSortMtEph.rs",
    "lines": "46-49",
    "spec_strength": "unknown",
    "snippet": "    fn sort_vec<T: TotalOrder + Copy + Send + 'static>(a: &ArraySeqMtEphS<T>) -> (result: Vec<T>)\n        requires a.spec_len() <= usize::MAX,\n        ensures result@ =~= a.seq@.sort_by(spec_leq::<T>())\n        decreases a.spec_len(),"
  },
  {
    "id": 846,
    "function": "median_of_three",
    "file": "Chap36/QuickSortMtEph.rs",
    "lines": "371-372",
    "spec_strength": "unknown",
    "snippet": "    fn median_of_three<T: TotalOrder + Copy>(a: T, b: T, c: T) -> (result: T)\n        ensures result == a || result == b || result == c,"
  },
  {
    "id": 847,
    "function": "median3_pivot_idx",
    "file": "Chap36/QuickSortMtEph.rs",
    "lines": "400-402",
    "spec_strength": "unknown",
    "snippet": "    fn median3_pivot_idx<T: TotalOrder + Copy>(a: &ArraySeqMtEphS<T>, n: usize) -> (idx: usize)\n        requires n >= 2, n == a.spec_len(),\n        ensures idx < n, idx == 0 || idx == n / 2 || idx == n - 1,"
  },
  {
    "id": 848,
    "function": "sort_vec_random",
    "file": "Chap36/QuickSortMtEph.rs",
    "lines": "417-420",
    "spec_strength": "unknown",
    "snippet": "    fn sort_vec_random<T: TotalOrder + Copy + Send + 'static>(a: &ArraySeqMtEphS<T>) -> (result: Vec<T>)\n        requires a.spec_len() <= usize::MAX,\n        ensures result@ =~= a.seq@.sort_by(spec_leq::<T>())\n        decreases a.spec_len(),"
  },
  {
    "id": 849,
    "function": "sort_vec_median3",
    "file": "Chap36/QuickSortMtEph.rs",
    "lines": "430-433",
    "spec_strength": "unknown",
    "snippet": "    fn sort_vec_median3<T: TotalOrder + Copy + Send + 'static>(a: &ArraySeqMtEphS<T>) -> (result: Vec<T>)\n        requires a.spec_len() <= usize::MAX,\n        ensures result@ =~= a.seq@.sort_by(spec_leq::<T>())\n        decreases a.spec_len(),"
  },
  {
    "id": 850,
    "function": "sort_vec_with_idx",
    "file": "Chap36/QuickSortMtEph.rs",
    "lines": "445-451",
    "spec_strength": "unknown",
    "snippet": "    fn sort_vec_with_idx<T: TotalOrder + Copy + Send + 'static>(a: &ArraySeqMtEphS<T>, pivot_idx: usize) -> (result: Vec<T>)\n        requires\n            a.spec_len() <= usize::MAX,\n            a.spec_len() >= 2,\n            pivot_idx < a.spec_len(),\n        ensures result@ =~= a.seq@.sort_by(spec_leq::<T>())\n        decreases a.spec_len(),"
  },
  {
    "id": 851,
    "function": "quick_sort_first",
    "file": "Chap36/QuickSortMtEph.rs",
    "lines": "737-739",
    "spec_strength": "unknown",
    "snippet": "    pub fn quick_sort_first<T: TotalOrder + Copy + Send + 'static>(a: &mut ArraySeqMtEphS<T>)\n        requires old(a).spec_len() <= usize::MAX,\n        ensures a.seq@ =~= old(a).seq@.sort_by(spec_leq::<T>())"
  },
  {
    "id": 852,
    "function": "quick_sort_median3",
    "file": "Chap36/QuickSortMtEph.rs",
    "lines": "746-748",
    "spec_strength": "unknown",
    "snippet": "    pub fn quick_sort_median3<T: TotalOrder + Copy + Send + 'static>(a: &mut ArraySeqMtEphS<T>)\n        requires old(a).spec_len() <= usize::MAX,\n        ensures a.seq@ =~= old(a).seq@.sort_by(spec_leq::<T>())"
  },
  {
    "id": 853,
    "function": "quick_sort_random",
    "file": "Chap36/QuickSortMtEph.rs",
    "lines": "755-757",
    "spec_strength": "unknown",
    "snippet": "    pub fn quick_sort_random<T: TotalOrder + Copy + Send + 'static>(a: &mut ArraySeqMtEphS<T>)\n        requires old(a).spec_len() <= usize::MAX,\n        ensures a.seq@ =~= old(a).seq@.sort_by(spec_leq::<T>())"
  },
  {
    "id": 854,
    "function": "pivot_mt_first",
    "file": "Chap36/QuickSortMtEphSlice.rs",
    "lines": "20",
    "spec_strength": "",
    "snippet": "        fn pivot_mt_first(&self, lo: usize, hi: usize)   -> T;"
  },
  {
    "id": 855,
    "function": "pivot_mt_median3",
    "file": "Chap36/QuickSortMtEphSlice.rs",
    "lines": "23",
    "spec_strength": "",
    "snippet": "        fn pivot_mt_median3(&self, lo: usize, hi: usize) -> T;"
  },
  {
    "id": 856,
    "function": "pivot_mt_random",
    "file": "Chap36/QuickSortMtEphSlice.rs",
    "lines": "26",
    "spec_strength": "",
    "snippet": "        fn pivot_mt_random(&self, lo: usize, hi: usize)  -> T;"
  },
  {
    "id": 857,
    "function": "quick_sort_mt_first",
    "file": "Chap36/QuickSortMtEphSlice.rs",
    "lines": "29",
    "spec_strength": "",
    "snippet": "        fn quick_sort_mt_first(&self);"
  },
  {
    "id": 858,
    "function": "quick_sort_mt_median3",
    "file": "Chap36/QuickSortMtEphSlice.rs",
    "lines": "32",
    "spec_strength": "",
    "snippet": "        fn quick_sort_mt_median3(&self);"
  },
  {
    "id": 859,
    "function": "quick_sort_mt_random",
    "file": "Chap36/QuickSortMtEphSlice.rs",
    "lines": "35",
    "spec_strength": "",
    "snippet": "        fn quick_sort_mt_random(&self);"
  },
  {
    "id": 860,
    "function": "sort_vec",
    "file": "Chap36/QuickSortStEph.rs",
    "lines": "44-47",
    "spec_strength": "unknown",
    "snippet": "    fn sort_vec<T: TotalOrder + Copy>(a: &ArraySeqStEphS<T>) -> (result: Vec<T>)\n        requires a.spec_len() <= usize::MAX,\n        ensures result@ =~= a.seq@.sort_by(spec_leq::<T>())\n        decreases a.spec_len(),"
  },
  {
    "id": 861,
    "function": "quick_sort_first",
    "file": "Chap36/QuickSortStEph.rs",
    "lines": "367-369",
    "spec_strength": "unknown",
    "snippet": "    pub fn quick_sort_first<T: TotalOrder + Copy>(a: &mut ArraySeqStEphS<T>)\n        requires old(a).spec_len() <= usize::MAX,\n        ensures a.seq@ =~= old(a).seq@.sort_by(spec_leq::<T>())"
  },
  {
    "id": 862,
    "function": "median_of_three",
    "file": "Chap36/QuickSortStEph.rs",
    "lines": "388-389",
    "spec_strength": "unknown",
    "snippet": "    fn median_of_three<T: TotalOrder + Copy>(a: T, b: T, c: T) -> (result: T)\n        ensures result == a || result == b || result == c,"
  },
  {
    "id": 863,
    "function": "median3_pivot_idx",
    "file": "Chap36/QuickSortStEph.rs",
    "lines": "419-421",
    "spec_strength": "unknown",
    "snippet": "    fn median3_pivot_idx<T: TotalOrder + Copy>(a: &ArraySeqStEphS<T>, n: usize) -> (idx: usize)\n        requires n >= 2, n == a.spec_len(),\n        ensures idx < n, idx == 0 || idx == n / 2 || idx == n - 1,"
  },
  {
    "id": 864,
    "function": "sort_vec_random",
    "file": "Chap36/QuickSortStEph.rs",
    "lines": "436-439",
    "spec_strength": "unknown",
    "snippet": "    fn sort_vec_random<T: TotalOrder + Copy>(a: &ArraySeqStEphS<T>) -> (result: Vec<T>)\n        requires a.spec_len() <= usize::MAX,\n        ensures result@ =~= a.seq@.sort_by(spec_leq::<T>())\n        decreases a.spec_len(),"
  },
  {
    "id": 865,
    "function": "sort_vec_median3",
    "file": "Chap36/QuickSortStEph.rs",
    "lines": "449-452",
    "spec_strength": "unknown",
    "snippet": "    fn sort_vec_median3<T: TotalOrder + Copy>(a: &ArraySeqStEphS<T>) -> (result: Vec<T>)\n        requires a.spec_len() <= usize::MAX,\n        ensures result@ =~= a.seq@.sort_by(spec_leq::<T>())\n        decreases a.spec_len(),"
  },
  {
    "id": 866,
    "function": "sort_vec_with_idx",
    "file": "Chap36/QuickSortStEph.rs",
    "lines": "464-470",
    "spec_strength": "unknown",
    "snippet": "    fn sort_vec_with_idx<T: TotalOrder + Copy>(a: &ArraySeqStEphS<T>, pivot_idx: usize) -> (result: Vec<T>)\n        requires\n            a.spec_len() <= usize::MAX,\n            a.spec_len() >= 2,\n            pivot_idx < a.spec_len(),\n        ensures result@ =~= a.seq@.sort_by(spec_leq::<T>())\n        decreases a.spec_len(),"
  },
  {
    "id": 867,
    "function": "quick_sort_median3",
    "file": "Chap36/QuickSortStEph.rs",
    "lines": "735-737",
    "spec_strength": "unknown",
    "snippet": "    pub fn quick_sort_median3<T: TotalOrder + Copy>(a: &mut ArraySeqStEphS<T>)\n        requires old(a).spec_len() <= usize::MAX,\n        ensures a.seq@ =~= old(a).seq@.sort_by(spec_leq::<T>())"
  },
  {
    "id": 868,
    "function": "quick_sort_random",
    "file": "Chap36/QuickSortStEph.rs",
    "lines": "744-746",
    "spec_strength": "unknown",
    "snippet": "    pub fn quick_sort_random<T: TotalOrder + Copy>(a: &mut ArraySeqStEphS<T>)\n        requires old(a).spec_len() <= usize::MAX,\n        ensures a.seq@ =~= old(a).seq@.sort_by(spec_leq::<T>())"
  },
  {
    "id": 869,
    "function": "lemma_size_eq_inorder_len",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "125-128",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_size_eq_inorder_len<T: StT>(link: &Link<T>)\n        requires spec_wf(*link),\n        ensures spec_cached_size(link) == spec_inorder(*link).len(),\n        decreases *link,"
  },
  {
    "id": 870,
    "function": "empty",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "145-146",
    "spec_strength": "unknown",
    "snippet": "        fn empty() -> (result: Self)\n            ensures result.spec_seq() =~= Seq::<T::V>::empty(), result.spec_well_formed();"
  },
  {
    "id": 871,
    "function": "new",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "148-149",
    "spec_strength": "unknown",
    "snippet": "        fn new() -> (result: Self)\n            ensures result.spec_seq() =~= Seq::<T::V>::empty(), result.spec_well_formed();"
  },
  {
    "id": 872,
    "function": "length",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "151-153",
    "spec_strength": "unknown",
    "snippet": "        fn length(&self) -> (result: N)\n            requires self.spec_well_formed(),\n            ensures result as nat == self.spec_seq().len();"
  },
  {
    "id": 873,
    "function": "nth",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "155-157",
    "spec_strength": "unknown",
    "snippet": "        fn nth(&self, index: N) -> (result: &T)\n            requires self.spec_well_formed(), (index as int) < self.spec_seq().len(),\n            ensures result@ == self.spec_seq()[index as int];"
  },
  {
    "id": 874,
    "function": "set",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "159-160",
    "spec_strength": "unknown",
    "snippet": "        fn set(&mut self, index: N, item: T) -> (result: Result<(), &'static str>)\n            requires old(self).spec_well_formed(), (index as int) < old(self).spec_seq().len();"
  },
  {
    "id": 875,
    "function": "singleton",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "162-163",
    "spec_strength": "hole",
    "snippet": "        fn singleton(item: T) -> (result: Self)\n            ensures result.spec_seq().len() == 1, result.spec_well_formed();"
  },
  {
    "id": 876,
    "function": "isEmpty",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "165-167",
    "spec_strength": "unknown",
    "snippet": "        fn isEmpty(&self) -> (result: B)\n            requires self.spec_well_formed(),\n            ensures result == (self.spec_seq().len() == 0);"
  },
  {
    "id": 877,
    "function": "isSingleton",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "169-171",
    "spec_strength": "unknown",
    "snippet": "        fn isSingleton(&self) -> (result: B)\n            requires self.spec_well_formed(),\n            ensures result == (self.spec_seq().len() == 1);"
  },
  {
    "id": 878,
    "function": "subseq_copy",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "173-174",
    "spec_strength": "hole",
    "snippet": "        fn subseq_copy(&self, start: N, length: N) -> (result: Self)\n            requires self.spec_well_formed();"
  },
  {
    "id": 879,
    "function": "new_root",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "176-177",
    "spec_strength": "unknown",
    "snippet": "        fn new_root() -> (result: Self)\n            ensures result.spec_seq() =~= Seq::<T::V>::empty(), result.spec_well_formed();"
  },
  {
    "id": 880,
    "function": "update",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "179",
    "spec_strength": "hole",
    "snippet": "        fn update(&mut self, index: N, item: T);"
  },
  {
    "id": 881,
    "function": "from_vec",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "181",
    "spec_strength": "hole",
    "snippet": "        fn from_vec(values: Vec<T>) -> (result: AVLTreeS<T>);"
  },
  {
    "id": 882,
    "function": "to_arrayseq",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "183",
    "spec_strength": "hole",
    "snippet": "        fn to_arrayseq(&self) -> (result: ArraySeqStEphS<T>);"
  },
  {
    "id": 883,
    "function": "iter",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "185",
    "spec_strength": "hole",
    "snippet": "        fn iter<'a>(&'a self) -> (result: AVLTreeSeqIter<'a, T>);"
  },
  {
    "id": 884,
    "function": "push_back",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "187",
    "spec_strength": "hole",
    "snippet": "        fn push_back(&mut self, value: T);"
  },
  {
    "id": 885,
    "function": "contains_value",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "189",
    "spec_strength": "hole",
    "snippet": "        fn contains_value(&self, target: &T) -> (result: B);"
  },
  {
    "id": 886,
    "function": "insert_value",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "191",
    "spec_strength": "hole",
    "snippet": "        fn insert_value(&mut self, value: T);"
  },
  {
    "id": 887,
    "function": "delete_value",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "193",
    "spec_strength": "hole",
    "snippet": "        fn delete_value(&mut self, target: &T) -> (result: bool);"
  },
  {
    "id": 888,
    "function": "is_tree_empty",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "195",
    "spec_strength": "hole",
    "snippet": "        fn is_tree_empty(&self) -> (result: bool);"
  },
  {
    "id": 889,
    "function": "values_in_order",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "197",
    "spec_strength": "hole",
    "snippet": "        fn values_in_order(&self) -> (result: Vec<T>);"
  },
  {
    "id": 890,
    "function": "h_fn",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "202-203",
    "spec_strength": "unknown",
    "snippet": "    fn h_fn<T: StT>(n: &Link<T>) -> (result: N)\n        ensures result as nat == spec_cached_height(n),"
  },
  {
    "id": 891,
    "function": "size_link_fn",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "211-212",
    "spec_strength": "hole",
    "snippet": "    fn size_link_fn<T: StT>(n: &Link<T>) -> (result: N)\n        ensures result as nat == spec_cached_size(n),"
  },
  {
    "id": 892,
    "function": "update_meta",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "224",
    "spec_strength": "hole",
    "snippet": "    fn update_meta<T: StT>(n: &mut Box<AVLTreeNode<T>>) {"
  },
  {
    "id": 893,
    "function": "rotate_right_fn",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "233-237",
    "spec_strength": "hole",
    "snippet": "    fn rotate_right_fn<T: StT>(mut y: Box<AVLTreeNode<T>>) -> (result: Box<AVLTreeNode<T>>)\n        requires spec_wf(Some(y)),\n        ensures\n            spec_inorder(Some(result)) =~= spec_inorder(Some(y)),\n            spec_wf(Some(result)),"
  },
  {
    "id": 894,
    "function": "rotate_left_fn",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "250-254",
    "spec_strength": "hole",
    "snippet": "    fn rotate_left_fn<T: StT>(mut x: Box<AVLTreeNode<T>>) -> (result: Box<AVLTreeNode<T>>)\n        requires spec_wf(Some(x)),\n        ensures\n            spec_inorder(Some(result)) =~= spec_inorder(Some(x)),\n            spec_wf(Some(result)),"
  },
  {
    "id": 895,
    "function": "rebalance_fn",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "267-271",
    "spec_strength": "hole",
    "snippet": "    fn rebalance_fn<T: StT>(mut n: Box<AVLTreeNode<T>>) -> (result: Box<AVLTreeNode<T>>)\n        requires spec_wf(Some(n)),\n        ensures\n            spec_inorder(Some(result)) =~= spec_inorder(Some(n)),\n            spec_wf(Some(result)),"
  },
  {
    "id": 896,
    "function": "insert_at_link",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "294",
    "spec_strength": "hole",
    "snippet": "    pub(crate) fn insert_at_link<T: StT>(node: Link<T>, index: N, value: T, next_key: &mut N) -> (result: Link<T>) {"
  },
  {
    "id": 897,
    "function": "nth_link",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "323-325",
    "spec_strength": "hole",
    "snippet": "    fn nth_link<'a, T: StT>(node: &'a Link<T>, index: N) -> (result: &'a T)\n        requires spec_wf(*node), (index as int) < spec_inorder(*node).len(),\n        ensures result@ == spec_inorder(*node)[index as int],"
  },
  {
    "id": 898,
    "function": "set_link",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "339",
    "spec_strength": "hole",
    "snippet": "    fn set_link<T: StT>(node: &mut Link<T>, index: N, value: T) -> (result: Result<(), &'static str>) {"
  },
  {
    "id": 899,
    "function": "push_inorder",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "357",
    "spec_strength": "hole",
    "snippet": "    fn push_inorder<T: StT>(link: &Link<T>, out: &mut Vec<T>) {"
  },
  {
    "id": 900,
    "function": "compare_trees",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "366",
    "spec_strength": "hole",
    "snippet": "    fn compare_trees<T: StT>(a: &Link<T>, b: &Link<T>) -> (result: bool) {"
  },
  {
    "id": 901,
    "function": "eq",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "621-622",
    "spec_strength": "hole",
    "snippet": "        fn eq(&self, other: &Self) -> (r: bool)\n            ensures r == (self@ == other@)"
  },
  {
    "id": 902,
    "function": "default",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "647",
    "spec_strength": "",
    "snippet": "        fn default() -> Self { Self::new() }"
  },
  {
    "id": 903,
    "function": "push_left_iter",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "672-678",
    "spec_strength": "",
    "snippet": "    fn push_left_iter<'a, T: StT>(it: &mut AVLTreeSeqIter<'a, T>, link: &'a Link<T>) {\n        let mut cursor = link;\n        while let Some(node) = cursor.as_ref() {\n            it.stack.push(node);\n            cursor = &node.left;\n        }\n    }"
  },
  {
    "id": 904,
    "function": "next",
    "file": "Chap37/AVLTreeSeq.rs",
    "lines": "682-687",
    "spec_strength": "",
    "snippet": "        fn next(&mut self) -> Option<Self::Item> {\n            let node = self.stack.pop()?;\n            let value_ref: &T = &node.value;\n            push_left_iter(self, &node.right);\n            Some(value_ref)\n        }"
  },
  {
    "id": 905,
    "function": "lemma_size_eq_inorder_len",
    "file": "Chap37/AVLTreeSeqMtPer.rs",
    "lines": "118-121",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_size_eq_inorder_len<T: StTInMtT>(link: &Link<T>)\n        requires spec_wf(*link),\n        ensures spec_cached_size(link) == spec_inorder(*link).len(),\n        decreases *link,"
  },
  {
    "id": 906,
    "function": "empty",
    "file": "Chap37/AVLTreeSeqMtPer.rs",
    "lines": "138-139",
    "spec_strength": "unknown",
    "snippet": "        fn empty() -> (result: Self)\n            ensures result.spec_seq() =~= Seq::<T::V>::empty(), result.spec_well_formed();"
  },
  {
    "id": 907,
    "function": "new",
    "file": "Chap37/AVLTreeSeqMtPer.rs",
    "lines": "141-142",
    "spec_strength": "unknown",
    "snippet": "        fn new() -> (result: Self)\n            ensures result.spec_seq() =~= Seq::<T::V>::empty(), result.spec_well_formed();"
  },
  {
    "id": 908,
    "function": "singleton",
    "file": "Chap37/AVLTreeSeqMtPer.rs",
    "lines": "144-145",
    "spec_strength": "unknown",
    "snippet": "        fn singleton(item: T) -> (result: Self)\n            ensures result.spec_seq() =~= seq![item@], result.spec_well_formed();"
  },
  {
    "id": 909,
    "function": "length",
    "file": "Chap37/AVLTreeSeqMtPer.rs",
    "lines": "147-149",
    "spec_strength": "unknown",
    "snippet": "        fn length(&self) -> (result: N)\n            requires self.spec_well_formed(),\n            ensures result as nat == self.spec_seq().len();"
  },
  {
    "id": 910,
    "function": "nth",
    "file": "Chap37/AVLTreeSeqMtPer.rs",
    "lines": "151-153",
    "spec_strength": "unknown",
    "snippet": "        fn nth(&self, index: N) -> (result: &T)\n            requires self.spec_well_formed(), (index as int) < self.spec_seq().len(),\n            ensures result@ == self.spec_seq()[index as int];"
  },
  {
    "id": 911,
    "function": "isEmpty",
    "file": "Chap37/AVLTreeSeqMtPer.rs",
    "lines": "155-157",
    "spec_strength": "unknown",
    "snippet": "        fn isEmpty(&self) -> (result: B)\n            requires self.spec_well_formed(),\n            ensures result == (self.spec_seq().len() == 0);"
  },
  {
    "id": 912,
    "function": "isSingleton",
    "file": "Chap37/AVLTreeSeqMtPer.rs",
    "lines": "159-161",
    "spec_strength": "unknown",
    "snippet": "        fn isSingleton(&self) -> (result: B)\n            requires self.spec_well_formed(),\n            ensures result == (self.spec_seq().len() == 1);"
  },
  {
    "id": 913,
    "function": "set",
    "file": "Chap37/AVLTreeSeqMtPer.rs",
    "lines": "163-164",
    "spec_strength": "unknown",
    "snippet": "        fn set(&self, index: N, item: T) -> (result: Result<Self, &'static str>)\n            requires self.spec_well_formed(), (index as int) < self.spec_seq().len();"
  },
  {
    "id": 914,
    "function": "subseq_copy",
    "file": "Chap37/AVLTreeSeqMtPer.rs",
    "lines": "166-167",
    "spec_strength": "hole",
    "snippet": "        fn subseq_copy(&self, start: N, length: N) -> (result: Self)\n            requires self.spec_well_formed();"
  },
  {
    "id": 915,
    "function": "from_vec",
    "file": "Chap37/AVLTreeSeqMtPer.rs",
    "lines": "169",
    "spec_strength": "",
    "snippet": "        fn from_vec(values: Vec<T>) -> (result: Self);"
  },
  {
    "id": 916,
    "function": "values_in_order",
    "file": "Chap37/AVLTreeSeqMtPer.rs",
    "lines": "171",
    "spec_strength": "hole",
    "snippet": "        fn values_in_order(&self) -> (result: Vec<T>);"
  },
  {
    "id": 917,
    "function": "height_fn",
    "file": "Chap37/AVLTreeSeqMtPer.rs",
    "lines": "176-177",
    "spec_strength": "unknown",
    "snippet": "    fn height_fn<T: StTInMtT>(n: &Link<T>) -> (result: N)\n        ensures result as nat == spec_cached_height(n),"
  },
  {
    "id": 918,
    "function": "size_fn",
    "file": "Chap37/AVLTreeSeqMtPer.rs",
    "lines": "185-186",
    "spec_strength": "unknown",
    "snippet": "    fn size_fn<T: StTInMtT>(n: &Link<T>) -> (result: N)\n        ensures result as nat == spec_cached_size(n),"
  },
  {
    "id": 919,
    "function": "mk",
    "file": "Chap37/AVLTreeSeqMtPer.rs",
    "lines": "195-204",
    "spec_strength": "hole",
    "snippet": "    fn mk<T: StTInMtT>(value: T, left: Link<T>, right: Link<T>) -> (result: Arc<Node<T>>)\n        requires\n            1 + spec_cached_size(&left) + spec_cached_size(&right) <= N::MAX as nat,\n            1 + spec_nat_max(spec_cached_height(&left), spec_cached_height(&right)) <= N::MAX as nat,\n        ensures\n            spec_inorder(Some(result)) =~= spec_inorder(left) + seq![value@] + spec_inorder(right),\n            result.size as nat == 1 + spec_cached_size(&left) + spec_cached_size(&right),\n            result.height as nat == 1 + spec_nat_max(\n                spec_cached_height(&left), spec_cached_height(&right)),\n            spec_wf(left) && spec_wf(right) ==> spec_wf(Some(result)),"
  },
  {
    "id": 920,
    "function": "rotate_right",
    "file": "Chap37/AVLTreeSeqMtPer.rs",
    "lines": "214-218",
    "spec_strength": "hole",
    "snippet": "    fn rotate_right<T: StTInMtT>(y: Arc<Node<T>>) -> (result: Arc<Node<T>>)\n        requires y.left.is_some(), spec_wf(Some(y)),\n        ensures\n            spec_inorder(Some(result)) =~= spec_inorder(Some(y)),\n            spec_wf(Some(result)),"
  },
  {
    "id": 921,
    "function": "rotate_left",
    "file": "Chap37/AVLTreeSeqMtPer.rs",
    "lines": "227-231",
    "spec_strength": "hole",
    "snippet": "    fn rotate_left<T: StTInMtT>(x: Arc<Node<T>>) -> (result: Arc<Node<T>>)\n        requires x.right.is_some(), spec_wf(Some(x)),\n        ensures\n            spec_inorder(Some(result)) =~= spec_inorder(Some(x)),\n            spec_wf(Some(result)),"
  },
  {
    "id": 922,
    "function": "rebalance",
    "file": "Chap37/AVLTreeSeqMtPer.rs",
    "lines": "240-244",
    "spec_strength": "hole",
    "snippet": "    fn rebalance<T: StTInMtT>(n: Arc<Node<T>>) -> (result: Arc<Node<T>>)\n        requires spec_wf(Some(n)),\n        ensures\n            spec_inorder(Some(result)) =~= spec_inorder(Some(n)),\n            spec_wf(Some(result)),"
  },
  {
    "id": 923,
    "function": "nth_ref",
    "file": "Chap37/AVLTreeSeqMtPer.rs",
    "lines": "268-270",
    "spec_strength": "hole",
    "snippet": "    fn nth_ref<'a, T: StTInMtT>(cur: &'a Link<T>, index: N) -> (result: &'a T)\n        requires spec_wf(*cur), (index as int) < spec_inorder(*cur).len(),\n        ensures result@ == spec_inorder(*cur)[index as int],"
  },
  {
    "id": 924,
    "function": "set_rec",
    "file": "Chap37/AVLTreeSeqMtPer.rs",
    "lines": "289-291",
    "spec_strength": "hole",
    "snippet": "    fn set_rec<T: StTInMtT>(cur: &Link<T>, index: N, value: T) -> (result: Result<Link<T>, &'static str>)\n        requires spec_wf(*cur), (index as int) < spec_inorder(*cur).len(),\n        ensures result.is_ok(),"
  },
  {
    "id": 925,
    "function": "inorder_collect",
    "file": "Chap37/AVLTreeSeqMtPer.rs",
    "lines": "317",
    "spec_strength": "hole",
    "snippet": "    fn inorder_collect<T: StTInMtT>(cur: &Link<T>, out: &mut Vec<T>) {"
  },
  {
    "id": 926,
    "function": "build_balanced_from_slice",
    "file": "Chap37/AVLTreeSeqMtPer.rs",
    "lines": "326-327",
    "spec_strength": "hole",
    "snippet": "    fn build_balanced_from_slice<T: StTInMtT>(a: &[T]) -> (result: Link<T>)\n        ensures spec_wf(result),"
  },
  {
    "id": 927,
    "function": "rec",
    "file": "Chap37/AVLTreeSeqMtPer.rs",
    "lines": "329",
    "spec_strength": "",
    "snippet": "        fn rec<T: StTInMtT>(a: &[T]) -> Link<T> {"
  },
  {
    "id": 928,
    "function": "compare_trees",
    "file": "Chap37/AVLTreeSeqMtPer.rs",
    "lines": "344",
    "spec_strength": "hole",
    "snippet": "    fn compare_trees<T: StTInMtT>(a: &Link<T>, b: &Link<T>) -> (result: bool) {"
  },
  {
    "id": 929,
    "function": "eq",
    "file": "Chap37/AVLTreeSeqMtPer.rs",
    "lines": "462-463",
    "spec_strength": "hole",
    "snippet": "        fn eq(&self, other: &Self) -> (r: bool)\n            ensures r == (self@ == other@)"
  },
  {
    "id": 930,
    "function": "default",
    "file": "Chap37/AVLTreeSeqMtPer.rs",
    "lines": "487",
    "spec_strength": "",
    "snippet": "        fn default() -> Self { Self::empty() }"
  },
  {
    "id": 931,
    "function": "next",
    "file": "Chap37/AVLTreeSeqMtPer.rs",
    "lines": "511-519",
    "spec_strength": "",
    "snippet": "        fn next(&mut self) -> Option<Self::Item> {\n            if self.index < self.values.len() {\n                let val = self.values[self.index].clone();\n                self.index += 1;\n                Some(val)\n            } else {\n                None\n            }\n        }"
  },
  {
    "id": 932,
    "function": "lemma_size_eq_inorder_len",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "124-127",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_size_eq_inorder_len<T: StT>(link: &Link<T>)\n        requires spec_wf(*link),\n        ensures spec_cached_size(link) == spec_inorder(*link).len(),\n        decreases *link,"
  },
  {
    "id": 933,
    "function": "empty",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "144-145",
    "spec_strength": "unknown",
    "snippet": "        fn empty() -> (result: Self)\n            ensures result.spec_seq() =~= Seq::<T::V>::empty(), result.spec_well_formed();"
  },
  {
    "id": 934,
    "function": "new",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "147-148",
    "spec_strength": "unknown",
    "snippet": "        fn new() -> (result: Self)\n            ensures result.spec_seq() =~= Seq::<T::V>::empty(), result.spec_well_formed();"
  },
  {
    "id": 935,
    "function": "length",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "150-152",
    "spec_strength": "unknown",
    "snippet": "        fn length(&self) -> (result: N)\n            requires self.spec_well_formed(),\n            ensures result as nat == self.spec_seq().len();"
  },
  {
    "id": 936,
    "function": "nth",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "154-156",
    "spec_strength": "unknown",
    "snippet": "        fn nth(&self, index: N) -> (result: &T)\n            requires self.spec_well_formed(), (index as int) < self.spec_seq().len(),\n            ensures result@ == self.spec_seq()[index as int];"
  },
  {
    "id": 937,
    "function": "set",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "158-159",
    "spec_strength": "unknown",
    "snippet": "        fn set(&mut self, index: N, item: T) -> (result: Result<(), &'static str>)\n            requires old(self).spec_well_formed(), (index as int) < old(self).spec_seq().len();"
  },
  {
    "id": 938,
    "function": "singleton",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "161-162",
    "spec_strength": "hole",
    "snippet": "        fn singleton(item: T) -> (result: Self)\n            ensures result.spec_seq().len() == 1, result.spec_well_formed();"
  },
  {
    "id": 939,
    "function": "isEmpty",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "164-166",
    "spec_strength": "unknown",
    "snippet": "        fn isEmpty(&self) -> (result: B)\n            requires self.spec_well_formed(),\n            ensures result == (self.spec_seq().len() == 0);"
  },
  {
    "id": 940,
    "function": "isSingleton",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "168-170",
    "spec_strength": "unknown",
    "snippet": "        fn isSingleton(&self) -> (result: B)\n            requires self.spec_well_formed(),\n            ensures result == (self.spec_seq().len() == 1);"
  },
  {
    "id": 941,
    "function": "subseq_copy",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "172-173",
    "spec_strength": "hole",
    "snippet": "        fn subseq_copy(&self, start: N, length: N) -> (result: Self)\n            requires self.spec_well_formed();"
  },
  {
    "id": 942,
    "function": "new_root",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "175-176",
    "spec_strength": "unknown",
    "snippet": "        fn new_root() -> (result: Self)\n            ensures result.spec_seq() =~= Seq::<T::V>::empty(), result.spec_well_formed();"
  },
  {
    "id": 943,
    "function": "update",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "178",
    "spec_strength": "hole",
    "snippet": "        fn update(&mut self, index: N, item: T);"
  },
  {
    "id": 944,
    "function": "from_vec",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "180",
    "spec_strength": "hole",
    "snippet": "        fn from_vec(values: Vec<T>) -> (result: AVLTreeSeqStEphS<T>);"
  },
  {
    "id": 945,
    "function": "to_arrayseq",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "182",
    "spec_strength": "hole",
    "snippet": "        fn to_arrayseq(&self) -> (result: ArraySeqStEphS<T>);"
  },
  {
    "id": 946,
    "function": "iter",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "184",
    "spec_strength": "hole",
    "snippet": "        fn iter<'a>(&'a self) -> (result: AVLTreeSeqIterStEph<'a, T>);"
  },
  {
    "id": 947,
    "function": "push_back",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "186",
    "spec_strength": "hole",
    "snippet": "        fn push_back(&mut self, value: T);"
  },
  {
    "id": 948,
    "function": "contains_value",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "188",
    "spec_strength": "hole",
    "snippet": "        fn contains_value(&self, target: &T) -> (result: B);"
  },
  {
    "id": 949,
    "function": "insert_value",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "190",
    "spec_strength": "hole",
    "snippet": "        fn insert_value(&mut self, value: T);"
  },
  {
    "id": 950,
    "function": "delete_value",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "192",
    "spec_strength": "hole",
    "snippet": "        fn delete_value(&mut self, target: &T) -> (result: bool);"
  },
  {
    "id": 951,
    "function": "h_fn",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "197-198",
    "spec_strength": "unknown",
    "snippet": "    fn h_fn<T: StT>(n: &Link<T>) -> (result: N)\n        ensures result as nat == spec_cached_height(n),"
  },
  {
    "id": 952,
    "function": "size_link_fn",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "206-207",
    "spec_strength": "hole",
    "snippet": "    fn size_link_fn<T: StT>(n: &Link<T>) -> (result: N)\n        ensures result as nat == spec_cached_size(n),"
  },
  {
    "id": 953,
    "function": "update_meta",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "219",
    "spec_strength": "hole",
    "snippet": "    fn update_meta<T: StT>(n: &mut Box<AVLTreeNode<T>>) {"
  },
  {
    "id": 954,
    "function": "rotate_right_fn",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "228-232",
    "spec_strength": "hole",
    "snippet": "    fn rotate_right_fn<T: StT>(mut y: Box<AVLTreeNode<T>>) -> (result: Box<AVLTreeNode<T>>)\n        requires spec_wf(Some(y)),\n        ensures\n            spec_inorder(Some(result)) =~= spec_inorder(Some(y)),\n            spec_wf(Some(result)),"
  },
  {
    "id": 955,
    "function": "rotate_left_fn",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "245-249",
    "spec_strength": "hole",
    "snippet": "    fn rotate_left_fn<T: StT>(mut x: Box<AVLTreeNode<T>>) -> (result: Box<AVLTreeNode<T>>)\n        requires spec_wf(Some(x)),\n        ensures\n            spec_inorder(Some(result)) =~= spec_inorder(Some(x)),\n            spec_wf(Some(result)),"
  },
  {
    "id": 956,
    "function": "rebalance_fn",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "262-266",
    "spec_strength": "hole",
    "snippet": "    fn rebalance_fn<T: StT>(mut n: Box<AVLTreeNode<T>>) -> (result: Box<AVLTreeNode<T>>)\n        requires spec_wf(Some(n)),\n        ensures\n            spec_inorder(Some(result)) =~= spec_inorder(Some(n)),\n            spec_wf(Some(result)),"
  },
  {
    "id": 957,
    "function": "insert_at_link",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "289",
    "spec_strength": "hole",
    "snippet": "    pub(crate) fn insert_at_link<T: StT>(node: Link<T>, index: N, value: T, next_key: &mut N) -> (result: Link<T>) {"
  },
  {
    "id": 958,
    "function": "nth_link",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "318-320",
    "spec_strength": "hole",
    "snippet": "    fn nth_link<'a, T: StT>(node: &'a Link<T>, index: N) -> (result: &'a T)\n        requires spec_wf(*node), (index as int) < spec_inorder(*node).len(),\n        ensures result@ == spec_inorder(*node)[index as int],"
  },
  {
    "id": 959,
    "function": "set_link",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "334",
    "spec_strength": "hole",
    "snippet": "    fn set_link<T: StT>(node: &mut Link<T>, index: N, value: T) -> (result: Result<(), &'static str>) {"
  },
  {
    "id": 960,
    "function": "compare_trees",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "352",
    "spec_strength": "hole",
    "snippet": "    fn compare_trees<T: StT>(a: &Link<T>, b: &Link<T>) -> (result: bool) {"
  },
  {
    "id": 961,
    "function": "eq",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "607-608",
    "spec_strength": "hole",
    "snippet": "        fn eq(&self, other: &Self) -> (r: bool)\n            ensures r == (self@ == other@)"
  },
  {
    "id": 962,
    "function": "default",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "633",
    "spec_strength": "",
    "snippet": "        fn default() -> Self { Self::new() }"
  },
  {
    "id": 963,
    "function": "push_left_iter",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "638-644",
    "spec_strength": "",
    "snippet": "    fn push_left_iter<'a, T: StT>(it: &mut AVLTreeSeqIterStEph<'a, T>, link: &'a Link<T>) {\n        let mut cursor = link;\n        while let Some(node) = cursor.as_ref() {\n            it.stack.push(node);\n            cursor = &node.left;\n        }\n    }"
  },
  {
    "id": 964,
    "function": "next",
    "file": "Chap37/AVLTreeSeqStEph.rs",
    "lines": "648-653",
    "spec_strength": "",
    "snippet": "        fn next(&mut self) -> Option<Self::Item> {\n            let node = self.stack.pop()?;\n            let value_ref: &T = &node.value;\n            push_left_iter(self, &node.right);\n            Some(value_ref)\n        }"
  },
  {
    "id": 965,
    "function": "lemma_size_eq_inorder_len",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "124-127",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_size_eq_inorder_len<T: StT>(link: &Link<T>)\n        requires spec_wf(*link),\n        ensures spec_cached_size(link) == spec_inorder(*link).len(),\n        decreases *link,"
  },
  {
    "id": 966,
    "function": "empty",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "144-145",
    "spec_strength": "unknown",
    "snippet": "        fn empty() -> (result: Self)\n            ensures result.spec_seq() =~= Seq::<T::V>::empty(), result.spec_well_formed();"
  },
  {
    "id": 967,
    "function": "new",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "147-148",
    "spec_strength": "unknown",
    "snippet": "        fn new() -> (result: Self)\n            ensures result.spec_seq() =~= Seq::<T::V>::empty(), result.spec_well_formed();"
  },
  {
    "id": 968,
    "function": "singleton",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "150-151",
    "spec_strength": "unknown",
    "snippet": "        fn singleton(item: T) -> (result: Self)\n            ensures result.spec_seq() =~= seq![item@], result.spec_well_formed();"
  },
  {
    "id": 969,
    "function": "length",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "153-155",
    "spec_strength": "unknown",
    "snippet": "        fn length(&self) -> (result: N)\n            requires self.spec_well_formed(),\n            ensures result as nat == self.spec_seq().len();"
  },
  {
    "id": 970,
    "function": "nth",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "157-159",
    "spec_strength": "unknown",
    "snippet": "        fn nth(&self, index: N) -> (result: &T)\n            requires self.spec_well_formed(), (index as int) < self.spec_seq().len(),\n            ensures result@ == self.spec_seq()[index as int];"
  },
  {
    "id": 971,
    "function": "isEmpty",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "161-163",
    "spec_strength": "unknown",
    "snippet": "        fn isEmpty(&self) -> (result: B)\n            requires self.spec_well_formed(),\n            ensures result == (self.spec_seq().len() == 0);"
  },
  {
    "id": 972,
    "function": "isSingleton",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "165-167",
    "spec_strength": "unknown",
    "snippet": "        fn isSingleton(&self) -> (result: B)\n            requires self.spec_well_formed(),\n            ensures result == (self.spec_seq().len() == 1);"
  },
  {
    "id": 973,
    "function": "set",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "169-170",
    "spec_strength": "unknown",
    "snippet": "        fn set(&self, index: N, item: T) -> (result: Result<Self, &'static str>)\n            requires self.spec_well_formed(), (index as int) < self.spec_seq().len();"
  },
  {
    "id": 974,
    "function": "subseq_copy",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "172-173",
    "spec_strength": "hole",
    "snippet": "        fn subseq_copy(&self, start: N, length: N) -> (result: Self)\n            requires self.spec_well_formed();"
  },
  {
    "id": 975,
    "function": "from_vec",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "175",
    "spec_strength": "",
    "snippet": "        fn from_vec(values: Vec<T>) -> (result: Self);"
  },
  {
    "id": 976,
    "function": "values_in_order",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "177",
    "spec_strength": "hole",
    "snippet": "        fn values_in_order(&self) -> (result: Vec<T>);"
  },
  {
    "id": 977,
    "function": "to_arrayseq",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "179",
    "spec_strength": "hole",
    "snippet": "        fn to_arrayseq(&self) -> (result: ArraySeqStPerS<T>);"
  },
  {
    "id": 978,
    "function": "iter",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "181",
    "spec_strength": "hole",
    "snippet": "        fn iter<'a>(&'a self) -> (result: AVLTreeSeqStPerIter<'a, T>);"
  },
  {
    "id": 979,
    "function": "height_fn",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "186-187",
    "spec_strength": "unknown",
    "snippet": "    fn height_fn<T: StT>(n: &Link<T>) -> (result: N)\n        ensures result as nat == spec_cached_height(n),"
  },
  {
    "id": 980,
    "function": "size_fn",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "195-196",
    "spec_strength": "unknown",
    "snippet": "    fn size_fn<T: StT>(n: &Link<T>) -> (result: N)\n        ensures result as nat == spec_cached_size(n),"
  },
  {
    "id": 981,
    "function": "mk",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "205-214",
    "spec_strength": "hole",
    "snippet": "    fn mk<T: StT>(value: T, left: Link<T>, right: Link<T>) -> (result: Arc<Node<T>>)\n        requires\n            1 + spec_cached_size(&left) + spec_cached_size(&right) <= N::MAX as nat,\n            1 + spec_nat_max(spec_cached_height(&left), spec_cached_height(&right)) <= N::MAX as nat,\n        ensures\n            spec_inorder(Some(result)) =~= spec_inorder(left) + seq![value@] + spec_inorder(right),\n            result.size as nat == 1 + spec_cached_size(&left) + spec_cached_size(&right),\n            result.height as nat == 1 + spec_nat_max(\n                spec_cached_height(&left), spec_cached_height(&right)),\n            spec_wf(left) && spec_wf(right) ==> spec_wf(Some(result)),"
  },
  {
    "id": 982,
    "function": "rotate_right",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "224-228",
    "spec_strength": "hole",
    "snippet": "    fn rotate_right<T: StT>(y: Arc<Node<T>>) -> (result: Arc<Node<T>>)\n        requires y.left.is_some(), spec_wf(Some(y)),\n        ensures\n            spec_inorder(Some(result)) =~= spec_inorder(Some(y)),\n            spec_wf(Some(result)),"
  },
  {
    "id": 983,
    "function": "rotate_left",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "237-241",
    "spec_strength": "hole",
    "snippet": "    fn rotate_left<T: StT>(x: Arc<Node<T>>) -> (result: Arc<Node<T>>)\n        requires x.right.is_some(), spec_wf(Some(x)),\n        ensures\n            spec_inorder(Some(result)) =~= spec_inorder(Some(x)),\n            spec_wf(Some(result)),"
  },
  {
    "id": 984,
    "function": "rebalance",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "250-254",
    "spec_strength": "hole",
    "snippet": "    fn rebalance<T: StT>(n: Arc<Node<T>>) -> (result: Arc<Node<T>>)\n        requires spec_wf(Some(n)),\n        ensures\n            spec_inorder(Some(result)) =~= spec_inorder(Some(n)),\n            spec_wf(Some(result)),"
  },
  {
    "id": 985,
    "function": "nth_ref",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "278-280",
    "spec_strength": "hole",
    "snippet": "    fn nth_ref<'a, T: StT>(cur: &'a Link<T>, index: N) -> (result: &'a T)\n        requires spec_wf(*cur), (index as int) < spec_inorder(*cur).len(),\n        ensures result@ == spec_inorder(*cur)[index as int],"
  },
  {
    "id": 986,
    "function": "set_rec",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "299-301",
    "spec_strength": "hole",
    "snippet": "    fn set_rec<T: StT>(cur: &Link<T>, index: N, value: T) -> (result: Result<Link<T>, &'static str>)\n        requires spec_wf(*cur), (index as int) < spec_inorder(*cur).len(),\n        ensures result.is_ok(),"
  },
  {
    "id": 987,
    "function": "inorder_collect",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "327",
    "spec_strength": "hole",
    "snippet": "    fn inorder_collect<T: StT>(cur: &Link<T>, out: &mut Vec<T>) {"
  },
  {
    "id": 988,
    "function": "build_balanced_from_slice",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "336-337",
    "spec_strength": "hole",
    "snippet": "    fn build_balanced_from_slice<T: StT>(a: &[T]) -> (result: Link<T>)\n        ensures spec_wf(result),"
  },
  {
    "id": 989,
    "function": "rec",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "339",
    "spec_strength": "",
    "snippet": "        fn rec<T: StT>(a: &[T]) -> Link<T> {"
  },
  {
    "id": 990,
    "function": "compare_trees",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "352",
    "spec_strength": "hole",
    "snippet": "    fn compare_trees<T: StT>(a: &Link<T>, b: &Link<T>) -> (result: bool) {"
  },
  {
    "id": 991,
    "function": "eq",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "478-479",
    "spec_strength": "hole",
    "snippet": "        fn eq(&self, other: &Self) -> (r: bool)\n            ensures r == (self@ == other@)"
  },
  {
    "id": 992,
    "function": "default",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "503",
    "spec_strength": "",
    "snippet": "        fn default() -> Self { Self::empty() }"
  },
  {
    "id": 993,
    "function": "push_left_iter",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "520-525",
    "spec_strength": "",
    "snippet": "    fn push_left_iter<'a, T: StT>(it: &mut AVLTreeSeqStPerIter<'a, T>, mut cur: Option<&'a Node<T>>) {\n        while let Some(n) = cur {\n            it.stack.push(n);\n            cur = n.left.as_deref();\n        }\n    }"
  },
  {
    "id": 994,
    "function": "next",
    "file": "Chap37/AVLTreeSeqStPer.rs",
    "lines": "529-538",
    "spec_strength": "",
    "snippet": "        fn next(&mut self) -> Option<Self::Item> {\n            if self.current.is_some() {\n                let cur = self.current.take();\n                push_left_iter(self, cur);\n            }\n            let node = self.stack.pop()?;\n            let value_ref: &T = &node.value;\n            push_left_iter(self, node.right.as_deref());\n            Some(value_ref)\n        }"
  },
  {
    "id": 995,
    "function": "lemma_bst_deep",
    "file": "Chap37/BSTAVLMtEph.rs",
    "lines": "53-85",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_bst_deep<T: TotalOrder>(tree: BalBinTree<T>)\n        requires tree_is_bst::<T>(tree),\n        ensures\n            match tree {\n                BalBinTree::Leaf => true,\n                BalBinTree::Node(node) =>\n                    tree_is_bst::<T>(node.left)\n                    && tree_is_bst::<T>(node.right)\n                    && (forall|x: T| #![auto] tree_contains(node.left, x) ==>\n                        T::le(x, node.value) && x != node.value)\n                    && (forall|x: T| #![auto] tree_contains(node.right, x) ==>\n                        T::le(node.value, x) && x != node.value)\n                    && match node.left {\n                        BalBinTree::Leaf => true,\n                        BalBinTree::Node(lnode) =>\n                            tree_is_bst::<T>(lnode.left)\n                            && tree_is_bst::<T>(lnode.right)\n                            && (forall|x: T| #![auto] tree_contains(lnode.left, x) ==>\n                                T::le(x, lnode.value) && x != lnode.value)\n                            && (forall|x: T| #![auto] tree_contains(lnode.right, x) ==>\n                                T::le(lnode.value, x) && x != lnode.value)\n                    }\n                    && match node.right {\n                        BalBinTree::Leaf => true,\n                        BalBinTree::Node(rnode) =>\n                            tree_is_bst::<T>(rnode.left)\n                            && tree_is_bst::<T>(rnode.right)\n                            && (forall|x: T| #![auto] tree_contains(rnode.left, x) ==>\n                                T::le(x, rnode.value) && x != rnode.value)\n                            && (forall|x: T| #![auto] tree_contains(rnode.right, x) ==>\n                                T::le(rnode.value, x) && x != rnode.value)\n                    }\n            }"
  },
  {
    "id": 996,
    "function": "rotate_right",
    "file": "Chap37/BSTAVLMtEph.rs",
    "lines": "100-104",
    "spec_strength": "unknown",
    "snippet": "    fn rotate_right<T: TotalOrder>(tree: BalBinTree<T>) -> (result: BalBinTree<T>)\n        requires tree_is_bst::<T>(tree), !(tree is Leaf),\n        ensures\n            tree_is_bst::<T>(result),\n            forall|x: T| #![auto] tree_contains(result, x) == tree_contains(tree, x),"
  },
  {
    "id": 997,
    "function": "rotate_left",
    "file": "Chap37/BSTAVLMtEph.rs",
    "lines": "166-170",
    "spec_strength": "unknown",
    "snippet": "    fn rotate_left<T: TotalOrder>(tree: BalBinTree<T>) -> (result: BalBinTree<T>)\n        requires tree_is_bst::<T>(tree), !(tree is Leaf),\n        ensures\n            tree_is_bst::<T>(result),\n            forall|x: T| #![auto] tree_contains(result, x) == tree_contains(tree, x),"
  },
  {
    "id": 998,
    "function": "insert_node",
    "file": "Chap37/BSTAVLMtEph.rs",
    "lines": "233-242",
    "spec_strength": "unknown",
    "snippet": "    fn insert_node<T: TotalOrder>(node: BalBinTree<T>, value: T) -> (result: BalBinTree<T>)\n        requires tree_is_bst::<T>(node),\n        ensures\n            tree_is_bst::<T>(result),\n            tree_contains(result, value),\n            forall|x: T| #![auto] tree_contains(result, x) <==>\n                (tree_contains(node, x) || x == value),\n            result.spec_size() <= node.spec_size() + 1,\n            result.spec_height() <= node.spec_height() + 1,\n        decreases node.spec_size(),"
  },
  {
    "id": 999,
    "function": "contains_node",
    "file": "Chap37/BSTAVLMtEph.rs",
    "lines": "325-328",
    "spec_strength": "unknown",
    "snippet": "    fn contains_node<T: TotalOrder>(node: &BalBinTree<T>, target: &T) -> (result: bool)\n        requires tree_is_bst::<T>(*node),\n        ensures result == tree_contains(*node, *target),\n        decreases node.spec_size(),"
  },
  {
    "id": 1000,
    "function": "find_node",
    "file": "Chap37/BSTAVLMtEph.rs",
    "lines": "350-355",
    "spec_strength": "unknown",
    "snippet": "    fn find_node<'a, T: TotalOrder>(node: &'a BalBinTree<T>, target: &T) -> (result: Option<&'a T>)\n        requires tree_is_bst::<T>(*node),\n        ensures\n            result.is_some() == tree_contains(*node, *target),\n            result.is_some() ==> *result.unwrap() == *target,\n        decreases node.spec_size(),"
  },
  {
    "id": 1001,
    "function": "min_node",
    "file": "Chap37/BSTAVLMtEph.rs",
    "lines": "377-378",
    "spec_strength": "",
    "snippet": "    fn min_node<T: TotalOrder>(node: &BalBinTree<T>) -> (result: Option<&T>)\n        decreases node.spec_size(),"
  },
  {
    "id": 1002,
    "function": "max_node",
    "file": "Chap37/BSTAVLMtEph.rs",
    "lines": "389-390",
    "spec_strength": "",
    "snippet": "    fn max_node<T: TotalOrder>(node: &BalBinTree<T>) -> (result: Option<&T>)\n        decreases node.spec_size(),"
  },
  {
    "id": 1003,
    "function": "new",
    "file": "Chap37/BSTAVLMtEph.rs",
    "lines": "404",
    "spec_strength": "",
    "snippet": "        pub fn new() -> (tree: Self)"
  },
  {
    "id": 1004,
    "function": "insert",
    "file": "Chap37/BSTAVLMtEph.rs",
    "lines": "414",
    "spec_strength": "",
    "snippet": "        pub fn insert(&self, value: T)"
  },
  {
    "id": 1005,
    "function": "contains",
    "file": "Chap37/BSTAVLMtEph.rs",
    "lines": "437",
    "spec_strength": "",
    "snippet": "        pub fn contains(&self, target: &T) -> (result: bool)"
  },
  {
    "id": 1006,
    "function": "size",
    "file": "Chap37/BSTAVLMtEph.rs",
    "lines": "446",
    "spec_strength": "",
    "snippet": "        pub fn size(&self) -> (n: usize)"
  },
  {
    "id": 1007,
    "function": "is_empty",
    "file": "Chap37/BSTAVLMtEph.rs",
    "lines": "456",
    "spec_strength": "",
    "snippet": "        pub fn is_empty(&self) -> (b: bool)"
  },
  {
    "id": 1008,
    "function": "height",
    "file": "Chap37/BSTAVLMtEph.rs",
    "lines": "465",
    "spec_strength": "",
    "snippet": "        pub fn height(&self) -> (h: usize)"
  },
  {
    "id": 1009,
    "function": "lemma_bst_deep",
    "file": "Chap37/BSTAVLStEph.rs",
    "lines": "56-88",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_bst_deep<T: TotalOrder>(tree: BalBinTree<T>)\n        requires tree_is_bst::<T>(tree),\n        ensures\n            match tree {\n                BalBinTree::Leaf => true,\n                BalBinTree::Node(node) =>\n                    tree_is_bst::<T>(node.left)\n                    && tree_is_bst::<T>(node.right)\n                    && (forall|x: T| #![auto] tree_contains(node.left, x) ==>\n                        T::le(x, node.value) && x != node.value)\n                    && (forall|x: T| #![auto] tree_contains(node.right, x) ==>\n                        T::le(node.value, x) && x != node.value)\n                    && match node.left {\n                        BalBinTree::Leaf => true,\n                        BalBinTree::Node(lnode) =>\n                            tree_is_bst::<T>(lnode.left)\n                            && tree_is_bst::<T>(lnode.right)\n                            && (forall|x: T| #![auto] tree_contains(lnode.left, x) ==>\n                                T::le(x, lnode.value) && x != lnode.value)\n                            && (forall|x: T| #![auto] tree_contains(lnode.right, x) ==>\n                                T::le(lnode.value, x) && x != lnode.value)\n                    }\n                    && match node.right {\n                        BalBinTree::Leaf => true,\n                        BalBinTree::Node(rnode) =>\n                            tree_is_bst::<T>(rnode.left)\n                            && tree_is_bst::<T>(rnode.right)\n                            && (forall|x: T| #![auto] tree_contains(rnode.left, x) ==>\n                                T::le(x, rnode.value) && x != rnode.value)\n                            && (forall|x: T| #![auto] tree_contains(rnode.right, x) ==>\n                                T::le(rnode.value, x) && x != rnode.value)\n                    }\n            }"
  },
  {
    "id": 1010,
    "function": "lemma_max_plus_one",
    "file": "Chap37/BSTAVLStEph.rs",
    "lines": "95-97",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_max_plus_one(a: nat, b: nat)\n        ensures\n            (if a >= b { a + 1 } else { b }) <= (if a >= b { a } else { b }) + 1,"
  },
  {
    "id": 1011,
    "function": "rotate_right",
    "file": "Chap37/BSTAVLStEph.rs",
    "lines": "108-146",
    "spec_strength": "unknown",
    "snippet": "    fn rotate_right<T: TotalOrder>(tree: BalBinTree<T>) -> (result: BalBinTree<T>)\n        requires\n            tree_is_bst::<T>(tree),\n            !(tree is Leaf),\n        ensures\n            tree_is_bst::<T>(result),\n            forall|x: T| #![auto] tree_contains(result, x) == tree_contains(tree, x),\n            match tree {\n                BalBinTree::Node(outer) => match outer.left {\n                    BalBinTree::Node(l) => {\n                        let lr_h = l.right.spec_height();\n                        let r_h = outer.right.spec_height();\n                        let ll_h = l.left.spec_height();\n                        let new_rh: nat = 1 + if lr_h >= r_h { lr_h } else { r_h };\n                        &&& result.spec_height() == (1 + if ll_h >= new_rh { ll_h } else { new_rh })\n                        &&& ((avl_balanced(l.left) && avl_balanced(l.right) && avl_balanced(outer.right)\n                             && lr_h as int - r_h as int >= -1 && lr_h as int - r_h as int <= 1\n                             && ll_h as int - new_rh as int >= -1 && ll_h as int - new_rh as int <= 1)\n                            ==> avl_balanced(result))\n                        &&& result is Node\n                        &&& match result {\n                            BalBinTree::Node(res) => {\n                                &&& res.left.spec_height() == ll_h\n                                &&& avl_balanced(res.left) == avl_balanced(l.left)\n                                &&& res.right.spec_height() == new_rh\n                                &&& (avl_balanced(res.right) <==> (avl_balanced(l.right)\n                                    && avl_balanced(outer.right) && {\n                                    let lh = lr_h as int;\n                                    let rh = r_h as int;\n                                    -1 <= lh - rh && lh - rh <= 1\n                                }))\n                            },\n                            _ => false,\n                        }\n                    },\n                    _ => true,\n                },\n                _ => true,\n            },"
  },
  {
    "id": 1012,
    "function": "rotate_left",
    "file": "Chap37/BSTAVLStEph.rs",
    "lines": "260-298",
    "spec_strength": "unknown",
    "snippet": "    fn rotate_left<T: TotalOrder>(tree: BalBinTree<T>) -> (result: BalBinTree<T>)\n        requires\n            tree_is_bst::<T>(tree),\n            !(tree is Leaf),\n        ensures\n            tree_is_bst::<T>(result),\n            forall|x: T| #![auto] tree_contains(result, x) == tree_contains(tree, x),\n            match tree {\n                BalBinTree::Node(outer) => match outer.right {\n                    BalBinTree::Node(r) => {\n                        let rl_h = r.left.spec_height();\n                        let l_h = outer.left.spec_height();\n                        let rr_h = r.right.spec_height();\n                        let new_lh: nat = 1 + if l_h >= rl_h { l_h } else { rl_h };\n                        &&& result.spec_height() == (1 + if new_lh >= rr_h { new_lh } else { rr_h })\n                        &&& ((avl_balanced(outer.left) && avl_balanced(r.left) && avl_balanced(r.right)\n                             && l_h as int - rl_h as int >= -1 && l_h as int - rl_h as int <= 1\n                             && new_lh as int - rr_h as int >= -1 && new_lh as int - rr_h as int <= 1)\n                            ==> avl_balanced(result))\n                        &&& result is Node\n                        &&& match result {\n                            BalBinTree::Node(res) => {\n                                &&& res.right.spec_height() == rr_h\n                                &&& avl_balanced(res.right) == avl_balanced(r.right)\n                                &&& res.left.spec_height() == new_lh\n                                &&& (avl_balanced(res.left) <==> (avl_balanced(outer.left)\n                                    && avl_balanced(r.left) && {\n                                    let lh = l_h as int;\n                                    let rh = rl_h as int;\n                                    -1 <= lh - rh && lh - rh <= 1\n                                }))\n                            },\n                            _ => false,\n                        }\n                    },\n                    _ => true,\n                },\n                _ => true,\n            },"
  },
  {
    "id": 1013,
    "function": "rebalance",
    "file": "Chap37/BSTAVLStEph.rs",
    "lines": "419-447",
    "spec_strength": "unknown",
    "snippet": "    fn rebalance<T: TotalOrder>(tree: BalBinTree<T>) -> (result: BalBinTree<T>)\n        requires\n            tree_is_bst::<T>(tree),\n            !(tree is Leaf),\n            tree.spec_height() <= usize::MAX,\n            match tree {\n                BalBinTree::Node(inner) =>\n                    avl_balanced(inner.left) && avl_balanced(inner.right)\n                    && {\n                        let lh = inner.left.spec_height() as int;\n                        let rh = inner.right.spec_height() as int;\n                        -2 <= lh - rh && lh - rh <= 2\n                    },\n                _ => false,\n            },\n        ensures\n            tree_is_bst::<T>(result),\n            avl_balanced(result),\n            result.spec_height() <= tree.spec_height(),\n            result.spec_height() + 1 >= tree.spec_height(),\n            forall|x: T| #![auto] tree_contains(result, x) == tree_contains(tree, x),\n            match tree {\n                BalBinTree::Node(inner) => {\n                    let lh = inner.left.spec_height() as int;\n                    let rh = inner.right.spec_height() as int;\n                    (-1 <= lh - rh && lh - rh <= 1) ==> result.spec_height() == tree.spec_height()\n                },\n                _ => true,\n            },"
  },
  {
    "id": 1014,
    "function": "insert_node",
    "file": "Chap37/BSTAVLStEph.rs",
    "lines": "705-716",
    "spec_strength": "unknown",
    "snippet": "    fn insert_node<T: TotalOrder>(node: BalBinTree<T>, value: T) -> (result: BalBinTree<T>)\n        requires\n            tree_is_avl::<T>(node),\n            node.spec_height() <= usize::MAX - 1,\n        ensures\n            tree_is_avl::<T>(result),\n            tree_contains(result, value),\n            result.spec_height() <= node.spec_height() + 1,\n            result.spec_height() >= node.spec_height(),\n            forall|x: T| #![auto] tree_contains(result, x) <==>\n                (tree_contains(node, x) || x == value),\n        decreases node.spec_size(),"
  },
  {
    "id": 1015,
    "function": "contains_node",
    "file": "Chap37/BSTAVLStEph.rs",
    "lines": "859-862",
    "spec_strength": "unknown",
    "snippet": "    fn contains_node<T: TotalOrder>(node: &BalBinTree<T>, target: &T) -> (result: bool)\n        requires tree_is_bst::<T>(*node),\n        ensures result == tree_contains(*node, *target),\n        decreases node.spec_size(),"
  },
  {
    "id": 1016,
    "function": "find_node",
    "file": "Chap37/BSTAVLStEph.rs",
    "lines": "892-897",
    "spec_strength": "unknown",
    "snippet": "    fn find_node<'a, T: TotalOrder>(node: &'a BalBinTree<T>, target: &T) -> (result: Option<&'a T>)\n        requires tree_is_bst::<T>(*node),\n        ensures\n            result.is_some() == tree_contains(*node, *target),\n            result.is_some() ==> *result.unwrap() == *target,\n        decreases node.spec_size(),"
  },
  {
    "id": 1017,
    "function": "min_node",
    "file": "Chap37/BSTAVLStEph.rs",
    "lines": "927-928",
    "spec_strength": "",
    "snippet": "    fn min_node<T: TotalOrder>(node: &BalBinTree<T>) -> (result: Option<&T>)\n        decreases node.spec_size(),"
  },
  {
    "id": 1018,
    "function": "max_node",
    "file": "Chap37/BSTAVLStEph.rs",
    "lines": "942-943",
    "spec_strength": "",
    "snippet": "    fn max_node<T: TotalOrder>(node: &BalBinTree<T>) -> (result: Option<&T>)\n        decreases node.spec_size(),"
  },
  {
    "id": 1019,
    "function": "avl_new",
    "file": "Chap37/BSTAVLStEph.rs",
    "lines": "957-960",
    "spec_strength": "unknown",
    "snippet": "    pub fn avl_new<T: TotalOrder>() -> (tree: BSTAVLStEph<T>)\n        ensures\n            tree_is_avl::<T>(tree.root),\n            forall|x: T| !tree_contains(tree.root, x),"
  },
  {
    "id": 1020,
    "function": "avl_size",
    "file": "Chap37/BSTAVLStEph.rs",
    "lines": "965-967",
    "spec_strength": "unknown",
    "snippet": "    pub fn avl_size<T: TotalOrder>(tree: &BSTAVLStEph<T>) -> (n: usize)\n        requires tree.root.spec_size() <= usize::MAX,\n        ensures n == tree.root.spec_size(),"
  },
  {
    "id": 1021,
    "function": "avl_is_empty",
    "file": "Chap37/BSTAVLStEph.rs",
    "lines": "972-973",
    "spec_strength": "unknown",
    "snippet": "    pub fn avl_is_empty<T: TotalOrder>(tree: &BSTAVLStEph<T>) -> (b: bool)\n        ensures b == (tree.root.spec_size() == 0),"
  },
  {
    "id": 1022,
    "function": "avl_height",
    "file": "Chap37/BSTAVLStEph.rs",
    "lines": "978-980",
    "spec_strength": "unknown",
    "snippet": "    pub fn avl_height<T: TotalOrder>(tree: &BSTAVLStEph<T>) -> (h: usize)\n        requires tree.root.spec_height() <= usize::MAX,\n        ensures h == tree.root.spec_height(),"
  },
  {
    "id": 1023,
    "function": "avl_insert",
    "file": "Chap37/BSTAVLStEph.rs",
    "lines": "985-993",
    "spec_strength": "unknown",
    "snippet": "    pub fn avl_insert<T: TotalOrder>(tree: BSTAVLStEph<T>, value: T) -> (result: BSTAVLStEph<T>)\n        requires\n            tree_is_avl::<T>(tree.root),\n            tree.root.spec_height() <= usize::MAX - 1,\n        ensures\n            tree_is_avl::<T>(result.root),\n            tree_contains(result.root, value),\n            forall|x: T| #![auto] tree_contains(result.root, x) <==>\n                (tree_contains(tree.root, x) || x == value),"
  },
  {
    "id": 1024,
    "function": "avl_contains",
    "file": "Chap37/BSTAVLStEph.rs",
    "lines": "998-1000",
    "spec_strength": "unknown",
    "snippet": "    pub fn avl_contains<T: TotalOrder>(tree: &BSTAVLStEph<T>, target: &T) -> (result: bool)\n        requires tree_is_bst::<T>(tree.root),\n        ensures result == tree_contains(tree.root, *target),"
  },
  {
    "id": 1025,
    "function": "avl_find",
    "file": "Chap37/BSTAVLStEph.rs",
    "lines": "1005-1009",
    "spec_strength": "unknown",
    "snippet": "    pub fn avl_find<'a, T: TotalOrder>(tree: &'a BSTAVLStEph<T>, target: &T) -> (result: Option<&'a T>)\n        requires tree_is_bst::<T>(tree.root),\n        ensures\n            result.is_some() == tree_contains(tree.root, *target),\n            result.is_some() ==> *result.unwrap() == *target,"
  },
  {
    "id": 1026,
    "function": "insert_node",
    "file": "Chap37/BSTBBAlphaMtEph.rs",
    "lines": "63-72",
    "spec_strength": "unknown",
    "snippet": "    fn insert_node<T: TotalOrder>(node: BalBinTree<T>, value: T) -> (result: BalBinTree<T>)\n        requires tree_is_bst::<T>(node),\n        ensures\n            tree_is_bst::<T>(result),\n            tree_contains(result, value),\n            forall|x: T| #![auto] tree_contains(result, x) <==>\n                (tree_contains(node, x) || x == value),\n            result.spec_size() <= node.spec_size() + 1,\n            result.spec_height() <= node.spec_height() + 1,\n        decreases node.spec_size(),"
  },
  {
    "id": 1027,
    "function": "contains_node",
    "file": "Chap37/BSTBBAlphaMtEph.rs",
    "lines": "155-158",
    "spec_strength": "unknown",
    "snippet": "    fn contains_node<T: TotalOrder>(node: &BalBinTree<T>, target: &T) -> (result: bool)\n        requires tree_is_bst::<T>(*node),\n        ensures result == tree_contains(*node, *target),\n        decreases node.spec_size(),"
  },
  {
    "id": 1028,
    "function": "find_node",
    "file": "Chap37/BSTBBAlphaMtEph.rs",
    "lines": "180-185",
    "spec_strength": "unknown",
    "snippet": "    fn find_node<'a, T: TotalOrder>(node: &'a BalBinTree<T>, target: &T) -> (result: Option<&'a T>)\n        requires tree_is_bst::<T>(*node),\n        ensures\n            result.is_some() == tree_contains(*node, *target),\n            result.is_some() ==> *result.unwrap() == *target,\n        decreases node.spec_size(),"
  },
  {
    "id": 1029,
    "function": "min_node",
    "file": "Chap37/BSTBBAlphaMtEph.rs",
    "lines": "207-208",
    "spec_strength": "",
    "snippet": "    fn min_node<T: TotalOrder>(node: &BalBinTree<T>) -> (result: Option<&T>)\n        decreases node.spec_size(),"
  },
  {
    "id": 1030,
    "function": "max_node",
    "file": "Chap37/BSTBBAlphaMtEph.rs",
    "lines": "219-220",
    "spec_strength": "",
    "snippet": "    fn max_node<T: TotalOrder>(node: &BalBinTree<T>) -> (result: Option<&T>)\n        decreases node.spec_size(),"
  },
  {
    "id": 1031,
    "function": "new",
    "file": "Chap37/BSTBBAlphaMtEph.rs",
    "lines": "234",
    "spec_strength": "",
    "snippet": "        pub fn new() -> (tree: Self)"
  },
  {
    "id": 1032,
    "function": "insert",
    "file": "Chap37/BSTBBAlphaMtEph.rs",
    "lines": "244",
    "spec_strength": "",
    "snippet": "        pub fn insert(&self, value: T)"
  },
  {
    "id": 1033,
    "function": "contains",
    "file": "Chap37/BSTBBAlphaMtEph.rs",
    "lines": "267",
    "spec_strength": "",
    "snippet": "        pub fn contains(&self, target: &T) -> (result: bool)"
  },
  {
    "id": 1034,
    "function": "size",
    "file": "Chap37/BSTBBAlphaMtEph.rs",
    "lines": "276",
    "spec_strength": "",
    "snippet": "        pub fn size(&self) -> (n: usize)"
  },
  {
    "id": 1035,
    "function": "is_empty",
    "file": "Chap37/BSTBBAlphaMtEph.rs",
    "lines": "286",
    "spec_strength": "",
    "snippet": "        pub fn is_empty(&self) -> (b: bool)"
  },
  {
    "id": 1036,
    "function": "height",
    "file": "Chap37/BSTBBAlphaMtEph.rs",
    "lines": "295",
    "spec_strength": "",
    "snippet": "        pub fn height(&self) -> (h: usize)"
  },
  {
    "id": 1037,
    "function": "insert_node",
    "file": "Chap37/BSTBBAlphaStEph.rs",
    "lines": "60-67",
    "spec_strength": "unknown",
    "snippet": "    fn insert_node<T: TotalOrder>(node: BalBinTree<T>, value: T) -> (result: BalBinTree<T>)\n        requires tree_is_bst::<T>(node),\n        ensures\n            tree_is_bst::<T>(result),\n            tree_contains(result, value),\n            forall|x: T| #![auto] tree_contains(result, x) <==>\n                (tree_contains(node, x) || x == value),\n        decreases node.spec_size(),"
  },
  {
    "id": 1038,
    "function": "contains_node",
    "file": "Chap37/BSTBBAlphaStEph.rs",
    "lines": "189-192",
    "spec_strength": "unknown",
    "snippet": "    fn contains_node<T: TotalOrder>(node: &BalBinTree<T>, target: &T) -> (result: bool)\n        requires tree_is_bst::<T>(*node),\n        ensures result == tree_contains(*node, *target),\n        decreases node.spec_size(),"
  },
  {
    "id": 1039,
    "function": "find_node",
    "file": "Chap37/BSTBBAlphaStEph.rs",
    "lines": "222-227",
    "spec_strength": "unknown",
    "snippet": "    fn find_node<'a, T: TotalOrder>(node: &'a BalBinTree<T>, target: &T) -> (result: Option<&'a T>)\n        requires tree_is_bst::<T>(*node),\n        ensures\n            result.is_some() == tree_contains(*node, *target),\n            result.is_some() ==> *result.unwrap() == *target,\n        decreases node.spec_size(),"
  },
  {
    "id": 1040,
    "function": "min_node",
    "file": "Chap37/BSTBBAlphaStEph.rs",
    "lines": "257-258",
    "spec_strength": "",
    "snippet": "    fn min_node<T: TotalOrder>(node: &BalBinTree<T>) -> (result: Option<&T>)\n        decreases node.spec_size(),"
  },
  {
    "id": 1041,
    "function": "max_node",
    "file": "Chap37/BSTBBAlphaStEph.rs",
    "lines": "272-273",
    "spec_strength": "",
    "snippet": "    fn max_node<T: TotalOrder>(node: &BalBinTree<T>) -> (result: Option<&T>)\n        decreases node.spec_size(),"
  },
  {
    "id": 1042,
    "function": "bb_new",
    "file": "Chap37/BSTBBAlphaStEph.rs",
    "lines": "287-290",
    "spec_strength": "unknown",
    "snippet": "    pub fn bb_new<T: TotalOrder>() -> (tree: BSTBBAlphaStEph<T>)\n        ensures\n            tree_is_bst::<T>(tree.root),\n            forall|x: T| !tree_contains(tree.root, x),"
  },
  {
    "id": 1043,
    "function": "bb_size",
    "file": "Chap37/BSTBBAlphaStEph.rs",
    "lines": "295-297",
    "spec_strength": "unknown",
    "snippet": "    pub fn bb_size<T: TotalOrder>(tree: &BSTBBAlphaStEph<T>) -> (n: usize)\n        requires tree.root.spec_size() <= usize::MAX,\n        ensures n == tree.root.spec_size(),"
  },
  {
    "id": 1044,
    "function": "bb_is_empty",
    "file": "Chap37/BSTBBAlphaStEph.rs",
    "lines": "302-303",
    "spec_strength": "unknown",
    "snippet": "    pub fn bb_is_empty<T: TotalOrder>(tree: &BSTBBAlphaStEph<T>) -> (b: bool)\n        ensures b == (tree.root.spec_size() == 0),"
  },
  {
    "id": 1045,
    "function": "bb_height",
    "file": "Chap37/BSTBBAlphaStEph.rs",
    "lines": "308-310",
    "spec_strength": "unknown",
    "snippet": "    pub fn bb_height<T: TotalOrder>(tree: &BSTBBAlphaStEph<T>) -> (h: usize)\n        requires tree.root.spec_height() <= usize::MAX,\n        ensures h == tree.root.spec_height(),"
  },
  {
    "id": 1046,
    "function": "bb_insert",
    "file": "Chap37/BSTBBAlphaStEph.rs",
    "lines": "315-321",
    "spec_strength": "unknown",
    "snippet": "    pub fn bb_insert<T: TotalOrder>(tree: BSTBBAlphaStEph<T>, value: T) -> (result: BSTBBAlphaStEph<T>)\n        requires tree_is_bst::<T>(tree.root),\n        ensures\n            tree_is_bst::<T>(result.root),\n            tree_contains(result.root, value),\n            forall|x: T| #![auto] tree_contains(result.root, x) <==>\n                (tree_contains(tree.root, x) || x == value),"
  },
  {
    "id": 1047,
    "function": "bb_contains",
    "file": "Chap37/BSTBBAlphaStEph.rs",
    "lines": "326-328",
    "spec_strength": "unknown",
    "snippet": "    pub fn bb_contains<T: TotalOrder>(tree: &BSTBBAlphaStEph<T>, target: &T) -> (result: bool)\n        requires tree_is_bst::<T>(tree.root),\n        ensures result == tree_contains(tree.root, *target),"
  },
  {
    "id": 1048,
    "function": "bb_find",
    "file": "Chap37/BSTBBAlphaStEph.rs",
    "lines": "333-337",
    "spec_strength": "unknown",
    "snippet": "    pub fn bb_find<'a, T: TotalOrder>(tree: &'a BSTBBAlphaStEph<T>, target: &T) -> (result: Option<&'a T>)\n        requires tree_is_bst::<T>(tree.root),\n        ensures\n            result.is_some() == tree_contains(tree.root, *target),\n            result.is_some() ==> *result.unwrap() == *target,"
  },
  {
    "id": 1049,
    "function": "insert_node",
    "file": "Chap37/BSTPlainMtEph.rs",
    "lines": "58-67",
    "spec_strength": "unknown",
    "snippet": "    fn insert_node<T: TotalOrder>(node: BalBinTree<T>, value: T) -> (result: BalBinTree<T>)\n        requires tree_is_bst::<T>(node),\n        ensures\n            tree_is_bst::<T>(result),\n            tree_contains(result, value),\n            forall|x: T| #![auto] tree_contains(result, x) <==>\n                (tree_contains(node, x) || x == value),\n            result.spec_size() <= node.spec_size() + 1,\n            result.spec_height() <= node.spec_height() + 1,\n        decreases node.spec_size(),"
  },
  {
    "id": 1050,
    "function": "contains_node",
    "file": "Chap37/BSTPlainMtEph.rs",
    "lines": "150-153",
    "spec_strength": "unknown",
    "snippet": "    fn contains_node<T: TotalOrder>(node: &BalBinTree<T>, target: &T) -> (result: bool)\n        requires tree_is_bst::<T>(*node),\n        ensures result == tree_contains(*node, *target),\n        decreases node.spec_size(),"
  },
  {
    "id": 1051,
    "function": "find_node",
    "file": "Chap37/BSTPlainMtEph.rs",
    "lines": "175-180",
    "spec_strength": "unknown",
    "snippet": "    fn find_node<'a, T: TotalOrder>(node: &'a BalBinTree<T>, target: &T) -> (result: Option<&'a T>)\n        requires tree_is_bst::<T>(*node),\n        ensures\n            result.is_some() == tree_contains(*node, *target),\n            result.is_some() ==> *result.unwrap() == *target,\n        decreases node.spec_size(),"
  },
  {
    "id": 1052,
    "function": "min_node",
    "file": "Chap37/BSTPlainMtEph.rs",
    "lines": "202-203",
    "spec_strength": "",
    "snippet": "    fn min_node<T: TotalOrder>(node: &BalBinTree<T>) -> (result: Option<&T>)\n        decreases node.spec_size(),"
  },
  {
    "id": 1053,
    "function": "max_node",
    "file": "Chap37/BSTPlainMtEph.rs",
    "lines": "214-215",
    "spec_strength": "",
    "snippet": "    fn max_node<T: TotalOrder>(node: &BalBinTree<T>) -> (result: Option<&T>)\n        decreases node.spec_size(),"
  },
  {
    "id": 1054,
    "function": "new",
    "file": "Chap37/BSTPlainMtEph.rs",
    "lines": "229",
    "spec_strength": "",
    "snippet": "        pub fn new() -> (tree: Self)"
  },
  {
    "id": 1055,
    "function": "insert",
    "file": "Chap37/BSTPlainMtEph.rs",
    "lines": "239",
    "spec_strength": "",
    "snippet": "        pub fn insert(&self, value: T)"
  },
  {
    "id": 1056,
    "function": "contains",
    "file": "Chap37/BSTPlainMtEph.rs",
    "lines": "262",
    "spec_strength": "",
    "snippet": "        pub fn contains(&self, target: &T) -> (result: bool)"
  },
  {
    "id": 1057,
    "function": "is_empty",
    "file": "Chap37/BSTPlainMtEph.rs",
    "lines": "271",
    "spec_strength": "",
    "snippet": "        pub fn is_empty(&self) -> (b: bool)"
  },
  {
    "id": 1058,
    "function": "size",
    "file": "Chap37/BSTPlainMtEph.rs",
    "lines": "280",
    "spec_strength": "",
    "snippet": "        pub fn size(&self) -> (n: usize)"
  },
  {
    "id": 1059,
    "function": "height",
    "file": "Chap37/BSTPlainMtEph.rs",
    "lines": "290",
    "spec_strength": "",
    "snippet": "        pub fn height(&self) -> (h: usize)"
  },
  {
    "id": 1060,
    "function": "insert_node",
    "file": "Chap37/BSTPlainStEph.rs",
    "lines": "64-71",
    "spec_strength": "unknown",
    "snippet": "    fn insert_node<T: TotalOrder>(node: BalBinTree<T>, value: T) -> (result: BalBinTree<T>)\n        requires tree_is_bst::<T>(node),\n        ensures\n            tree_is_bst::<T>(result),\n            tree_contains(result, value),\n            forall|x: T| #![auto] tree_contains(result, x) <==>\n                (tree_contains(node, x) || x == value),\n        decreases node.spec_size(),"
  },
  {
    "id": 1061,
    "function": "contains_node",
    "file": "Chap37/BSTPlainStEph.rs",
    "lines": "193-196",
    "spec_strength": "unknown",
    "snippet": "    fn contains_node<T: TotalOrder>(node: &BalBinTree<T>, target: &T) -> (result: bool)\n        requires tree_is_bst::<T>(*node),\n        ensures result == tree_contains(*node, *target),\n        decreases node.spec_size(),"
  },
  {
    "id": 1062,
    "function": "find_node",
    "file": "Chap37/BSTPlainStEph.rs",
    "lines": "226-231",
    "spec_strength": "unknown",
    "snippet": "    fn find_node<'a, T: TotalOrder>(node: &'a BalBinTree<T>, target: &T) -> (result: Option<&'a T>)\n        requires tree_is_bst::<T>(*node),\n        ensures\n            result.is_some() == tree_contains(*node, *target),\n            result.is_some() ==> *result.unwrap() == *target,\n        decreases node.spec_size(),"
  },
  {
    "id": 1063,
    "function": "min_node",
    "file": "Chap37/BSTPlainStEph.rs",
    "lines": "261-262",
    "spec_strength": "",
    "snippet": "    fn min_node<T: TotalOrder>(node: &BalBinTree<T>) -> (result: Option<&T>)\n        decreases node.spec_size(),"
  },
  {
    "id": 1064,
    "function": "max_node",
    "file": "Chap37/BSTPlainStEph.rs",
    "lines": "276-277",
    "spec_strength": "",
    "snippet": "    fn max_node<T: TotalOrder>(node: &BalBinTree<T>) -> (result: Option<&T>)\n        decreases node.spec_size(),"
  },
  {
    "id": 1065,
    "function": "bst_new",
    "file": "Chap37/BSTPlainStEph.rs",
    "lines": "291-294",
    "spec_strength": "unknown",
    "snippet": "    pub fn bst_new<T: TotalOrder>() -> (tree: BSTPlainStEph<T>)\n        ensures\n            tree_is_bst::<T>(tree.root),\n            forall|x: T| !tree_contains(tree.root, x),"
  },
  {
    "id": 1066,
    "function": "bst_size",
    "file": "Chap37/BSTPlainStEph.rs",
    "lines": "299-301",
    "spec_strength": "unknown",
    "snippet": "    pub fn bst_size<T: TotalOrder>(tree: &BSTPlainStEph<T>) -> (n: usize)\n        requires tree.root.spec_size() <= usize::MAX,\n        ensures n == tree.root.spec_size(),"
  },
  {
    "id": 1067,
    "function": "bst_is_empty",
    "file": "Chap37/BSTPlainStEph.rs",
    "lines": "306-307",
    "spec_strength": "unknown",
    "snippet": "    pub fn bst_is_empty<T: TotalOrder>(tree: &BSTPlainStEph<T>) -> (b: bool)\n        ensures b == (tree.root.spec_size() == 0),"
  },
  {
    "id": 1068,
    "function": "bst_height",
    "file": "Chap37/BSTPlainStEph.rs",
    "lines": "312-314",
    "spec_strength": "unknown",
    "snippet": "    pub fn bst_height<T: TotalOrder>(tree: &BSTPlainStEph<T>) -> (h: usize)\n        requires tree.root.spec_height() <= usize::MAX,\n        ensures h == tree.root.spec_height(),"
  },
  {
    "id": 1069,
    "function": "bst_insert",
    "file": "Chap37/BSTPlainStEph.rs",
    "lines": "319-325",
    "spec_strength": "unknown",
    "snippet": "    pub fn bst_insert<T: TotalOrder>(tree: BSTPlainStEph<T>, value: T) -> (result: BSTPlainStEph<T>)\n        requires tree_is_bst::<T>(tree.root),\n        ensures\n            tree_is_bst::<T>(result.root),\n            tree_contains(result.root, value),\n            forall|x: T| #![auto] tree_contains(result.root, x) <==>\n                (tree_contains(tree.root, x) || x == value),"
  },
  {
    "id": 1070,
    "function": "bst_contains",
    "file": "Chap37/BSTPlainStEph.rs",
    "lines": "330-332",
    "spec_strength": "unknown",
    "snippet": "    pub fn bst_contains<T: TotalOrder>(tree: &BSTPlainStEph<T>, target: &T) -> (result: bool)\n        requires tree_is_bst::<T>(tree.root),\n        ensures result == tree_contains(tree.root, *target),"
  },
  {
    "id": 1071,
    "function": "bst_find",
    "file": "Chap37/BSTPlainStEph.rs",
    "lines": "337-341",
    "spec_strength": "unknown",
    "snippet": "    pub fn bst_find<'a, T: TotalOrder>(tree: &'a BSTPlainStEph<T>, target: &T) -> (result: Option<&'a T>)\n        requires tree_is_bst::<T>(tree.root),\n        ensures\n            result.is_some() == tree_contains(tree.root, *target),\n            result.is_some() ==> *result.unwrap() == *target,"
  },
  {
    "id": 1072,
    "function": "new_rb_link_lock",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "329",
    "spec_strength": "hole",
    "snippet": "        fn new_rb_link_lock<T: StTInMtT + Ord>(val: Link<T>) -> (lock: RwLock<Link<T>, RBLinkWf>) {"
  },
  {
    "id": 1073,
    "function": "new_node",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "31-39",
    "spec_strength": "",
    "snippet": "    fn new_node<T: StTInMtT + Ord>(key: T) -> Node<T> {\n        Node {\n            key,\n            color: Color::Red,\n            size: 1,\n            left: None,\n            right: None,\n        }\n    }"
  },
  {
    "id": 1074,
    "function": "is_red",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "41",
    "spec_strength": "",
    "snippet": "    fn is_red<T: StTInMtT + Ord>(link: &Link<T>) -> bool { matches!(link, Some(node) if node.color == Color::Red) }"
  },
  {
    "id": 1075,
    "function": "size_link",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "43",
    "spec_strength": "",
    "snippet": "    fn size_link<T: StTInMtT + Ord>(link: &Link<T>) -> N { link.as_ref().map_or(0, |n| n.size) }"
  },
  {
    "id": 1076,
    "function": "update",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "45",
    "spec_strength": "",
    "snippet": "    fn update<T: StTInMtT + Ord>(node: &mut Node<T>) { node.size = 1 + size_link(&node.left) + size_link(&node.right); }"
  },
  {
    "id": 1077,
    "function": "rotate_left",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "47-64",
    "spec_strength": "",
    "snippet": "    fn rotate_left<T: StTInMtT + Ord>(link: &mut Link<T>) {\n        if let Some(mut h) = link.take() {\n            if let Some(mut x) = h.right.take() {\n                h.right = x.left.take();\n                update(&mut h);\n                x.color = h.color;\n                h.color = Color::Red;\n                x.left = Some(h);\n                if let Some(left) = x.left.as_mut() {\n                    update(left);\n                }\n                update(&mut x);\n                *link = Some(x);\n            } else {\n                *link = Some(h);\n            }\n        }\n    }"
  },
  {
    "id": 1078,
    "function": "rotate_right",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "66-83",
    "spec_strength": "",
    "snippet": "    fn rotate_right<T: StTInMtT + Ord>(link: &mut Link<T>) {\n        if let Some(mut h) = link.take() {\n            if let Some(mut x) = h.left.take() {\n                h.left = x.right.take();\n                update(&mut h);\n                x.color = h.color;\n                h.color = Color::Red;\n                x.right = Some(h);\n                if let Some(right) = x.right.as_mut() {\n                    update(right);\n                }\n                update(&mut x);\n                *link = Some(x);\n            } else {\n                *link = Some(h);\n            }\n        }\n    }"
  },
  {
    "id": 1079,
    "function": "flip_colors",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "85-104",
    "spec_strength": "",
    "snippet": "    fn flip_colors<T: StTInMtT + Ord>(link: &mut Link<T>) {\n        if let Some(node) = link.as_mut() {\n            node.color = match node.color {\n                | Color::Red => Color::Black,\n                | Color::Black => Color::Red,\n            };\n            if let Some(left) = node.left.as_mut() {\n                left.color = match left.color {\n                    | Color::Red => Color::Black,\n                    | Color::Black => Color::Red,\n                };\n            }\n            if let Some(right) = node.right.as_mut() {\n                right.color = match right.color {\n                    | Color::Red => Color::Black,\n                    | Color::Black => Color::Red,\n                };\n            }\n        }\n    }"
  },
  {
    "id": 1080,
    "function": "fix_up",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "106-140",
    "spec_strength": "",
    "snippet": "    fn fix_up<T: StTInMtT + Ord>(link: &mut Link<T>) {\n        let rotate_left_needed = match link {\n            | Some(node) => is_red(&node.right) && !is_red(&node.left),\n            | None => false,\n        };\n        if rotate_left_needed {\n            rotate_left(link);\n        }\n\n        let rotate_right_needed = match link {\n            | Some(node) => {\n                if let Some(left) = node.left.as_ref() {\n                    is_red(&node.left) && is_red(&left.left)\n                } else {\n                    false\n                }\n            }\n            | None => false,\n        };\n        if rotate_right_needed {\n            rotate_right(link);\n        }\n\n        let flip_needed = match link {\n            | Some(node) => is_red(&node.left) && is_red(&node.right),\n            | None => false,\n        };\n        if flip_needed {\n            flip_colors(link);\n        }\n\n        if let Some(node) = link.as_mut() {\n            update(node);\n        }\n    }"
  },
  {
    "id": 1081,
    "function": "insert_link",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "142-156",
    "spec_strength": "",
    "snippet": "    fn insert_link<T: StTInMtT + Ord>(link: &mut Link<T>, value: T) {\n        if let Some(node) = link.as_mut() {\n            if value < node.key {\n                insert_link(&mut node.left, value);\n            } else if value > node.key {\n                insert_link(&mut node.right, value);\n            } else {\n                return;\n            }\n        } else {\n            *link = Some(Box::new(new_node(value)));\n            return;\n        }\n        fix_up(link);\n    }"
  },
  {
    "id": 1082,
    "function": "find_link",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "158-171",
    "spec_strength": "",
    "snippet": "    fn find_link<'a, T: StTInMtT + Ord>(link: &'a Link<T>, target: &T) -> Option<&'a T> {\n        match link {\n            | None => None,\n            | Some(node) => {\n                if *target == node.key {\n                    Some(&node.key)\n                } else if *target < node.key {\n                    find_link(&node.left, target)\n                } else {\n                    find_link(&node.right, target)\n                }\n            }\n        }\n    }"
  },
  {
    "id": 1083,
    "function": "min_link",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "173-181",
    "spec_strength": "",
    "snippet": "    fn min_link<T: StTInMtT + Ord>(link: &Link<T>) -> Option<&T> {\n        match link {\n            | None => None,\n            | Some(node) => match node.left {\n                | None => Some(&node.key),\n                | Some(_) => min_link(&node.left),\n            },\n        }\n    }"
  },
  {
    "id": 1084,
    "function": "max_link",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "183-191",
    "spec_strength": "",
    "snippet": "    fn max_link<T: StTInMtT + Ord>(link: &Link<T>) -> Option<&T> {\n        match link {\n            | None => None,\n            | Some(node) => match node.right {\n                | None => Some(&node.key),\n                | Some(_) => max_link(&node.right),\n            },\n        }\n    }"
  },
  {
    "id": 1085,
    "function": "in_order_collect",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "193-199",
    "spec_strength": "",
    "snippet": "    fn in_order_collect<T: StTInMtT + Ord>(link: &Link<T>, out: &mut Vec<T>) {\n        if let Some(node) = link {\n            in_order_collect(&node.left, out);\n            out.push(node.key.clone());\n            in_order_collect(&node.right, out);\n        }\n    }"
  },
  {
    "id": 1086,
    "function": "pre_order_collect",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "201-207",
    "spec_strength": "",
    "snippet": "    fn pre_order_collect<T: StTInMtT + Ord>(link: &Link<T>, out: &mut Vec<T>) {\n        if let Some(node) = link {\n            out.push(node.key.clone());\n            pre_order_collect(&node.left, out);\n            pre_order_collect(&node.right, out);\n        }\n    }"
  },
  {
    "id": 1087,
    "function": "in_order_parallel",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "211-226",
    "spec_strength": "",
    "snippet": "    fn in_order_parallel<T: StTInMtT + Ord>(link: &Link<T>) -> Vec<T> {\n        match link {\n            | None => Vec::new(),\n            | Some(node) => {\n                use crate::Types::Types::Pair;\n                let Pair(left_vec, right_vec) = crate::ParaPair!(\n                    move || in_order_parallel(&node.left),\n                    move || in_order_parallel(&node.right)\n                );\n                let mut result = left_vec;\n                result.push(node.key.clone());\n                result.extend(right_vec);\n                result\n            }\n        }\n    }"
  },
  {
    "id": 1088,
    "function": "pre_order_parallel",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "228-243",
    "spec_strength": "",
    "snippet": "    fn pre_order_parallel<T: StTInMtT + Ord>(link: &Link<T>) -> Vec<T> {\n        match link {\n            | None => Vec::new(),\n            | Some(node) => {\n                use crate::Types::Types::Pair;\n                let Pair(left_vec, right_vec) = crate::ParaPair!(\n                    move || pre_order_parallel(&node.left),\n                    move || pre_order_parallel(&node.right)\n                );\n                let mut result = vec![node.key.clone()];\n                result.extend(left_vec);\n                result.extend(right_vec);\n                result\n            }\n        }\n    }"
  },
  {
    "id": 1089,
    "function": "build_balanced",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "245-264",
    "spec_strength": "",
    "snippet": "    // Parallel construction from sorted slice\n    fn build_balanced<T: StTInMtT + Ord>(values: &[T]) -> Link<T> {\n        if values.is_empty() {\n            return None;\n        }\n        let mid = values.len() / 2;\n        \n        use crate::Types::Types::Pair;\n        let Pair(left, right) = crate::ParaPair!(\n            move || build_balanced(&values[..mid]),\n            move || build_balanced(&values[mid + 1..])\n        );\n        \n        let mut node = Box::new(new_node(values[mid].clone()));\n        node.left = left;\n        node.right = right;\n        node.color = Color::Black;\n        update(&mut node);\n        Some(node)\n    }"
  },
  {
    "id": 1090,
    "function": "filter_parallel",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "266-291",
    "spec_strength": "",
    "snippet": "    // Parallel filter\n    fn filter_parallel<T: StTInMtT + Ord, F>(link: &Link<T>, predicate: &Arc<F>) -> Vec<T>\n    where\n        F: Fn(&T) -> bool + Send + Sync,\n    {\n        match link {\n            | None => Vec::new(),\n            | Some(node) => {\n                let pred_left = Arc::clone(predicate);\n                let pred_right = Arc::clone(predicate);\n                \n                use crate::Types::Types::Pair;\n                let Pair(left_vals, right_vals) = crate::ParaPair!(\n                    move || filter_parallel(&node.left, &pred_left),\n                    move || filter_parallel(&node.right, &pred_right)\n                );\n                \n                let mut result = left_vals;\n                if predicate(&node.key) {\n                    result.push(node.key.clone());\n                }\n                result.extend(right_vals);\n                result\n            }\n        }\n    }"
  },
  {
    "id": 1091,
    "function": "reduce_parallel",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "293-315",
    "spec_strength": "",
    "snippet": "    // Parallel reduce\n    fn reduce_parallel<T: StTInMtT + Ord, F>(link: &Link<T>, op: &Arc<F>, identity: T) -> T\n    where\n        F: Fn(T, T) -> T + Send + Sync,\n    {\n        match link {\n            | None => identity,\n            | Some(node) => {\n                let op_left = Arc::clone(op);\n                let op_right = Arc::clone(op);\n                let id_left = identity.clone();\n                \n                use crate::Types::Types::Pair;\n                let Pair(left_acc, right_acc) = crate::ParaPair!(\n                    move || reduce_parallel(&node.left, &op_left, id_left),\n                    move || reduce_parallel(&node.right, &op_right, identity)\n                );\n                \n                let with_key = op(left_acc, node.key.clone());\n                op(with_key, right_acc)\n            }\n        }\n    }"
  },
  {
    "id": 1092,
    "function": "new",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "348-349",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work (1), Span (1)\n        fn new()                       -> Self;"
  },
  {
    "id": 1093,
    "function": "from_sorted_slice",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "350-351",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work (n), Span (log n) - Parallel construction from sorted slice\n        fn from_sorted_slice(values: &[T]) -> Self;"
  },
  {
    "id": 1094,
    "function": "insert",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "352-353",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work (log n), Span (log n) with locking\n        fn insert(&self, value: T);"
  },
  {
    "id": 1095,
    "function": "find",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "354-355",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work (log n), Span (log n) with locking\n        fn find(&self, target: &T)     -> Option<T>;"
  },
  {
    "id": 1096,
    "function": "contains",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "356",
    "spec_strength": "",
    "snippet": "        fn contains(&self, target: &T) -> B;"
  },
  {
    "id": 1097,
    "function": "size",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "357",
    "spec_strength": "",
    "snippet": "        fn size(&self)                 -> N;"
  },
  {
    "id": 1098,
    "function": "is_empty",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "358",
    "spec_strength": "",
    "snippet": "        fn is_empty(&self)             -> B;"
  },
  {
    "id": 1099,
    "function": "height",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "359",
    "spec_strength": "",
    "snippet": "        fn height(&self)               -> N;"
  },
  {
    "id": 1100,
    "function": "minimum",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "360",
    "spec_strength": "",
    "snippet": "        fn minimum(&self)              -> Option<T>;"
  },
  {
    "id": 1101,
    "function": "maximum",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "361",
    "spec_strength": "",
    "snippet": "        fn maximum(&self)              -> Option<T>;"
  },
  {
    "id": 1102,
    "function": "in_order",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "362-363",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work (n), Span (log n) - Parallel traversal\n        fn in_order(&self)             -> ArraySeqStPerS<T>;"
  },
  {
    "id": 1103,
    "function": "pre_order",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "364-365",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work (n), Span (log n) - Parallel traversal\n        fn pre_order(&self)            -> ArraySeqStPerS<T>;"
  },
  {
    "id": 1104,
    "function": "filter",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "366-369",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work (n), Span (log n) - Parallel filter\n        fn filter<F>(&self, predicate: F) -> ArraySeqStPerS<T>\n        where\n            F: Fn(&T) -> bool + Send + Sync;"
  },
  {
    "id": 1105,
    "function": "reduce",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "370-373",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work (n), Span (log n) - Parallel reduce\n        fn reduce<F>(&self, op: F, identity: T) -> T\n        where\n            F: Fn(T, T) -> T + Send + Sync;"
  },
  {
    "id": 1106,
    "function": "height_rec",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "411-416",
    "spec_strength": "",
    "snippet": "            fn height_rec<T: StTInMtT + Ord>(link: &Link<T>) -> N {\n                match link {\n                    | None => 0,\n                    | Some(node) => 1 + height_rec(&node.left).max(height_rec(&node.right)),\n                }\n            }"
  },
  {
    "id": 1107,
    "function": "default",
    "file": "Chap37/BSTRBMtEph.rs",
    "lines": "481",
    "spec_strength": "",
    "snippet": "        fn default() -> Self { Self::new() }"
  },
  {
    "id": 1108,
    "function": "lemma_bst_deep",
    "file": "Chap37/BSTRBStEph.rs",
    "lines": "41-73",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_bst_deep<T: TotalOrder>(tree: BalBinTree<T>)\n        requires tree_is_bst::<T>(tree),\n        ensures\n            match tree {\n                BalBinTree::Leaf => true,\n                BalBinTree::Node(node) =>\n                    tree_is_bst::<T>(node.left)\n                    && tree_is_bst::<T>(node.right)\n                    && (forall|x: T| #![auto] tree_contains(node.left, x) ==>\n                        T::le(x, node.value) && x != node.value)\n                    && (forall|x: T| #![auto] tree_contains(node.right, x) ==>\n                        T::le(node.value, x) && x != node.value)\n                    && match node.left {\n                        BalBinTree::Leaf => true,\n                        BalBinTree::Node(lnode) =>\n                            tree_is_bst::<T>(lnode.left)\n                            && tree_is_bst::<T>(lnode.right)\n                            && (forall|x: T| #![auto] tree_contains(lnode.left, x) ==>\n                                T::le(x, lnode.value) && x != lnode.value)\n                            && (forall|x: T| #![auto] tree_contains(lnode.right, x) ==>\n                                T::le(lnode.value, x) && x != lnode.value)\n                    }\n                    && match node.right {\n                        BalBinTree::Leaf => true,\n                        BalBinTree::Node(rnode) =>\n                            tree_is_bst::<T>(rnode.left)\n                            && tree_is_bst::<T>(rnode.right)\n                            && (forall|x: T| #![auto] tree_contains(rnode.left, x) ==>\n                                T::le(x, rnode.value) && x != rnode.value)\n                            && (forall|x: T| #![auto] tree_contains(rnode.right, x) ==>\n                                T::le(rnode.value, x) && x != rnode.value)\n                    }\n            }"
  },
  {
    "id": 1109,
    "function": "rotate_right",
    "file": "Chap37/BSTRBStEph.rs",
    "lines": "87-93",
    "spec_strength": "unknown",
    "snippet": "    fn rotate_right<T: TotalOrder>(tree: BalBinTree<T>) -> (result: BalBinTree<T>)\n        requires\n            tree_is_bst::<T>(tree),\n            !(tree is Leaf),\n        ensures\n            tree_is_bst::<T>(result),\n            forall|x: T| #![auto] tree_contains(result, x) == tree_contains(tree, x),"
  },
  {
    "id": 1110,
    "function": "rotate_left",
    "file": "Chap37/BSTRBStEph.rs",
    "lines": "185-191",
    "spec_strength": "unknown",
    "snippet": "    fn rotate_left<T: TotalOrder>(tree: BalBinTree<T>) -> (result: BalBinTree<T>)\n        requires\n            tree_is_bst::<T>(tree),\n            !(tree is Leaf),\n        ensures\n            tree_is_bst::<T>(result),\n            forall|x: T| #![auto] tree_contains(result, x) == tree_contains(tree, x),"
  },
  {
    "id": 1111,
    "function": "insert_node",
    "file": "Chap37/BSTRBStEph.rs",
    "lines": "282-289",
    "spec_strength": "unknown",
    "snippet": "    fn insert_node<T: TotalOrder>(node: BalBinTree<T>, value: T) -> (result: BalBinTree<T>)\n        requires tree_is_bst::<T>(node),\n        ensures\n            tree_is_bst::<T>(result),\n            tree_contains(result, value),\n            forall|x: T| #![auto] tree_contains(result, x) <==>\n                (tree_contains(node, x) || x == value),\n        decreases node.spec_size(),"
  },
  {
    "id": 1112,
    "function": "contains_node",
    "file": "Chap37/BSTRBStEph.rs",
    "lines": "411-414",
    "spec_strength": "unknown",
    "snippet": "    fn contains_node<T: TotalOrder>(node: &BalBinTree<T>, target: &T) -> (result: bool)\n        requires tree_is_bst::<T>(*node),\n        ensures result == tree_contains(*node, *target),\n        decreases node.spec_size(),"
  },
  {
    "id": 1113,
    "function": "find_node",
    "file": "Chap37/BSTRBStEph.rs",
    "lines": "444-449",
    "spec_strength": "unknown",
    "snippet": "    fn find_node<'a, T: TotalOrder>(node: &'a BalBinTree<T>, target: &T) -> (result: Option<&'a T>)\n        requires tree_is_bst::<T>(*node),\n        ensures\n            result.is_some() == tree_contains(*node, *target),\n            result.is_some() ==> *result.unwrap() == *target,\n        decreases node.spec_size(),"
  },
  {
    "id": 1114,
    "function": "min_node",
    "file": "Chap37/BSTRBStEph.rs",
    "lines": "479-480",
    "spec_strength": "",
    "snippet": "    fn min_node<T: TotalOrder>(node: &BalBinTree<T>) -> (result: Option<&T>)\n        decreases node.spec_size(),"
  },
  {
    "id": 1115,
    "function": "max_node",
    "file": "Chap37/BSTRBStEph.rs",
    "lines": "494-495",
    "spec_strength": "",
    "snippet": "    fn max_node<T: TotalOrder>(node: &BalBinTree<T>) -> (result: Option<&T>)\n        decreases node.spec_size(),"
  },
  {
    "id": 1116,
    "function": "rb_new",
    "file": "Chap37/BSTRBStEph.rs",
    "lines": "509-512",
    "spec_strength": "unknown",
    "snippet": "    pub fn rb_new<T: TotalOrder>() -> (tree: BSTRBStEph<T>)\n        ensures\n            tree_is_bst::<T>(tree.root),\n            forall|x: T| !tree_contains(tree.root, x),"
  },
  {
    "id": 1117,
    "function": "rb_size",
    "file": "Chap37/BSTRBStEph.rs",
    "lines": "517-519",
    "spec_strength": "unknown",
    "snippet": "    pub fn rb_size<T: TotalOrder>(tree: &BSTRBStEph<T>) -> (n: usize)\n        requires tree.root.spec_size() <= usize::MAX,\n        ensures n == tree.root.spec_size(),"
  },
  {
    "id": 1118,
    "function": "rb_is_empty",
    "file": "Chap37/BSTRBStEph.rs",
    "lines": "524-525",
    "spec_strength": "unknown",
    "snippet": "    pub fn rb_is_empty<T: TotalOrder>(tree: &BSTRBStEph<T>) -> (b: bool)\n        ensures b == (tree.root.spec_size() == 0),"
  },
  {
    "id": 1119,
    "function": "rb_height",
    "file": "Chap37/BSTRBStEph.rs",
    "lines": "530-532",
    "spec_strength": "unknown",
    "snippet": "    pub fn rb_height<T: TotalOrder>(tree: &BSTRBStEph<T>) -> (h: usize)\n        requires tree.root.spec_height() <= usize::MAX,\n        ensures h == tree.root.spec_height(),"
  },
  {
    "id": 1120,
    "function": "rb_insert",
    "file": "Chap37/BSTRBStEph.rs",
    "lines": "537-543",
    "spec_strength": "unknown",
    "snippet": "    pub fn rb_insert<T: TotalOrder>(tree: BSTRBStEph<T>, value: T) -> (result: BSTRBStEph<T>)\n        requires tree_is_bst::<T>(tree.root),\n        ensures\n            tree_is_bst::<T>(result.root),\n            tree_contains(result.root, value),\n            forall|x: T| #![auto] tree_contains(result.root, x) <==>\n                (tree_contains(tree.root, x) || x == value),"
  },
  {
    "id": 1121,
    "function": "rb_contains",
    "file": "Chap37/BSTRBStEph.rs",
    "lines": "548-550",
    "spec_strength": "unknown",
    "snippet": "    pub fn rb_contains<T: TotalOrder>(tree: &BSTRBStEph<T>, target: &T) -> (result: bool)\n        requires tree_is_bst::<T>(tree.root),\n        ensures result == tree_contains(tree.root, *target),"
  },
  {
    "id": 1122,
    "function": "rb_find",
    "file": "Chap37/BSTRBStEph.rs",
    "lines": "555-559",
    "spec_strength": "unknown",
    "snippet": "    pub fn rb_find<'a, T: TotalOrder>(tree: &'a BSTRBStEph<T>, target: &T) -> (result: Option<&'a T>)\n        requires tree_is_bst::<T>(tree.root),\n        ensures\n            result.is_some() == tree_contains(tree.root, *target),\n            result.is_some() ==> *result.unwrap() == *target,"
  },
  {
    "id": 1123,
    "function": "values_vec",
    "file": "Chap37/BSTSetAVLMtEph.rs",
    "lines": "24",
    "spec_strength": "",
    "snippet": "    fn values_vec<T: StTInMtT + Ord>(tree: &BSTAVLMtEph<T>) -> Vec<T> { tree.in_order().iter().cloned().collect() }"
  },
  {
    "id": 1124,
    "function": "rebuild_from_vec",
    "file": "Chap37/BSTSetAVLMtEph.rs",
    "lines": "26",
    "spec_strength": "",
    "snippet": "    fn rebuild_from_vec<T: StTInMtT + Ord>(values: Vec<T>) -> BSTAVLMtEph<T> {"
  },
  {
    "id": 1125,
    "function": "from_sorted_iter",
    "file": "Chap37/BSTSetAVLMtEph.rs",
    "lines": "34-36",
    "spec_strength": "",
    "snippet": "    fn from_sorted_iter<T: StTInMtT + Ord, I>(values: I) -> BSTSetAVLMtEph<T>\n    where\n        I: IntoIterator<Item = T>,"
  },
  {
    "id": 1126,
    "function": "empty",
    "file": "Chap37/BSTSetAVLMtEph.rs",
    "lines": "47",
    "spec_strength": "",
    "snippet": "        fn empty()                                   -> Self;"
  },
  {
    "id": 1127,
    "function": "singleton",
    "file": "Chap37/BSTSetAVLMtEph.rs",
    "lines": "49",
    "spec_strength": "",
    "snippet": "        fn singleton(value: T)                       -> Self;"
  },
  {
    "id": 1128,
    "function": "size",
    "file": "Chap37/BSTSetAVLMtEph.rs",
    "lines": "51",
    "spec_strength": "",
    "snippet": "        fn size(&self)                               -> N;"
  },
  {
    "id": 1129,
    "function": "is_empty",
    "file": "Chap37/BSTSetAVLMtEph.rs",
    "lines": "53",
    "spec_strength": "",
    "snippet": "        fn is_empty(&self)                           -> B;"
  },
  {
    "id": 1130,
    "function": "find",
    "file": "Chap37/BSTSetAVLMtEph.rs",
    "lines": "55",
    "spec_strength": "",
    "snippet": "        fn find(&self, value: &T)                    -> Option<T>;"
  },
  {
    "id": 1131,
    "function": "contains",
    "file": "Chap37/BSTSetAVLMtEph.rs",
    "lines": "57",
    "spec_strength": "",
    "snippet": "        fn contains(&self, value: &T)                -> B;"
  },
  {
    "id": 1132,
    "function": "minimum",
    "file": "Chap37/BSTSetAVLMtEph.rs",
    "lines": "59",
    "spec_strength": "",
    "snippet": "        fn minimum(&self)                            -> Option<T>;"
  },
  {
    "id": 1133,
    "function": "maximum",
    "file": "Chap37/BSTSetAVLMtEph.rs",
    "lines": "61",
    "spec_strength": "",
    "snippet": "        fn maximum(&self)                            -> Option<T>;"
  },
  {
    "id": 1134,
    "function": "insert",
    "file": "Chap37/BSTSetAVLMtEph.rs",
    "lines": "63",
    "spec_strength": "",
    "snippet": "        fn insert(&mut self, value: T);"
  },
  {
    "id": 1135,
    "function": "delete",
    "file": "Chap37/BSTSetAVLMtEph.rs",
    "lines": "65",
    "spec_strength": "",
    "snippet": "        fn delete(&mut self, target: &T);"
  },
  {
    "id": 1136,
    "function": "union",
    "file": "Chap37/BSTSetAVLMtEph.rs",
    "lines": "67",
    "spec_strength": "",
    "snippet": "        fn union(&self, other: &Self)                -> Self;"
  },
  {
    "id": 1137,
    "function": "intersection",
    "file": "Chap37/BSTSetAVLMtEph.rs",
    "lines": "69",
    "spec_strength": "",
    "snippet": "        fn intersection(&self, other: &Self)         -> Self;"
  },
  {
    "id": 1138,
    "function": "difference",
    "file": "Chap37/BSTSetAVLMtEph.rs",
    "lines": "71",
    "spec_strength": "",
    "snippet": "        fn difference(&self, other: &Self)           -> Self;"
  },
  {
    "id": 1139,
    "function": "split",
    "file": "Chap37/BSTSetAVLMtEph.rs",
    "lines": "73",
    "spec_strength": "",
    "snippet": "        fn split(&self, pivot: &T)                   -> (Self, B, Self);"
  },
  {
    "id": 1140,
    "function": "join_pair",
    "file": "Chap37/BSTSetAVLMtEph.rs",
    "lines": "75",
    "spec_strength": "",
    "snippet": "        fn join_pair(left: Self, right: Self)        -> Self;"
  },
  {
    "id": 1141,
    "function": "join_m",
    "file": "Chap37/BSTSetAVLMtEph.rs",
    "lines": "77",
    "spec_strength": "",
    "snippet": "        fn join_m(left: Self, pivot: T, right: Self) -> Self;"
  },
  {
    "id": 1142,
    "function": "filter",
    "file": "Chap37/BSTSetAVLMtEph.rs",
    "lines": "79",
    "spec_strength": "",
    "snippet": "        fn filter<F: FnMut(&T) -> bool + Send>(&self, predicate: F) -> Self;"
  },
  {
    "id": 1143,
    "function": "reduce",
    "file": "Chap37/BSTSetAVLMtEph.rs",
    "lines": "81",
    "spec_strength": "",
    "snippet": "        fn reduce<F: FnMut(T, T) -> T + Send>(&self, op: F, base: T) -> T;"
  },
  {
    "id": 1144,
    "function": "iter_in_order",
    "file": "Chap37/BSTSetAVLMtEph.rs",
    "lines": "83",
    "spec_strength": "",
    "snippet": "        fn iter_in_order(&self)                      -> ArraySeqStPerS<T>;"
  },
  {
    "id": 1145,
    "function": "as_tree",
    "file": "Chap37/BSTSetAVLMtEph.rs",
    "lines": "85",
    "spec_strength": "",
    "snippet": "        fn as_tree(&self)                            -> &BSTAVLMtEph<T>;"
  },
  {
    "id": 1146,
    "function": "empty",
    "file": "Chap37/BSTSetBBAlphaMtEph.rs",
    "lines": "26",
    "spec_strength": "",
    "snippet": "        fn empty()                                   -> Self;"
  },
  {
    "id": 1147,
    "function": "singleton",
    "file": "Chap37/BSTSetBBAlphaMtEph.rs",
    "lines": "28",
    "spec_strength": "",
    "snippet": "        fn singleton(value: T)                       -> Self;"
  },
  {
    "id": 1148,
    "function": "size",
    "file": "Chap37/BSTSetBBAlphaMtEph.rs",
    "lines": "30",
    "spec_strength": "",
    "snippet": "        fn size(&self)                               -> N;"
  },
  {
    "id": 1149,
    "function": "is_empty",
    "file": "Chap37/BSTSetBBAlphaMtEph.rs",
    "lines": "32",
    "spec_strength": "",
    "snippet": "        fn is_empty(&self)                           -> B;"
  },
  {
    "id": 1150,
    "function": "find",
    "file": "Chap37/BSTSetBBAlphaMtEph.rs",
    "lines": "34",
    "spec_strength": "",
    "snippet": "        fn find(&self, value: &T)                    -> Option<T>;"
  },
  {
    "id": 1151,
    "function": "contains",
    "file": "Chap37/BSTSetBBAlphaMtEph.rs",
    "lines": "36",
    "spec_strength": "",
    "snippet": "        fn contains(&self, value: &T)                -> B;"
  },
  {
    "id": 1152,
    "function": "minimum",
    "file": "Chap37/BSTSetBBAlphaMtEph.rs",
    "lines": "38",
    "spec_strength": "",
    "snippet": "        fn minimum(&self)                            -> Option<T>;"
  },
  {
    "id": 1153,
    "function": "maximum",
    "file": "Chap37/BSTSetBBAlphaMtEph.rs",
    "lines": "40",
    "spec_strength": "",
    "snippet": "        fn maximum(&self)                            -> Option<T>;"
  },
  {
    "id": 1154,
    "function": "insert",
    "file": "Chap37/BSTSetBBAlphaMtEph.rs",
    "lines": "42",
    "spec_strength": "",
    "snippet": "        fn insert(&mut self, value: T);"
  },
  {
    "id": 1155,
    "function": "delete",
    "file": "Chap37/BSTSetBBAlphaMtEph.rs",
    "lines": "44",
    "spec_strength": "",
    "snippet": "        fn delete(&mut self, target: &T);"
  },
  {
    "id": 1156,
    "function": "union",
    "file": "Chap37/BSTSetBBAlphaMtEph.rs",
    "lines": "46",
    "spec_strength": "",
    "snippet": "        fn union(&self, other: &Self)                -> Self;"
  },
  {
    "id": 1157,
    "function": "intersection",
    "file": "Chap37/BSTSetBBAlphaMtEph.rs",
    "lines": "48",
    "spec_strength": "",
    "snippet": "        fn intersection(&self, other: &Self)         -> Self;"
  },
  {
    "id": 1158,
    "function": "difference",
    "file": "Chap37/BSTSetBBAlphaMtEph.rs",
    "lines": "50",
    "spec_strength": "",
    "snippet": "        fn difference(&self, other: &Self)           -> Self;"
  },
  {
    "id": 1159,
    "function": "split",
    "file": "Chap37/BSTSetBBAlphaMtEph.rs",
    "lines": "52",
    "spec_strength": "",
    "snippet": "        fn split(&self, pivot: &T)                   -> (Self, B, Self);"
  },
  {
    "id": 1160,
    "function": "join_pair",
    "file": "Chap37/BSTSetBBAlphaMtEph.rs",
    "lines": "54",
    "spec_strength": "",
    "snippet": "        fn join_pair(left: Self, right: Self)        -> Self;"
  },
  {
    "id": 1161,
    "function": "join_m",
    "file": "Chap37/BSTSetBBAlphaMtEph.rs",
    "lines": "56",
    "spec_strength": "",
    "snippet": "        fn join_m(left: Self, pivot: T, right: Self) -> Self;"
  },
  {
    "id": 1162,
    "function": "filter",
    "file": "Chap37/BSTSetBBAlphaMtEph.rs",
    "lines": "58",
    "spec_strength": "",
    "snippet": "        fn filter<F: FnMut(&T) -> bool + Send>(&self, predicate: F) -> Self;"
  },
  {
    "id": 1163,
    "function": "reduce",
    "file": "Chap37/BSTSetBBAlphaMtEph.rs",
    "lines": "60",
    "spec_strength": "",
    "snippet": "        fn reduce<F: FnMut(T, T) -> T + Send>(&self, op: F, base: T) -> T;"
  },
  {
    "id": 1164,
    "function": "iter_in_order",
    "file": "Chap37/BSTSetBBAlphaMtEph.rs",
    "lines": "62",
    "spec_strength": "",
    "snippet": "        fn iter_in_order(&self)                      -> ArraySeqStPerS<T>;"
  },
  {
    "id": 1165,
    "function": "as_tree",
    "file": "Chap37/BSTSetBBAlphaMtEph.rs",
    "lines": "64",
    "spec_strength": "",
    "snippet": "        fn as_tree(&self)                            -> &BSTBBAlphaMtEph<T>;"
  },
  {
    "id": 1166,
    "function": "values_vec",
    "file": "Chap37/BSTSetBBAlphaMtEph.rs",
    "lines": "67",
    "spec_strength": "",
    "snippet": "    fn values_vec<T: StTInMtT + Ord>(tree: &BSTBBAlphaMtEph<T>) -> Vec<T> {"
  },
  {
    "id": 1167,
    "function": "rebuild_from_vec",
    "file": "Chap37/BSTSetBBAlphaMtEph.rs",
    "lines": "70",
    "spec_strength": "",
    "snippet": "    fn rebuild_from_vec<T: StTInMtT + Ord>(values: Vec<T>) -> BSTBBAlphaMtEph<T> {"
  },
  {
    "id": 1168,
    "function": "from_sorted_iter",
    "file": "Chap37/BSTSetBBAlphaMtEph.rs",
    "lines": "75",
    "spec_strength": "",
    "snippet": "    fn from_sorted_iter<T: StTInMtT + Ord, I: IntoIterator<Item = T>>(values: I) -> BSTSetBBAlphaMtEph<T> {"
  },
  {
    "id": 1169,
    "function": "empty",
    "file": "Chap37/BSTSetPlainMtEph.rs",
    "lines": "26",
    "spec_strength": "",
    "snippet": "        fn empty()                                   -> Self;"
  },
  {
    "id": 1170,
    "function": "singleton",
    "file": "Chap37/BSTSetPlainMtEph.rs",
    "lines": "28",
    "spec_strength": "",
    "snippet": "        fn singleton(value: T)                       -> Self;"
  },
  {
    "id": 1171,
    "function": "size",
    "file": "Chap37/BSTSetPlainMtEph.rs",
    "lines": "30",
    "spec_strength": "",
    "snippet": "        fn size(&self)                               -> N;"
  },
  {
    "id": 1172,
    "function": "is_empty",
    "file": "Chap37/BSTSetPlainMtEph.rs",
    "lines": "32",
    "spec_strength": "",
    "snippet": "        fn is_empty(&self)                           -> B;"
  },
  {
    "id": 1173,
    "function": "find",
    "file": "Chap37/BSTSetPlainMtEph.rs",
    "lines": "34",
    "spec_strength": "",
    "snippet": "        fn find(&self, value: &T)                    -> Option<T>;"
  },
  {
    "id": 1174,
    "function": "contains",
    "file": "Chap37/BSTSetPlainMtEph.rs",
    "lines": "36",
    "spec_strength": "",
    "snippet": "        fn contains(&self, value: &T)                -> B;"
  },
  {
    "id": 1175,
    "function": "minimum",
    "file": "Chap37/BSTSetPlainMtEph.rs",
    "lines": "38",
    "spec_strength": "",
    "snippet": "        fn minimum(&self)                            -> Option<T>;"
  },
  {
    "id": 1176,
    "function": "maximum",
    "file": "Chap37/BSTSetPlainMtEph.rs",
    "lines": "40",
    "spec_strength": "",
    "snippet": "        fn maximum(&self)                            -> Option<T>;"
  },
  {
    "id": 1177,
    "function": "insert",
    "file": "Chap37/BSTSetPlainMtEph.rs",
    "lines": "42",
    "spec_strength": "",
    "snippet": "        fn insert(&mut self, value: T);"
  },
  {
    "id": 1178,
    "function": "delete",
    "file": "Chap37/BSTSetPlainMtEph.rs",
    "lines": "44",
    "spec_strength": "",
    "snippet": "        fn delete(&mut self, target: &T);"
  },
  {
    "id": 1179,
    "function": "union",
    "file": "Chap37/BSTSetPlainMtEph.rs",
    "lines": "46",
    "spec_strength": "",
    "snippet": "        fn union(&self, other: &Self)                -> Self;"
  },
  {
    "id": 1180,
    "function": "intersection",
    "file": "Chap37/BSTSetPlainMtEph.rs",
    "lines": "48",
    "spec_strength": "",
    "snippet": "        fn intersection(&self, other: &Self)         -> Self;"
  },
  {
    "id": 1181,
    "function": "difference",
    "file": "Chap37/BSTSetPlainMtEph.rs",
    "lines": "50",
    "spec_strength": "",
    "snippet": "        fn difference(&self, other: &Self)           -> Self;"
  },
  {
    "id": 1182,
    "function": "split",
    "file": "Chap37/BSTSetPlainMtEph.rs",
    "lines": "52",
    "spec_strength": "",
    "snippet": "        fn split(&self, pivot: &T)                   -> (Self, B, Self);"
  },
  {
    "id": 1183,
    "function": "join_pair",
    "file": "Chap37/BSTSetPlainMtEph.rs",
    "lines": "54",
    "spec_strength": "",
    "snippet": "        fn join_pair(left: Self, right: Self)        -> Self;"
  },
  {
    "id": 1184,
    "function": "join_m",
    "file": "Chap37/BSTSetPlainMtEph.rs",
    "lines": "56",
    "spec_strength": "",
    "snippet": "        fn join_m(left: Self, pivot: T, right: Self) -> Self;"
  },
  {
    "id": 1185,
    "function": "filter",
    "file": "Chap37/BSTSetPlainMtEph.rs",
    "lines": "58",
    "spec_strength": "",
    "snippet": "        fn filter<F: FnMut(&T) -> bool + Send>(&self, predicate: F) -> Self;"
  },
  {
    "id": 1186,
    "function": "reduce",
    "file": "Chap37/BSTSetPlainMtEph.rs",
    "lines": "60",
    "spec_strength": "",
    "snippet": "        fn reduce<F: FnMut(T, T) -> T + Send>(&self, op: F, base: T) -> T;"
  },
  {
    "id": 1187,
    "function": "iter_in_order",
    "file": "Chap37/BSTSetPlainMtEph.rs",
    "lines": "62",
    "spec_strength": "",
    "snippet": "        fn iter_in_order(&self)                      -> ArraySeqStPerS<T>;"
  },
  {
    "id": 1188,
    "function": "as_tree",
    "file": "Chap37/BSTSetPlainMtEph.rs",
    "lines": "64",
    "spec_strength": "",
    "snippet": "        fn as_tree(&self)                            -> &BSTPlainMtEph<T>;"
  },
  {
    "id": 1189,
    "function": "values_vec",
    "file": "Chap37/BSTSetPlainMtEph.rs",
    "lines": "67",
    "spec_strength": "",
    "snippet": "    fn values_vec<T: StTInMtT + Ord>(tree: &BSTPlainMtEph<T>) -> Vec<T> {"
  },
  {
    "id": 1190,
    "function": "rebuild_from_vec",
    "file": "Chap37/BSTSetPlainMtEph.rs",
    "lines": "70",
    "spec_strength": "",
    "snippet": "    fn rebuild_from_vec<T: StTInMtT + Ord>(values: Vec<T>) -> BSTPlainMtEph<T> {"
  },
  {
    "id": 1191,
    "function": "from_sorted_iter",
    "file": "Chap37/BSTSetPlainMtEph.rs",
    "lines": "75",
    "spec_strength": "",
    "snippet": "    fn from_sorted_iter<T: StTInMtT + Ord, I: IntoIterator<Item = T>>(values: I) -> BSTSetPlainMtEph<T> {"
  },
  {
    "id": 1192,
    "function": "empty",
    "file": "Chap37/BSTSetRBMtEph.rs",
    "lines": "26",
    "spec_strength": "",
    "snippet": "        fn empty()                                   -> Self;"
  },
  {
    "id": 1193,
    "function": "singleton",
    "file": "Chap37/BSTSetRBMtEph.rs",
    "lines": "28",
    "spec_strength": "",
    "snippet": "        fn singleton(value: T)                       -> Self;"
  },
  {
    "id": 1194,
    "function": "size",
    "file": "Chap37/BSTSetRBMtEph.rs",
    "lines": "30",
    "spec_strength": "",
    "snippet": "        fn size(&self)                               -> N;"
  },
  {
    "id": 1195,
    "function": "is_empty",
    "file": "Chap37/BSTSetRBMtEph.rs",
    "lines": "32",
    "spec_strength": "",
    "snippet": "        fn is_empty(&self)                           -> B;"
  },
  {
    "id": 1196,
    "function": "find",
    "file": "Chap37/BSTSetRBMtEph.rs",
    "lines": "34",
    "spec_strength": "",
    "snippet": "        fn find(&self, value: &T)                    -> Option<T>;"
  },
  {
    "id": 1197,
    "function": "contains",
    "file": "Chap37/BSTSetRBMtEph.rs",
    "lines": "36",
    "spec_strength": "",
    "snippet": "        fn contains(&self, value: &T)                -> B;"
  },
  {
    "id": 1198,
    "function": "minimum",
    "file": "Chap37/BSTSetRBMtEph.rs",
    "lines": "38",
    "spec_strength": "",
    "snippet": "        fn minimum(&self)                            -> Option<T>;"
  },
  {
    "id": 1199,
    "function": "maximum",
    "file": "Chap37/BSTSetRBMtEph.rs",
    "lines": "40",
    "spec_strength": "",
    "snippet": "        fn maximum(&self)                            -> Option<T>;"
  },
  {
    "id": 1200,
    "function": "insert",
    "file": "Chap37/BSTSetRBMtEph.rs",
    "lines": "42",
    "spec_strength": "",
    "snippet": "        fn insert(&mut self, value: T);"
  },
  {
    "id": 1201,
    "function": "delete",
    "file": "Chap37/BSTSetRBMtEph.rs",
    "lines": "44",
    "spec_strength": "",
    "snippet": "        fn delete(&mut self, target: &T);"
  },
  {
    "id": 1202,
    "function": "union",
    "file": "Chap37/BSTSetRBMtEph.rs",
    "lines": "46",
    "spec_strength": "",
    "snippet": "        fn union(&self, other: &Self)                -> Self;"
  },
  {
    "id": 1203,
    "function": "intersection",
    "file": "Chap37/BSTSetRBMtEph.rs",
    "lines": "48",
    "spec_strength": "",
    "snippet": "        fn intersection(&self, other: &Self)         -> Self;"
  },
  {
    "id": 1204,
    "function": "difference",
    "file": "Chap37/BSTSetRBMtEph.rs",
    "lines": "50",
    "spec_strength": "",
    "snippet": "        fn difference(&self, other: &Self)           -> Self;"
  },
  {
    "id": 1205,
    "function": "split",
    "file": "Chap37/BSTSetRBMtEph.rs",
    "lines": "52",
    "spec_strength": "",
    "snippet": "        fn split(&self, pivot: &T)                   -> (Self, B, Self);"
  },
  {
    "id": 1206,
    "function": "join_pair",
    "file": "Chap37/BSTSetRBMtEph.rs",
    "lines": "54",
    "spec_strength": "",
    "snippet": "        fn join_pair(left: Self, right: Self)        -> Self;"
  },
  {
    "id": 1207,
    "function": "join_m",
    "file": "Chap37/BSTSetRBMtEph.rs",
    "lines": "56",
    "spec_strength": "",
    "snippet": "        fn join_m(left: Self, pivot: T, right: Self) -> Self;"
  },
  {
    "id": 1208,
    "function": "filter",
    "file": "Chap37/BSTSetRBMtEph.rs",
    "lines": "58",
    "spec_strength": "",
    "snippet": "        fn filter<F: FnMut(&T) -> bool + Send>(&self, predicate: F) -> Self;"
  },
  {
    "id": 1209,
    "function": "reduce",
    "file": "Chap37/BSTSetRBMtEph.rs",
    "lines": "60",
    "spec_strength": "",
    "snippet": "        fn reduce<F: FnMut(T, T) -> T + Send>(&self, op: F, base: T) -> T;"
  },
  {
    "id": 1210,
    "function": "iter_in_order",
    "file": "Chap37/BSTSetRBMtEph.rs",
    "lines": "62",
    "spec_strength": "",
    "snippet": "        fn iter_in_order(&self)                      -> ArraySeqStPerS<T>;"
  },
  {
    "id": 1211,
    "function": "as_tree",
    "file": "Chap37/BSTSetRBMtEph.rs",
    "lines": "64",
    "spec_strength": "",
    "snippet": "        fn as_tree(&self)                            -> &BSTRBMtEph<T>;"
  },
  {
    "id": 1212,
    "function": "values_vec",
    "file": "Chap37/BSTSetRBMtEph.rs",
    "lines": "67",
    "spec_strength": "",
    "snippet": "    fn values_vec<T: StTInMtT + Ord>(tree: &BSTRBMtEph<T>) -> Vec<T> {"
  },
  {
    "id": 1213,
    "function": "from_sorted_iter",
    "file": "Chap37/BSTSetRBMtEph.rs",
    "lines": "70",
    "spec_strength": "",
    "snippet": "    fn from_sorted_iter<T: StTInMtT + Ord, I: IntoIterator<Item = T>>(values: I) -> BSTSetRBMtEph<T> {"
  },
  {
    "id": 1214,
    "function": "empty",
    "file": "Chap37/BSTSetSplayMtEph.rs",
    "lines": "26",
    "spec_strength": "",
    "snippet": "        fn empty()                                   -> Self;"
  },
  {
    "id": 1215,
    "function": "singleton",
    "file": "Chap37/BSTSetSplayMtEph.rs",
    "lines": "28",
    "spec_strength": "",
    "snippet": "        fn singleton(value: T)                       -> Self;"
  },
  {
    "id": 1216,
    "function": "size",
    "file": "Chap37/BSTSetSplayMtEph.rs",
    "lines": "30",
    "spec_strength": "",
    "snippet": "        fn size(&self)                               -> N;"
  },
  {
    "id": 1217,
    "function": "is_empty",
    "file": "Chap37/BSTSetSplayMtEph.rs",
    "lines": "32",
    "spec_strength": "",
    "snippet": "        fn is_empty(&self)                           -> B;"
  },
  {
    "id": 1218,
    "function": "find",
    "file": "Chap37/BSTSetSplayMtEph.rs",
    "lines": "34",
    "spec_strength": "",
    "snippet": "        fn find(&self, value: &T)                    -> Option<T>;"
  },
  {
    "id": 1219,
    "function": "contains",
    "file": "Chap37/BSTSetSplayMtEph.rs",
    "lines": "36",
    "spec_strength": "",
    "snippet": "        fn contains(&self, value: &T)                -> B;"
  },
  {
    "id": 1220,
    "function": "minimum",
    "file": "Chap37/BSTSetSplayMtEph.rs",
    "lines": "38",
    "spec_strength": "",
    "snippet": "        fn minimum(&self)                            -> Option<T>;"
  },
  {
    "id": 1221,
    "function": "maximum",
    "file": "Chap37/BSTSetSplayMtEph.rs",
    "lines": "40",
    "spec_strength": "",
    "snippet": "        fn maximum(&self)                            -> Option<T>;"
  },
  {
    "id": 1222,
    "function": "insert",
    "file": "Chap37/BSTSetSplayMtEph.rs",
    "lines": "42",
    "spec_strength": "",
    "snippet": "        fn insert(&mut self, value: T);"
  },
  {
    "id": 1223,
    "function": "delete",
    "file": "Chap37/BSTSetSplayMtEph.rs",
    "lines": "44",
    "spec_strength": "",
    "snippet": "        fn delete(&mut self, target: &T);"
  },
  {
    "id": 1224,
    "function": "union",
    "file": "Chap37/BSTSetSplayMtEph.rs",
    "lines": "46",
    "spec_strength": "",
    "snippet": "        fn union(&self, other: &Self)                -> Self;"
  },
  {
    "id": 1225,
    "function": "intersection",
    "file": "Chap37/BSTSetSplayMtEph.rs",
    "lines": "48",
    "spec_strength": "",
    "snippet": "        fn intersection(&self, other: &Self)         -> Self;"
  },
  {
    "id": 1226,
    "function": "difference",
    "file": "Chap37/BSTSetSplayMtEph.rs",
    "lines": "50",
    "spec_strength": "",
    "snippet": "        fn difference(&self, other: &Self)           -> Self;"
  },
  {
    "id": 1227,
    "function": "split",
    "file": "Chap37/BSTSetSplayMtEph.rs",
    "lines": "52",
    "spec_strength": "",
    "snippet": "        fn split(&self, pivot: &T)                   -> (Self, B, Self);"
  },
  {
    "id": 1228,
    "function": "join_pair",
    "file": "Chap37/BSTSetSplayMtEph.rs",
    "lines": "54",
    "spec_strength": "",
    "snippet": "        fn join_pair(left: Self, right: Self)        -> Self;"
  },
  {
    "id": 1229,
    "function": "join_m",
    "file": "Chap37/BSTSetSplayMtEph.rs",
    "lines": "56",
    "spec_strength": "",
    "snippet": "        fn join_m(left: Self, pivot: T, right: Self) -> Self;"
  },
  {
    "id": 1230,
    "function": "filter",
    "file": "Chap37/BSTSetSplayMtEph.rs",
    "lines": "58",
    "spec_strength": "",
    "snippet": "        fn filter<F: FnMut(&T) -> bool + Send>(&self, predicate: F) -> Self;"
  },
  {
    "id": 1231,
    "function": "reduce",
    "file": "Chap37/BSTSetSplayMtEph.rs",
    "lines": "60",
    "spec_strength": "",
    "snippet": "        fn reduce<F: FnMut(T, T) -> T + Send>(&self, op: F, base: T) -> T;"
  },
  {
    "id": 1232,
    "function": "iter_in_order",
    "file": "Chap37/BSTSetSplayMtEph.rs",
    "lines": "62",
    "spec_strength": "",
    "snippet": "        fn iter_in_order(&self)                      -> ArraySeqStPerS<T>;"
  },
  {
    "id": 1233,
    "function": "as_tree",
    "file": "Chap37/BSTSetSplayMtEph.rs",
    "lines": "64",
    "spec_strength": "",
    "snippet": "        fn as_tree(&self)                            -> &BSTSplayMtEph<T>;"
  },
  {
    "id": 1234,
    "function": "values_vec",
    "file": "Chap37/BSTSetSplayMtEph.rs",
    "lines": "67",
    "spec_strength": "",
    "snippet": "    fn values_vec<T: StTInMtT + Ord>(tree: &BSTSplayMtEph<T>) -> Vec<T> {"
  },
  {
    "id": 1235,
    "function": "from_sorted_iter",
    "file": "Chap37/BSTSetSplayMtEph.rs",
    "lines": "71",
    "spec_strength": "",
    "snippet": "    fn from_sorted_iter<T: StTInMtT + Ord, I: IntoIterator<Item = T>>(values: I) -> BSTSetSplayMtEph<T> {"
  },
  {
    "id": 1236,
    "function": "new_splay_link_lock",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "351",
    "spec_strength": "hole",
    "snippet": "        fn new_splay_link_lock<T: StTInMtT + Ord>(val: Link<T>) -> (lock: RwLock<Link<T>, SplayLinkWf>) {"
  },
  {
    "id": 1237,
    "function": "new_node",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "24-31",
    "spec_strength": "",
    "snippet": "    fn new_node<T: StTInMtT + Ord>(key: T) -> Node<T> {\n        Node {\n            key,\n            size: 1,\n            left: None,\n            right: None,\n        }\n    }"
  },
  {
    "id": 1238,
    "function": "size_link",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "33",
    "spec_strength": "",
    "snippet": "    fn size_link<T: StTInMtT + Ord>(link: &Link<T>) -> N { link.as_ref().map_or(0, |n| n.size) }"
  },
  {
    "id": 1239,
    "function": "update",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "35",
    "spec_strength": "",
    "snippet": "    fn update<T: StTInMtT + Ord>(node: &mut Node<T>) { node.size = 1 + size_link(&node.left) + size_link(&node.right); }"
  },
  {
    "id": 1240,
    "function": "splay",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "37-148",
    "spec_strength": "",
    "snippet": "    fn splay<T: StTInMtT + Ord>(root: Box<Node<T>>, target: &T) -> Box<Node<T>> {\n        let mut root = root;\n        match target.cmp(&root.key) {\n            std::cmp::Ordering::Equal => root,\n            std::cmp::Ordering::Less => {\n                let Some(mut left) = root.left.take() else { return root };\n                match target.cmp(&left.key) {\n                    std::cmp::Ordering::Equal => {\n                        root.left = left.right.take();\n                        update(&mut root);\n                        left.right = Some(root);\n                        update(&mut left);\n                        left\n                    }\n                    std::cmp::Ordering::Less => {\n                        if let Some(ll) = left.left.take() {\n                            left.left = Some(splay(ll, target));\n                        }\n                        root.left = left.right.take();\n                        update(&mut root);\n                        left.right = Some(root);\n                        update(&mut left);\n                        if let Some(mut ll) = left.left.take() {\n                            left.left = ll.right.take();\n                            update(&mut left);\n                            ll.right = Some(left);\n                            update(&mut ll);\n                            ll\n                        } else {\n                            left\n                        }\n                    }\n                    std::cmp::Ordering::Greater => {\n                        if let Some(lr) = left.right.take() {\n                            left.right = Some(splay(lr, target));\n                        }\n                        if left.right.is_some() {\n                            let mut lr = left.right.take().unwrap();\n                            left.right = lr.left.take();\n                            update(&mut left);\n                            lr.left = Some(left);\n                            update(&mut lr);\n                            root.left = lr.right.take();\n                            update(&mut root);\n                            lr.right = Some(root);\n                            update(&mut lr);\n                            lr\n                        } else {\n                            root.left = left.right.take();\n                            update(&mut root);\n                            left.right = Some(root);\n                            update(&mut left);\n                            left\n                        }\n                    }\n                }\n            }\n            std::cmp::Ordering::Greater => {\n                let Some(mut right) = root.right.take() else { return root };\n                match target.cmp(&right.key) {\n                    std::cmp::Ordering::Equal => {\n                        root.right = right.left.take();\n                        update(&mut root);\n                        right.left = Some(root);\n                        update(&mut right);\n                        right\n                    }\n                    std::cmp::Ordering::Greater => {\n                        if let Some(rr) = right.right.take() {\n                            right.right = Some(splay(rr, target));\n                        }\n                        root.right = right.left.take();\n                        update(&mut root);\n                        right.left = Some(root);\n                        update(&mut right);\n                        if let Some(mut rr) = right.right.take() {\n                            right.right = rr.left.take();\n                            update(&mut right);\n                            rr.left = Some(right);\n                            update(&mut rr);\n                            rr\n                        } else {\n                            right\n                        }\n                    }\n                    std::cmp::Ordering::Less => {\n                        if let Some(rl) = right.left.take() {\n                            right.left = Some(splay(rl, target));\n                        }\n                        if right.left.is_some() {\n                            let mut rl = right.left.take().unwrap();\n                            right.left = rl.right.take();\n                            update(&mut right);\n                            rl.right = Some(right);\n                            update(&mut rl);\n                            root.right = rl.left.take();\n                            update(&mut root);\n                            rl.left = Some(root);\n                            update(&mut rl);\n                            rl\n                        } else {\n                            root.right = right.left.take();\n                            update(&mut root);\n                            right.left = Some(root);\n                            update(&mut right);\n                            right\n                        }\n                    }\n                }\n            }\n        }\n    }"
  },
  {
    "id": 1241,
    "function": "bst_insert",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "150-168",
    "spec_strength": "",
    "snippet": "    fn bst_insert<T: StTInMtT + Ord>(link: &mut Link<T>, value: T) -> bool {\n        match link {\n            | Some(node) => {\n                let inserted = if value < node.key {\n                    bst_insert(&mut node.left, value)\n                } else if value > node.key {\n                    bst_insert(&mut node.right, value)\n                } else {\n                    false\n                };\n                if inserted { update(node); }\n                inserted\n            }\n            | None => {\n                *link = Some(Box::new(new_node(value)));\n                true\n            }\n        }\n    }"
  },
  {
    "id": 1242,
    "function": "insert_link",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "170-179",
    "spec_strength": "",
    "snippet": "    fn insert_link<T: StTInMtT + Ord>(link: &mut Link<T>, value: T) -> bool {\n        let v = value.clone();\n        let inserted = bst_insert(link, value);\n        if inserted {\n            if let Some(root) = link.take() {\n                *link = Some(splay(root, &v));\n            }\n        }\n        inserted\n    }"
  },
  {
    "id": 1243,
    "function": "find_link",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "181-194",
    "spec_strength": "",
    "snippet": "    fn find_link<'a, T: StTInMtT + Ord>(link: &'a Link<T>, target: &T) -> Option<&'a T> {\n        match link {\n            | None => None,\n            | Some(node) => {\n                if *target == node.key {\n                    Some(&node.key)\n                } else if *target < node.key {\n                    find_link(&node.left, target)\n                } else {\n                    find_link(&node.right, target)\n                }\n            }\n        }\n    }"
  },
  {
    "id": 1244,
    "function": "min_link",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "196-204",
    "spec_strength": "",
    "snippet": "    fn min_link<T: StTInMtT + Ord>(link: &Link<T>) -> Option<&T> {\n        match link {\n            | None => None,\n            | Some(node) => match node.left {\n                | None => Some(&node.key),\n                | Some(_) => min_link(&node.left),\n            },\n        }\n    }"
  },
  {
    "id": 1245,
    "function": "max_link",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "206-214",
    "spec_strength": "",
    "snippet": "    fn max_link<T: StTInMtT + Ord>(link: &Link<T>) -> Option<&T> {\n        match link {\n            | None => None,\n            | Some(node) => match node.right {\n                | None => Some(&node.key),\n                | Some(_) => max_link(&node.right),\n            },\n        }\n    }"
  },
  {
    "id": 1246,
    "function": "in_order_collect",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "216-222",
    "spec_strength": "",
    "snippet": "    fn in_order_collect<T: StTInMtT + Ord>(link: &Link<T>, out: &mut Vec<T>) {\n        if let Some(node) = link {\n            in_order_collect(&node.left, out);\n            out.push(node.key.clone());\n            in_order_collect(&node.right, out);\n        }\n    }"
  },
  {
    "id": 1247,
    "function": "pre_order_collect",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "224-230",
    "spec_strength": "",
    "snippet": "    fn pre_order_collect<T: StTInMtT + Ord>(link: &Link<T>, out: &mut Vec<T>) {\n        if let Some(node) = link {\n            out.push(node.key.clone());\n            pre_order_collect(&node.left, out);\n            pre_order_collect(&node.right, out);\n        }\n    }"
  },
  {
    "id": 1248,
    "function": "in_order_parallel",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "234-249",
    "spec_strength": "",
    "snippet": "    fn in_order_parallel<T: StTInMtT + Ord>(link: &Link<T>) -> Vec<T> {\n        match link {\n            | None => Vec::new(),\n            | Some(node) => {\n                use crate::Types::Types::Pair;\n                let Pair(left_vec, right_vec) = crate::ParaPair!(\n                    move || in_order_parallel(&node.left),\n                    move || in_order_parallel(&node.right)\n                );\n                let mut result = left_vec;\n                result.push(node.key.clone());\n                result.extend(right_vec);\n                result\n            }\n        }\n    }"
  },
  {
    "id": 1249,
    "function": "pre_order_parallel",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "251-266",
    "spec_strength": "",
    "snippet": "    fn pre_order_parallel<T: StTInMtT + Ord>(link: &Link<T>) -> Vec<T> {\n        match link {\n            | None => Vec::new(),\n            | Some(node) => {\n                use crate::Types::Types::Pair;\n                let Pair(left_vec, right_vec) = crate::ParaPair!(\n                    move || pre_order_parallel(&node.left),\n                    move || pre_order_parallel(&node.right)\n                );\n                let mut result = vec![node.key.clone()];\n                result.extend(left_vec);\n                result.extend(right_vec);\n                result\n            }\n        }\n    }"
  },
  {
    "id": 1250,
    "function": "build_balanced",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "268-286",
    "spec_strength": "",
    "snippet": "    // Parallel construction from sorted slice\n    fn build_balanced<T: StTInMtT + Ord>(values: &[T]) -> Link<T> {\n        if values.is_empty() {\n            return None;\n        }\n        let mid = values.len() / 2;\n        \n        use crate::Types::Types::Pair;\n        let Pair(left, right) = crate::ParaPair!(\n            move || build_balanced(&values[..mid]),\n            move || build_balanced(&values[mid + 1..])\n        );\n        \n        let mut node = Box::new(new_node(values[mid].clone()));\n        node.left = left;\n        node.right = right;\n        update(&mut node);\n        Some(node)\n    }"
  },
  {
    "id": 1251,
    "function": "filter_parallel",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "288-313",
    "spec_strength": "",
    "snippet": "    // Parallel filter\n    fn filter_parallel<T: StTInMtT + Ord, F>(link: &Link<T>, predicate: &Arc<F>) -> Vec<T>\n    where\n        F: Fn(&T) -> bool + Send + Sync,\n    {\n        match link {\n            | None => Vec::new(),\n            | Some(node) => {\n                let pred_left = Arc::clone(predicate);\n                let pred_right = Arc::clone(predicate);\n                \n                use crate::Types::Types::Pair;\n                let Pair(left_vals, right_vals) = crate::ParaPair!(\n                    move || filter_parallel(&node.left, &pred_left),\n                    move || filter_parallel(&node.right, &pred_right)\n                );\n                \n                let mut result = left_vals;\n                if predicate(&node.key) {\n                    result.push(node.key.clone());\n                }\n                result.extend(right_vals);\n                result\n            }\n        }\n    }"
  },
  {
    "id": 1252,
    "function": "reduce_parallel",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "315-337",
    "spec_strength": "",
    "snippet": "    // Parallel reduce\n    fn reduce_parallel<T: StTInMtT + Ord, F>(link: &Link<T>, op: &Arc<F>, identity: T) -> T\n    where\n        F: Fn(T, T) -> T + Send + Sync,\n    {\n        match link {\n            | None => identity,\n            | Some(node) => {\n                let op_left = Arc::clone(op);\n                let op_right = Arc::clone(op);\n                let id_left = identity.clone();\n                \n                use crate::Types::Types::Pair;\n                let Pair(left_acc, right_acc) = crate::ParaPair!(\n                    move || reduce_parallel(&node.left, &op_left, id_left),\n                    move || reduce_parallel(&node.right, &op_right, identity)\n                );\n                \n                let with_key = op(left_acc, node.key.clone());\n                op(with_key, right_acc)\n            }\n        }\n    }"
  },
  {
    "id": 1253,
    "function": "new",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "370-371",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work (1), Span (1)\n        fn new()                       -> Self;"
  },
  {
    "id": 1254,
    "function": "from_sorted_slice",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "372-373",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work (n), Span (log n) - Parallel construction from sorted slice\n        fn from_sorted_slice(values: &[T]) -> Self;"
  },
  {
    "id": 1255,
    "function": "insert",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "374-375",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work (log n) amortized, (n) worst case; Span (log n) amortized with locking\n        fn insert(&self, value: T);"
  },
  {
    "id": 1256,
    "function": "find",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "376-377",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work (log n) amortized, (n) worst case; Span (log n) amortized with locking\n        fn find(&self, target: &T)     -> Option<T>;"
  },
  {
    "id": 1257,
    "function": "contains",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "378-379",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work (log n) amortized, (n) worst case; Span (log n) amortized with locking\n        fn contains(&self, target: &T) -> B;"
  },
  {
    "id": 1258,
    "function": "size",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "380-381",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work (1), Span (1)\n        fn size(&self)                 -> N;"
  },
  {
    "id": 1259,
    "function": "is_empty",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "382-383",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work (1), Span (1)\n        fn is_empty(&self)             -> B;"
  },
  {
    "id": 1260,
    "function": "height",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "384-385",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work (n), Span (n)\n        fn height(&self)               -> N;"
  },
  {
    "id": 1261,
    "function": "minimum",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "386-387",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work (log n) amortized, (n) worst case; Span (log n) amortized with locking\n        fn minimum(&self)              -> Option<T>;"
  },
  {
    "id": 1262,
    "function": "maximum",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "388-389",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work (log n) amortized, (n) worst case; Span (log n) amortized with locking\n        fn maximum(&self)              -> Option<T>;"
  },
  {
    "id": 1263,
    "function": "in_order",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "390-391",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work (n), Span (log n) - Parallel traversal\n        fn in_order(&self)             -> ArraySeqStPerS<T>;"
  },
  {
    "id": 1264,
    "function": "pre_order",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "392-393",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work (n), Span (log n) - Parallel traversal\n        fn pre_order(&self)            -> ArraySeqStPerS<T>;"
  },
  {
    "id": 1265,
    "function": "filter",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "394-397",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work (n), Span (log n) - Parallel filter\n        fn filter<F>(&self, predicate: F) -> ArraySeqStPerS<T>\n        where\n            F: Fn(&T) -> bool + Send + Sync;"
  },
  {
    "id": 1266,
    "function": "reduce",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "398-401",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work (n), Span (log n) - Parallel reduce\n        fn reduce<F>(&self, op: F, identity: T) -> T\n        where\n            F: Fn(T, T) -> T + Send + Sync;"
  },
  {
    "id": 1267,
    "function": "height_rec",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "436-441",
    "spec_strength": "",
    "snippet": "            fn height_rec<T: StTInMtT + Ord>(link: &Link<T>) -> N {\n                match link {\n                    | None => 0,\n                    | Some(node) => 1 + height_rec(&node.left).max(height_rec(&node.right)),\n                }\n            }"
  },
  {
    "id": 1268,
    "function": "default",
    "file": "Chap37/BSTSplayMtEph.rs",
    "lines": "506",
    "spec_strength": "",
    "snippet": "        fn default() -> Self { Self::new() }"
  },
  {
    "id": 1269,
    "function": "new_node",
    "file": "Chap37/BSTSplayStEph.rs",
    "lines": "36",
    "spec_strength": "",
    "snippet": "    fn new_node<T: StT + Ord>(key: T) -> Node<T> {"
  },
  {
    "id": 1270,
    "function": "size_link",
    "file": "Chap37/BSTSplayStEph.rs",
    "lines": "54",
    "spec_strength": "",
    "snippet": "    fn size_link<T: StT + Ord>(link: &Link<T>) -> N {"
  },
  {
    "id": 1271,
    "function": "height_link",
    "file": "Chap37/BSTSplayStEph.rs",
    "lines": "61-63",
    "spec_strength": "hole",
    "snippet": "    fn height_link<T: StT + Ord>(link: &Link<T>) -> N\n        requires spec_size_link(link) < usize::MAX as nat,\n        decreases *link,"
  },
  {
    "id": 1272,
    "function": "update",
    "file": "Chap37/BSTSplayStEph.rs",
    "lines": "84",
    "spec_strength": "hole",
    "snippet": "    fn update<T: StT + Ord>(node: &mut Node<T>) {"
  },
  {
    "id": 1273,
    "function": "splay",
    "file": "Chap37/BSTSplayStEph.rs",
    "lines": "90-91",
    "spec_strength": "",
    "snippet": "    fn splay<T: StT + Ord>(root: Box<Node<T>>, target: &T) -> Box<Node<T>>\n        decreases root,"
  },
  {
    "id": 1274,
    "function": "bst_insert",
    "file": "Chap37/BSTSplayStEph.rs",
    "lines": "212",
    "spec_strength": "hole",
    "snippet": "    fn bst_insert<T: StT + Ord>(link: &mut Link<T>, value: T) -> bool {"
  },
  {
    "id": 1275,
    "function": "insert_link",
    "file": "Chap37/BSTSplayStEph.rs",
    "lines": "233-234",
    "spec_strength": "hole",
    "snippet": "    fn insert_link<T: StT + Ord>(link: &mut Link<T>, value: T) -> bool\n        decreases old(link),"
  },
  {
    "id": 1276,
    "function": "find_link",
    "file": "Chap37/BSTSplayStEph.rs",
    "lines": "246-247",
    "spec_strength": "",
    "snippet": "    fn find_link<'a, T: StT + Ord>(link: &'a Link<T>, target: &T) -> Option<&'a T>\n        decreases *link,"
  },
  {
    "id": 1277,
    "function": "min_link",
    "file": "Chap37/BSTSplayStEph.rs",
    "lines": "263-264",
    "spec_strength": "",
    "snippet": "    fn min_link<T: StT + Ord>(link: &Link<T>) -> Option<&T>\n        decreases *link,"
  },
  {
    "id": 1278,
    "function": "max_link",
    "file": "Chap37/BSTSplayStEph.rs",
    "lines": "275-276",
    "spec_strength": "",
    "snippet": "    fn max_link<T: StT + Ord>(link: &Link<T>) -> Option<&T>\n        decreases *link,"
  },
  {
    "id": 1279,
    "function": "in_order_collect",
    "file": "Chap37/BSTSplayStEph.rs",
    "lines": "287-288",
    "spec_strength": "",
    "snippet": "    fn in_order_collect<T: StT + Ord>(link: &Link<T>, out: &mut Vec<T>)\n        decreases *link,"
  },
  {
    "id": 1280,
    "function": "pre_order_collect",
    "file": "Chap37/BSTSplayStEph.rs",
    "lines": "297-298",
    "spec_strength": "",
    "snippet": "    fn pre_order_collect<T: StT + Ord>(link: &Link<T>, out: &mut Vec<T>)\n        decreases *link,"
  },
  {
    "id": 1281,
    "function": "new",
    "file": "Chap37/BSTSplayStEph.rs",
    "lines": "325-327",
    "spec_strength": "",
    "snippet": "        fn new()                       -> Self\n        where\n            Self: Sized;"
  },
  {
    "id": 1282,
    "function": "size",
    "file": "Chap37/BSTSplayStEph.rs",
    "lines": "329",
    "spec_strength": "",
    "snippet": "        fn size(&self)                 -> N;"
  },
  {
    "id": 1283,
    "function": "is_empty",
    "file": "Chap37/BSTSplayStEph.rs",
    "lines": "331",
    "spec_strength": "",
    "snippet": "        fn is_empty(&self)             -> B;"
  },
  {
    "id": 1284,
    "function": "height",
    "file": "Chap37/BSTSplayStEph.rs",
    "lines": "333-334",
    "spec_strength": "unknown",
    "snippet": "        fn height(&self)               -> N\n            requires self.spec_size() < usize::MAX as nat;"
  },
  {
    "id": 1285,
    "function": "insert",
    "file": "Chap37/BSTSplayStEph.rs",
    "lines": "336",
    "spec_strength": "",
    "snippet": "        fn insert(&mut self, value: T);"
  },
  {
    "id": 1286,
    "function": "find",
    "file": "Chap37/BSTSplayStEph.rs",
    "lines": "338",
    "spec_strength": "",
    "snippet": "        fn find(&self, target: &T)     -> Option<&T>;"
  },
  {
    "id": 1287,
    "function": "contains",
    "file": "Chap37/BSTSplayStEph.rs",
    "lines": "340",
    "spec_strength": "",
    "snippet": "        fn contains(&self, target: &T) -> B;"
  },
  {
    "id": 1288,
    "function": "minimum",
    "file": "Chap37/BSTSplayStEph.rs",
    "lines": "342",
    "spec_strength": "",
    "snippet": "        fn minimum(&self)              -> Option<&T>;"
  },
  {
    "id": 1289,
    "function": "maximum",
    "file": "Chap37/BSTSplayStEph.rs",
    "lines": "344",
    "spec_strength": "",
    "snippet": "        fn maximum(&self)              -> Option<&T>;"
  },
  {
    "id": 1290,
    "function": "in_order",
    "file": "Chap37/BSTSplayStEph.rs",
    "lines": "346",
    "spec_strength": "hole",
    "snippet": "        fn in_order(&self)             -> ArraySeqStPerS<T>;"
  },
  {
    "id": 1291,
    "function": "pre_order",
    "file": "Chap37/BSTSplayStEph.rs",
    "lines": "348",
    "spec_strength": "hole",
    "snippet": "        fn pre_order(&self)            -> ArraySeqStPerS<T>;"
  },
  {
    "id": 1292,
    "function": "default",
    "file": "Chap37/BSTSplayStEph.rs",
    "lines": "390",
    "spec_strength": "",
    "snippet": "        fn default() -> Self { Self::new() }"
  },
  {
    "id": 1293,
    "function": "new_bst_para_lock",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "47",
    "spec_strength": "hole",
    "snippet": "        fn new_bst_para_lock<T: MtKey>(val: Option<Box<NodeInner<T>>>) -> (lock: RwLock<Option<Box<NodeInner<T>>>, BstParaWf>) {"
  },
  {
    "id": 1294,
    "function": "new_leaf",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "85-87",
    "spec_strength": "",
    "snippet": "    fn new_leaf<T: MtKey>() -> ParamBST<T> {\n        ParamBST { root: Arc::new(new_bst_para_lock(None)) }\n    }"
  },
  {
    "id": 1295,
    "function": "new",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "90-91",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1), Span O(1)\n        fn new()                           -> Self;"
  },
  {
    "id": 1296,
    "function": "expose",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "92-93",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1), Span O(1)\n        fn expose(&self)                   -> Exposed<T>;"
  },
  {
    "id": 1297,
    "function": "join_mid",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "94-95",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1), Span O(1)\n        fn join_mid(exposed: Exposed<T>)   -> Self;"
  },
  {
    "id": 1298,
    "function": "size",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "96-97",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1), Span O(1)\n        fn size(&self)                     -> usize;"
  },
  {
    "id": 1299,
    "function": "is_empty",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "98-99",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1), Span O(1)\n        fn is_empty(&self)                 -> B;"
  },
  {
    "id": 1300,
    "function": "insert",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "100-101",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(lg |t|), Span O(lg |t|)\n        fn insert(&self, key: T);"
  },
  {
    "id": 1301,
    "function": "delete",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "102-103",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(lg |t|), Span O(lg |t|)\n        fn delete(&self, key: &T);"
  },
  {
    "id": 1302,
    "function": "find",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "104-105",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(lg |t|), Span O(lg |t|)\n        fn find(&self, key: &T)            -> Option<T>;"
  },
  {
    "id": 1303,
    "function": "split",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "106-107",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(lg |t|), Span O(lg |t|)\n        fn split(&self, key: &T)           -> (Self, B, Self);"
  },
  {
    "id": 1304,
    "function": "join_pair",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "108-109",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(lg(|t1| + |t2|)), Span O(lg(|t1| + |t2|))\n        fn join_pair(&self, other: Self)   -> Self;"
  },
  {
    "id": 1305,
    "function": "union",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "110-111",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(m  lg(n/m)), Span O(lg n)\n        fn union(&self, other: &Self)      -> Self;"
  },
  {
    "id": 1306,
    "function": "intersect",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "112-113",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(m  lg(n/m)), Span O(lg n)\n        fn intersect(&self, other: &Self)  -> Self;"
  },
  {
    "id": 1307,
    "function": "difference",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "114-115",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(m  lg(n/m)), Span O(lg n)\n        fn difference(&self, other: &Self) -> Self;"
  },
  {
    "id": 1308,
    "function": "filter",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "116-117",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(|t|), Span O(lg |t|)\n        fn filter<F: Fn(&T) -> bool + Send + Sync + 'static>(&self, predicate: F) -> Self;"
  },
  {
    "id": 1309,
    "function": "reduce",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "118-119",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(|t|), Span O(lg |t|)\n        fn reduce<F: Fn(T, T) -> T + Send + Sync + 'static>(&self, op: F, base: T) -> T;"
  },
  {
    "id": 1310,
    "function": "in_order",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "120-121",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(|t|), Span O(|t|)\n        fn in_order(&self)                 -> ArraySeqStPerS<T>;"
  },
  {
    "id": 1311,
    "function": "expose_internal",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "124-132",
    "spec_strength": "",
    "snippet": "    fn expose_internal<T: MtKey + 'static>(tree: &ParamBST<T>) -> Exposed<T> {\n        let handle = tree.root.acquire_read();\n        let result = match handle.borrow() {\n            | None => Exposed::Leaf,\n            | Some(node) => Exposed::Node(node.left.clone(), node.key.clone(), node.right.clone()),\n        };\n        handle.release_read();\n        result\n    }"
  },
  {
    "id": 1312,
    "function": "split_inner",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "146-163",
    "spec_strength": "",
    "snippet": "    fn split_inner<T: MtKey + 'static>(tree: &ParamBST<T>, key: &T) -> (ParamBST<T>, B, ParamBST<T>) {\n        match expose_internal(tree) {\n            | Exposed::Leaf => (new_leaf(), false, new_leaf()),\n            | Exposed::Node(left, root_key, right) => match key.cmp(&root_key) {\n                | Less => {\n                    let (ll, found, lr) = split_inner(&left, key);\n                    let rebuilt = join_mid(Exposed::Node(lr, root_key, right));\n                    (ll, found, rebuilt)\n                }\n                | Greater => {\n                    let (rl, found, rr) = split_inner(&right, key);\n                    let rebuilt = join_mid(Exposed::Node(left, root_key, rl));\n                    (rebuilt, found, rr)\n                }\n                | Equal => (left, true, right),\n            },\n        }\n    }"
  },
  {
    "id": 1313,
    "function": "join_m",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "165-167",
    "spec_strength": "",
    "snippet": "    fn join_m<T: MtKey + 'static>(left: ParamBST<T>, key: T, right: ParamBST<T>) -> ParamBST<T> {\n        join_mid(Exposed::Node(left, key, right))\n    }"
  },
  {
    "id": 1314,
    "function": "min_key",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "169-177",
    "spec_strength": "",
    "snippet": "    fn min_key<T: MtKey + 'static>(tree: &ParamBST<T>) -> Option<T> {\n        match expose_internal(tree) {\n            | Exposed::Leaf => None,\n            | Exposed::Node(left, key, _) => match min_key(&left) {\n                | Some(rec) => Some(rec),\n                | None => Some(key),\n            },\n        }\n    }"
  },
  {
    "id": 1315,
    "function": "join_pair_inner",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "179-188",
    "spec_strength": "",
    "snippet": "    fn join_pair_inner<T: MtKey + 'static>(left: ParamBST<T>, right: ParamBST<T>) -> ParamBST<T> {\n        match expose_internal(&right) {\n            | Exposed::Leaf => left,\n            | Exposed::Node(_, key, _) => {\n                let min_k = min_key(&right).unwrap_or(key);\n                let (_, _, reduced_right) = split_inner(&right, &min_k);\n                join_m(left, min_k, reduced_right)\n            }\n        }\n    }"
  },
  {
    "id": 1316,
    "function": "union_inner",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "190-201",
    "spec_strength": "",
    "snippet": "    fn union_inner<T: MtKey + 'static>(a: &ParamBST<T>, b: &ParamBST<T>) -> ParamBST<T> {\n        match (expose_internal(a), expose_internal(b)) {\n            | (Exposed::Leaf, _) => b.clone(),\n            | (_, Exposed::Leaf) => a.clone(),\n            | (Exposed::Node(al, ak, ar), _) => {\n                let (bl, _, br) = split_inner(b, &ak);\n                let Pair(left_union, right_union) =\n                    crate::ParaPair!(move || union_inner(&al, &bl), move || union_inner(&ar, &br));\n                join_m(left_union, ak, right_union)\n            }\n        }\n    }"
  },
  {
    "id": 1317,
    "function": "intersect_inner",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "203-217",
    "spec_strength": "",
    "snippet": "    fn intersect_inner<T: MtKey + 'static>(a: &ParamBST<T>, b: &ParamBST<T>) -> ParamBST<T> {\n        match (expose_internal(a), expose_internal(b)) {\n            | (Exposed::Leaf, _) | (_, Exposed::Leaf) => new_leaf(),\n            | (Exposed::Node(al, ak, ar), _) => {\n                let (bl, found, br) = split_inner(b, &ak);\n                let Pair(left_res, right_res) =\n                    crate::ParaPair!(move || intersect_inner(&al, &bl), move || { intersect_inner(&ar, &br) });\n                if found {\n                    join_m(left_res, ak, right_res)\n                } else {\n                    join_pair_inner(left_res, right_res)\n                }\n            }\n        }\n    }"
  },
  {
    "id": 1318,
    "function": "difference_inner",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "219-235",
    "spec_strength": "",
    "snippet": "    fn difference_inner<T: MtKey + 'static>(a: &ParamBST<T>, b: &ParamBST<T>) -> ParamBST<T> {\n        match (expose_internal(a), expose_internal(b)) {\n            | (Exposed::Leaf, _) => new_leaf(),\n            | (_, Exposed::Leaf) => a.clone(),\n            | (Exposed::Node(al, ak, ar), _) => {\n                let (bl, found, br) = split_inner(b, &ak);\n                let Pair(left_res, right_res) = crate::ParaPair!(move || difference_inner(&al, &bl), move || {\n                    difference_inner(&ar, &br)\n                });\n                if found {\n                    join_pair_inner(left_res, right_res)\n                } else {\n                    join_m(left_res, ak, right_res)\n                }\n            }\n        }\n    }"
  },
  {
    "id": 1319,
    "function": "filter_inner",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "237-257",
    "spec_strength": "",
    "snippet": "    fn filter_inner<T: MtKey + 'static, F: Fn(&T) -> bool + Send + Sync + 'static>(\n        tree: &ParamBST<T>,\n        predicate: &Arc<F>,\n    ) -> ParamBST<T> {\n        match expose_internal(tree) {\n            | Exposed::Leaf => new_leaf(),\n            | Exposed::Node(left, key, right) => {\n                let pred_left = Arc::clone(predicate);\n                let pred_right = Arc::clone(predicate);\n                let Pair(left_filtered, right_filtered) =\n                    crate::ParaPair!(move || filter_inner(&left, &pred_left), move || {\n                        filter_inner(&right, &pred_right)\n                    });\n                if (**predicate)(&key) {\n                    join_m(left_filtered, key, right_filtered)\n                } else {\n                    join_pair_inner(left_filtered, right_filtered)\n                }\n            }\n        }\n    }"
  },
  {
    "id": 1320,
    "function": "filter_parallel",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "259-265",
    "spec_strength": "",
    "snippet": "    fn filter_parallel<T: MtKey + 'static, F: Fn(&T) -> bool + Send + Sync + 'static>(\n        tree: &ParamBST<T>,\n        predicate: F,\n    ) -> ParamBST<T> {\n        let predicate = Arc::new(predicate);\n        filter_inner(tree, &predicate)\n    }"
  },
  {
    "id": 1321,
    "function": "reduce_inner",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "267-288",
    "spec_strength": "",
    "snippet": "    fn reduce_inner<T: MtKey + 'static, F: Fn(T, T) -> T + Send + Sync + 'static>(\n        tree: &ParamBST<T>,\n        op: &Arc<F>,\n        identity: T,\n    ) -> T {\n        match expose_internal(tree) {\n            | Exposed::Leaf => identity,\n            | Exposed::Node(left, key, right) => {\n                let op_left = Arc::clone(op);\n                let op_right = Arc::clone(op);\n                let left_base = identity.clone();\n                let right_base = identity;\n                let Pair(left_acc, right_acc) =\n                    crate::ParaPair!(move || reduce_inner(&left, &op_left, left_base), move || {\n                        reduce_inner(&right, &op_right, right_base)\n                    });\n                let op_ref = op.as_ref();\n                let right_with_key = op_ref(key, right_acc);\n                op_ref(left_acc, right_with_key)\n            }\n        }\n    }"
  },
  {
    "id": 1322,
    "function": "reduce_parallel",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "290-297",
    "spec_strength": "",
    "snippet": "    fn reduce_parallel<T: MtKey + 'static, F: Fn(T, T) -> T + Send + Sync + 'static>(\n        tree: &ParamBST<T>,\n        op: F,\n        base: T,\n    ) -> T {\n        let op = Arc::new(op);\n        reduce_inner(tree, &op, base)\n    }"
  },
  {
    "id": 1323,
    "function": "collect_in_order",
    "file": "Chap38/BSTParaMtEph.rs",
    "lines": "299-308",
    "spec_strength": "",
    "snippet": "    fn collect_in_order<T: MtKey + 'static>(tree: &ParamBST<T>, out: &mut Vec<T>) {\n        match expose_internal(tree) {\n            | Exposed::Leaf => {}\n            | Exposed::Node(left, key, right) => {\n                collect_in_order(&left, out);\n                out.push(key);\n                collect_in_order(&right, out);\n            }\n        }\n    }"
  },
  {
    "id": 1324,
    "function": "new_bst_para_lock",
    "file": "Chap38/BSTParaStEph.rs",
    "lines": "107",
    "spec_strength": "hole",
    "snippet": "    fn new_bst_para_lock<T: StT + Ord>(val: Option<Box<NodeInner<T>>>) -> (lock: RwLock<Option<Box<NodeInner<T>>>, BstParaWf>) {"
  },
  {
    "id": 1325,
    "function": "new",
    "file": "Chap38/BSTParaStEph.rs",
    "lines": "114-116",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1), Span O(1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)\n        fn new()                         -> Self;"
  },
  {
    "id": 1326,
    "function": "expose",
    "file": "Chap38/BSTParaStEph.rs",
    "lines": "117-119",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1), Span O(1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)\n        fn expose(&self)                 -> Exposed<T>;"
  },
  {
    "id": 1327,
    "function": "join_mid",
    "file": "Chap38/BSTParaStEph.rs",
    "lines": "120-122",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1), Span O(1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)\n        fn join_mid(exposed: Exposed<T>) -> Self;"
  },
  {
    "id": 1328,
    "function": "size",
    "file": "Chap38/BSTParaStEph.rs",
    "lines": "123-125",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1), Span O(1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)\n        fn size(&self)                   -> N;"
  },
  {
    "id": 1329,
    "function": "is_empty",
    "file": "Chap38/BSTParaStEph.rs",
    "lines": "126-128",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1), Span O(1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)\n        fn is_empty(&self)               -> B;"
  },
  {
    "id": 1330,
    "function": "insert",
    "file": "Chap38/BSTParaStEph.rs",
    "lines": "129-131",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(lg |t|), Span O(lg |t|)\n        /// - Claude-Opus-4.6: Work (log n), Span (log n)\n        fn insert(&self, key: T);"
  },
  {
    "id": 1331,
    "function": "delete",
    "file": "Chap38/BSTParaStEph.rs",
    "lines": "132-134",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(lg |t|), Span O(lg |t|)\n        /// - Claude-Opus-4.6: Work (log n), Span (log n)\n        fn delete(&self, key: &T);"
  },
  {
    "id": 1332,
    "function": "find",
    "file": "Chap38/BSTParaStEph.rs",
    "lines": "135-137",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(lg |t|), Span O(lg |t|)\n        /// - Claude-Opus-4.6: Work (log n), Span (log n)\n        fn find(&self, key: &T)          -> Option<T>;"
  },
  {
    "id": 1333,
    "function": "split",
    "file": "Chap38/BSTParaStEph.rs",
    "lines": "138-140",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(lg |t|), Span O(lg |t|)\n        /// - Claude-Opus-4.6: Work (log n), Span (log n)\n        fn split(&self, key: &T)         -> (Self, B, Self);"
  },
  {
    "id": 1334,
    "function": "join_pair",
    "file": "Chap38/BSTParaStEph.rs",
    "lines": "141-143",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(lg(|t1| + |t2|)), Span O(lg(|t1| + |t2|))\n        /// - Claude-Opus-4.6: Work (log(|t1| + |t2|)), Span (log(|t1| + |t2|))\n        fn join_pair(&self, other: Self) -> Self;"
  },
  {
    "id": 1335,
    "function": "union",
    "file": "Chap38/BSTParaStEph.rs",
    "lines": "144-146",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(m  lg(n/m)), Span O(m  lg(n/m))  sequential, no parallelism\n        /// - Claude-Opus-4.6: Work (m  lg(n/m)), Span (m  lg(n/m))  sequential variant\n        fn union(&self, other: &Self)    -> Self;"
  },
  {
    "id": 1336,
    "function": "in_order",
    "file": "Chap38/BSTParaStEph.rs",
    "lines": "147-149",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(|t|), Span O(|t|)\n        /// - Claude-Opus-4.6: Work (n), Span (n)\n        fn in_order(&self)               -> ArraySeqStPerS<T>;"
  },
  {
    "id": 1337,
    "function": "new_leaf",
    "file": "Chap38/BSTParaStEph.rs",
    "lines": "152-154",
    "spec_strength": "",
    "snippet": "    fn new_leaf<T: StT + Ord>() -> ParamBST<T> {\n        ParamBST { root: Arc::new(new_bst_para_lock(None)) }\n    }"
  },
  {
    "id": 1338,
    "function": "expose_internal",
    "file": "Chap38/BSTParaStEph.rs",
    "lines": "156-165",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work O(1), Span O(1)\n    fn expose_internal<T: StT + Ord>(tree: &ParamBST<T>) -> Exposed<T> {\n        let handle = tree.root.acquire_read();\n        let result = match handle.borrow() {\n            | None => Exposed::Leaf,\n            | Some(node) => Exposed::Node(node.left.clone(), node.key.clone(), node.right.clone()),\n        };\n        handle.release_read();\n        result\n    }"
  },
  {
    "id": 1339,
    "function": "split_inner",
    "file": "Chap38/BSTParaStEph.rs",
    "lines": "180-199",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work O(lg |t|), Span O(lg |t|)\n    /// - Claude-Opus-4.6: Work (log n), Span (log n)\n    fn split_inner<T: StT + Ord>(tree: &ParamBST<T>, key: &T) -> (ParamBST<T>, B, ParamBST<T>) {\n        match expose_internal(tree) {\n            | Exposed::Leaf => (new_leaf(), false, new_leaf()),\n            | Exposed::Node(left, root_key, right) => match key.cmp(&root_key) {\n                | Less => {\n                    let (ll, found, lr) = split_inner(&left, key);\n                    let rebuilt = join_mid(Exposed::Node(lr, root_key, right));\n                    (ll, found, rebuilt)\n                }\n                | Greater => {\n                    let (rl, found, rr) = split_inner(&right, key);\n                    let rebuilt = join_mid(Exposed::Node(left, root_key, rl));\n                    (rebuilt, found, rr)\n                }\n                | Equal => (left, true, right),\n            },\n        }\n    }"
  },
  {
    "id": 1340,
    "function": "join_m",
    "file": "Chap38/BSTParaStEph.rs",
    "lines": "201-205",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work O(1), Span O(1)\n    /// - Claude-Opus-4.6: Work (1), Span (1)\n    fn join_m<T: StT + Ord>(left: ParamBST<T>, key: T, right: ParamBST<T>) -> ParamBST<T> {\n        join_mid(Exposed::Node(left, key, right))\n    }"
  },
  {
    "id": 1341,
    "function": "min_key",
    "file": "Chap38/BSTParaStEph.rs",
    "lines": "207-217",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work O(lg |t|), Span O(lg |t|)\n    /// - Claude-Opus-4.6: Work (log n), Span (log n)\n    fn min_key<T: StT + Ord>(tree: &ParamBST<T>) -> Option<T> {\n        match expose_internal(tree) {\n            | Exposed::Leaf => None,\n            | Exposed::Node(left, key, _) => match min_key(&left) {\n                | Some(rec) => Some(rec),\n                | None => Some(key),\n            },\n        }\n    }"
  },
  {
    "id": 1342,
    "function": "join_pair_inner",
    "file": "Chap38/BSTParaStEph.rs",
    "lines": "219-230",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work O(lg(|left| + |right|)), Span O(lg(|left| + |right|))\n    /// - Claude-Opus-4.6: Work (log(|left| + |right|)), Span (log(|left| + |right|))\n    fn join_pair_inner<T: StT + Ord>(left: ParamBST<T>, right: ParamBST<T>) -> ParamBST<T> {\n        match expose_internal(&right) {\n            | Exposed::Leaf => left,\n            | Exposed::Node(_, key, _) => {\n                let min_k = min_key(&right).unwrap_or(key);\n                let (_, _, reduced_right) = split_inner(&right, &min_k);\n                join_m(left, min_k, reduced_right)\n            }\n        }\n    }"
  },
  {
    "id": 1343,
    "function": "union_inner",
    "file": "Chap38/BSTParaStEph.rs",
    "lines": "232-245",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work O(m  lg(n/m)), Span O(m  lg(n/m))  sequential, no parallelism\n    /// - Claude-Opus-4.6: Work (m  lg(n/m)), Span (m  lg(n/m))  sequential variant\n    fn union_inner<T: StT + Ord>(a: &ParamBST<T>, b: &ParamBST<T>) -> ParamBST<T> {\n        match (expose_internal(a), expose_internal(b)) {\n            | (Exposed::Leaf, _) => b.clone(),\n            | (_, Exposed::Leaf) => a.clone(),\n            | (Exposed::Node(al, ak, ar), _) => {\n                let (bl, _, br) = split_inner(b, &ak);\n                let left_union = union_inner(&al, &bl);\n                let right_union = union_inner(&ar, &br);\n                join_m(left_union, ak, right_union)\n            }\n        }\n    }"
  },
  {
    "id": 1344,
    "function": "collect_in_order",
    "file": "Chap38/BSTParaStEph.rs",
    "lines": "247-258",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work O(|t|), Span O(|t|)\n    /// - Claude-Opus-4.6: Work (n), Span (n)\n    fn collect_in_order<T: StT + Ord>(tree: &ParamBST<T>, out: &mut Vec<T>) {\n        match expose_internal(tree) {\n            | Exposed::Leaf => {}\n            | Exposed::Node(left, key, right) => {\n                collect_in_order(&left, out);\n                out.push(key);\n                collect_in_order(&right, out);\n            }\n        }\n    }"
  },
  {
    "id": 1345,
    "function": "new_treap_lock",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "48",
    "spec_strength": "hole",
    "snippet": "    fn new_treap_lock<T: MtKey>(val: Option<Box<NodeInner<T>>>) -> (lock: RwLock<Option<Box<NodeInner<T>>>, TreapWf>) {"
  },
  {
    "id": 1346,
    "function": "priority_for",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "85-93",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work (1), Span (1)\n    /// - Claude-Opus-4.6: Work (1), Span (1)\n    fn priority_for<T: MtKey>(key: &T) -> i64 {\n        let mut hasher = std::collections::hash_map::DefaultHasher::new();\n        let mut buf = String::new();\n        let _ = write!(&mut buf, \"{key:?}\");\n        Hash::hash(&buf, &mut hasher);\n        hasher.finish() as i64\n    }"
  },
  {
    "id": 1347,
    "function": "tree_priority",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "95-102",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work (1), Span (1)\n    /// - Claude-Opus-4.6: Work (1), Span (1)\n    fn tree_priority<T: MtKey>(tree: &ParamTreap<T>) -> i64 {\n        let handle = tree.root.acquire_read();\n        let result = handle.borrow().as_ref().map_or(i64::MIN, |node| node.priority);\n        handle.release_read();\n        result\n    }"
  },
  {
    "id": 1348,
    "function": "tree_size",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "104-111",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work (1), Span (1)\n    /// - Claude-Opus-4.6: Work (1), Span (1)\n    fn tree_size<T: MtKey>(tree: &ParamTreap<T>) -> N {\n        let handle = tree.root.acquire_read();\n        let result = handle.borrow().as_ref().map_or(0, |node| node.size);\n        handle.release_read();\n        result\n    }"
  },
  {
    "id": 1349,
    "function": "make_node",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "113-122",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work (1), Span (1)\n    /// - Claude-Opus-4.6: Work (1), Span (1)\n    fn make_node<T: MtKey>(left: ParamTreap<T>, key: T, priority: i64, right: ParamTreap<T>) -> ParamTreap<T> {\n        let size = 1 + tree_size(&left) + tree_size(&right);\n        ParamTreap {\n            root: Arc::new(new_treap_lock(\n                Some(Box::new(NodeInner { key, priority, size, left, right })),\n            )),\n        }\n    }"
  },
  {
    "id": 1350,
    "function": "join_with_priority",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "124-146",
    "spec_strength": "",
    "snippet": "    fn join_with_priority<T: MtKey + 'static>(left: ParamTreap<T>, key: T, priority: i64, right: ParamTreap<T>) -> ParamTreap<T>\n    where\n        ParamTreap<T>: ParamTreapTrait<T>,\n    {\n        let left_priority = tree_priority(&left);\n        let right_priority = tree_priority(&right);\n        if priority > left_priority && priority > right_priority {\n            return make_node(left, key, priority, right);\n        }\n        if left_priority > right_priority {\n            if let Some((ll, lk, lp, lr)) = left.expose_with_priority() {\n                let merged_right = join_with_priority(lr, key, priority, right);\n                return make_node(ll, lk, lp, merged_right);\n            }\n            make_node(left, key, priority, right)\n        } else {\n            if let Some((rl, rk, rp, rr)) = right.expose_with_priority() {\n                let merged_left = join_with_priority(left, key, priority, rl);\n                return make_node(merged_left, rk, rp, rr);\n            }\n            make_node(left, key, priority, right)\n        }\n    }"
  },
  {
    "id": 1351,
    "function": "split_inner",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "148-168",
    "spec_strength": "",
    "snippet": "    fn split_inner<T: MtKey + 'static>(tree: &ParamTreap<T>, key: &T) -> (ParamTreap<T>, B, ParamTreap<T>)\n    where\n        ParamTreap<T>: ParamTreapTrait<T>,\n    {\n        match tree.expose_with_priority() {\n            | None => (ParamTreap::new(), false, ParamTreap::new()),\n            | Some((left, root_key, priority, right)) => match key.cmp(&root_key) {\n                | Less => {\n                    let (ll, found, lr) = split_inner(&left, key);\n                    let rebuilt = join_with_priority(lr, root_key, priority, right);\n                    (ll, found, rebuilt)\n                }\n                | Greater => {\n                    let (rl, found, rr) = split_inner(&right, key);\n                    let rebuilt = join_with_priority(left, root_key, priority, rl);\n                    (rebuilt, found, rr)\n                }\n                | Equal => (left, true, right),\n            },\n        }\n    }"
  },
  {
    "id": 1352,
    "function": "join_pair_inner",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "170-183",
    "spec_strength": "",
    "snippet": "    fn join_pair_inner<T: MtKey + 'static>(left: ParamTreap<T>, right: ParamTreap<T>) -> ParamTreap<T>\n    where\n        ParamTreap<T>: ParamTreapTrait<T>,\n    {\n        match right.expose_with_priority() {\n            | None => left,\n            | Some((r_left, r_key, r_priority, r_right)) => {\n                let (split_left, _, split_right) = split_inner(&left, &r_key);\n                let combined_left = join_pair_inner(split_left, r_left);\n                let combined_right = join_pair_inner(split_right, r_right);\n                join_with_priority(combined_left, r_key, r_priority, combined_right)\n            }\n        }\n    }"
  },
  {
    "id": 1353,
    "function": "union_inner",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "185-198",
    "spec_strength": "",
    "snippet": "    fn union_inner<T: MtKey + 'static>(a: &ParamTreap<T>, b: &ParamTreap<T>) -> ParamTreap<T>\n    where\n        ParamTreap<T>: ParamTreapTrait<T>,\n    {\n        match a.expose_with_priority() {\n            | None => b.clone(),\n            | Some((al, ak, ap, ar)) => {\n                let (bl, _, br) = split_inner(b, &ak);\n                let Pair(left_union, right_union) =\n                    crate::ParaPair!(move || union_inner(&al, &bl), move || union_inner(&ar, &br));\n                join_with_priority(left_union, ak, ap, right_union)\n            }\n        }\n    }"
  },
  {
    "id": 1354,
    "function": "intersect_inner",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "200-217",
    "spec_strength": "",
    "snippet": "    fn intersect_inner<T: MtKey + 'static>(a: &ParamTreap<T>, b: &ParamTreap<T>) -> ParamTreap<T>\n    where\n        ParamTreap<T>: ParamTreapTrait<T>,\n    {\n        match a.expose_with_priority() {\n            | None => ParamTreap::new(),\n            | Some((al, ak, ap, ar)) => {\n                let (bl, found, br) = split_inner(b, &ak);\n                let Pair(left_res, right_res) =\n                    crate::ParaPair!(move || intersect_inner(&al, &bl), move || intersect_inner(&ar, &br));\n                if found {\n                    join_with_priority(left_res, ak, ap, right_res)\n                } else {\n                    join_pair_inner(left_res, right_res)\n                }\n            }\n        }\n    }"
  },
  {
    "id": 1355,
    "function": "difference_inner",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "219-236",
    "spec_strength": "",
    "snippet": "    fn difference_inner<T: MtKey + 'static>(a: &ParamTreap<T>, b: &ParamTreap<T>) -> ParamTreap<T>\n    where\n        ParamTreap<T>: ParamTreapTrait<T>,\n    {\n        match a.expose_with_priority() {\n            | None => ParamTreap::new(),\n            | Some((al, ak, ap, ar)) => {\n                let (bl, found, br) = split_inner(b, &ak);\n                let Pair(left_res, right_res) =\n                    crate::ParaPair!(move || difference_inner(&al, &bl), move || difference_inner(&ar, &br));\n                if found {\n                    join_pair_inner(left_res, right_res)\n                } else {\n                    join_with_priority(left_res, ak, ap, right_res)\n                }\n            }\n        }\n    }"
  },
  {
    "id": 1356,
    "function": "filter_inner",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "238-256",
    "spec_strength": "",
    "snippet": "    fn filter_inner<T: MtKey + 'static, F: Pred<T>>(tree: &ParamTreap<T>, predicate: &Arc<F>) -> ParamTreap<T>\n    where\n        ParamTreap<T>: ParamTreapTrait<T>,\n    {\n        match tree.expose_with_priority() {\n            | None => ParamTreap::new(),\n            | Some((left, key, priority, right)) => {\n                let pred_left = Arc::clone(predicate);\n                let pred_right = Arc::clone(predicate);\n                let Pair(left_filtered, right_filtered) =\n                    crate::ParaPair!(move || filter_inner(&left, &pred_left), move || filter_inner(&right, &pred_right));\n                if (**predicate)(&key) {\n                    join_with_priority(left_filtered, key, priority, right_filtered)\n                } else {\n                    join_pair_inner(left_filtered, right_filtered)\n                }\n            }\n        }\n    }"
  },
  {
    "id": 1357,
    "function": "filter_parallel",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "258-264",
    "spec_strength": "",
    "snippet": "    fn filter_parallel<T: MtKey + 'static, F: Pred<T>>(tree: &ParamTreap<T>, predicate: F) -> ParamTreap<T>\n    where\n        ParamTreap<T>: ParamTreapTrait<T>,\n    {\n        let predicate = Arc::new(predicate);\n        filter_inner(tree, &predicate)\n    }"
  },
  {
    "id": 1358,
    "function": "reduce_inner",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "266-287",
    "spec_strength": "",
    "snippet": "    fn reduce_inner<T: MtKey + 'static, F>(tree: &ParamTreap<T>, op: &Arc<F>, identity: T) -> T\n    where\n        ParamTreap<T>: ParamTreapTrait<T>,\n        F: Fn(T, T) -> T + Send + Sync + 'static,\n    {\n        match tree.expose_with_priority() {\n            | None => identity,\n            | Some((left, key, _priority, right)) => {\n                let op_left = Arc::clone(op);\n                let op_right = Arc::clone(op);\n                let left_base = identity.clone();\n                let right_base = identity;\n                let Pair(left_acc, right_acc) = crate::ParaPair!(\n                    move || reduce_inner(&left, &op_left, left_base),\n                    move || reduce_inner(&right, &op_right, right_base)\n                );\n                let op_ref = op.as_ref();\n                let right_with_key = op_ref(key, right_acc);\n                op_ref(left_acc, right_with_key)\n            }\n        }\n    }"
  },
  {
    "id": 1359,
    "function": "reduce_parallel",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "289-296",
    "spec_strength": "",
    "snippet": "    fn reduce_parallel<T: MtKey + 'static, F>(tree: &ParamTreap<T>, op: F, base: T) -> T\n    where\n        ParamTreap<T>: ParamTreapTrait<T>,\n        F: Fn(T, T) -> T + Send + Sync + 'static,\n    {\n        let op = Arc::new(op);\n        reduce_inner(tree, &op, base)\n    }"
  },
  {
    "id": 1360,
    "function": "collect_in_order",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "298-310",
    "spec_strength": "",
    "snippet": "    fn collect_in_order<T: MtKey + 'static>(tree: &ParamTreap<T>, out: &mut Vec<T>)\n    where\n        ParamTreap<T>: ParamTreapTrait<T>,\n    {\n        match tree.expose_with_priority() {\n            | None => {}\n            | Some((left, key, _priority, right)) => {\n                collect_in_order(&left, out);\n                out.push(key);\n                collect_in_order(&right, out);\n            }\n        }\n    }"
  },
  {
    "id": 1361,
    "function": "new",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "315-317",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1), Span O(1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)\n        fn new()                                   -> Self;"
  },
  {
    "id": 1362,
    "function": "expose",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "318-320",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1), Span O(1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)\n        fn expose(&self)                           -> Exposed<T>;"
  },
  {
    "id": 1363,
    "function": "expose_with_priority",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "321-323",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1), Span O(1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)\n        fn expose_with_priority(&self)             -> Option<(ParamTreap<T>, T, i64, ParamTreap<T>)>;"
  },
  {
    "id": 1364,
    "function": "join_mid",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "324-326",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(log(|left| + |right|)), Span O(log(|left| + |right|))\n        /// - Claude-Opus-4.6: Work O(log(|left| + |right|)), Span O(log(|left| + |right|))  delegates to join_with_priority\n        fn join_mid(exposed: Exposed<T>)           -> Self;"
  },
  {
    "id": 1365,
    "function": "size",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "327-329",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1), Span O(1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)\n        fn size(&self)                             -> N;"
  },
  {
    "id": 1366,
    "function": "is_empty",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "330-332",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1), Span O(1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)\n        fn is_empty(&self)                         -> B;"
  },
  {
    "id": 1367,
    "function": "insert",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "333-335",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(lg |t|), Span O(lg |t|)\n        /// - Claude-Opus-4.6: Work O(lg |t|), Span O(lg |t|)\n        fn insert(&self, key: T);"
  },
  {
    "id": 1368,
    "function": "delete",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "336-338",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(lg |t|), Span O(lg |t|)\n        /// - Claude-Opus-4.6: Work O(lg |t|), Span O(lg |t|)\n        fn delete(&self, key: &T);"
  },
  {
    "id": 1369,
    "function": "find",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "339-341",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(lg |t|), Span O(lg |t|)\n        /// - Claude-Opus-4.6: Work O(lg |t|), Span O(lg |t|)\n        fn find(&self, key: &T)                    -> Option<T>;"
  },
  {
    "id": 1370,
    "function": "split",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "342-344",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(lg |t|), Span O(lg |t|)\n        /// - Claude-Opus-4.6: Work O(lg |t|), Span O(lg |t|)\n        fn split(&self, key: &T)                   -> (Self, B, Self);"
  },
  {
    "id": 1371,
    "function": "join_pair",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "345-347",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(lg(|t_1| + |t_2|)), Span O(lg(|t_1| + |t_2|))\n        /// - Claude-Opus-4.6: Work O(lg(|t_1| + |t_2|)), Span O(lg(|t_1| + |t_2|))\n        fn join_pair(&self, other: Self)           -> Self;"
  },
  {
    "id": 1372,
    "function": "union",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "348-350",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(m  lg(n/m)), Span O(lg n)\n        /// - Claude-Opus-4.6: Work O(m  lg(n/m)), Span O(lg n)\n        fn union(&self, other: &Self)              -> Self;"
  },
  {
    "id": 1373,
    "function": "intersect",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "351-353",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(m  lg(n/m)), Span O(lg n)\n        /// - Claude-Opus-4.6: Work O(m  lg(n/m)), Span O(lg n)\n        fn intersect(&self, other: &Self)          -> Self;"
  },
  {
    "id": 1374,
    "function": "difference",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "354-356",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(m  lg(n/m)), Span O(lg n)\n        /// - Claude-Opus-4.6: Work O(m  lg(n/m)), Span O(lg n)\n        fn difference(&self, other: &Self)         -> Self;"
  },
  {
    "id": 1375,
    "function": "filter",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "357-359",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(|t|), Span O(lg |t|)\n        /// - Claude-Opus-4.6: Work O(|t|), Span O(lg |t|)\n        fn filter<F: Pred<T>>(&self, predicate: F) -> Self;"
  },
  {
    "id": 1376,
    "function": "reduce",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "360-364",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(|t|), Span O(lg |t|)\n        /// - Claude-Opus-4.6: Work O(|t|), Span O(lg |t|)\n        fn reduce<F>(&self, op: F, base: T)        -> T\n        where\n            F: Fn(T, T) -> T + Send + Sync + 'static;"
  },
  {
    "id": 1377,
    "function": "in_order",
    "file": "Chap39/BSTParaTreapMtEph.rs",
    "lines": "365-367",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(|t|), Span O(|t|)\n        /// - Claude-Opus-4.6: Work O(|t|), Span O(|t|)\n        fn in_order(&self)                         -> ArraySeqStPerS<T>;"
  },
  {
    "id": 1378,
    "function": "priority_for",
    "file": "Chap39/BSTSetTreapMtEph.rs",
    "lines": "40",
    "spec_strength": "hole",
    "snippet": "    fn priority_for<T: Hash>(key: &T) -> u64 {"
  },
  {
    "id": 1379,
    "function": "empty",
    "file": "Chap39/BSTSetTreapMtEph.rs",
    "lines": "64",
    "spec_strength": "",
    "snippet": "        fn empty()                                   -> Self;"
  },
  {
    "id": 1380,
    "function": "singleton",
    "file": "Chap39/BSTSetTreapMtEph.rs",
    "lines": "67",
    "spec_strength": "",
    "snippet": "        fn singleton(value: T)                       -> Self;"
  },
  {
    "id": 1381,
    "function": "size",
    "file": "Chap39/BSTSetTreapMtEph.rs",
    "lines": "70",
    "spec_strength": "",
    "snippet": "        fn size(&self)                               -> N;"
  },
  {
    "id": 1382,
    "function": "is_empty",
    "file": "Chap39/BSTSetTreapMtEph.rs",
    "lines": "73",
    "spec_strength": "",
    "snippet": "        fn is_empty(&self)                           -> B;"
  },
  {
    "id": 1383,
    "function": "find",
    "file": "Chap39/BSTSetTreapMtEph.rs",
    "lines": "76",
    "spec_strength": "",
    "snippet": "        fn find(&self, value: &T)                    -> Option<T>;"
  },
  {
    "id": 1384,
    "function": "contains",
    "file": "Chap39/BSTSetTreapMtEph.rs",
    "lines": "79",
    "spec_strength": "",
    "snippet": "        fn contains(&self, value: &T)                -> B;"
  },
  {
    "id": 1385,
    "function": "minimum",
    "file": "Chap39/BSTSetTreapMtEph.rs",
    "lines": "82",
    "spec_strength": "",
    "snippet": "        fn minimum(&self)                            -> Option<T>;"
  },
  {
    "id": 1386,
    "function": "maximum",
    "file": "Chap39/BSTSetTreapMtEph.rs",
    "lines": "85",
    "spec_strength": "",
    "snippet": "        fn maximum(&self)                            -> Option<T>;"
  },
  {
    "id": 1387,
    "function": "insert",
    "file": "Chap39/BSTSetTreapMtEph.rs",
    "lines": "88",
    "spec_strength": "",
    "snippet": "        fn insert(&mut self, value: T);"
  },
  {
    "id": 1388,
    "function": "delete",
    "file": "Chap39/BSTSetTreapMtEph.rs",
    "lines": "91",
    "spec_strength": "hole",
    "snippet": "        fn delete(&mut self, target: &T);"
  },
  {
    "id": 1389,
    "function": "union",
    "file": "Chap39/BSTSetTreapMtEph.rs",
    "lines": "94",
    "spec_strength": "hole",
    "snippet": "        fn union(&self, other: &Self)                -> Self;"
  },
  {
    "id": 1390,
    "function": "intersection",
    "file": "Chap39/BSTSetTreapMtEph.rs",
    "lines": "97",
    "spec_strength": "hole",
    "snippet": "        fn intersection(&self, other: &Self)         -> Self;"
  },
  {
    "id": 1391,
    "function": "difference",
    "file": "Chap39/BSTSetTreapMtEph.rs",
    "lines": "100",
    "spec_strength": "hole",
    "snippet": "        fn difference(&self, other: &Self)           -> Self;"
  },
  {
    "id": 1392,
    "function": "split",
    "file": "Chap39/BSTSetTreapMtEph.rs",
    "lines": "103",
    "spec_strength": "hole",
    "snippet": "        fn split(&self, pivot: &T)                   -> (Self, B, Self);"
  },
  {
    "id": 1393,
    "function": "join_pair",
    "file": "Chap39/BSTSetTreapMtEph.rs",
    "lines": "106",
    "spec_strength": "hole",
    "snippet": "        fn join_pair(left: Self, right: Self)        -> Self;"
  },
  {
    "id": 1394,
    "function": "join_m",
    "file": "Chap39/BSTSetTreapMtEph.rs",
    "lines": "109",
    "spec_strength": "hole",
    "snippet": "        fn join_m(left: Self, pivot: T, right: Self) -> Self;"
  },
  {
    "id": 1395,
    "function": "filter",
    "file": "Chap39/BSTSetTreapMtEph.rs",
    "lines": "112",
    "spec_strength": "hole",
    "snippet": "        fn filter<F: FnMut(&T) -> bool>(&self, predicate: F) -> Self;"
  },
  {
    "id": 1396,
    "function": "reduce",
    "file": "Chap39/BSTSetTreapMtEph.rs",
    "lines": "115",
    "spec_strength": "hole",
    "snippet": "        fn reduce<F: FnMut(T, T) -> T>(&self, op: F, base: T) -> T;"
  },
  {
    "id": 1397,
    "function": "iter_in_order",
    "file": "Chap39/BSTSetTreapMtEph.rs",
    "lines": "118",
    "spec_strength": "",
    "snippet": "        fn iter_in_order(&self)                      -> ArraySeqStPerS<T>;"
  },
  {
    "id": 1398,
    "function": "as_tree",
    "file": "Chap39/BSTSetTreapMtEph.rs",
    "lines": "121",
    "spec_strength": "",
    "snippet": "        fn as_tree(&self)                            -> &BSTTreapMtEph<T>;"
  },
  {
    "id": 1399,
    "function": "values_vec",
    "file": "Chap39/BSTSetTreapMtEph.rs",
    "lines": "125",
    "spec_strength": "hole",
    "snippet": "    fn values_vec<T: StTInMtT + Ord>(tree: &BSTTreapMtEph<T>) -> Vec<T> {"
  },
  {
    "id": 1400,
    "function": "rebuild_from_vec",
    "file": "Chap39/BSTSetTreapMtEph.rs",
    "lines": "129",
    "spec_strength": "",
    "snippet": "    fn rebuild_from_vec<T: StTInMtT + Ord + Hash>(values: Vec<T>) -> BSTTreapMtEph<T> {"
  },
  {
    "id": 1401,
    "function": "from_sorted_iter",
    "file": "Chap39/BSTSetTreapMtEph.rs",
    "lines": "139",
    "spec_strength": "hole",
    "snippet": "    fn from_sorted_iter<T: StTInMtT + Ord + Hash, I: IntoIterator<Item = T>>(values: I) -> BSTSetTreapMtEph<T> {"
  },
  {
    "id": 1402,
    "function": "new`",
    "file": "Chap39/BSTTreapMtEph.rs",
    "lines": "115",
    "spec_strength": "",
    "snippet": "        fn new()                       -> Self;"
  },
  {
    "id": 1403,
    "function": "clone_link",
    "file": "Chap39/BSTTreapMtEph.rs",
    "lines": "44-45",
    "spec_strength": "hole",
    "snippet": "    fn clone_link<T: StTInMtT + Ord + Clone>(link: &Link<T>) -> (c: Link<T>)\n        decreases link,"
  },
  {
    "id": 1404,
    "function": "new_treap_link_lock",
    "file": "Chap39/BSTTreapMtEph.rs",
    "lines": "92",
    "spec_strength": "hole",
    "snippet": "    fn new_treap_link_lock<T: StTInMtT + Ord>(val: Link<T>) -> (lock: RwLock<Link<T>, TreapLinkWf>) {"
  },
  {
    "id": 1405,
    "function": "insert",
    "file": "Chap39/BSTTreapMtEph.rs",
    "lines": "118",
    "spec_strength": "",
    "snippet": "        fn insert(&self, value: T, priority: u64);"
  },
  {
    "id": 1406,
    "function": "find",
    "file": "Chap39/BSTTreapMtEph.rs",
    "lines": "121",
    "spec_strength": "",
    "snippet": "        fn find(&self, target: &T)     -> Option<T>;"
  },
  {
    "id": 1407,
    "function": "contains",
    "file": "Chap39/BSTTreapMtEph.rs",
    "lines": "124",
    "spec_strength": "",
    "snippet": "        fn contains(&self, target: &T) -> B;"
  },
  {
    "id": 1408,
    "function": "size",
    "file": "Chap39/BSTTreapMtEph.rs",
    "lines": "127",
    "spec_strength": "",
    "snippet": "        fn size(&self)                 -> N;"
  },
  {
    "id": 1409,
    "function": "is_empty",
    "file": "Chap39/BSTTreapMtEph.rs",
    "lines": "130",
    "spec_strength": "",
    "snippet": "        fn is_empty(&self)             -> B;"
  },
  {
    "id": 1410,
    "function": "height",
    "file": "Chap39/BSTTreapMtEph.rs",
    "lines": "133",
    "spec_strength": "",
    "snippet": "        fn height(&self)               -> N;"
  },
  {
    "id": 1411,
    "function": "minimum",
    "file": "Chap39/BSTTreapMtEph.rs",
    "lines": "136",
    "spec_strength": "",
    "snippet": "        fn minimum(&self)              -> Option<T>;"
  },
  {
    "id": 1412,
    "function": "maximum",
    "file": "Chap39/BSTTreapMtEph.rs",
    "lines": "139",
    "spec_strength": "",
    "snippet": "        fn maximum(&self)              -> Option<T>;"
  },
  {
    "id": 1413,
    "function": "in_order",
    "file": "Chap39/BSTTreapMtEph.rs",
    "lines": "142",
    "spec_strength": "",
    "snippet": "        fn in_order(&self)             -> ArraySeqStPerS<T>;"
  },
  {
    "id": 1414,
    "function": "pre_order",
    "file": "Chap39/BSTTreapMtEph.rs",
    "lines": "145",
    "spec_strength": "",
    "snippet": "        fn pre_order(&self)            -> ArraySeqStPerS<T>;"
  },
  {
    "id": 1415,
    "function": "size_link",
    "file": "Chap39/BSTTreapMtEph.rs",
    "lines": "151",
    "spec_strength": "",
    "snippet": "    fn size_link<T: StTInMtT + Ord>(link: &Link<T>) -> N {"
  },
  {
    "id": 1416,
    "function": "update",
    "file": "Chap39/BSTTreapMtEph.rs",
    "lines": "161",
    "spec_strength": "hole",
    "snippet": "    fn update<T: StTInMtT + Ord>(node: &mut Node<T>) {"
  },
  {
    "id": 1417,
    "function": "rotate_left",
    "file": "Chap39/BSTTreapMtEph.rs",
    "lines": "167",
    "spec_strength": "",
    "snippet": "    fn rotate_left<T: StTInMtT + Ord>(link: &mut Link<T>) {"
  },
  {
    "id": 1418,
    "function": "rotate_right",
    "file": "Chap39/BSTTreapMtEph.rs",
    "lines": "183",
    "spec_strength": "",
    "snippet": "    fn rotate_right<T: StTInMtT + Ord>(link: &mut Link<T>) {"
  },
  {
    "id": 1419,
    "function": "insert_link",
    "file": "Chap39/BSTTreapMtEph.rs",
    "lines": "199-200",
    "spec_strength": "",
    "snippet": "    fn insert_link<T: StTInMtT + Ord>(link: &mut Link<T>, value: T, priority: u64)\n        decreases old(link),"
  },
  {
    "id": 1420,
    "function": "find_link",
    "file": "Chap39/BSTTreapMtEph.rs",
    "lines": "237-238",
    "spec_strength": "",
    "snippet": "    fn find_link<'a, T: StTInMtT + Ord>(link: &'a Link<T>, target: &T) -> Option<&'a T>\n        decreases *link,"
  },
  {
    "id": 1421,
    "function": "min_link",
    "file": "Chap39/BSTTreapMtEph.rs",
    "lines": "256-257",
    "spec_strength": "",
    "snippet": "    fn min_link<T: StTInMtT + Ord>(link: &Link<T>) -> Option<&T>\n        decreases *link,"
  },
  {
    "id": 1422,
    "function": "max_link",
    "file": "Chap39/BSTTreapMtEph.rs",
    "lines": "270-271",
    "spec_strength": "",
    "snippet": "    fn max_link<T: StTInMtT + Ord>(link: &Link<T>) -> Option<&T>\n        decreases *link,"
  },
  {
    "id": 1423,
    "function": "height_link",
    "file": "Chap39/BSTTreapMtEph.rs",
    "lines": "283",
    "spec_strength": "hole",
    "snippet": "    fn height_link<T: StTInMtT + Ord>(link: &Link<T>) -> N {"
  },
  {
    "id": 1424,
    "function": "in_order_collect",
    "file": "Chap39/BSTTreapMtEph.rs",
    "lines": "292-293",
    "spec_strength": "",
    "snippet": "    fn in_order_collect<T: StTInMtT + Ord>(link: &Link<T>, out: &mut Vec<T>)\n        decreases *link,"
  },
  {
    "id": 1425,
    "function": "pre_order_collect",
    "file": "Chap39/BSTTreapMtEph.rs",
    "lines": "304-305",
    "spec_strength": "",
    "snippet": "    fn pre_order_collect<T: StTInMtT + Ord>(link: &Link<T>, out: &mut Vec<T>)\n        decreases *link,"
  },
  {
    "id": 1426,
    "function": "default",
    "file": "Chap39/BSTTreapMtEph.rs",
    "lines": "384",
    "spec_strength": "",
    "snippet": "        fn default() -> Self { Self::new() }"
  },
  {
    "id": 1427,
    "function": "new_node",
    "file": "Chap39/BSTTreapStEph.rs",
    "lines": "40",
    "spec_strength": "",
    "snippet": "    fn new_node<T: StT + Ord>(key: T, priority: u64) -> Node<T> {"
  },
  {
    "id": 1428,
    "function": "new",
    "file": "Chap39/BSTTreapStEph.rs",
    "lines": "69-71",
    "spec_strength": "",
    "snippet": "        fn new()                       -> Self\n        where\n            Self: Sized;"
  },
  {
    "id": 1429,
    "function": "size",
    "file": "Chap39/BSTTreapStEph.rs",
    "lines": "74",
    "spec_strength": "",
    "snippet": "        fn size(&self)                 -> N;"
  },
  {
    "id": 1430,
    "function": "is_empty",
    "file": "Chap39/BSTTreapStEph.rs",
    "lines": "77",
    "spec_strength": "",
    "snippet": "        fn is_empty(&self)             -> B;"
  },
  {
    "id": 1431,
    "function": "height",
    "file": "Chap39/BSTTreapStEph.rs",
    "lines": "80-81",
    "spec_strength": "unknown",
    "snippet": "        fn height(&self)               -> N\n            requires self.spec_size() < usize::MAX as nat;"
  },
  {
    "id": 1432,
    "function": "insert",
    "file": "Chap39/BSTTreapStEph.rs",
    "lines": "84",
    "spec_strength": "",
    "snippet": "        fn insert(&mut self, value: T, priority: u64);"
  },
  {
    "id": 1433,
    "function": "find",
    "file": "Chap39/BSTTreapStEph.rs",
    "lines": "87",
    "spec_strength": "",
    "snippet": "        fn find(&self, target: &T)     -> Option<&T>;"
  },
  {
    "id": 1434,
    "function": "contains",
    "file": "Chap39/BSTTreapStEph.rs",
    "lines": "90",
    "spec_strength": "",
    "snippet": "        fn contains(&self, target: &T) -> B;"
  },
  {
    "id": 1435,
    "function": "minimum",
    "file": "Chap39/BSTTreapStEph.rs",
    "lines": "93",
    "spec_strength": "",
    "snippet": "        fn minimum(&self)              -> Option<&T>;"
  },
  {
    "id": 1436,
    "function": "maximum",
    "file": "Chap39/BSTTreapStEph.rs",
    "lines": "96",
    "spec_strength": "",
    "snippet": "        fn maximum(&self)              -> Option<&T>;"
  },
  {
    "id": 1437,
    "function": "in_order",
    "file": "Chap39/BSTTreapStEph.rs",
    "lines": "99",
    "spec_strength": "hole",
    "snippet": "        fn in_order(&self)             -> ArraySeqStPerS<T>;"
  },
  {
    "id": 1438,
    "function": "pre_order",
    "file": "Chap39/BSTTreapStEph.rs",
    "lines": "102",
    "spec_strength": "hole",
    "snippet": "        fn pre_order(&self)            -> ArraySeqStPerS<T>;"
  },
  {
    "id": 1439,
    "function": "size_link",
    "file": "Chap39/BSTTreapStEph.rs",
    "lines": "117",
    "spec_strength": "hole",
    "snippet": "    fn size_link<T: StT + Ord>(link: &Link<T>) -> N { link.as_ref().map_or(0, |n| n.size) }"
  },
  {
    "id": 1440,
    "function": "height_link",
    "file": "Chap39/BSTTreapStEph.rs",
    "lines": "119-121",
    "spec_strength": "hole",
    "snippet": "    fn height_link<T: StT + Ord>(link: &Link<T>) -> N\n        requires spec_size_link(link) < usize::MAX as nat,\n        decreases *link,"
  },
  {
    "id": 1441,
    "function": "update",
    "file": "Chap39/BSTTreapStEph.rs",
    "lines": "142",
    "spec_strength": "hole",
    "snippet": "    fn update<T: StT + Ord>(node: &mut Node<T>) {"
  },
  {
    "id": 1442,
    "function": "rotate_left",
    "file": "Chap39/BSTTreapStEph.rs",
    "lines": "148",
    "spec_strength": "",
    "snippet": "    fn rotate_left<T: StT + Ord>(link: &mut Link<T>) {"
  },
  {
    "id": 1443,
    "function": "rotate_right",
    "file": "Chap39/BSTTreapStEph.rs",
    "lines": "164",
    "spec_strength": "",
    "snippet": "    fn rotate_right<T: StT + Ord>(link: &mut Link<T>) {"
  },
  {
    "id": 1444,
    "function": "insert_link",
    "file": "Chap39/BSTTreapStEph.rs",
    "lines": "181-182",
    "spec_strength": "hole",
    "snippet": "    fn insert_link<T: StT + Ord>(link: &mut Link<T>, value: T, priority: u64)\n        decreases old(link),"
  },
  {
    "id": 1445,
    "function": "find_link",
    "file": "Chap39/BSTTreapStEph.rs",
    "lines": "207-208",
    "spec_strength": "hole",
    "snippet": "    fn find_link<'a, T: StT + Ord>(link: &'a Link<T>, target: &T) -> Option<&'a T>\n        decreases *link,"
  },
  {
    "id": 1446,
    "function": "min_link",
    "file": "Chap39/BSTTreapStEph.rs",
    "lines": "226-227",
    "spec_strength": "",
    "snippet": "    fn min_link<T: StT + Ord>(link: &Link<T>) -> Option<&T>\n        decreases *link,"
  },
  {
    "id": 1447,
    "function": "max_link",
    "file": "Chap39/BSTTreapStEph.rs",
    "lines": "240-241",
    "spec_strength": "",
    "snippet": "    fn max_link<T: StT + Ord>(link: &Link<T>) -> Option<&T>\n        decreases *link,"
  },
  {
    "id": 1448,
    "function": "in_order_collect",
    "file": "Chap39/BSTTreapStEph.rs",
    "lines": "254-255",
    "spec_strength": "",
    "snippet": "    fn in_order_collect<T: StT + Ord>(link: &Link<T>, out: &mut Vec<T>)\n        decreases *link,"
  },
  {
    "id": 1449,
    "function": "pre_order_collect",
    "file": "Chap39/BSTTreapStEph.rs",
    "lines": "266-267",
    "spec_strength": "",
    "snippet": "    fn pre_order_collect<T: StT + Ord>(link: &Link<T>, out: &mut Vec<T>)\n        decreases *link,"
  },
  {
    "id": 1450,
    "function": "default",
    "file": "Chap39/BSTTreapStEph.rs",
    "lines": "317",
    "spec_strength": "",
    "snippet": "        fn default() -> Self { Self::new() }"
  },
  {
    "id": 1451,
    "function": "new_node",
    "file": "Chap40/BSTKeyValueStEph.rs",
    "lines": "40",
    "spec_strength": "",
    "snippet": "    fn new_node<K: StT + Ord, V: StT>(key: K, value: V, priority: u64) -> Node<K, V> {"
  },
  {
    "id": 1452,
    "function": "new",
    "file": "Chap40/BSTKeyValueStEph.rs",
    "lines": "70-72",
    "spec_strength": "",
    "snippet": "        fn new()                    -> Self\n        where\n            Self: Sized;"
  },
  {
    "id": 1453,
    "function": "size",
    "file": "Chap40/BSTKeyValueStEph.rs",
    "lines": "74",
    "spec_strength": "",
    "snippet": "        fn size(&self)              -> N;"
  },
  {
    "id": 1454,
    "function": "is_empty",
    "file": "Chap40/BSTKeyValueStEph.rs",
    "lines": "76",
    "spec_strength": "",
    "snippet": "        fn is_empty(&self)          -> B;"
  },
  {
    "id": 1455,
    "function": "height",
    "file": "Chap40/BSTKeyValueStEph.rs",
    "lines": "78",
    "spec_strength": "",
    "snippet": "        fn height(&self)            -> N;"
  },
  {
    "id": 1456,
    "function": "insert",
    "file": "Chap40/BSTKeyValueStEph.rs",
    "lines": "80",
    "spec_strength": "hole",
    "snippet": "        fn insert(&mut self, key: K, value: V, priority: u64);"
  },
  {
    "id": 1457,
    "function": "delete",
    "file": "Chap40/BSTKeyValueStEph.rs",
    "lines": "82",
    "spec_strength": "hole",
    "snippet": "        fn delete(&mut self, key: &K);"
  },
  {
    "id": 1458,
    "function": "find",
    "file": "Chap40/BSTKeyValueStEph.rs",
    "lines": "84",
    "spec_strength": "",
    "snippet": "        fn find(&self, key: &K)     -> Option<&V>;"
  },
  {
    "id": 1459,
    "function": "contains",
    "file": "Chap40/BSTKeyValueStEph.rs",
    "lines": "86",
    "spec_strength": "",
    "snippet": "        fn contains(&self, key: &K) -> B;"
  },
  {
    "id": 1460,
    "function": "get",
    "file": "Chap40/BSTKeyValueStEph.rs",
    "lines": "88",
    "spec_strength": "",
    "snippet": "        fn get(&self, key: &K)      -> Option<&V>;"
  },
  {
    "id": 1461,
    "function": "keys",
    "file": "Chap40/BSTKeyValueStEph.rs",
    "lines": "90",
    "spec_strength": "hole",
    "snippet": "        fn keys(&self)              -> ArraySeqStPerS<K>;"
  },
  {
    "id": 1462,
    "function": "values",
    "file": "Chap40/BSTKeyValueStEph.rs",
    "lines": "92",
    "spec_strength": "hole",
    "snippet": "        fn values(&self)            -> ArraySeqStPerS<V>;"
  },
  {
    "id": 1463,
    "function": "minimum_key",
    "file": "Chap40/BSTKeyValueStEph.rs",
    "lines": "95",
    "spec_strength": "",
    "snippet": "        fn minimum_key(&self)       -> Option<&K>;"
  },
  {
    "id": 1464,
    "function": "maximum_key",
    "file": "Chap40/BSTKeyValueStEph.rs",
    "lines": "98",
    "spec_strength": "",
    "snippet": "        fn maximum_key(&self)       -> Option<&K>;"
  },
  {
    "id": 1465,
    "function": "height_link",
    "file": "Chap40/BSTKeyValueStEph.rs",
    "lines": "101-102",
    "spec_strength": "hole",
    "snippet": "    fn height_link<K: StT + Ord, V: StT>(link: &Link<K, V>) -> N\n        decreases *link,"
  },
  {
    "id": 1466,
    "function": "rotate_left",
    "file": "Chap40/BSTKeyValueStEph.rs",
    "lines": "116",
    "spec_strength": "",
    "snippet": "    fn rotate_left<K: StT + Ord, V: StT>(link: &mut Link<K, V>) {"
  },
  {
    "id": 1467,
    "function": "rotate_right",
    "file": "Chap40/BSTKeyValueStEph.rs",
    "lines": "130",
    "spec_strength": "",
    "snippet": "    fn rotate_right<K: StT + Ord, V: StT>(link: &mut Link<K, V>) {"
  },
  {
    "id": 1468,
    "function": "insert_link",
    "file": "Chap40/BSTKeyValueStEph.rs",
    "lines": "145-146",
    "spec_strength": "hole",
    "snippet": "    fn insert_link<K: StT + Ord, V: StT>(link: &mut Link<K, V>, key: K, value: V, priority: u64) -> bool\n        decreases old(link),"
  },
  {
    "id": 1469,
    "function": "find_link",
    "file": "Chap40/BSTKeyValueStEph.rs",
    "lines": "174",
    "spec_strength": "hole",
    "snippet": "    fn find_link<'a, K: StT + Ord, V: StT>(link: &'a Link<K, V>, key: &K) -> Option<&'a V> {"
  },
  {
    "id": 1470,
    "function": "min_key_link",
    "file": "Chap40/BSTKeyValueStEph.rs",
    "lines": "191-192",
    "spec_strength": "",
    "snippet": "    fn min_key_link<K: StT + Ord, V: StT>(link: &Link<K, V>) -> Option<&K>\n        decreases *link,"
  },
  {
    "id": 1471,
    "function": "max_key_link",
    "file": "Chap40/BSTKeyValueStEph.rs",
    "lines": "205-206",
    "spec_strength": "",
    "snippet": "    fn max_key_link<K: StT + Ord, V: StT>(link: &Link<K, V>) -> Option<&K>\n        decreases *link,"
  },
  {
    "id": 1472,
    "function": "collect_keys",
    "file": "Chap40/BSTKeyValueStEph.rs",
    "lines": "219-220",
    "spec_strength": "",
    "snippet": "    fn collect_keys<K: StT + Ord, V: StT>(link: &Link<K, V>, out: &mut Vec<K>)\n        decreases *link,"
  },
  {
    "id": 1473,
    "function": "collect_values",
    "file": "Chap40/BSTKeyValueStEph.rs",
    "lines": "231-232",
    "spec_strength": "",
    "snippet": "    fn collect_values<K: StT + Ord, V: StT>(link: &Link<K, V>, out: &mut Vec<V>)\n        decreases *link,"
  },
  {
    "id": 1474,
    "function": "collect_in_order_kvp",
    "file": "Chap40/BSTKeyValueStEph.rs",
    "lines": "242-243",
    "spec_strength": "",
    "snippet": "    fn collect_in_order_kvp<K: StT + Ord, V: StT>(link: &Link<K, V>, out: &mut Vec<(K, V, u64)>)\n        decreases *link,"
  },
  {
    "id": 1475,
    "function": "build_treap_from_sorted",
    "file": "Chap40/BSTKeyValueStEph.rs",
    "lines": "254-256",
    "spec_strength": "hole",
    "snippet": "    fn build_treap_from_sorted<K: StT + Ord, V: StT>(\n        seq: &[(K, V, u64)],\n    ) -> Link<K, V> {"
  },
  {
    "id": 1476,
    "function": "default",
    "file": "Chap40/BSTKeyValueStEph.rs",
    "lines": "329",
    "spec_strength": "",
    "snippet": "        fn default() -> Self { Self::new() }"
  },
  {
    "id": 1477,
    "function": "new`",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "117-119",
    "spec_strength": "",
    "snippet": "        fn new()                                  -> Self\n        where\n            Self: Sized;"
  },
  {
    "id": 1478,
    "function": "identity`",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "64",
    "spec_strength": "",
    "snippet": "        fn identity()          -> R;"
  },
  {
    "id": 1479,
    "function": "combine`",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "66",
    "spec_strength": "hole",
    "snippet": "        fn combine(a: R, b: R) -> R;"
  },
  {
    "id": 1480,
    "function": "lift`",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "68",
    "spec_strength": "",
    "snippet": "        fn lift(value: &V)     -> R;"
  },
  {
    "id": 1481,
    "function": "size",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "121",
    "spec_strength": "",
    "snippet": "        fn size(&self)                            -> N;"
  },
  {
    "id": 1482,
    "function": "is_empty",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "123",
    "spec_strength": "",
    "snippet": "        fn is_empty(&self)                        -> B;"
  },
  {
    "id": 1483,
    "function": "height",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "125",
    "spec_strength": "",
    "snippet": "        fn height(&self)                          -> N;"
  },
  {
    "id": 1484,
    "function": "insert",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "127",
    "spec_strength": "",
    "snippet": "        fn insert(&mut self, key: K, value: V, priority: u64);"
  },
  {
    "id": 1485,
    "function": "delete",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "129",
    "spec_strength": "hole",
    "snippet": "        fn delete(&mut self, key: &K);"
  },
  {
    "id": 1486,
    "function": "find",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "131",
    "spec_strength": "",
    "snippet": "        fn find(&self, key: &K)                   -> Option<&V>;"
  },
  {
    "id": 1487,
    "function": "contains",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "133",
    "spec_strength": "",
    "snippet": "        fn contains(&self, key: &K)               -> B;"
  },
  {
    "id": 1488,
    "function": "get",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "135",
    "spec_strength": "",
    "snippet": "        fn get(&self, key: &K)                    -> Option<&V>;"
  },
  {
    "id": 1489,
    "function": "keys",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "137",
    "spec_strength": "hole",
    "snippet": "        fn keys(&self)                            -> ArraySeqStPerS<K>;"
  },
  {
    "id": 1490,
    "function": "values",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "139",
    "spec_strength": "hole",
    "snippet": "        fn values(&self)                          -> ArraySeqStPerS<V>;"
  },
  {
    "id": 1491,
    "function": "minimum_key",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "142",
    "spec_strength": "",
    "snippet": "        fn minimum_key(&self)                     -> Option<&K>;"
  },
  {
    "id": 1492,
    "function": "maximum_key",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "145",
    "spec_strength": "",
    "snippet": "        fn maximum_key(&self)                     -> Option<&K>;"
  },
  {
    "id": 1493,
    "function": "reduced_value",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "148",
    "spec_strength": "",
    "snippet": "        fn reduced_value(&self)                   -> R;"
  },
  {
    "id": 1494,
    "function": "range_reduce",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "151",
    "spec_strength": "",
    "snippet": "        fn range_reduce(&self, low: &K, high: &K) -> R;"
  },
  {
    "id": 1495,
    "function": "default",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "155",
    "spec_strength": "",
    "snippet": "        fn default() -> Self { Self::new() }"
  },
  {
    "id": 1496,
    "function": "size_link",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "160",
    "spec_strength": "",
    "snippet": "    fn size_link<K: StT + Ord, V: StT, R: StT>(link: &Link<K, V, R>) -> N {"
  },
  {
    "id": 1497,
    "function": "reduced_value_link",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "170",
    "spec_strength": "hole",
    "snippet": "    fn reduced_value_link<K: StT + Ord, V: StT, R: StT, Op: ReduceOp<V, R>>(link: &Link<K, V, R>) -> R {"
  },
  {
    "id": 1498,
    "function": "update_node",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "180",
    "spec_strength": "hole",
    "snippet": "    fn update_node<K: StT + Ord, V: StT, R: StT, Op: ReduceOp<V, R>>(node: &mut Node<K, V, R>) {"
  },
  {
    "id": 1499,
    "function": "make_node",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "193-199",
    "spec_strength": "",
    "snippet": "    fn make_node<K: StT + Ord, V: StT, R: StT, Op: ReduceOp<V, R>>(\n        key: K,\n        value: V,\n        priority: u64,\n        left: Link<K, V, R>,\n        right: Link<K, V, R>,\n    ) -> Link<K, V, R> {"
  },
  {
    "id": 1500,
    "function": "rotate_left",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "210",
    "spec_strength": "",
    "snippet": "    fn rotate_left<K: StT + Ord, V: StT, R: StT, Op: ReduceOp<V, R>>(link: &mut Link<K, V, R>) {"
  },
  {
    "id": 1501,
    "function": "rotate_right",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "226",
    "spec_strength": "",
    "snippet": "    fn rotate_right<K: StT + Ord, V: StT, R: StT, Op: ReduceOp<V, R>>(link: &mut Link<K, V, R>) {"
  },
  {
    "id": 1502,
    "function": "insert_link",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "243-248",
    "spec_strength": "hole",
    "snippet": "    fn insert_link<K: StT + Ord, V: StT, R: StT, Op: ReduceOp<V, R>>(\n        link: &mut Link<K, V, R>,\n        key: K,\n        value: V,\n        priority: u64,\n    ) {"
  },
  {
    "id": 1503,
    "function": "find_link",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "274-278",
    "spec_strength": "",
    "snippet": "    fn find_link<'a, K: StT + Ord, V: StT, R: StT>(\n        link: &'a Link<K, V, R>,\n        key: &K,\n    ) -> Option<&'a V>\n        decreases *link,"
  },
  {
    "id": 1504,
    "function": "min_key_link",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "296-297",
    "spec_strength": "",
    "snippet": "    fn min_key_link<K: StT + Ord, V: StT, R: StT>(link: &Link<K, V, R>) -> Option<&K>\n        decreases *link,"
  },
  {
    "id": 1505,
    "function": "max_key_link",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "310-311",
    "spec_strength": "",
    "snippet": "    fn max_key_link<K: StT + Ord, V: StT, R: StT>(link: &Link<K, V, R>) -> Option<&K>\n        decreases *link,"
  },
  {
    "id": 1506,
    "function": "collect_keys",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "324-325",
    "spec_strength": "",
    "snippet": "    fn collect_keys<K: StT + Ord, V: StT, R: StT>(link: &Link<K, V, R>, out: &mut Vec<K>)\n        decreases *link,"
  },
  {
    "id": 1507,
    "function": "collect_values",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "336-337",
    "spec_strength": "",
    "snippet": "    fn collect_values<K: StT + Ord, V: StT, R: StT>(link: &Link<K, V, R>, out: &mut Vec<V>)\n        decreases *link,"
  },
  {
    "id": 1508,
    "function": "collect_in_order_kvp",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "347-351",
    "spec_strength": "",
    "snippet": "    fn collect_in_order_kvp<K: StT + Ord, V: StT, R: StT>(\n        link: &Link<K, V, R>,\n        out: &mut Vec<(K, V, u64)>,\n    )\n        decreases *link,"
  },
  {
    "id": 1509,
    "function": "height_link",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "360-361",
    "spec_strength": "hole",
    "snippet": "    fn height_link<K: StT + Ord, V: StT, R: StT>(link: &Link<K, V, R>) -> N\n        decreases *link,"
  },
  {
    "id": 1510,
    "function": "build_treap_from_sorted",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "375-377",
    "spec_strength": "hole",
    "snippet": "    fn build_treap_from_sorted<K: StT + Ord, V: StT, R: StT, Op: ReduceOp<V, R>>(\n        seq: &[(K, V, u64)],\n    ) -> Link<K, V, R> {"
  },
  {
    "id": 1511,
    "function": "range_reduce_link",
    "file": "Chap40/BSTReducedStEph.rs",
    "lines": "398-402",
    "spec_strength": "hole",
    "snippet": "    fn range_reduce_link<K: StT + Ord, V: StT, R: StT, Op: ReduceOp<V, R>>(\n        link: &Link<K, V, R>,\n        low: &K,\n        high: &K,\n    ) -> R {"
  },
  {
    "id": 1512,
    "function": "new`",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "70-72",
    "spec_strength": "",
    "snippet": "        fn new()                       -> Self\n        where\n            Self: Sized;"
  },
  {
    "id": 1513,
    "function": "size",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "74",
    "spec_strength": "",
    "snippet": "        fn size(&self)                 -> N;"
  },
  {
    "id": 1514,
    "function": "is_empty",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "76",
    "spec_strength": "",
    "snippet": "        fn is_empty(&self)             -> B;"
  },
  {
    "id": 1515,
    "function": "height",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "78",
    "spec_strength": "",
    "snippet": "        fn height(&self)               -> N;"
  },
  {
    "id": 1516,
    "function": "insert",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "80",
    "spec_strength": "",
    "snippet": "        fn insert(&mut self, value: T, priority: u64);"
  },
  {
    "id": 1517,
    "function": "delete",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "82",
    "spec_strength": "hole",
    "snippet": "        fn delete(&mut self, key: &T);"
  },
  {
    "id": 1518,
    "function": "find",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "84",
    "spec_strength": "",
    "snippet": "        fn find(&self, target: &T)     -> Option<&T>;"
  },
  {
    "id": 1519,
    "function": "contains",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "86",
    "spec_strength": "",
    "snippet": "        fn contains(&self, target: &T) -> B;"
  },
  {
    "id": 1520,
    "function": "minimum",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "88",
    "spec_strength": "",
    "snippet": "        fn minimum(&self)              -> Option<&T>;"
  },
  {
    "id": 1521,
    "function": "maximum",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "90",
    "spec_strength": "",
    "snippet": "        fn maximum(&self)              -> Option<&T>;"
  },
  {
    "id": 1522,
    "function": "in_order",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "92",
    "spec_strength": "hole",
    "snippet": "        fn in_order(&self)             -> ArraySeqStPerS<T>;"
  },
  {
    "id": 1523,
    "function": "rank",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "94",
    "spec_strength": "",
    "snippet": "        fn rank(&self, key: &T)        -> N;"
  },
  {
    "id": 1524,
    "function": "select",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "97",
    "spec_strength": "",
    "snippet": "        fn select(&self, rank: N)      -> Option<&T>;"
  },
  {
    "id": 1525,
    "function": "split_rank",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "100",
    "spec_strength": "hole",
    "snippet": "        fn split_rank(&self, rank: N)  -> (BSTSizeStEph<T>, BSTSizeStEph<T>);"
  },
  {
    "id": 1526,
    "function": "height_link",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "103-104",
    "spec_strength": "hole",
    "snippet": "    fn height_link<T: StT + Ord>(link: &Link<T>) -> N\n        decreases *link,"
  },
  {
    "id": 1527,
    "function": "size_link",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "118",
    "spec_strength": "",
    "snippet": "    fn size_link<T: StT + Ord>(link: &Link<T>) -> N {"
  },
  {
    "id": 1528,
    "function": "update_size",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "128",
    "spec_strength": "hole",
    "snippet": "    fn update_size<T: StT + Ord>(node: &mut Node<T>) {"
  },
  {
    "id": 1529,
    "function": "make_node",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "134",
    "spec_strength": "",
    "snippet": "    fn make_node<T: StT + Ord>(key: T, priority: u64, left: Link<T>, right: Link<T>) -> Link<T> {"
  },
  {
    "id": 1530,
    "function": "rotate_left",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "144",
    "spec_strength": "",
    "snippet": "    fn rotate_left<T: StT + Ord>(link: &mut Link<T>) {"
  },
  {
    "id": 1531,
    "function": "rotate_right",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "160",
    "spec_strength": "",
    "snippet": "    fn rotate_right<T: StT + Ord>(link: &mut Link<T>) {"
  },
  {
    "id": 1532,
    "function": "insert_link",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "177-178",
    "spec_strength": "hole",
    "snippet": "    fn insert_link<T: StT + Ord>(link: &mut Link<T>, value: T, priority: u64)\n        decreases old(link),"
  },
  {
    "id": 1533,
    "function": "find_link",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "202-203",
    "spec_strength": "",
    "snippet": "    fn find_link<'a, T: StT + Ord>(link: &'a Link<T>, target: &T) -> Option<&'a T>\n        decreases *link,"
  },
  {
    "id": 1534,
    "function": "min_link",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "221-222",
    "spec_strength": "",
    "snippet": "    fn min_link<T: StT + Ord>(link: &Link<T>) -> Option<&T>\n        decreases *link,"
  },
  {
    "id": 1535,
    "function": "max_link",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "235-236",
    "spec_strength": "",
    "snippet": "    fn max_link<T: StT + Ord>(link: &Link<T>) -> Option<&T>\n        decreases *link,"
  },
  {
    "id": 1536,
    "function": "in_order_collect",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "249-250",
    "spec_strength": "",
    "snippet": "    fn in_order_collect<T: StT + Ord>(link: &Link<T>, out: &mut Vec<T>)\n        decreases *link,"
  },
  {
    "id": 1537,
    "function": "in_order_collect_with_priority",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "261-265",
    "spec_strength": "",
    "snippet": "    fn in_order_collect_with_priority<T: StT + Ord>(\n        link: &Link<T>,\n        out: &mut Vec<(T, u64)>,\n    )\n        decreases *link,"
  },
  {
    "id": 1538,
    "function": "build_treap_from_sorted",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "277",
    "spec_strength": "hole",
    "snippet": "    fn build_treap_from_sorted<T: StT + Ord>(seq: &[(T, u64)]) -> Link<T> {"
  },
  {
    "id": 1539,
    "function": "rank_link",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "298-299",
    "spec_strength": "hole",
    "snippet": "    fn rank_link<T: StT + Ord>(link: &Link<T>, key: &T) -> N\n        decreases *link,"
  },
  {
    "id": 1540,
    "function": "select_link",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "318-319",
    "spec_strength": "",
    "snippet": "    fn select_link<T: StT + Ord>(link: &Link<T>, rank: N) -> Option<&T>\n        decreases *link,"
  },
  {
    "id": 1541,
    "function": "default",
    "file": "Chap40/BSTSizeStEph.rs",
    "lines": "405",
    "spec_strength": "",
    "snippet": "        fn default() -> Self { Self::new()         }"
  },
  {
    "id": 1542,
    "function": "new_set_mt_lock",
    "file": "Chap41/AVLTreeSetMtEph.rs",
    "lines": "53",
    "spec_strength": "hole",
    "snippet": "    fn new_set_mt_lock<T: StTInMtT + Ord + 'static>(val: AVLTreeSetStEph<T>) -> (lock: RwLock<AVLTreeSetStEph<T>, SetMtWf>) {"
  },
  {
    "id": 1543,
    "function": "size",
    "file": "Chap41/AVLTreeSetMtEph.rs",
    "lines": "80-81",
    "spec_strength": "hole",
    "snippet": "        fn size(&self) -> (result: usize)\n            ensures result == self@.len(), self@.finite();"
  },
  {
    "id": 1544,
    "function": "to_seq",
    "file": "Chap41/AVLTreeSetMtEph.rs",
    "lines": "84-85",
    "spec_strength": "hole",
    "snippet": "        fn to_seq(&self) -> (result: AVLTreeSeqStEphS<T>)\n            ensures self@.finite();"
  },
  {
    "id": 1545,
    "function": "empty",
    "file": "Chap41/AVLTreeSetMtEph.rs",
    "lines": "88-89",
    "spec_strength": "hole",
    "snippet": "        fn empty() -> (result: Self)\n            ensures result@ == Set::<<T as View>::V>::empty();"
  },
  {
    "id": 1546,
    "function": "singleton",
    "file": "Chap41/AVLTreeSetMtEph.rs",
    "lines": "92-93",
    "spec_strength": "hole",
    "snippet": "        fn singleton(x: T) -> (result: Self)\n            ensures result@ == Set::<<T as View>::V>::empty().insert(x@), result@.finite();"
  },
  {
    "id": 1547,
    "function": "from_seq",
    "file": "Chap41/AVLTreeSetMtEph.rs",
    "lines": "95-96",
    "spec_strength": "hole",
    "snippet": "        fn from_seq(seq: AVLTreeSeqStEphS<T>) -> (result: Self)\n            ensures result@.finite();"
  },
  {
    "id": 1548,
    "function": "filter",
    "file": "Chap41/AVLTreeSetMtEph.rs",
    "lines": "99-100",
    "spec_strength": "hole",
    "snippet": "        fn filter<F: PredMt<T> + Clone>(&self, f: F) -> (result: Self)\n            ensures result@.finite(), result@.subset_of(self@);"
  },
  {
    "id": 1549,
    "function": "intersection",
    "file": "Chap41/AVLTreeSetMtEph.rs",
    "lines": "103-104",
    "spec_strength": "hole",
    "snippet": "        fn intersection(&self, other: &Self) -> (result: Self)\n            ensures result@ == self@.intersect(other@), result@.finite();"
  },
  {
    "id": 1550,
    "function": "difference",
    "file": "Chap41/AVLTreeSetMtEph.rs",
    "lines": "107-108",
    "spec_strength": "hole",
    "snippet": "        fn difference(&self, other: &Self) -> (result: Self)\n            ensures result@ == self@.difference(other@), result@.finite();"
  },
  {
    "id": 1551,
    "function": "union",
    "file": "Chap41/AVLTreeSetMtEph.rs",
    "lines": "111-112",
    "spec_strength": "hole",
    "snippet": "        fn union(&self, other: &Self) -> (result: Self)\n            ensures result@ == self@.union(other@), result@.finite();"
  },
  {
    "id": 1552,
    "function": "find",
    "file": "Chap41/AVLTreeSetMtEph.rs",
    "lines": "115-116",
    "spec_strength": "hole",
    "snippet": "        fn find(&self, x: &T) -> (result: B)\n            ensures result == self@.contains(x@);"
  },
  {
    "id": 1553,
    "function": "delete",
    "file": "Chap41/AVLTreeSetMtEph.rs",
    "lines": "119-120",
    "spec_strength": "hole",
    "snippet": "        fn delete(&mut self, x: &T)\n            ensures self@ == old(self)@.remove(x@), self@.finite();"
  },
  {
    "id": 1554,
    "function": "insert",
    "file": "Chap41/AVLTreeSetMtEph.rs",
    "lines": "123-124",
    "spec_strength": "hole",
    "snippet": "        fn insert(&mut self, x: T)\n            ensures self@ == old(self)@.insert(x@), self@.finite();"
  },
  {
    "id": 1555,
    "function": "default",
    "file": "Chap41/AVLTreeSetMtEph.rs",
    "lines": "401",
    "spec_strength": "",
    "snippet": "        fn default() -> Self { Self::empty() }"
  },
  {
    "id": 1556,
    "function": "size",
    "file": "Chap41/AVLTreeSetMtPer.rs",
    "lines": "69-70",
    "spec_strength": "hole",
    "snippet": "        fn size(&self) -> (result: usize)\n            ensures result == self@.len(), self@.finite();"
  },
  {
    "id": 1557,
    "function": "to_seq",
    "file": "Chap41/AVLTreeSetMtPer.rs",
    "lines": "73-74",
    "spec_strength": "hole",
    "snippet": "        fn to_seq(&self) -> (result: AVLTreeSeqMtPerS<T>)\n            ensures self@.finite();"
  },
  {
    "id": 1558,
    "function": "empty",
    "file": "Chap41/AVLTreeSetMtPer.rs",
    "lines": "77-78",
    "spec_strength": "hole",
    "snippet": "        fn empty() -> (result: Self)\n            ensures result@ == Set::<<T as View>::V>::empty();"
  },
  {
    "id": 1559,
    "function": "singleton",
    "file": "Chap41/AVLTreeSetMtPer.rs",
    "lines": "81-82",
    "spec_strength": "hole",
    "snippet": "        fn singleton(x: T) -> (result: Self)\n            ensures result@ == Set::<<T as View>::V>::empty().insert(x@), result@.finite();"
  },
  {
    "id": 1560,
    "function": "from_seq",
    "file": "Chap41/AVLTreeSetMtPer.rs",
    "lines": "84-85",
    "spec_strength": "hole",
    "snippet": "        fn from_seq(seq: AVLTreeSeqMtPerS<T>) -> (result: Self)\n            ensures result@.finite();"
  },
  {
    "id": 1561,
    "function": "filter",
    "file": "Chap41/AVLTreeSetMtPer.rs",
    "lines": "88-89",
    "spec_strength": "hole",
    "snippet": "        fn filter<F: PredMt<T> + Clone>(&self, f: F) -> (result: Self)\n            ensures result@.finite(), result@.subset_of(self@);"
  },
  {
    "id": 1562,
    "function": "intersection",
    "file": "Chap41/AVLTreeSetMtPer.rs",
    "lines": "92-93",
    "spec_strength": "hole",
    "snippet": "        fn intersection(&self, other: &Self) -> (result: Self)\n            ensures result@ == self@.intersect(other@), result@.finite();"
  },
  {
    "id": 1563,
    "function": "difference",
    "file": "Chap41/AVLTreeSetMtPer.rs",
    "lines": "96-97",
    "spec_strength": "hole",
    "snippet": "        fn difference(&self, other: &Self) -> (result: Self)\n            ensures result@ == self@.difference(other@), result@.finite();"
  },
  {
    "id": 1564,
    "function": "union",
    "file": "Chap41/AVLTreeSetMtPer.rs",
    "lines": "100-101",
    "spec_strength": "hole",
    "snippet": "        fn union(&self, other: &Self) -> (result: Self)\n            ensures result@ == self@.union(other@), result@.finite();"
  },
  {
    "id": 1565,
    "function": "find",
    "file": "Chap41/AVLTreeSetMtPer.rs",
    "lines": "104-105",
    "spec_strength": "hole",
    "snippet": "        fn find(&self, x: &T) -> (result: B)\n            ensures result == self@.contains(x@);"
  },
  {
    "id": 1566,
    "function": "delete",
    "file": "Chap41/AVLTreeSetMtPer.rs",
    "lines": "108-109",
    "spec_strength": "hole",
    "snippet": "        fn delete(&self, x: &T) -> (result: Self)\n            ensures result@ == self@.remove(x@), result@.finite();"
  },
  {
    "id": 1567,
    "function": "insert",
    "file": "Chap41/AVLTreeSetMtPer.rs",
    "lines": "112-113",
    "spec_strength": "hole",
    "snippet": "        fn insert(&self, x: T) -> (result: Self)\n            ensures result@ == self@.insert(x@), result@.finite();"
  },
  {
    "id": 1568,
    "function": "default",
    "file": "Chap41/AVLTreeSetMtPer.rs",
    "lines": "467",
    "spec_strength": "",
    "snippet": "        fn default() -> Self { Self::empty() }"
  },
  {
    "id": 1569,
    "function": "eq",
    "file": "Chap41/AVLTreeSetMtPer.rs",
    "lines": "471-480",
    "spec_strength": "",
    "snippet": "        fn eq(&self, other: &Self) -> bool {\n            self.size() == other.size() && {\n                for i in 0..self.size() {\n                    if !other.find(self.elements.nth(i)) {\n                        return false;\n                    }\n                }\n                true\n            }\n        }"
  },
  {
    "id": 1570,
    "function": "partial_cmp",
    "file": "Chap41/AVLTreeSetMtPer.rs",
    "lines": "486-488",
    "spec_strength": "",
    "snippet": "        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n            Some(self.cmp(other))\n        }"
  },
  {
    "id": 1571,
    "function": "cmp",
    "file": "Chap41/AVLTreeSetMtPer.rs",
    "lines": "492-510",
    "spec_strength": "",
    "snippet": "        fn cmp(&self, other: &Self) -> Ordering {\n            // Lexicographic ordering: compare element by element (no cloning)\n            let n_self = self.size();\n            let n_other = other.size();\n            let min_n = n_self.min(n_other);\n\n            // Compare common prefix\n            for i in 0..min_n {\n                let a = self.elements.nth(i);\n                let b = other.elements.nth(i);\n                match a.cmp(b) {\n                    Equal => continue,\n                    non_equal => return non_equal,\n                }\n            }\n\n            // If all compared elements are equal, compare by size\n            n_self.cmp(&n_other)\n        }"
  },
  {
    "id": 1572,
    "function": "size",
    "file": "Chap41/AVLTreeSetStEph.rs",
    "lines": "59-60",
    "spec_strength": "hole",
    "snippet": "        fn size(&self) -> (result: usize)\n            ensures result == self@.len(), self@.finite();"
  },
  {
    "id": 1573,
    "function": "to_seq",
    "file": "Chap41/AVLTreeSetStEph.rs",
    "lines": "63-64",
    "spec_strength": "hole",
    "snippet": "        fn to_seq(&self) -> (result: AVLTreeSeqStEphS<T>)\n            ensures self@.finite();"
  },
  {
    "id": 1574,
    "function": "empty",
    "file": "Chap41/AVLTreeSetStEph.rs",
    "lines": "67-68",
    "spec_strength": "hole",
    "snippet": "        fn empty() -> (result: Self)\n            ensures result@ == Set::<<T as View>::V>::empty();"
  },
  {
    "id": 1575,
    "function": "singleton",
    "file": "Chap41/AVLTreeSetStEph.rs",
    "lines": "71-72",
    "spec_strength": "hole",
    "snippet": "        fn singleton(x: T) -> (result: Self)\n            ensures result@ == Set::<<T as View>::V>::empty().insert(x@), result@.finite();"
  },
  {
    "id": 1576,
    "function": "from_seq",
    "file": "Chap41/AVLTreeSetStEph.rs",
    "lines": "74-75",
    "spec_strength": "hole",
    "snippet": "        fn from_seq(seq: AVLTreeSeqStEphS<T>) -> (result: Self)\n            ensures result@.finite();"
  },
  {
    "id": 1577,
    "function": "filter",
    "file": "Chap41/AVLTreeSetStEph.rs",
    "lines": "78-79",
    "spec_strength": "hole",
    "snippet": "        fn filter<F: PredSt<T>>(&self, f: F) -> (result: Self)\n            ensures result@.finite(), result@.subset_of(self@);"
  },
  {
    "id": 1578,
    "function": "intersection",
    "file": "Chap41/AVLTreeSetStEph.rs",
    "lines": "82-83",
    "spec_strength": "hole",
    "snippet": "        fn intersection(&self, other: &Self) -> (result: Self)\n            ensures result@ == self@.intersect(other@), result@.finite();"
  },
  {
    "id": 1579,
    "function": "difference",
    "file": "Chap41/AVLTreeSetStEph.rs",
    "lines": "86-87",
    "spec_strength": "hole",
    "snippet": "        fn difference(&self, other: &Self) -> (result: Self)\n            ensures result@ == self@.difference(other@), result@.finite();"
  },
  {
    "id": 1580,
    "function": "union",
    "file": "Chap41/AVLTreeSetStEph.rs",
    "lines": "90-91",
    "spec_strength": "hole",
    "snippet": "        fn union(&self, other: &Self) -> (result: Self)\n            ensures result@ == self@.union(other@), result@.finite();"
  },
  {
    "id": 1581,
    "function": "find",
    "file": "Chap41/AVLTreeSetStEph.rs",
    "lines": "94-95",
    "spec_strength": "hole",
    "snippet": "        fn find(&self, x: &T) -> (result: B)\n            ensures result == self@.contains(x@);"
  },
  {
    "id": 1582,
    "function": "delete",
    "file": "Chap41/AVLTreeSetStEph.rs",
    "lines": "98-99",
    "spec_strength": "hole",
    "snippet": "        fn delete(&mut self, x: &T)\n            ensures self@ == old(self)@.remove(x@), self@.finite();"
  },
  {
    "id": 1583,
    "function": "insert",
    "file": "Chap41/AVLTreeSetStEph.rs",
    "lines": "102-103",
    "spec_strength": "hole",
    "snippet": "        fn insert(&mut self, x: T)\n            ensures self@ == old(self)@.insert(x@), self@.finite();"
  },
  {
    "id": 1584,
    "function": "default",
    "file": "Chap41/AVLTreeSetStEph.rs",
    "lines": "435",
    "spec_strength": "",
    "snippet": "        fn default() -> Self { Self::empty() }"
  },
  {
    "id": 1585,
    "function": "eq",
    "file": "Chap41/AVLTreeSetStEph.rs",
    "lines": "439-448",
    "spec_strength": "",
    "snippet": "        fn eq(&self, other: &Self) -> bool {\n            self.size() == other.size() && {\n                for i in 0..self.elements.length() {\n                    if !other.find(self.elements.nth(i)) {\n                        return false;\n                    }\n                }\n                true\n            }\n        }"
  },
  {
    "id": 1586,
    "function": "size",
    "file": "Chap41/AVLTreeSetStPer.rs",
    "lines": "57-58",
    "spec_strength": "hole",
    "snippet": "        fn size(&self) -> (result: usize)\n            ensures result == self@.len(), self@.finite();"
  },
  {
    "id": 1587,
    "function": "to_seq",
    "file": "Chap41/AVLTreeSetStPer.rs",
    "lines": "61-62",
    "spec_strength": "hole",
    "snippet": "        fn to_seq(&self) -> (result: AVLTreeSeqStPerS<T>)\n            ensures self@.finite();"
  },
  {
    "id": 1588,
    "function": "empty",
    "file": "Chap41/AVLTreeSetStPer.rs",
    "lines": "65-66",
    "spec_strength": "hole",
    "snippet": "        fn empty() -> (result: Self)\n            ensures result@ == Set::<<T as View>::V>::empty();"
  },
  {
    "id": 1589,
    "function": "singleton",
    "file": "Chap41/AVLTreeSetStPer.rs",
    "lines": "69-70",
    "spec_strength": "hole",
    "snippet": "        fn singleton(x: T) -> (result: Self)\n            ensures result@ == Set::<<T as View>::V>::empty().insert(x@), result@.finite();"
  },
  {
    "id": 1590,
    "function": "from_seq",
    "file": "Chap41/AVLTreeSetStPer.rs",
    "lines": "72-73",
    "spec_strength": "hole",
    "snippet": "        fn from_seq(seq: AVLTreeSeqStPerS<T>) -> (result: Self)\n            ensures result@.finite();"
  },
  {
    "id": 1591,
    "function": "filter",
    "file": "Chap41/AVLTreeSetStPer.rs",
    "lines": "76-77",
    "spec_strength": "hole",
    "snippet": "        fn filter<F: PredSt<T>>(&self, f: F) -> (result: Self)\n            ensures result@.finite(), result@.subset_of(self@);"
  },
  {
    "id": 1592,
    "function": "intersection",
    "file": "Chap41/AVLTreeSetStPer.rs",
    "lines": "80-81",
    "spec_strength": "hole",
    "snippet": "        fn intersection(&self, other: &Self) -> (result: Self)\n            ensures result@ == self@.intersect(other@), result@.finite();"
  },
  {
    "id": 1593,
    "function": "difference",
    "file": "Chap41/AVLTreeSetStPer.rs",
    "lines": "84-85",
    "spec_strength": "hole",
    "snippet": "        fn difference(&self, other: &Self) -> (result: Self)\n            ensures result@ == self@.difference(other@), result@.finite();"
  },
  {
    "id": 1594,
    "function": "union",
    "file": "Chap41/AVLTreeSetStPer.rs",
    "lines": "88-89",
    "spec_strength": "hole",
    "snippet": "        fn union(&self, other: &Self) -> (result: Self)\n            ensures result@ == self@.union(other@), result@.finite();"
  },
  {
    "id": 1595,
    "function": "find",
    "file": "Chap41/AVLTreeSetStPer.rs",
    "lines": "92-93",
    "spec_strength": "hole",
    "snippet": "        fn find(&self, x: &T) -> (result: B)\n            ensures result == self@.contains(x@);"
  },
  {
    "id": 1596,
    "function": "delete",
    "file": "Chap41/AVLTreeSetStPer.rs",
    "lines": "96-97",
    "spec_strength": "hole",
    "snippet": "        fn delete(&self, x: &T) -> (result: Self)\n            ensures result@ == self@.remove(x@), result@.finite();"
  },
  {
    "id": 1597,
    "function": "insert",
    "file": "Chap41/AVLTreeSetStPer.rs",
    "lines": "100-101",
    "spec_strength": "hole",
    "snippet": "        fn insert(&self, x: T) -> (result: Self)\n            ensures result@ == self@.insert(x@), result@.finite();"
  },
  {
    "id": 1598,
    "function": "default",
    "file": "Chap41/AVLTreeSetStPer.rs",
    "lines": "441",
    "spec_strength": "",
    "snippet": "        fn default() -> Self { Self::empty() }"
  },
  {
    "id": 1599,
    "function": "eq",
    "file": "Chap41/AVLTreeSetStPer.rs",
    "lines": "445-454",
    "spec_strength": "",
    "snippet": "        fn eq(&self, other: &Self) -> bool {\n            self.size() == other.size() && {\n                for i in 0..self.elements.length() {\n                    if !other.find(self.elements.nth(i)) {\n                        return false;\n                    }\n                }\n                true\n            }\n        }"
  },
  {
    "id": 1600,
    "function": "new",
    "file": "Chap41/ArraySetEnumMtEph.rs",
    "lines": "48-49",
    "spec_strength": "hole",
    "snippet": "        fn new(u: usize) -> (result: Self)\n            ensures result@ == Set::<usize>::empty();"
  },
  {
    "id": 1601,
    "function": "size",
    "file": "Chap41/ArraySetEnumMtEph.rs",
    "lines": "52-53",
    "spec_strength": "hole",
    "snippet": "        fn size(&self) -> (result: usize)\n            ensures result == self@.len(), self@.finite();"
  },
  {
    "id": 1602,
    "function": "to_seq",
    "file": "Chap41/ArraySetEnumMtEph.rs",
    "lines": "56-57",
    "spec_strength": "hole",
    "snippet": "        fn to_seq(&self) -> (result: ArraySeqMtEphS<usize>)\n            ensures self@.finite();"
  },
  {
    "id": 1603,
    "function": "empty",
    "file": "Chap41/ArraySetEnumMtEph.rs",
    "lines": "59-60",
    "spec_strength": "hole",
    "snippet": "        fn empty(u: usize) -> (result: Self)\n            ensures result@ == Set::<usize>::empty();"
  },
  {
    "id": 1604,
    "function": "singleton",
    "file": "Chap41/ArraySetEnumMtEph.rs",
    "lines": "63-67",
    "spec_strength": "hole",
    "snippet": "        fn singleton(u: usize, x: usize) -> (result: Self)\n            ensures\n                (x < u ==> result@ == Set::<usize>::empty().insert(x)),\n                (x >= u ==> result@ == Set::<usize>::empty()),\n                result@.finite();"
  },
  {
    "id": 1605,
    "function": "from_seq",
    "file": "Chap41/ArraySetEnumMtEph.rs",
    "lines": "69-70",
    "spec_strength": "hole",
    "snippet": "        fn from_seq(u: usize, seq: ArraySeqMtEphS<usize>) -> (result: Self)\n            ensures result@.finite();"
  },
  {
    "id": 1606,
    "function": "filter",
    "file": "Chap41/ArraySetEnumMtEph.rs",
    "lines": "73-74",
    "spec_strength": "hole",
    "snippet": "        fn filter<F: PredVal<usize> + Clone>(&self, f: F) -> (result: Self)\n            ensures result@.finite(), result@.subset_of(self@);"
  },
  {
    "id": 1607,
    "function": "intersection",
    "file": "Chap41/ArraySetEnumMtEph.rs",
    "lines": "77-78",
    "spec_strength": "hole",
    "snippet": "        fn intersection(&self, other: &Self) -> (result: Self)\n            ensures result@ == self@.intersect(other@), result@.finite();"
  },
  {
    "id": 1608,
    "function": "difference",
    "file": "Chap41/ArraySetEnumMtEph.rs",
    "lines": "81-82",
    "spec_strength": "hole",
    "snippet": "        fn difference(&self, other: &Self) -> (result: Self)\n            ensures result@ == self@.difference(other@), result@.finite();"
  },
  {
    "id": 1609,
    "function": "union",
    "file": "Chap41/ArraySetEnumMtEph.rs",
    "lines": "85-86",
    "spec_strength": "hole",
    "snippet": "        fn union(&self, other: &Self) -> (result: Self)\n            ensures result@ == self@.union(other@), result@.finite();"
  },
  {
    "id": 1610,
    "function": "find",
    "file": "Chap41/ArraySetEnumMtEph.rs",
    "lines": "89-90",
    "spec_strength": "hole",
    "snippet": "        fn find(&self, x: usize) -> (result: B)\n            ensures result == self@.contains(x);"
  },
  {
    "id": 1611,
    "function": "delete",
    "file": "Chap41/ArraySetEnumMtEph.rs",
    "lines": "93-94",
    "spec_strength": "hole",
    "snippet": "        fn delete(&mut self, x: usize)\n            ensures self@ == old(self)@.remove(x), self@.finite();"
  },
  {
    "id": 1612,
    "function": "insert",
    "file": "Chap41/ArraySetEnumMtEph.rs",
    "lines": "97-98",
    "spec_strength": "hole",
    "snippet": "        fn insert(&mut self, x: usize)\n            ensures self@ == old(self)@.insert(x), self@.finite();"
  },
  {
    "id": 1613,
    "function": "eq",
    "file": "Chap41/ArraySetEnumMtEph.rs",
    "lines": "292-301",
    "spec_strength": "",
    "snippet": "        fn eq(&self, other: &Self) -> bool {\n            self.universe_size == other.universe_size && {\n                for i in 0..self.universe_size {\n                    if self.bits[i] != other.bits[i] {\n                        return false;\n                    }\n                }\n                true\n            }\n        }"
  },
  {
    "id": 1614,
    "function": "lemma_filter_remove",
    "file": "Chap41/ArraySetStEph.rs",
    "lines": "74-77",
    "spec_strength": "hole",
    "snippet": "    proof fn lemma_filter_remove<V>(s: Seq<V>, v: V)\n        requires s.no_duplicates()\n        ensures s.filter(|e: V| e != v).to_set() =~= s.to_set().remove(v)\n        decreases s.len()"
  },
  {
    "id": 1615,
    "function": "lemma_push_preserves_no_dups",
    "file": "Chap41/ArraySetStEph.rs",
    "lines": "97-102",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_push_preserves_no_dups<V>(s: Seq<V>, x: V)\n        requires\n            s.no_duplicates(),\n            !s.contains(x),\n        ensures\n            s.push(x).no_duplicates()"
  },
  {
    "id": 1616,
    "function": "lemma_subseq_no_dups_subset",
    "file": "Chap41/ArraySetStEph.rs",
    "lines": "123-129",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_subseq_no_dups_subset<V>(orig: Seq<V>, sub: Seq<V>)\n        requires\n            orig.no_duplicates(),\n            forall|i: int| #![trigger sub[i]] 0 <= i < sub.len() ==> orig.contains(sub[i]),\n            sub.no_duplicates(),\n        ensures\n            sub.to_set().subset_of(orig.to_set())"
  },
  {
    "id": 1617,
    "function": "size",
    "file": "Chap41/ArraySetStEph.rs",
    "lines": "146-148",
    "spec_strength": "unknown",
    "snippet": "        fn size(&self) -> (result: usize)\n            requires self.spec_wf()\n            ensures result == self@.len(), self@.finite();"
  },
  {
    "id": 1618,
    "function": "to_seq",
    "file": "Chap41/ArraySetStEph.rs",
    "lines": "150-151",
    "spec_strength": "unknown",
    "snippet": "        fn to_seq(&self) -> (result: ArraySeqStEphS<T>)\n            ensures self@.finite();"
  },
  {
    "id": 1619,
    "function": "empty",
    "file": "Chap41/ArraySetStEph.rs",
    "lines": "153-154",
    "spec_strength": "unknown",
    "snippet": "        fn empty() -> (result: Self)\n            ensures result@ == Set::<<T as View>::V>::empty(), result.spec_wf();"
  },
  {
    "id": 1620,
    "function": "singleton",
    "file": "Chap41/ArraySetStEph.rs",
    "lines": "156-157",
    "spec_strength": "unknown",
    "snippet": "        fn singleton(x: T) -> (result: Self)\n            ensures result@ == Set::<<T as View>::V>::empty().insert(x@), result@.finite(), result.spec_wf();"
  },
  {
    "id": 1621,
    "function": "from_seq",
    "file": "Chap41/ArraySetStEph.rs",
    "lines": "159-160",
    "spec_strength": "unknown",
    "snippet": "        fn from_seq(seq: ArraySeqStEphS<T>) -> (result: Self)\n            ensures result@.finite(), result.spec_wf();"
  },
  {
    "id": 1622,
    "function": "filter",
    "file": "Chap41/ArraySetStEph.rs",
    "lines": "162-164",
    "spec_strength": "hole",
    "snippet": "        fn filter<F: PredSt<T>>(&self, f: F) -> (result: Self)\n            requires self.spec_wf()\n            ensures result@.finite(), result@.subset_of(self@), result.spec_wf();"
  },
  {
    "id": 1623,
    "function": "intersection",
    "file": "Chap41/ArraySetStEph.rs",
    "lines": "166-168",
    "spec_strength": "hole",
    "snippet": "        fn intersection(&self, other: &Self) -> (result: Self)\n            requires self.spec_wf(), other.spec_wf()\n            ensures result@ == self@.intersect(other@), result@.finite(), result.spec_wf();"
  },
  {
    "id": 1624,
    "function": "difference",
    "file": "Chap41/ArraySetStEph.rs",
    "lines": "170-172",
    "spec_strength": "hole",
    "snippet": "        fn difference(&self, other: &Self) -> (result: Self)\n            requires self.spec_wf(), other.spec_wf()\n            ensures result@ == self@.difference(other@), result@.finite(), result.spec_wf();"
  },
  {
    "id": 1625,
    "function": "union",
    "file": "Chap41/ArraySetStEph.rs",
    "lines": "174-176",
    "spec_strength": "hole",
    "snippet": "        fn union(&self, other: &Self) -> (result: Self)\n            requires self.spec_wf(), other.spec_wf()\n            ensures result@ == self@.union(other@), result@.finite(), result.spec_wf();"
  },
  {
    "id": 1626,
    "function": "find",
    "file": "Chap41/ArraySetStEph.rs",
    "lines": "178-179",
    "spec_strength": "hole",
    "snippet": "        fn find(&self, x: &T) -> (result: B)\n            ensures result == self@.contains(x@);"
  },
  {
    "id": 1627,
    "function": "delete",
    "file": "Chap41/ArraySetStEph.rs",
    "lines": "181-183",
    "spec_strength": "hole",
    "snippet": "        fn delete(&mut self, x: &T)\n            requires old(self).spec_wf()\n            ensures self@ == old(self)@.remove(x@), self@.finite(), self.spec_wf();"
  },
  {
    "id": 1628,
    "function": "insert",
    "file": "Chap41/ArraySetStEph.rs",
    "lines": "185-187",
    "spec_strength": "hole",
    "snippet": "        fn insert(&mut self, x: T)\n            requires old(self).spec_wf()\n            ensures self@ == old(self)@.insert(x@), self@.finite(), self.spec_wf();"
  },
  {
    "id": 1629,
    "function": "default",
    "file": "Chap41/ArraySetStEph.rs",
    "lines": "492",
    "spec_strength": "",
    "snippet": "        fn default() -> Self { Self::empty() }"
  },
  {
    "id": 1630,
    "function": "eq",
    "file": "Chap41/ArraySetStEph.rs",
    "lines": "496-505",
    "spec_strength": "",
    "snippet": "        fn eq(&self, other: &Self) -> bool {\n            self.size() == other.size() && {\n                for i in 0..self.elements.length() {\n                    if !other.find(self.elements.nth(i)) {\n                        return false;\n                    }\n                }\n                true\n            }\n        }"
  },
  {
    "id": 1631,
    "function": "example_41_1_array_set",
    "file": "Chap41/Example41_3.rs",
    "lines": "21",
    "spec_strength": "",
    "snippet": "        fn example_41_1_array_set();"
  },
  {
    "id": 1632,
    "function": "example_41_1_avl_set",
    "file": "Chap41/Example41_3.rs",
    "lines": "25",
    "spec_strength": "",
    "snippet": "        fn example_41_1_avl_set();"
  },
  {
    "id": 1633,
    "function": "demonstrate_set_operations",
    "file": "Chap41/Example41_3.rs",
    "lines": "29",
    "spec_strength": "",
    "snippet": "        fn demonstrate_set_operations();"
  },
  {
    "id": 1634,
    "function": "example_41_1_array_set_impl",
    "file": "Chap41/Example41_3.rs",
    "lines": "33-34",
    "spec_strength": "hole",
    "snippet": "    fn example_41_1_array_set_impl()\n        ensures true"
  },
  {
    "id": 1635,
    "function": "example_41_1_avl_set_impl",
    "file": "Chap41/Example41_3.rs",
    "lines": "86-87",
    "spec_strength": "hole",
    "snippet": "    fn example_41_1_avl_set_impl()\n        ensures true"
  },
  {
    "id": 1636,
    "function": "example_41_3_from_seq_demonstration_impl",
    "file": "Chap41/Example41_3.rs",
    "lines": "139-140",
    "spec_strength": "hole",
    "snippet": "    fn example_41_3_from_seq_demonstration_impl()\n        ensures true"
  },
  {
    "id": 1637,
    "function": "additional_set_operations_impl",
    "file": "Chap41/Example41_3.rs",
    "lines": "188-189",
    "spec_strength": "hole",
    "snippet": "    fn additional_set_operations_impl()\n        ensures true"
  },
  {
    "id": 1638,
    "function": "example_41_3_from_seq_demonstration",
    "file": "Chap41/Example41_3.rs",
    "lines": "246",
    "spec_strength": "",
    "snippet": "    pub fn example_41_3_from_seq_demonstration() { example_41_3_from_seq_demonstration_impl(); }"
  },
  {
    "id": 1639,
    "function": "additional_set_operations",
    "file": "Chap41/Example41_3.rs",
    "lines": "247",
    "spec_strength": "",
    "snippet": "    pub fn additional_set_operations() { additional_set_operations_impl(); }"
  },
  {
    "id": 1640,
    "function": "_example_42_1_verified",
    "file": "Chap42/Example42_1.rs",
    "lines": "11",
    "spec_strength": "",
    "snippet": "        proof fn _example_42_1_verified() {}"
  },
  {
    "id": 1641,
    "function": "example_42_1",
    "file": "Chap42/Example42_1.rs",
    "lines": "21-23",
    "spec_strength": "",
    "snippet": "        /// Example 42.1: Basic table operations demonstration\n        /// APAS: Work (n log n), Span (log n)\n        fn example_42_1();"
  },
  {
    "id": 1642,
    "function": "demonstrate_table_operations",
    "file": "Chap42/Example42_1.rs",
    "lines": "25-27",
    "spec_strength": "",
    "snippet": "        /// Demonstrate table operations with different implementations\n        /// APAS: Work (n log n), Span (log n)\n        fn demonstrate_table_operations();"
  },
  {
    "id": 1643,
    "function": "performance_comparison",
    "file": "Chap42/Example42_1.rs",
    "lines": "151-202",
    "spec_strength": "",
    "snippet": "    /// Demonstrate performance characteristics of different table implementations\n    pub fn performance_comparison() {\n        println!(\"\\n=== Performance Comparison ===\");\n\n        let size = 1000;\n        println!(\"Building tables with {size} entries...\");\n\n        // Build persistent table\n        let start = std::time::Instant::now();\n        let mut table_per = TableStPer::empty();\n        for i in 0..size {\n            table_per = table_per.insert(i, format!(\"value_{i}\"), |_old, new| new.clone());\n        }\n        let per_time = start.elapsed();\n        println!(\"Persistent table construction: {per_time:?}\");\n\n        // Build ephemeral table\n        let start = std::time::Instant::now();\n        let mut table_eph = TableStEph::empty();\n        for i in 0..size {\n            table_eph.insert(i, format!(\"value_{i}\"), |_old, new| new.clone());\n        }\n        let eph_time = start.elapsed();\n        println!(\"Ephemeral table construction: {eph_time:?}\");\n\n        // Build multi-threaded table\n        let start = std::time::Instant::now();\n        let mut table_mt = TableMtEph::empty();\n        for i in 0..size {\n            table_mt.insert(i, format!(\"value_{i}\"), |_old, new| new.clone());\n        }\n        let mt_time = start.elapsed();\n        println!(\"Multi-threaded table construction: {mt_time:?}\");\n\n        // Test map operation performance\n        println!(\"\\nMap operation performance:\");\n\n        let start = std::time::Instant::now();\n        let _mapped_per = table_per.map(|s| s.to_uppercase());\n        let per_map_time = start.elapsed();\n        println!(\"Persistent map: {per_map_time:?}\");\n\n        let start = std::time::Instant::now();\n        table_eph.map(|s| s.to_uppercase());\n        let eph_map_time = start.elapsed();\n        println!(\"Ephemeral map: {eph_map_time:?}\");\n\n        let start = std::time::Instant::now();\n        table_mt.map(|s| s.to_uppercase());\n        let mt_map_time = start.elapsed();\n        println!(\"Multi-threaded map: {mt_map_time:?}\");\n    }"
  },
  {
    "id": 1644,
    "function": "size",
    "file": "Chap42/TableMtEph.rs",
    "lines": "64-65",
    "spec_strength": "hole",
    "snippet": "        fn size(&self) -> (result: usize)\n            ensures result == self@.dom().len();"
  },
  {
    "id": 1645,
    "function": "empty",
    "file": "Chap42/TableMtEph.rs",
    "lines": "67-68",
    "spec_strength": "unknown",
    "snippet": "        fn empty() -> (result: Self)\n            ensures result@ == Map::<K::V, V::V>::empty();"
  },
  {
    "id": 1646,
    "function": "singleton",
    "file": "Chap42/TableMtEph.rs",
    "lines": "70-71",
    "spec_strength": "hole",
    "snippet": "        fn singleton(key: K, value: V) -> (result: Self)\n            ensures result@.dom().finite(), result@.dom().len() == 1;"
  },
  {
    "id": 1647,
    "function": "domain",
    "file": "Chap42/TableMtEph.rs",
    "lines": "73-74",
    "spec_strength": "hole",
    "snippet": "        fn domain(&self) -> (result: ArraySetStEph<K>)\n            ensures result@.finite();"
  },
  {
    "id": 1648,
    "function": "tabulate",
    "file": "Chap42/TableMtEph.rs",
    "lines": "76-77",
    "spec_strength": "hole",
    "snippet": "        fn tabulate<F: Fn(&K) -> V + Send + Sync + 'static>(f: F, keys: &ArraySetStEph<K>) -> (result: Self)\n            ensures result@.dom().finite();"
  },
  {
    "id": 1649,
    "function": "map",
    "file": "Chap42/TableMtEph.rs",
    "lines": "79-80",
    "spec_strength": "hole",
    "snippet": "        fn map<F: Fn(&V) -> V + Send + Sync + 'static>(&mut self, f: F)\n            ensures self@.dom() == old(self)@.dom();"
  },
  {
    "id": 1650,
    "function": "filter",
    "file": "Chap42/TableMtEph.rs",
    "lines": "82-83",
    "spec_strength": "hole",
    "snippet": "        fn filter<F: Fn(&K, &V) -> B + Send + Sync + 'static>(&mut self, f: F)\n            ensures self@.dom().subset_of(old(self)@.dom());"
  },
  {
    "id": 1651,
    "function": "intersection",
    "file": "Chap42/TableMtEph.rs",
    "lines": "85-86",
    "spec_strength": "hole",
    "snippet": "        fn intersection<F: Fn(&V, &V) -> V + Send + Sync + 'static>(&mut self, other: &Self, combine: F)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1652,
    "function": "union",
    "file": "Chap42/TableMtEph.rs",
    "lines": "88-89",
    "spec_strength": "hole",
    "snippet": "        fn union<F: Fn(&V, &V) -> V + Send + Sync + 'static>(&mut self, other: &Self, combine: F)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1653,
    "function": "difference",
    "file": "Chap42/TableMtEph.rs",
    "lines": "91-92",
    "spec_strength": "hole",
    "snippet": "        fn difference(&mut self, other: &Self)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1654,
    "function": "find",
    "file": "Chap42/TableMtEph.rs",
    "lines": "94-95",
    "spec_strength": "hole",
    "snippet": "        fn find(&self, key: &K) -> (result: Option<V>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1655,
    "function": "delete",
    "file": "Chap42/TableMtEph.rs",
    "lines": "97-98",
    "spec_strength": "hole",
    "snippet": "        fn delete(&mut self, key: &K)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1656,
    "function": "insert",
    "file": "Chap42/TableMtEph.rs",
    "lines": "100-101",
    "spec_strength": "hole",
    "snippet": "        fn insert<F: Fn(&V, &V) -> V + Send + Sync + 'static>(&mut self, key: K, value: V, combine: F)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1657,
    "function": "restrict",
    "file": "Chap42/TableMtEph.rs",
    "lines": "103-104",
    "spec_strength": "hole",
    "snippet": "        fn restrict(&mut self, keys: &ArraySetStEph<K>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1658,
    "function": "subtract",
    "file": "Chap42/TableMtEph.rs",
    "lines": "106-107",
    "spec_strength": "hole",
    "snippet": "        fn subtract(&mut self, keys: &ArraySetStEph<K>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1659,
    "function": "entries",
    "file": "Chap42/TableMtEph.rs",
    "lines": "109",
    "spec_strength": "",
    "snippet": "        fn entries(&self) -> (result: ArraySeqMtEphS<Pair<K, V>>);"
  },
  {
    "id": 1660,
    "function": "from_sorted_entries",
    "file": "Chap42/TableMtEph.rs",
    "lines": "719-720",
    "spec_strength": "unknown",
    "snippet": "    pub fn from_sorted_entries<K: MtKey, V: MtVal>(entries: Vec<Pair<K, V>>) -> (result: TableMtEph<K, V>)\n        ensures result@.dom().finite()"
  },
  {
    "id": 1661,
    "function": "lemma_entries_to_map_finite",
    "file": "Chap42/TableMtEph.rs",
    "lines": "729-731",
    "spec_strength": "unknown",
    "snippet": "    pub proof fn lemma_entries_to_map_finite<KV, VV>(entries: Seq<(KV, VV)>)\n        ensures spec_entries_to_map(entries).dom().finite()\n        decreases entries.len()"
  },
  {
    "id": 1662,
    "function": "eq",
    "file": "Chap42/TableMtEph.rs",
    "lines": "743-745",
    "spec_strength": "",
    "snippet": "        fn eq(&self, other: &Self) -> bool {\n            self.entries == other.entries\n        }"
  },
  {
    "id": 1663,
    "function": "size",
    "file": "Chap42/TableStEph.rs",
    "lines": "64-65",
    "spec_strength": "hole",
    "snippet": "        fn size(&self) -> (result: usize)\n            ensures result == self@.len();"
  },
  {
    "id": 1664,
    "function": "empty",
    "file": "Chap42/TableStEph.rs",
    "lines": "67-68",
    "spec_strength": "unknown",
    "snippet": "        fn empty() -> (result: Self)\n            ensures result@ == Map::<K::V, V::V>::empty();"
  },
  {
    "id": 1665,
    "function": "singleton",
    "file": "Chap42/TableStEph.rs",
    "lines": "70-71",
    "spec_strength": "hole",
    "snippet": "        fn singleton(key: K, value: V) -> (result: Self)\n            ensures result@ == Map::<K::V, V::V>::empty().insert(key@, value@);"
  },
  {
    "id": 1666,
    "function": "domain",
    "file": "Chap42/TableStEph.rs",
    "lines": "73-74",
    "spec_strength": "hole",
    "snippet": "        fn domain(&self) -> (result: ArraySetStEph<K>)\n            ensures result@.finite();"
  },
  {
    "id": 1667,
    "function": "tabulate",
    "file": "Chap42/TableStEph.rs",
    "lines": "76-77",
    "spec_strength": "hole",
    "snippet": "        fn tabulate<F: Fn(&K) -> V>(f: F, keys: &ArraySetStEph<K>) -> (result: Self)\n            ensures result@.dom().finite();"
  },
  {
    "id": 1668,
    "function": "map",
    "file": "Chap42/TableStEph.rs",
    "lines": "79-80",
    "spec_strength": "hole",
    "snippet": "        fn map<F: Fn(&V) -> V>(&mut self, f: F)\n            ensures self@.dom() == old(self)@.dom();"
  },
  {
    "id": 1669,
    "function": "filter",
    "file": "Chap42/TableStEph.rs",
    "lines": "82-83",
    "spec_strength": "hole",
    "snippet": "        fn filter<F: Fn(&K, &V) -> B>(&mut self, f: F)\n            ensures self@.dom().subset_of(old(self)@.dom());"
  },
  {
    "id": 1670,
    "function": "intersection",
    "file": "Chap42/TableStEph.rs",
    "lines": "85-86",
    "spec_strength": "hole",
    "snippet": "        fn intersection<F: Fn(&V, &V) -> V>(&mut self, other: &Self, combine: F)\n            ensures self@.dom().subset_of(old(self)@.dom().intersect(other@.dom()));"
  },
  {
    "id": 1671,
    "function": "union",
    "file": "Chap42/TableStEph.rs",
    "lines": "88-89",
    "spec_strength": "hole",
    "snippet": "        fn union<F: Fn(&V, &V) -> V>(&mut self, other: &Self, combine: F)\n            ensures old(self)@.dom().union(other@.dom()).subset_of(self@.dom());"
  },
  {
    "id": 1672,
    "function": "difference",
    "file": "Chap42/TableStEph.rs",
    "lines": "91-92",
    "spec_strength": "hole",
    "snippet": "        fn difference(&mut self, other: &Self)\n            ensures self@.dom().subset_of(old(self)@.dom().difference(other@.dom()));"
  },
  {
    "id": 1673,
    "function": "find",
    "file": "Chap42/TableStEph.rs",
    "lines": "94-99",
    "spec_strength": "hole",
    "snippet": "        fn find(&self, key: &K) -> (result: Option<V>)\n            ensures\n                match result {\n                    Some(v) => self@.contains_key(key@) && self@[key@] == v@,\n                    None => !self@.contains_key(key@),\n                };"
  },
  {
    "id": 1674,
    "function": "delete",
    "file": "Chap42/TableStEph.rs",
    "lines": "101-102",
    "spec_strength": "hole",
    "snippet": "        fn delete(&mut self, key: &K)\n            ensures !self@.contains_key(key@);"
  },
  {
    "id": 1675,
    "function": "insert",
    "file": "Chap42/TableStEph.rs",
    "lines": "104-105",
    "spec_strength": "hole",
    "snippet": "        fn insert<F: Fn(&V, &V) -> V>(&mut self, key: K, value: V, combine: F)\n            ensures self@.contains_key(key@);"
  },
  {
    "id": 1676,
    "function": "restrict",
    "file": "Chap42/TableStEph.rs",
    "lines": "107-108",
    "spec_strength": "hole",
    "snippet": "        fn restrict(&mut self, keys: &ArraySetStEph<K>)\n            ensures self@.dom().subset_of(old(self)@.dom());"
  },
  {
    "id": 1677,
    "function": "subtract",
    "file": "Chap42/TableStEph.rs",
    "lines": "110-111",
    "spec_strength": "hole",
    "snippet": "        fn subtract(&mut self, keys: &ArraySetStEph<K>)\n            ensures self@.dom().subset_of(old(self)@.dom());"
  },
  {
    "id": 1678,
    "function": "entries",
    "file": "Chap42/TableStEph.rs",
    "lines": "114",
    "spec_strength": "",
    "snippet": "        fn entries(&self) -> (result: ArraySeqStEphS<Pair<K, V>>);"
  },
  {
    "id": 1679,
    "function": "from_sorted_entries",
    "file": "Chap42/TableStEph.rs",
    "lines": "414-417",
    "spec_strength": "unknown",
    "snippet": "    pub fn from_sorted_entries<K: StT + Ord, V: StT>(\n        entries: Vec<Pair<K, V>>,\n    ) -> (result: TableStEph<K, V>)\n        ensures result@.dom().finite()"
  },
  {
    "id": 1680,
    "function": "lemma_entries_to_map_finite",
    "file": "Chap42/TableStEph.rs",
    "lines": "426-428",
    "spec_strength": "unknown",
    "snippet": "    pub proof fn lemma_entries_to_map_finite<KV, VV>(entries: Seq<(KV, VV)>)\n        ensures spec_entries_to_map(entries).dom().finite()\n        decreases entries.len()"
  },
  {
    "id": 1681,
    "function": "default",
    "file": "Chap42/TableStEph.rs",
    "lines": "454-456",
    "spec_strength": "",
    "snippet": "        fn default() -> Self {\n            TableStEph::empty()\n        }"
  },
  {
    "id": 1682,
    "function": "eq",
    "file": "Chap42/TableStEph.rs",
    "lines": "460-462",
    "spec_strength": "",
    "snippet": "        fn eq(&self, other: &Self) -> bool {\n            self.entries == other.entries\n        }"
  },
  {
    "id": 1683,
    "function": "eq",
    "file": "Chap42/TableStPer.rs",
    "lines": "42-44",
    "spec_strength": "",
    "snippet": "        fn eq(&self, other: &Self) -> bool {\n            self.entries == other.entries\n        }"
  },
  {
    "id": 1684,
    "function": "size",
    "file": "Chap42/TableStPer.rs",
    "lines": "55-57",
    "spec_strength": "",
    "snippet": "        /// APAS: Work (1), Span (1)\n        /// claude-4-sonet: Work (1), Span (1)\n        fn size(&self)                              -> usize;"
  },
  {
    "id": 1685,
    "function": "empty",
    "file": "Chap42/TableStPer.rs",
    "lines": "59-61",
    "spec_strength": "",
    "snippet": "        /// APAS: Work (1), Span (1)\n        /// claude-4-sonet: Work (1), Span (1)\n        fn empty()                                  -> Self;"
  },
  {
    "id": 1686,
    "function": "singleton",
    "file": "Chap42/TableStPer.rs",
    "lines": "63-65",
    "spec_strength": "",
    "snippet": "        /// APAS: Work (1), Span (1)\n        /// claude-4-sonet: Work (1), Span (1)\n        fn singleton(key: K, value: V)              -> Self;"
  },
  {
    "id": 1687,
    "function": "domain",
    "file": "Chap42/TableStPer.rs",
    "lines": "67-69",
    "spec_strength": "",
    "snippet": "        /// APAS: Work (|a|), Span (lg |a|)\n        /// claude-4-sonet: Work (n log n), Span (n log n), Parallelism (1)\n        fn domain(&self)                            -> ArraySetStEph<K>;"
  },
  {
    "id": 1688,
    "function": "tabulate",
    "file": "Chap42/TableStPer.rs",
    "lines": "71-73",
    "spec_strength": "",
    "snippet": "        /// APAS: Work (|s| * W(f)), Span (lg |s| + S(f))\n        /// claude-4-sonet: Work (|keys|  W(f)), Span (log |keys| + S(f)), Parallelism (|keys|/(log |keys| + S(f)))\n        fn tabulate<F: Fn(&K) -> V>(f: F, keys: &ArraySetStEph<K>) -> Self;"
  },
  {
    "id": 1689,
    "function": "map",
    "file": "Chap42/TableStPer.rs",
    "lines": "75-77",
    "spec_strength": "",
    "snippet": "        /// APAS: Work (|a| * W(f)), Span (lg |a| + S(f))\n        /// claude-4-sonet: Work (n  W(f)), Span (log n + S(f)), Parallelism (n/(log n + S(f)))\n        fn map<F: Fn(&V) -> V>(&self, f: F) -> Self;"
  },
  {
    "id": 1690,
    "function": "filter",
    "file": "Chap42/TableStPer.rs",
    "lines": "79-81",
    "spec_strength": "",
    "snippet": "        /// APAS: Work (|a| * W(f)), Span (lg |a| + S(f))\n        /// claude-4-sonet: Work (n  W(f)), Span (log n + S(f)), Parallelism (n/(log n + S(f)))\n        fn filter<F: Fn(&K, &V) -> B>(&self, f: F) -> Self;"
  },
  {
    "id": 1691,
    "function": "intersection",
    "file": "Chap42/TableStPer.rs",
    "lines": "83-85",
    "spec_strength": "",
    "snippet": "        /// APAS: Work (m * lg(1 + n/m)), Span (lg(n + m))\n        /// claude-4-sonet: Work (m log(1 + n/m)), Span (log(n + m)), Parallelism (m/log(n + m))\n        fn intersection<F: Fn(&V, &V) -> V>(&self, other: &Self, combine: F) -> Self;"
  },
  {
    "id": 1692,
    "function": "union",
    "file": "Chap42/TableStPer.rs",
    "lines": "87-89",
    "spec_strength": "",
    "snippet": "        /// APAS: Work (m * lg(1 + n/m)), Span (lg(n + m))\n        /// claude-4-sonet: Work (m log(1 + n/m)), Span (log(n + m)), Parallelism (m/log(n + m))\n        fn union<F: Fn(&V, &V) -> V>(&self, other: &Self, combine: F) -> Self;"
  },
  {
    "id": 1693,
    "function": "difference",
    "file": "Chap42/TableStPer.rs",
    "lines": "91-93",
    "spec_strength": "",
    "snippet": "        /// APAS: Work (m * lg(1 + n/m)), Span (lg(n + m))\n        /// claude-4-sonet: Work (m log(1 + n/m)), Span (log(n + m)), Parallelism (m/log(n + m))\n        fn difference(&self, other: &Self)          -> Self;"
  },
  {
    "id": 1694,
    "function": "find",
    "file": "Chap42/TableStPer.rs",
    "lines": "95-97",
    "spec_strength": "",
    "snippet": "        /// APAS: Work (lg |a|), Span (lg |a|)\n        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)\n        fn find(&self, key: &K)                     -> Option<V>;"
  },
  {
    "id": 1695,
    "function": "delete",
    "file": "Chap42/TableStPer.rs",
    "lines": "99-101",
    "spec_strength": "",
    "snippet": "        /// APAS: Work (lg |a|), Span (lg |a|)\n        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)\n        fn delete(&self, key: &K)                   -> Self;"
  },
  {
    "id": 1696,
    "function": "insert",
    "file": "Chap42/TableStPer.rs",
    "lines": "103-105",
    "spec_strength": "",
    "snippet": "        /// APAS: Work (lg |a|), Span (lg |a|)\n        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)\n        fn insert<F: Fn(&V, &V) -> V>(&self, key: K, value: V, combine: F) -> Self;"
  },
  {
    "id": 1697,
    "function": "restrict",
    "file": "Chap42/TableStPer.rs",
    "lines": "107-109",
    "spec_strength": "",
    "snippet": "        /// APAS: Work (m * lg(1 + n/m)), Span (lg(n + m))\n        /// claude-4-sonet: Work (m + n), Span (m + n), Parallelism (1)\n        fn restrict(&self, keys: &ArraySetStEph<K>) -> Self;"
  },
  {
    "id": 1698,
    "function": "subtract",
    "file": "Chap42/TableStPer.rs",
    "lines": "111-113",
    "spec_strength": "",
    "snippet": "        /// APAS: Work (m * lg(1 + n/m)), Span (lg(n + m))\n        /// claude-4-sonet: Work (m + n), Span (m + n), Parallelism (1)\n        fn subtract(&self, keys: &ArraySetStEph<K>) -> Self;"
  },
  {
    "id": 1699,
    "function": "collect",
    "file": "Chap42/TableStPer.rs",
    "lines": "115-117",
    "spec_strength": "",
    "snippet": "        /// APAS: Work (|a|), Span (lg |a|)\n        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)\n        fn collect(&self)                           -> ArraySeqStPerS<Pair<K, V>>;"
  },
  {
    "id": 1700,
    "function": "from_sorted_entries",
    "file": "Chap42/TableStPer.rs",
    "lines": "395-400",
    "spec_strength": "",
    "snippet": "    /// Create tables from sorted entries\n    pub fn from_sorted_entries<K: StT + Ord, V: StT>(entries: Vec<Pair<K, V>>) -> TableStPer<K, V> {\n        TableStPer {\n            entries: ArraySeqStPerS::from_vec(entries),\n        }\n    }"
  },
  {
    "id": 1701,
    "function": "recalculate_reduction",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "60-63",
    "spec_strength": "hole",
    "snippet": "    pub fn recalculate_reduction<K: MtKey, V: MtVal, F: MtReduceFn<V>>(\n        table: &AugOrderedTableMtEph<K, V, F>,\n    ) -> (result: V)\n    ensures table@.dom().finite()"
  },
  {
    "id": 1702,
    "function": "calculate_reduction",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "69-74",
    "spec_strength": "hole",
    "snippet": "    pub fn calculate_reduction<K: MtKey, V: MtVal, F: MtReduceFn<V>>(\n        base: &OrderedTableMtEph<K, V>,\n        reducer: &F,\n        identity: &V,\n    ) -> (result: V)\n    ensures base@.dom().finite()"
  },
  {
    "id": 1703,
    "function": "lemma_aug_view",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "99-102",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_aug_view<K: MtKey, V: MtVal, F: MtReduceFn<V>>(\n        t: &AugOrderedTableMtEph<K, V, F>,\n    )\n        ensures t@ =~= t.base_table@"
  },
  {
    "id": 1704,
    "function": "size",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "110-111",
    "spec_strength": "unknown",
    "snippet": "        fn size(&self) -> (result: usize)\n            ensures result == self@.dom().len(), self@.dom().finite();"
  },
  {
    "id": 1705,
    "function": "empty",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "112-113",
    "spec_strength": "unknown",
    "snippet": "        fn empty(reducer: F, identity: V) -> (result: Self)\n            ensures result@ == Map::<K::V, V::V>::empty();"
  },
  {
    "id": 1706,
    "function": "singleton",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "114-115",
    "spec_strength": "unknown",
    "snippet": "        fn singleton(k: K, v: V, reducer: F, identity: V) -> (result: Self)\n            ensures result@.dom().finite();"
  },
  {
    "id": 1707,
    "function": "find",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "116",
    "spec_strength": "",
    "snippet": "        fn find(&self, k: &K) -> (result: Option<V>);"
  },
  {
    "id": 1708,
    "function": "lookup",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "117",
    "spec_strength": "",
    "snippet": "        fn lookup(&self, k: &K) -> (result: Option<V>);"
  },
  {
    "id": 1709,
    "function": "is_empty",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "118-119",
    "spec_strength": "unknown",
    "snippet": "        fn is_empty(&self) -> (result: B)\n            ensures result == self@.dom().is_empty(), self@.dom().finite();"
  },
  {
    "id": 1710,
    "function": "insert",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "120-121",
    "spec_strength": "unknown",
    "snippet": "        fn insert<G: Fn(&V, &V) -> V + Send + Sync + 'static>(&mut self, k: K, v: V, combine: G)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1711,
    "function": "delete",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "122-123",
    "spec_strength": "unknown",
    "snippet": "        fn delete(&mut self, k: &K) -> (result: Option<V>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1712,
    "function": "domain",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "124-125",
    "spec_strength": "unknown",
    "snippet": "        fn domain(&self) -> (result: ArraySetStEph<K>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1713,
    "function": "tabulate",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "126-132",
    "spec_strength": "unknown",
    "snippet": "        fn tabulate<G: Fn(&K) -> V + Send + Sync + 'static>(\n            f: G,\n            keys: &ArraySetStEph<K>,\n            reducer: F,\n            identity: V,\n        ) -> (result: Self)\n            ensures result@.dom().finite();"
  },
  {
    "id": 1714,
    "function": "map",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "133-134",
    "spec_strength": "unknown",
    "snippet": "        fn map<G: Fn(&K, &V) -> V + Send + Sync + 'static>(&self, f: G) -> (result: Self)\n            ensures result@.dom().finite();"
  },
  {
    "id": 1715,
    "function": "filter",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "135-136",
    "spec_strength": "unknown",
    "snippet": "        fn filter<G: Fn(&K, &V) -> B + Send + Sync + 'static>(&self, f: G) -> (result: Self)\n            ensures result@.dom().finite();"
  },
  {
    "id": 1716,
    "function": "intersection",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "137-138",
    "spec_strength": "unknown",
    "snippet": "        fn intersection<G: Fn(&V, &V) -> V + Send + Sync + 'static>(&mut self, other: &Self, f: G)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1717,
    "function": "union",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "139-140",
    "spec_strength": "unknown",
    "snippet": "        fn union<G: Fn(&V, &V) -> V + Send + Sync + 'static>(&mut self, other: &Self, f: G)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1718,
    "function": "difference",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "141-142",
    "spec_strength": "unknown",
    "snippet": "        fn difference(&mut self, other: &Self)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1719,
    "function": "restrict",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "143-144",
    "spec_strength": "unknown",
    "snippet": "        fn restrict(&mut self, keys: &ArraySetStEph<K>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1720,
    "function": "subtract",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "145-146",
    "spec_strength": "unknown",
    "snippet": "        fn subtract(&mut self, keys: &ArraySetStEph<K>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1721,
    "function": "reduce",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "147-148",
    "spec_strength": "unknown",
    "snippet": "        fn reduce<R: StTInMtT + 'static, G: Fn(R, &K, &V) -> R + Send + Sync + 'static>(&self, init: R, f: G) -> (result: R)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1722,
    "function": "collect",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "149-150",
    "spec_strength": "unknown",
    "snippet": "        fn collect(&self) -> (result: AVLTreeSeqStPerS<Pair<K, V>>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1723,
    "function": "first_key",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "151-152",
    "spec_strength": "unknown",
    "snippet": "        fn first_key(&self) -> (result: Option<K>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1724,
    "function": "last_key",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "153-154",
    "spec_strength": "unknown",
    "snippet": "        fn last_key(&self) -> (result: Option<K>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1725,
    "function": "previous_key",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "155-156",
    "spec_strength": "unknown",
    "snippet": "        fn previous_key(&self, k: &K) -> (result: Option<K>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1726,
    "function": "next_key",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "157-158",
    "spec_strength": "unknown",
    "snippet": "        fn next_key(&self, k: &K) -> (result: Option<K>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1727,
    "function": "split_key",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "159-161",
    "spec_strength": "unknown",
    "snippet": "        fn split_key(&mut self, k: &K) -> (result: (Self, Option<V>, Self))\n            where Self: Sized,\n            ensures self@.dom().finite();"
  },
  {
    "id": 1728,
    "function": "join_key",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "162-163",
    "spec_strength": "hole",
    "snippet": "        fn join_key(&mut self, other: Self)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1729,
    "function": "get_key_range",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "164-165",
    "spec_strength": "unknown",
    "snippet": "        fn get_key_range(&self, k1: &K, k2: &K) -> (result: Self)\n            ensures result@.dom().finite();"
  },
  {
    "id": 1730,
    "function": "rank_key",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "166-167",
    "spec_strength": "unknown",
    "snippet": "        fn rank_key(&self, k: &K) -> (result: usize)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1731,
    "function": "select_key",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "168-169",
    "spec_strength": "unknown",
    "snippet": "        fn select_key(&self, i: usize) -> (result: Option<K>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1732,
    "function": "split_rank_key",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "170-172",
    "spec_strength": "unknown",
    "snippet": "        fn split_rank_key(&mut self, i: usize) -> (result: (Self, Self))\n            where Self: Sized,\n            ensures self@.dom().finite();"
  },
  {
    "id": 1733,
    "function": "reduce_val",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "173-174",
    "spec_strength": "unknown",
    "snippet": "        fn reduce_val(&self) -> (result: V)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1734,
    "function": "reduce_range",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "175-176",
    "spec_strength": "unknown",
    "snippet": "        fn reduce_range(&self, k1: &K, k2: &K) -> (result: V)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1735,
    "function": "reduce_range_parallel",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "177-178",
    "spec_strength": "hole",
    "snippet": "        fn reduce_range_parallel(&self, k1: &K, k2: &K) -> (result: V)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1736,
    "function": "eq",
    "file": "Chap43/AugOrderedTableMtEph.rs",
    "lines": "572-575",
    "spec_strength": "",
    "snippet": "        fn eq(&self, other: &Self) -> bool {\n            self.base_table == other.base_table\n                && self.cached_reduction == other.cached_reduction\n        }"
  },
  {
    "id": 1737,
    "function": "calculate_reduction",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "60-67",
    "spec_strength": "hole",
    "snippet": "    pub fn calculate_reduction<K: StT + Ord, V: StT, F>(\n        base: &OrderedTableStEph<K, V>,\n        reducer: &F,\n        identity: &V,\n    ) -> (result: V)\n    where\n        F: Fn(&V, &V) -> V + Clone,\n        ensures base@.dom().finite(),"
  },
  {
    "id": 1738,
    "function": "lemma_aug_view",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "92-95",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_aug_view<K: StT + Ord, V: StT, F: Fn(&V, &V) -> V + Clone>(\n        t: &AugOrderedTableStEph<K, V, F>,\n    )\n        ensures t@ =~= t.base_table@"
  },
  {
    "id": 1739,
    "function": "size",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "106-107",
    "spec_strength": "unknown",
    "snippet": "        fn size(&self) -> (result: usize)\n            ensures result == self@.dom().len(), self@.dom().finite();"
  },
  {
    "id": 1740,
    "function": "empty",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "108-109",
    "spec_strength": "unknown",
    "snippet": "        fn empty(reducer: F, identity: V) -> (result: Self)\n            ensures result@ == Map::<K::V, V::V>::empty();"
  },
  {
    "id": 1741,
    "function": "singleton",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "110-111",
    "spec_strength": "unknown",
    "snippet": "        fn singleton(k: K, v: V, reducer: F, identity: V) -> (result: Self)\n            ensures result@.dom().finite();"
  },
  {
    "id": 1742,
    "function": "find",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "112-117",
    "spec_strength": "hole",
    "snippet": "        fn find(&self, k: &K) -> (result: Option<V>)\n            ensures\n                match result {\n                    Some(v) => self@.contains_key(k@) && v@ == self@[k@],\n                    None => !self@.contains_key(k@),\n                };"
  },
  {
    "id": 1743,
    "function": "lookup",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "118-123",
    "spec_strength": "hole",
    "snippet": "        fn lookup(&self, k: &K) -> (result: Option<V>)\n            ensures\n                match result {\n                    Some(v) => self@.contains_key(k@) && v@ == self@[k@],\n                    None => !self@.contains_key(k@),\n                };"
  },
  {
    "id": 1744,
    "function": "is_empty",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "124-125",
    "spec_strength": "unknown",
    "snippet": "        fn is_empty(&self) -> (result: B)\n            ensures result == self@.dom().is_empty(), self@.dom().finite();"
  },
  {
    "id": 1745,
    "function": "insert",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "126-127",
    "spec_strength": "unknown",
    "snippet": "        fn insert<G: Fn(&V, &V) -> V>(&mut self, k: K, v: V, combine: G)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1746,
    "function": "delete",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "128-129",
    "spec_strength": "unknown",
    "snippet": "        fn delete(&mut self, k: &K) -> (result: Option<V>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1747,
    "function": "domain",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "130-131",
    "spec_strength": "unknown",
    "snippet": "        fn domain(&self) -> (result: ArraySetStEph<K>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1748,
    "function": "tabulate",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "132-133",
    "spec_strength": "unknown",
    "snippet": "        fn tabulate<G: Fn(&K) -> V>(f: G, keys: &ArraySetStEph<K>, reducer: F, identity: V) -> (result: Self)\n            ensures result@.dom().finite();"
  },
  {
    "id": 1749,
    "function": "map",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "134-135",
    "spec_strength": "unknown",
    "snippet": "        fn map<G: Fn(&K, &V) -> V>(&self, f: G) -> (result: Self)\n            ensures result@.dom().finite();"
  },
  {
    "id": 1750,
    "function": "filter",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "136-137",
    "spec_strength": "unknown",
    "snippet": "        fn filter<G: Fn(&K, &V) -> B>(&self, f: G) -> (result: Self)\n            ensures result@.dom().finite();"
  },
  {
    "id": 1751,
    "function": "reduce",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "138-139",
    "spec_strength": "unknown",
    "snippet": "        fn reduce<R, G: Fn(R, &K, &V) -> R>(&self, init: R, f: G) -> (result: R)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1752,
    "function": "intersection",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "140-141",
    "spec_strength": "unknown",
    "snippet": "        fn intersection<G: Fn(&V, &V) -> V>(&mut self, other: &Self, f: G)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1753,
    "function": "union",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "142-143",
    "spec_strength": "unknown",
    "snippet": "        fn union<G: Fn(&V, &V) -> V>(&mut self, other: &Self, f: G)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1754,
    "function": "difference",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "144-145",
    "spec_strength": "unknown",
    "snippet": "        fn difference(&mut self, other: &Self)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1755,
    "function": "restrict",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "146-147",
    "spec_strength": "unknown",
    "snippet": "        fn restrict(&mut self, keys: &ArraySetStEph<K>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1756,
    "function": "subtract",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "148-149",
    "spec_strength": "unknown",
    "snippet": "        fn subtract(&mut self, keys: &ArraySetStEph<K>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1757,
    "function": "collect",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "150-151",
    "spec_strength": "unknown",
    "snippet": "        fn collect(&self) -> (result: AVLTreeSeqStPerS<Pair<K, V>>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1758,
    "function": "first_key",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "152-153",
    "spec_strength": "unknown",
    "snippet": "        fn first_key(&self) -> (result: Option<K>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1759,
    "function": "last_key",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "154-155",
    "spec_strength": "unknown",
    "snippet": "        fn last_key(&self) -> (result: Option<K>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1760,
    "function": "previous_key",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "156-157",
    "spec_strength": "unknown",
    "snippet": "        fn previous_key(&self, k: &K) -> (result: Option<K>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1761,
    "function": "next_key",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "158-159",
    "spec_strength": "unknown",
    "snippet": "        fn next_key(&self, k: &K) -> (result: Option<K>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1762,
    "function": "split_key",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "160-162",
    "spec_strength": "unknown",
    "snippet": "        fn split_key(&mut self, k: &K) -> (result: (Self, Option<V>, Self))\n            where Self: Sized,\n            ensures self@.dom().finite();"
  },
  {
    "id": 1763,
    "function": "join_key",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "163-164",
    "spec_strength": "hole",
    "snippet": "        fn join_key(&mut self, other: Self)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1764,
    "function": "get_key_range",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "165-166",
    "spec_strength": "unknown",
    "snippet": "        fn get_key_range(&self, k1: &K, k2: &K) -> (result: Self)\n            ensures result@.dom().finite();"
  },
  {
    "id": 1765,
    "function": "rank_key",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "167-168",
    "spec_strength": "unknown",
    "snippet": "        fn rank_key(&self, k: &K) -> (result: usize)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1766,
    "function": "select_key",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "169-170",
    "spec_strength": "unknown",
    "snippet": "        fn select_key(&self, i: usize) -> (result: Option<K>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1767,
    "function": "split_rank_key",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "171-173",
    "spec_strength": "unknown",
    "snippet": "        fn split_rank_key(&mut self, i: usize) -> (result: (Self, Self))\n            where Self: Sized,\n            ensures self@.dom().finite();"
  },
  {
    "id": 1768,
    "function": "reduce_val",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "174-175",
    "spec_strength": "unknown",
    "snippet": "        fn reduce_val(&self) -> (result: V)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1769,
    "function": "reduce_range",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "176-177",
    "spec_strength": "unknown",
    "snippet": "        fn reduce_range(&self, k1: &K, k2: &K) -> (result: V)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1770,
    "function": "eq",
    "file": "Chap43/AugOrderedTableStEph.rs",
    "lines": "557-560",
    "spec_strength": "",
    "snippet": "        fn eq(&self, other: &Self) -> bool {\n            self.base_table == other.base_table\n                && self.cached_reduction == other.cached_reduction\n        }"
  },
  {
    "id": 1771,
    "function": "calculate_reduction",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "60-67",
    "spec_strength": "hole",
    "snippet": "    pub fn calculate_reduction<K: StT + Ord, V: StT, F>(\n        base: &OrderedTableStPer<K, V>,\n        reducer: &F,\n        identity: &V,\n    ) -> (result: V)\n    where\n        F: Fn(&V, &V) -> V + Clone,\n        ensures base@.dom().finite(),"
  },
  {
    "id": 1772,
    "function": "lemma_aug_view",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "92-95",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_aug_view<K: StT + Ord, V: StT, F: Fn(&V, &V) -> V + Clone>(\n        t: &AugOrderedTableStPer<K, V, F>,\n    )\n        ensures t@ =~= t.base_table@"
  },
  {
    "id": 1773,
    "function": "size",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "106-107",
    "spec_strength": "unknown",
    "snippet": "        fn size(&self) -> (result: usize)\n            ensures result == self@.dom().len(), self@.dom().finite();"
  },
  {
    "id": 1774,
    "function": "empty",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "108-109",
    "spec_strength": "unknown",
    "snippet": "        fn empty(reducer: F, identity: V) -> (result: Self)\n            ensures result@ == Map::<K::V, V::V>::empty();"
  },
  {
    "id": 1775,
    "function": "singleton",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "110-111",
    "spec_strength": "unknown",
    "snippet": "        fn singleton(k: K, v: V, reducer: F, identity: V) -> (result: Self)\n            ensures result@.dom().finite();"
  },
  {
    "id": 1776,
    "function": "find",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "112-117",
    "spec_strength": "hole",
    "snippet": "        fn find(&self, k: &K) -> (result: Option<V>)\n            ensures\n                match result {\n                    Some(v) => self@.contains_key(k@) && v@ == self@[k@],\n                    None => !self@.contains_key(k@),\n                };"
  },
  {
    "id": 1777,
    "function": "insert",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "118-119",
    "spec_strength": "unknown",
    "snippet": "        fn insert(&self, k: K, v: V) -> (result: Self)\n            ensures result@.dom().finite();"
  },
  {
    "id": 1778,
    "function": "delete",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "120-121",
    "spec_strength": "unknown",
    "snippet": "        fn delete(&self, k: &K) -> (result: Self)\n            ensures result@.dom().finite();"
  },
  {
    "id": 1779,
    "function": "domain",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "122-123",
    "spec_strength": "unknown",
    "snippet": "        fn domain(&self) -> (result: ArraySetStEph<K>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1780,
    "function": "tabulate",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "124-125",
    "spec_strength": "unknown",
    "snippet": "        fn tabulate<G: Fn(&K) -> V>(f: G, keys: &ArraySetStEph<K>, reducer: F, identity: V) -> (result: Self)\n            ensures result@.dom().finite();"
  },
  {
    "id": 1781,
    "function": "map",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "126-127",
    "spec_strength": "unknown",
    "snippet": "        fn map<G: Fn(&V) -> V>(&self, f: G) -> (result: Self)\n            ensures result@.dom().finite();"
  },
  {
    "id": 1782,
    "function": "filter",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "128-129",
    "spec_strength": "unknown",
    "snippet": "        fn filter<G: Fn(&K, &V) -> B>(&self, f: G) -> (result: Self)\n            ensures result@.dom().finite();"
  },
  {
    "id": 1783,
    "function": "intersection",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "130-131",
    "spec_strength": "unknown",
    "snippet": "        fn intersection<G: Fn(&V, &V) -> V>(&self, other: &Self, f: G) -> (result: Self)\n            ensures result@.dom().finite();"
  },
  {
    "id": 1784,
    "function": "union",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "132-133",
    "spec_strength": "unknown",
    "snippet": "        fn union<G: Fn(&V, &V) -> V>(&self, other: &Self, f: G) -> (result: Self)\n            ensures result@.dom().finite();"
  },
  {
    "id": 1785,
    "function": "difference",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "134-135",
    "spec_strength": "unknown",
    "snippet": "        fn difference(&self, other: &Self) -> (result: Self)\n            ensures result@.dom().finite();"
  },
  {
    "id": 1786,
    "function": "restrict",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "136-137",
    "spec_strength": "unknown",
    "snippet": "        fn restrict(&self, keys: &ArraySetStEph<K>) -> (result: Self)\n            ensures result@.dom().finite();"
  },
  {
    "id": 1787,
    "function": "subtract",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "138-139",
    "spec_strength": "unknown",
    "snippet": "        fn subtract(&self, keys: &ArraySetStEph<K>) -> (result: Self)\n            ensures result@.dom().finite();"
  },
  {
    "id": 1788,
    "function": "collect",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "140-141",
    "spec_strength": "unknown",
    "snippet": "        fn collect(&self) -> (result: AVLTreeSeqStPerS<Pair<K, V>>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1789,
    "function": "first_key",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "142-143",
    "spec_strength": "unknown",
    "snippet": "        fn first_key(&self) -> (result: Option<K>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1790,
    "function": "last_key",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "144-145",
    "spec_strength": "unknown",
    "snippet": "        fn last_key(&self) -> (result: Option<K>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1791,
    "function": "previous_key",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "146-147",
    "spec_strength": "unknown",
    "snippet": "        fn previous_key(&self, k: &K) -> (result: Option<K>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1792,
    "function": "next_key",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "148-149",
    "spec_strength": "unknown",
    "snippet": "        fn next_key(&self, k: &K) -> (result: Option<K>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1793,
    "function": "split_key",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "150-152",
    "spec_strength": "unknown",
    "snippet": "        fn split_key(&self, k: &K) -> (result: (Self, Option<V>, Self))\n            where Self: Sized,\n            ensures self@.dom().finite();"
  },
  {
    "id": 1794,
    "function": "join_key",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "153-154",
    "spec_strength": "hole",
    "snippet": "        fn join_key(left: &Self, right: &Self) -> (result: Self)\n            ensures result@.dom().finite();"
  },
  {
    "id": 1795,
    "function": "get_key_range",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "155-156",
    "spec_strength": "unknown",
    "snippet": "        fn get_key_range(&self, k1: &K, k2: &K) -> (result: Self)\n            ensures result@.dom().finite();"
  },
  {
    "id": 1796,
    "function": "rank_key",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "157-158",
    "spec_strength": "unknown",
    "snippet": "        fn rank_key(&self, k: &K) -> (result: usize)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1797,
    "function": "select_key",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "159-160",
    "spec_strength": "unknown",
    "snippet": "        fn select_key(&self, i: usize) -> (result: Option<K>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1798,
    "function": "split_rank_key",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "161-163",
    "spec_strength": "unknown",
    "snippet": "        fn split_rank_key(&self, i: usize) -> (result: (Self, Self))\n            where Self: Sized,\n            ensures self@.dom().finite();"
  },
  {
    "id": 1799,
    "function": "reduce_val",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "164-165",
    "spec_strength": "unknown",
    "snippet": "        fn reduce_val(&self) -> (result: V)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1800,
    "function": "reduce_range",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "166-167",
    "spec_strength": "unknown",
    "snippet": "        fn reduce_range(&self, k1: &K, k2: &K) -> (result: V)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1801,
    "function": "eq",
    "file": "Chap43/AugOrderedTableStPer.rs",
    "lines": "576-579",
    "spec_strength": "",
    "snippet": "        fn eq(&self, other: &Self) -> bool {\n            self.base_table == other.base_table\n                && self.cached_reduction == other.cached_reduction\n        }"
  },
  {
    "id": 1802,
    "function": "_example_43_1_verified",
    "file": "Chap43/Example43_1.rs",
    "lines": "11",
    "spec_strength": "",
    "snippet": "        proof fn _example_43_1_verified() {}"
  },
  {
    "id": 1803,
    "function": "run_example43_1",
    "file": "Chap43/Example43_1.rs",
    "lines": "19-21",
    "spec_strength": "",
    "snippet": "        /// Demonstrates Example 43.1 from the textbook with lexicographic ordering\n        /// APAS: Work (n log n), Span (log n)\n        fn run_example43_1();"
  },
  {
    "id": 1804,
    "function": "demonstrate_ordered_operations",
    "file": "Chap43/Example43_1.rs",
    "lines": "23-25",
    "spec_strength": "",
    "snippet": "        /// Demonstrate ordered set operations\n        /// APAS: Work (n log n), Span (log n)\n        fn demonstrate_ordered_operations();"
  },
  {
    "id": 1805,
    "function": "run_integer_example",
    "file": "Chap43/Example43_1.rs",
    "lines": "174-230",
    "spec_strength": "",
    "snippet": "    /// Demonstrates ordering operations with integer sets for additional clarity\n    pub fn run_integer_example() {\n        println!(\"\\n=== Integer Ordered Set Example ===\");\n\n        // Create an ordered set of integers\n        let int_set: OrderedSetStPer<i32> = OrderedSetStPerLit![1, 3, 5, 7, 9, 11, 13];\n\n        print!(\"Integer Set: [\");\n        let seq = int_set.to_seq();\n        for i in 0..seq.length() {\n            if i > 0 {\n                print!(\", \");\n            }\n            print!(\"{}\", seq.nth(i));\n        }\n        println!(\"]\");\n\n        // Demonstrate all ordering operations\n        println!(\"first() = {:?}\", int_set.first());\n        println!(\"last() = {:?}\", int_set.last());\n        println!(\"previous(7) = {:?}\", int_set.previous(&7));\n        println!(\"next(7) = {:?}\", int_set.next(&7));\n        println!(\"rank(7) = {}\", int_set.rank(&7));\n        println!(\"select(3) = {:?}\", int_set.select(3));\n\n        let range = int_set.get_range(&3, &9);\n        print!(\"getRange(3, 9) = [\");\n        let seq = range.to_seq();\n        for i in 0..seq.length() {\n            if i > 0 {\n                print!(\", \");\n            }\n            print!(\"{}\", seq.nth(i));\n        }\n        println!(\"]\");\n\n        let (left, right) = int_set.split_rank(4);\n        print!(\"splitRank(4) = ([\");\n        let seq = left.to_seq();\n        for i in 0..seq.length() {\n            if i > 0 {\n                print!(\", \");\n            }\n            print!(\"{}\", seq.nth(i));\n        }\n        print!(\"], [\");\n        let seq = right.to_seq();\n        for i in 0..seq.length() {\n            if i > 0 {\n                print!(\", \");\n            }\n            print!(\"{}\", seq.nth(i));\n        }\n        println!(\"])\");\n\n        println!(\"=== Integer Example Complete ===\");\n    }"
  },
  {
    "id": 1806,
    "function": "size",
    "file": "Chap43/OrderedSetMtEph.rs",
    "lines": "47-48",
    "spec_strength": "hole",
    "snippet": "        fn size(&self) -> (result: usize)\n            ensures result == self@.len(), self@.finite();"
  },
  {
    "id": 1807,
    "function": "empty",
    "file": "Chap43/OrderedSetMtEph.rs",
    "lines": "50-51",
    "spec_strength": "hole",
    "snippet": "        fn empty() -> (result: Self)\n            ensures result@ == Set::<<T as View>::V>::empty();"
  },
  {
    "id": 1808,
    "function": "singleton",
    "file": "Chap43/OrderedSetMtEph.rs",
    "lines": "53-54",
    "spec_strength": "hole",
    "snippet": "        fn singleton(x: T) -> (result: Self)\n            ensures result@ == Set::<<T as View>::V>::empty().insert(x@), result@.finite();"
  },
  {
    "id": 1809,
    "function": "find",
    "file": "Chap43/OrderedSetMtEph.rs",
    "lines": "56-57",
    "spec_strength": "hole",
    "snippet": "        fn find(&self, x: &T) -> (result: B)\n            ensures result == self@.contains(x@);"
  },
  {
    "id": 1810,
    "function": "insert",
    "file": "Chap43/OrderedSetMtEph.rs",
    "lines": "59-60",
    "spec_strength": "hole",
    "snippet": "        fn insert(&mut self, x: T)\n            ensures self@ == old(self)@.insert(x@), self@.finite();"
  },
  {
    "id": 1811,
    "function": "delete",
    "file": "Chap43/OrderedSetMtEph.rs",
    "lines": "62-63",
    "spec_strength": "hole",
    "snippet": "        fn delete(&mut self, x: &T)\n            ensures self@ == old(self)@.remove(x@), self@.finite();"
  },
  {
    "id": 1812,
    "function": "filter",
    "file": "Chap43/OrderedSetMtEph.rs",
    "lines": "65-66",
    "spec_strength": "hole",
    "snippet": "        fn filter<F: Pred<T>>(&mut self, f: F)\n            ensures self@.finite();"
  },
  {
    "id": 1813,
    "function": "intersection",
    "file": "Chap43/OrderedSetMtEph.rs",
    "lines": "68-69",
    "spec_strength": "hole",
    "snippet": "        fn intersection(&mut self, other: &Self)\n            ensures self@ == old(self)@.intersect(other@), self@.finite();"
  },
  {
    "id": 1814,
    "function": "union",
    "file": "Chap43/OrderedSetMtEph.rs",
    "lines": "71-72",
    "spec_strength": "hole",
    "snippet": "        fn union(&mut self, other: &Self)\n            ensures self@ == old(self)@.union(other@), self@.finite();"
  },
  {
    "id": 1815,
    "function": "difference",
    "file": "Chap43/OrderedSetMtEph.rs",
    "lines": "74-75",
    "spec_strength": "hole",
    "snippet": "        fn difference(&mut self, other: &Self)\n            ensures self@ == old(self)@.difference(other@), self@.finite();"
  },
  {
    "id": 1816,
    "function": "to_seq",
    "file": "Chap43/OrderedSetMtEph.rs",
    "lines": "77-78",
    "spec_strength": "hole",
    "snippet": "        fn to_seq(&self) -> (result: ArraySeqStPerS<T>)\n            ensures self@.finite();"
  },
  {
    "id": 1817,
    "function": "from_seq",
    "file": "Chap43/OrderedSetMtEph.rs",
    "lines": "80-81",
    "spec_strength": "hole",
    "snippet": "        fn from_seq(seq: ArraySeqStPerS<T>) -> (result: Self)\n            ensures result@.finite();"
  },
  {
    "id": 1818,
    "function": "first",
    "file": "Chap43/OrderedSetMtEph.rs",
    "lines": "85-86",
    "spec_strength": "hole",
    "snippet": "        fn first(&self) -> (result: Option<T>)\n            ensures self@.finite();"
  },
  {
    "id": 1819,
    "function": "last",
    "file": "Chap43/OrderedSetMtEph.rs",
    "lines": "88-89",
    "spec_strength": "hole",
    "snippet": "        fn last(&self) -> (result: Option<T>)\n            ensures self@.finite();"
  },
  {
    "id": 1820,
    "function": "previous",
    "file": "Chap43/OrderedSetMtEph.rs",
    "lines": "91-92",
    "spec_strength": "hole",
    "snippet": "        fn previous(&self, k: &T) -> (result: Option<T>)\n            ensures self@.finite();"
  },
  {
    "id": 1821,
    "function": "next",
    "file": "Chap43/OrderedSetMtEph.rs",
    "lines": "94-95",
    "spec_strength": "hole",
    "snippet": "        fn next(&self, k: &T) -> (result: Option<T>)\n            ensures self@.finite();"
  },
  {
    "id": 1822,
    "function": "split",
    "file": "Chap43/OrderedSetMtEph.rs",
    "lines": "97-99",
    "spec_strength": "hole",
    "snippet": "        fn split(&mut self, k: &T) -> (result: (Self, B, Self))\n            where Self: Sized\n            ensures self@.finite();"
  },
  {
    "id": 1823,
    "function": "join",
    "file": "Chap43/OrderedSetMtEph.rs",
    "lines": "101-102",
    "spec_strength": "hole",
    "snippet": "        fn join(&mut self, other: Self)\n            ensures self@.finite();"
  },
  {
    "id": 1824,
    "function": "get_range",
    "file": "Chap43/OrderedSetMtEph.rs",
    "lines": "104-105",
    "spec_strength": "hole",
    "snippet": "        fn get_range(&self, k1: &T, k2: &T) -> (result: Self)\n            ensures self@.finite();"
  },
  {
    "id": 1825,
    "function": "rank",
    "file": "Chap43/OrderedSetMtEph.rs",
    "lines": "107-108",
    "spec_strength": "hole",
    "snippet": "        fn rank(&self, k: &T) -> (result: usize)\n            ensures self@.finite();"
  },
  {
    "id": 1826,
    "function": "select",
    "file": "Chap43/OrderedSetMtEph.rs",
    "lines": "110-111",
    "spec_strength": "hole",
    "snippet": "        fn select(&self, i: usize) -> (result: Option<T>)\n            ensures self@.finite();"
  },
  {
    "id": 1827,
    "function": "split_rank",
    "file": "Chap43/OrderedSetMtEph.rs",
    "lines": "113-115",
    "spec_strength": "hole",
    "snippet": "        fn split_rank(&mut self, i: usize) -> (result: (Self, Self))\n            where Self: Sized\n            ensures self@.finite();"
  },
  {
    "id": 1828,
    "function": "size",
    "file": "Chap43/OrderedSetStEph.rs",
    "lines": "50-51",
    "spec_strength": "unknown",
    "snippet": "        fn size(&self) -> (result: usize)\n            ensures result == self@.len(), self@.finite();"
  },
  {
    "id": 1829,
    "function": "empty",
    "file": "Chap43/OrderedSetStEph.rs",
    "lines": "53-54",
    "spec_strength": "unknown",
    "snippet": "        fn empty() -> (result: Self)\n            ensures result@ == Set::<<T as View>::V>::empty();"
  },
  {
    "id": 1830,
    "function": "singleton",
    "file": "Chap43/OrderedSetStEph.rs",
    "lines": "56-57",
    "spec_strength": "unknown",
    "snippet": "        fn singleton(x: T) -> (result: Self)\n            ensures result@ == Set::<<T as View>::V>::empty().insert(x@), result@.finite();"
  },
  {
    "id": 1831,
    "function": "find",
    "file": "Chap43/OrderedSetStEph.rs",
    "lines": "59-60",
    "spec_strength": "unknown",
    "snippet": "        fn find(&self, x: &T) -> (result: B)\n            ensures result == self@.contains(x@);"
  },
  {
    "id": 1832,
    "function": "insert",
    "file": "Chap43/OrderedSetStEph.rs",
    "lines": "62-63",
    "spec_strength": "unknown",
    "snippet": "        fn insert(&mut self, x: T)\n            ensures self@ == old(self)@.insert(x@), self@.finite();"
  },
  {
    "id": 1833,
    "function": "delete",
    "file": "Chap43/OrderedSetStEph.rs",
    "lines": "65-66",
    "spec_strength": "unknown",
    "snippet": "        fn delete(&mut self, x: &T)\n            ensures self@ == old(self)@.remove(x@), self@.finite();"
  },
  {
    "id": 1834,
    "function": "filter",
    "file": "Chap43/OrderedSetStEph.rs",
    "lines": "68-69",
    "spec_strength": "unknown",
    "snippet": "        fn filter<F: PredSt<T>>(&mut self, f: F)\n            ensures self@.finite();"
  },
  {
    "id": 1835,
    "function": "intersection",
    "file": "Chap43/OrderedSetStEph.rs",
    "lines": "71-72",
    "spec_strength": "unknown",
    "snippet": "        fn intersection(&mut self, other: &Self)\n            ensures self@ == old(self)@.intersect(other@), self@.finite();"
  },
  {
    "id": 1836,
    "function": "union",
    "file": "Chap43/OrderedSetStEph.rs",
    "lines": "74-75",
    "spec_strength": "unknown",
    "snippet": "        fn union(&mut self, other: &Self)\n            ensures self@ == old(self)@.union(other@), self@.finite();"
  },
  {
    "id": 1837,
    "function": "difference",
    "file": "Chap43/OrderedSetStEph.rs",
    "lines": "77-78",
    "spec_strength": "unknown",
    "snippet": "        fn difference(&mut self, other: &Self)\n            ensures self@ == old(self)@.difference(other@), self@.finite();"
  },
  {
    "id": 1838,
    "function": "to_seq",
    "file": "Chap43/OrderedSetStEph.rs",
    "lines": "80-81",
    "spec_strength": "hole",
    "snippet": "        fn to_seq(&self) -> (result: AVLTreeSeqStPerS<T>)\n            ensures self@.finite();"
  },
  {
    "id": 1839,
    "function": "from_seq",
    "file": "Chap43/OrderedSetStEph.rs",
    "lines": "83-84",
    "spec_strength": "hole",
    "snippet": "        fn from_seq(seq: AVLTreeSeqStPerS<T>) -> (result: Self)\n            ensures result@.finite();"
  },
  {
    "id": 1840,
    "function": "first",
    "file": "Chap43/OrderedSetStEph.rs",
    "lines": "88-89",
    "spec_strength": "hole",
    "snippet": "        fn first(&self) -> (result: Option<T>)\n            ensures self@.finite();"
  },
  {
    "id": 1841,
    "function": "last",
    "file": "Chap43/OrderedSetStEph.rs",
    "lines": "91-92",
    "spec_strength": "hole",
    "snippet": "        fn last(&self) -> (result: Option<T>)\n            ensures self@.finite();"
  },
  {
    "id": 1842,
    "function": "previous",
    "file": "Chap43/OrderedSetStEph.rs",
    "lines": "94-95",
    "spec_strength": "hole",
    "snippet": "        fn previous(&self, k: &T) -> (result: Option<T>)\n            ensures self@.finite();"
  },
  {
    "id": 1843,
    "function": "next",
    "file": "Chap43/OrderedSetStEph.rs",
    "lines": "97-98",
    "spec_strength": "hole",
    "snippet": "        fn next(&self, k: &T) -> (result: Option<T>)\n            ensures self@.finite();"
  },
  {
    "id": 1844,
    "function": "split",
    "file": "Chap43/OrderedSetStEph.rs",
    "lines": "100-102",
    "spec_strength": "hole",
    "snippet": "        fn split(&mut self, k: &T) -> (result: (Self, B, Self))\n            where Self: Sized\n            ensures self@.finite();"
  },
  {
    "id": 1845,
    "function": "join",
    "file": "Chap43/OrderedSetStEph.rs",
    "lines": "104-105",
    "spec_strength": "unknown",
    "snippet": "        fn join(&mut self, other: Self)\n            ensures self@.finite();"
  },
  {
    "id": 1846,
    "function": "get_range",
    "file": "Chap43/OrderedSetStEph.rs",
    "lines": "107-108",
    "spec_strength": "hole",
    "snippet": "        fn get_range(&self, k1: &T, k2: &T) -> (result: Self)\n            ensures self@.finite();"
  },
  {
    "id": 1847,
    "function": "rank",
    "file": "Chap43/OrderedSetStEph.rs",
    "lines": "110-111",
    "spec_strength": "hole",
    "snippet": "        fn rank(&self, k: &T) -> (result: usize)\n            ensures self@.finite();"
  },
  {
    "id": 1848,
    "function": "select",
    "file": "Chap43/OrderedSetStEph.rs",
    "lines": "113-114",
    "spec_strength": "hole",
    "snippet": "        fn select(&self, i: usize) -> (result: Option<T>)\n            ensures self@.finite();"
  },
  {
    "id": 1849,
    "function": "split_rank",
    "file": "Chap43/OrderedSetStEph.rs",
    "lines": "116-118",
    "spec_strength": "hole",
    "snippet": "        fn split_rank(&mut self, i: usize) -> (result: (Self, Self))\n            where Self: Sized\n            ensures self@.finite();"
  },
  {
    "id": 1850,
    "function": "from_sorted_elements",
    "file": "Chap43/OrderedSetStEph.rs",
    "lines": "401-402",
    "spec_strength": "hole",
    "snippet": "    pub fn from_sorted_elements<T: StT + Ord>(elements: Vec<T>) -> (result: OrderedSetStEph<T>)\n        ensures result@.finite()"
  },
  {
    "id": 1851,
    "function": "default",
    "file": "Chap43/OrderedSetStEph.rs",
    "lines": "426",
    "spec_strength": "",
    "snippet": "        fn default() -> Self { Self::empty() }"
  },
  {
    "id": 1852,
    "function": "eq",
    "file": "Chap43/OrderedSetStEph.rs",
    "lines": "430-440",
    "spec_strength": "",
    "snippet": "        fn eq(&self, other: &Self) -> bool {\n            self.size() == other.size() && {\n                let seq = self.to_seq();\n                for i in 0..seq.length() {\n                    if !other.find(seq.nth(i)) {\n                        return false;\n                    }\n                }\n                true\n            }\n        }"
  },
  {
    "id": 1853,
    "function": "size",
    "file": "Chap43/OrderedSetStPer.rs",
    "lines": "49-50",
    "spec_strength": "unknown",
    "snippet": "        fn size(&self) -> (result: usize)\n            ensures result == self@.len(), self@.finite();"
  },
  {
    "id": 1854,
    "function": "empty",
    "file": "Chap43/OrderedSetStPer.rs",
    "lines": "52-53",
    "spec_strength": "unknown",
    "snippet": "        fn empty() -> (result: Self)\n            ensures result@ == Set::<<T as View>::V>::empty();"
  },
  {
    "id": 1855,
    "function": "singleton",
    "file": "Chap43/OrderedSetStPer.rs",
    "lines": "55-56",
    "spec_strength": "unknown",
    "snippet": "        fn singleton(x: T) -> (result: Self)\n            ensures result@ == Set::<<T as View>::V>::empty().insert(x@), result@.finite();"
  },
  {
    "id": 1856,
    "function": "find",
    "file": "Chap43/OrderedSetStPer.rs",
    "lines": "58-59",
    "spec_strength": "unknown",
    "snippet": "        fn find(&self, x: &T) -> (result: B)\n            ensures result == self@.contains(x@);"
  },
  {
    "id": 1857,
    "function": "insert",
    "file": "Chap43/OrderedSetStPer.rs",
    "lines": "61-62",
    "spec_strength": "unknown",
    "snippet": "        fn insert(&self, x: T) -> (result: Self)\n            ensures result@ == self@.insert(x@), result@.finite();"
  },
  {
    "id": 1858,
    "function": "delete",
    "file": "Chap43/OrderedSetStPer.rs",
    "lines": "64-65",
    "spec_strength": "unknown",
    "snippet": "        fn delete(&self, x: &T) -> (result: Self)\n            ensures result@ == self@.remove(x@), result@.finite();"
  },
  {
    "id": 1859,
    "function": "filter",
    "file": "Chap43/OrderedSetStPer.rs",
    "lines": "67-68",
    "spec_strength": "unknown",
    "snippet": "        fn filter<F: PredSt<T>>(&self, f: F) -> (result: Self)\n            ensures result@.finite(), result@.subset_of(self@);"
  },
  {
    "id": 1860,
    "function": "intersection",
    "file": "Chap43/OrderedSetStPer.rs",
    "lines": "70-71",
    "spec_strength": "unknown",
    "snippet": "        fn intersection(&self, other: &Self) -> (result: Self)\n            ensures result@ == self@.intersect(other@), result@.finite();"
  },
  {
    "id": 1861,
    "function": "union",
    "file": "Chap43/OrderedSetStPer.rs",
    "lines": "73-74",
    "spec_strength": "unknown",
    "snippet": "        fn union(&self, other: &Self) -> (result: Self)\n            ensures result@ == self@.union(other@), result@.finite();"
  },
  {
    "id": 1862,
    "function": "difference",
    "file": "Chap43/OrderedSetStPer.rs",
    "lines": "76-77",
    "spec_strength": "unknown",
    "snippet": "        fn difference(&self, other: &Self) -> (result: Self)\n            ensures result@ == self@.difference(other@), result@.finite();"
  },
  {
    "id": 1863,
    "function": "to_seq",
    "file": "Chap43/OrderedSetStPer.rs",
    "lines": "79-80",
    "spec_strength": "unknown",
    "snippet": "        fn to_seq(&self) -> (result: AVLTreeSeqStPerS<T>)\n            ensures self@.finite();"
  },
  {
    "id": 1864,
    "function": "from_seq",
    "file": "Chap43/OrderedSetStPer.rs",
    "lines": "82-83",
    "spec_strength": "unknown",
    "snippet": "        fn from_seq(seq: AVLTreeSeqStPerS<T>) -> (result: Self)\n            ensures result@.finite();"
  },
  {
    "id": 1865,
    "function": "first",
    "file": "Chap43/OrderedSetStPer.rs",
    "lines": "87-88",
    "spec_strength": "hole",
    "snippet": "        fn first(&self) -> (result: Option<T>)\n            ensures self@.finite();"
  },
  {
    "id": 1866,
    "function": "last",
    "file": "Chap43/OrderedSetStPer.rs",
    "lines": "90-91",
    "spec_strength": "hole",
    "snippet": "        fn last(&self) -> (result: Option<T>)\n            ensures self@.finite();"
  },
  {
    "id": 1867,
    "function": "previous",
    "file": "Chap43/OrderedSetStPer.rs",
    "lines": "93-94",
    "spec_strength": "hole",
    "snippet": "        fn previous(&self, k: &T) -> (result: Option<T>)\n            ensures self@.finite();"
  },
  {
    "id": 1868,
    "function": "next",
    "file": "Chap43/OrderedSetStPer.rs",
    "lines": "96-97",
    "spec_strength": "hole",
    "snippet": "        fn next(&self, k: &T) -> (result: Option<T>)\n            ensures self@.finite();"
  },
  {
    "id": 1869,
    "function": "split",
    "file": "Chap43/OrderedSetStPer.rs",
    "lines": "99-101",
    "spec_strength": "hole",
    "snippet": "        fn split(&self, k: &T) -> (result: (Self, B, Self))\n            where Self: Sized\n            ensures self@.finite();"
  },
  {
    "id": 1870,
    "function": "join",
    "file": "Chap43/OrderedSetStPer.rs",
    "lines": "103-104",
    "spec_strength": "unknown",
    "snippet": "        fn join(left: &Self, right: &Self) -> (result: Self)\n            ensures result@.finite();"
  },
  {
    "id": 1871,
    "function": "get_range",
    "file": "Chap43/OrderedSetStPer.rs",
    "lines": "106-107",
    "spec_strength": "hole",
    "snippet": "        fn get_range(&self, k1: &T, k2: &T) -> (result: Self)\n            ensures self@.finite();"
  },
  {
    "id": 1872,
    "function": "rank",
    "file": "Chap43/OrderedSetStPer.rs",
    "lines": "109-110",
    "spec_strength": "hole",
    "snippet": "        fn rank(&self, k: &T) -> (result: usize)\n            ensures self@.finite();"
  },
  {
    "id": 1873,
    "function": "select",
    "file": "Chap43/OrderedSetStPer.rs",
    "lines": "112-113",
    "spec_strength": "hole",
    "snippet": "        fn select(&self, i: usize) -> (result: Option<T>)\n            ensures self@.finite();"
  },
  {
    "id": 1874,
    "function": "split_rank",
    "file": "Chap43/OrderedSetStPer.rs",
    "lines": "115-117",
    "spec_strength": "hole",
    "snippet": "        fn split_rank(&self, i: usize) -> (result: (Self, Self))\n            where Self: Sized\n            ensures self@.finite();"
  },
  {
    "id": 1875,
    "function": "from_sorted_elements",
    "file": "Chap43/OrderedSetStPer.rs",
    "lines": "380-381",
    "spec_strength": "hole",
    "snippet": "    pub fn from_sorted_elements<T: StT + Ord>(elements: Vec<T>) -> (result: OrderedSetStPer<T>)\n        ensures result@.finite()"
  },
  {
    "id": 1876,
    "function": "default",
    "file": "Chap43/OrderedSetStPer.rs",
    "lines": "405",
    "spec_strength": "",
    "snippet": "        fn default() -> Self { Self::empty() }"
  },
  {
    "id": 1877,
    "function": "eq",
    "file": "Chap43/OrderedSetStPer.rs",
    "lines": "409-419",
    "spec_strength": "",
    "snippet": "        fn eq(&self, other: &Self) -> bool {\n            self.size() == other.size() && {\n                let seq = self.to_seq();\n                for i in 0..seq.length() {\n                    if !other.find(seq.nth(i)) {\n                        return false;\n                    }\n                }\n                true\n            }\n        }"
  },
  {
    "id": 1878,
    "function": "size",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "52-53",
    "spec_strength": "unknown",
    "snippet": "        fn size(&self) -> (result: usize)\n            ensures result == self@.dom().len(), self@.dom().finite();"
  },
  {
    "id": 1879,
    "function": "empty",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "55-56",
    "spec_strength": "unknown",
    "snippet": "        fn empty() -> (result: Self)\n            ensures result@ == Map::<K::V, V::V>::empty();"
  },
  {
    "id": 1880,
    "function": "singleton",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "58-59",
    "spec_strength": "hole",
    "snippet": "        fn singleton(k: K, v: V) -> (result: Self)\n            ensures result@ == Map::<K::V, V::V>::empty().insert(k@, v@), result@.dom().finite();"
  },
  {
    "id": 1881,
    "function": "find",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "61",
    "spec_strength": "",
    "snippet": "        fn find(&self, k: &K) -> (result: Option<V>);"
  },
  {
    "id": 1882,
    "function": "lookup",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "63",
    "spec_strength": "",
    "snippet": "        fn lookup(&self, k: &K) -> (result: Option<V>);"
  },
  {
    "id": 1883,
    "function": "is_empty",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "65-66",
    "spec_strength": "unknown",
    "snippet": "        fn is_empty(&self) -> (result: B)\n            ensures result == self@.dom().is_empty();"
  },
  {
    "id": 1884,
    "function": "insert",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "68-69",
    "spec_strength": "unknown",
    "snippet": "        fn insert<F: Fn(&V, &V) -> V + Send + Sync + 'static>(&mut self, k: K, v: V, combine: F)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1885,
    "function": "delete",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "71-72",
    "spec_strength": "hole",
    "snippet": "        fn delete(&mut self, k: &K) -> (result: Option<V>)\n            ensures self@ == old(self)@.remove(k@), self@.dom().finite();"
  },
  {
    "id": 1886,
    "function": "domain",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "74-75",
    "spec_strength": "unknown",
    "snippet": "        fn domain(&self) -> (result: ArraySetStEph<K>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1887,
    "function": "tabulate",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "77-78",
    "spec_strength": "unknown",
    "snippet": "        fn tabulate<F: Fn(&K) -> V + Send + Sync + 'static>(f: F, keys: &ArraySetStEph<K>) -> (result: Self)\n            ensures result@.dom().finite();"
  },
  {
    "id": 1888,
    "function": "map",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "80-81",
    "spec_strength": "hole",
    "snippet": "        fn map<F: Fn(&K, &V) -> V + Send + Sync + 'static>(&self, f: F) -> (result: Self)\n            ensures result@.dom().finite();"
  },
  {
    "id": 1889,
    "function": "filter",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "83-84",
    "spec_strength": "hole",
    "snippet": "        fn filter<F: Fn(&K, &V) -> B + Send + Sync + 'static>(&self, f: F) -> (result: Self)\n            ensures result@.dom().finite();"
  },
  {
    "id": 1890,
    "function": "intersection",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "86-87",
    "spec_strength": "unknown",
    "snippet": "        fn intersection<F: Fn(&V, &V) -> V + Send + Sync + 'static>(&mut self, other: &Self, f: F)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1891,
    "function": "union",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "89-90",
    "spec_strength": "unknown",
    "snippet": "        fn union<F: Fn(&V, &V) -> V + Send + Sync + 'static>(&mut self, other: &Self, f: F)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1892,
    "function": "difference",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "92-93",
    "spec_strength": "unknown",
    "snippet": "        fn difference(&mut self, other: &Self)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1893,
    "function": "restrict",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "95-96",
    "spec_strength": "unknown",
    "snippet": "        fn restrict(&mut self, keys: &ArraySetStEph<K>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1894,
    "function": "subtract",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "98-99",
    "spec_strength": "unknown",
    "snippet": "        fn subtract(&mut self, keys: &ArraySetStEph<K>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1895,
    "function": "reduce",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "101-102",
    "spec_strength": "hole",
    "snippet": "        fn reduce<R: StTInMtT + 'static, F: Fn(R, &K, &V) -> R + Send + Sync + 'static>(&self, init: R, f: F) -> (result: R)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1896,
    "function": "collect",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "104-105",
    "spec_strength": "hole",
    "snippet": "        fn collect(&self) -> (result: AVLTreeSeqStPerS<Pair<K, V>>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1897,
    "function": "first_key",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "107-108",
    "spec_strength": "hole",
    "snippet": "        fn first_key(&self) -> (result: Option<K>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1898,
    "function": "last_key",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "110-111",
    "spec_strength": "hole",
    "snippet": "        fn last_key(&self) -> (result: Option<K>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1899,
    "function": "previous_key",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "113-114",
    "spec_strength": "hole",
    "snippet": "        fn previous_key(&self, k: &K) -> (result: Option<K>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1900,
    "function": "next_key",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "116-117",
    "spec_strength": "hole",
    "snippet": "        fn next_key(&self, k: &K) -> (result: Option<K>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1901,
    "function": "split_key",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "119-121",
    "spec_strength": "hole",
    "snippet": "        fn split_key(&mut self, k: &K) -> (result: (Self, Option<V>, Self))\n            where Self: Sized\n            ensures self@.dom().finite();"
  },
  {
    "id": 1902,
    "function": "join_key",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "123-124",
    "spec_strength": "unknown",
    "snippet": "        fn join_key(&mut self, other: Self)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1903,
    "function": "get_key_range",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "126-127",
    "spec_strength": "hole",
    "snippet": "        fn get_key_range(&self, k1: &K, k2: &K) -> (result: Self)\n            ensures result@.dom().finite();"
  },
  {
    "id": 1904,
    "function": "rank_key",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "129-130",
    "spec_strength": "hole",
    "snippet": "        fn rank_key(&self, k: &K) -> (result: usize)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1905,
    "function": "select_key",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "132-133",
    "spec_strength": "hole",
    "snippet": "        fn select_key(&self, i: usize) -> (result: Option<K>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1906,
    "function": "split_rank_key",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "135-137",
    "spec_strength": "hole",
    "snippet": "        fn split_rank_key(&mut self, i: usize) -> (result: (Self, Self))\n            where Self: Sized\n            ensures self@.dom().finite();"
  },
  {
    "id": 1907,
    "function": "from_sorted_entries",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "505-506",
    "spec_strength": "hole",
    "snippet": "    pub fn from_sorted_entries<K: MtKey, V: MtVal>(entries: AVLTreeSeqStPerS<Pair<K, V>>) -> (result: OrderedTableMtEph<K, V>)\n        ensures result@.dom().finite()"
  },
  {
    "id": 1908,
    "function": "eq",
    "file": "Chap43/OrderedTableMtEph.rs",
    "lines": "523-525",
    "spec_strength": "",
    "snippet": "        fn eq(&self, other: &Self) -> bool {\n            self.base_table == other.base_table\n        }"
  },
  {
    "id": 1909,
    "function": "size",
    "file": "Chap43/OrderedTableMtPer.rs",
    "lines": "53-54",
    "spec_strength": "hole",
    "snippet": "        fn size(&self) -> (result: usize)\n            ensures result == self@.dom().len(), self@.dom().finite();"
  },
  {
    "id": 1910,
    "function": "empty",
    "file": "Chap43/OrderedTableMtPer.rs",
    "lines": "56-57",
    "spec_strength": "hole",
    "snippet": "        fn empty() -> (result: Self)\n            ensures result@ == Map::<K::V, V::V>::empty();"
  },
  {
    "id": 1911,
    "function": "singleton",
    "file": "Chap43/OrderedTableMtPer.rs",
    "lines": "59-60",
    "spec_strength": "hole",
    "snippet": "        fn singleton(k: K, v: V) -> (result: Self)\n            ensures result@ == Map::<K::V, V::V>::empty().insert(k@, v@), result@.dom().finite();"
  },
  {
    "id": 1912,
    "function": "find",
    "file": "Chap43/OrderedTableMtPer.rs",
    "lines": "62",
    "spec_strength": "hole",
    "snippet": "        fn find(&self, k: &K) -> (result: Option<V>);"
  },
  {
    "id": 1913,
    "function": "insert",
    "file": "Chap43/OrderedTableMtPer.rs",
    "lines": "64-65",
    "spec_strength": "hole",
    "snippet": "        fn insert(&self, k: K, v: V) -> (result: Self)\n            ensures result@.dom().finite();"
  },
  {
    "id": 1914,
    "function": "delete",
    "file": "Chap43/OrderedTableMtPer.rs",
    "lines": "67-68",
    "spec_strength": "hole",
    "snippet": "        fn delete(&self, k: &K) -> (result: Self)\n            ensures result@.dom().finite();"
  },
  {
    "id": 1915,
    "function": "domain",
    "file": "Chap43/OrderedTableMtPer.rs",
    "lines": "70-71",
    "spec_strength": "hole",
    "snippet": "        fn domain(&self) -> (result: OrderedSetMtEph<K>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1916,
    "function": "map",
    "file": "Chap43/OrderedTableMtPer.rs",
    "lines": "73-74",
    "spec_strength": "hole",
    "snippet": "        fn map<G: Fn(&K, &V) -> V + Send + Sync + 'static>(&self, f: G) -> (result: Self)\n            ensures result@.dom().finite();"
  },
  {
    "id": 1917,
    "function": "filter",
    "file": "Chap43/OrderedTableMtPer.rs",
    "lines": "76-77",
    "spec_strength": "hole",
    "snippet": "        fn filter<F: Pred<Pair<K, V>>>(&self, f: F) -> (result: Self)\n            ensures result@.dom().finite();"
  },
  {
    "id": 1918,
    "function": "first_key",
    "file": "Chap43/OrderedTableMtPer.rs",
    "lines": "79-80",
    "spec_strength": "hole",
    "snippet": "        fn first_key(&self) -> (result: Option<K>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1919,
    "function": "last_key",
    "file": "Chap43/OrderedTableMtPer.rs",
    "lines": "82-83",
    "spec_strength": "hole",
    "snippet": "        fn last_key(&self) -> (result: Option<K>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1920,
    "function": "previous_key",
    "file": "Chap43/OrderedTableMtPer.rs",
    "lines": "85-86",
    "spec_strength": "hole",
    "snippet": "        fn previous_key(&self, k: &K) -> (result: Option<K>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1921,
    "function": "next_key",
    "file": "Chap43/OrderedTableMtPer.rs",
    "lines": "88-89",
    "spec_strength": "hole",
    "snippet": "        fn next_key(&self, k: &K) -> (result: Option<K>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1922,
    "function": "split_key",
    "file": "Chap43/OrderedTableMtPer.rs",
    "lines": "91-93",
    "spec_strength": "hole",
    "snippet": "        fn split_key(&self, k: &K) -> (result: (Self, Option<V>, Self))\n            where Self: Sized\n            ensures self@.dom().finite();"
  },
  {
    "id": 1923,
    "function": "join_key",
    "file": "Chap43/OrderedTableMtPer.rs",
    "lines": "95-96",
    "spec_strength": "hole",
    "snippet": "        fn join_key(&self, other: &Self) -> (result: Self)\n            ensures result@.dom().finite();"
  },
  {
    "id": 1924,
    "function": "get_key_range",
    "file": "Chap43/OrderedTableMtPer.rs",
    "lines": "98-99",
    "spec_strength": "hole",
    "snippet": "        fn get_key_range(&self, k1: &K, k2: &K) -> (result: Self)\n            ensures result@.dom().finite();"
  },
  {
    "id": 1925,
    "function": "rank_key",
    "file": "Chap43/OrderedTableMtPer.rs",
    "lines": "101-102",
    "spec_strength": "hole",
    "snippet": "        fn rank_key(&self, k: &K) -> (result: usize)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1926,
    "function": "select_key",
    "file": "Chap43/OrderedTableMtPer.rs",
    "lines": "104-105",
    "spec_strength": "hole",
    "snippet": "        fn select_key(&self, i: usize) -> (result: Option<K>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1927,
    "function": "split_rank_key",
    "file": "Chap43/OrderedTableMtPer.rs",
    "lines": "107-109",
    "spec_strength": "hole",
    "snippet": "        fn split_rank_key(&self, i: usize) -> (result: (Self, Self))\n            where Self: Sized\n            ensures self@.dom().finite();"
  },
  {
    "id": 1928,
    "function": "default",
    "file": "Chap43/OrderedTableMtPer.rs",
    "lines": "369",
    "spec_strength": "",
    "snippet": "        fn default() -> Self { Self::empty() }"
  },
  {
    "id": 1929,
    "function": "size",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "48-49",
    "spec_strength": "unknown",
    "snippet": "        fn size(&self) -> (result: usize)\n            ensures result == self@.dom().len(), self@.dom().finite();"
  },
  {
    "id": 1930,
    "function": "empty",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "50-51",
    "spec_strength": "unknown",
    "snippet": "        fn empty() -> (result: Self)\n            ensures result@ == Map::<K::V, V::V>::empty();"
  },
  {
    "id": 1931,
    "function": "singleton",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "52-53",
    "spec_strength": "hole",
    "snippet": "        fn singleton(k: K, v: V) -> (result: Self)\n            ensures result@ == Map::<K::V, V::V>::empty().insert(k@, v@), result@.dom().finite();"
  },
  {
    "id": 1932,
    "function": "find",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "54",
    "spec_strength": "",
    "snippet": "        fn find(&self, k: &K) -> (result: Option<V>);"
  },
  {
    "id": 1933,
    "function": "lookup",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "55",
    "spec_strength": "",
    "snippet": "        fn lookup(&self, k: &K) -> (result: Option<V>);"
  },
  {
    "id": 1934,
    "function": "is_empty",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "56-57",
    "spec_strength": "unknown",
    "snippet": "        fn is_empty(&self) -> (result: B)\n            ensures result == self@.dom().is_empty();"
  },
  {
    "id": 1935,
    "function": "insert",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "58-59",
    "spec_strength": "unknown",
    "snippet": "        fn insert<F: Fn(&V, &V) -> V>(&mut self, k: K, v: V, combine: F)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1936,
    "function": "delete",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "60-61",
    "spec_strength": "hole",
    "snippet": "        fn delete(&mut self, k: &K) -> (result: Option<V>)\n            ensures self@ == old(self)@.remove(k@), self@.dom().finite();"
  },
  {
    "id": 1937,
    "function": "domain",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "62-63",
    "spec_strength": "unknown",
    "snippet": "        fn domain(&self) -> (result: ArraySetStEph<K>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1938,
    "function": "tabulate",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "64-65",
    "spec_strength": "unknown",
    "snippet": "        fn tabulate<F: Fn(&K) -> V>(f: F, keys: &ArraySetStEph<K>) -> (result: Self)\n            ensures result@.dom().finite();"
  },
  {
    "id": 1939,
    "function": "map",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "66-67",
    "spec_strength": "hole",
    "snippet": "        fn map<F: Fn(&K, &V) -> V>(&self, f: F) -> (result: Self)\n            ensures result@.dom().finite();"
  },
  {
    "id": 1940,
    "function": "filter",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "68-69",
    "spec_strength": "hole",
    "snippet": "        fn filter<F: Fn(&K, &V) -> B>(&self, f: F) -> (result: Self)\n            ensures result@.dom().finite();"
  },
  {
    "id": 1941,
    "function": "reduce",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "70-71",
    "spec_strength": "hole",
    "snippet": "        fn reduce<R, F: Fn(R, &K, &V) -> R>(&self, init: R, f: F) -> (result: R)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1942,
    "function": "intersection",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "72-73",
    "spec_strength": "unknown",
    "snippet": "        fn intersection<F: Fn(&V, &V) -> V>(&mut self, other: &Self, f: F)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1943,
    "function": "union",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "74-75",
    "spec_strength": "unknown",
    "snippet": "        fn union<F: Fn(&V, &V) -> V>(&mut self, other: &Self, f: F)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1944,
    "function": "difference",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "76-77",
    "spec_strength": "unknown",
    "snippet": "        fn difference(&mut self, other: &Self)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1945,
    "function": "restrict",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "78-79",
    "spec_strength": "unknown",
    "snippet": "        fn restrict(&mut self, keys: &ArraySetStEph<K>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1946,
    "function": "subtract",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "80-81",
    "spec_strength": "unknown",
    "snippet": "        fn subtract(&mut self, keys: &ArraySetStEph<K>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1947,
    "function": "collect",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "82-83",
    "spec_strength": "hole",
    "snippet": "        fn collect(&self) -> (result: AVLTreeSeqStPerS<Pair<K, V>>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1948,
    "function": "first_key",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "84-85",
    "spec_strength": "hole",
    "snippet": "        fn first_key(&self) -> (result: Option<K>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1949,
    "function": "last_key",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "86-87",
    "spec_strength": "hole",
    "snippet": "        fn last_key(&self) -> (result: Option<K>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1950,
    "function": "previous_key",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "88-89",
    "spec_strength": "hole",
    "snippet": "        fn previous_key(&self, k: &K) -> (result: Option<K>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1951,
    "function": "next_key",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "90-91",
    "spec_strength": "hole",
    "snippet": "        fn next_key(&self, k: &K) -> (result: Option<K>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1952,
    "function": "split_key",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "92-94",
    "spec_strength": "hole",
    "snippet": "        fn split_key(&mut self, k: &K) -> (result: (Self, Option<V>, Self))\n            where Self: Sized\n            ensures self@.dom().finite();"
  },
  {
    "id": 1953,
    "function": "join_key",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "95-96",
    "spec_strength": "unknown",
    "snippet": "        fn join_key(&mut self, other: Self)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1954,
    "function": "get_key_range",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "97-98",
    "spec_strength": "hole",
    "snippet": "        fn get_key_range(&self, k1: &K, k2: &K) -> (result: Self)\n            ensures result@.dom().finite();"
  },
  {
    "id": 1955,
    "function": "rank_key",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "99-100",
    "spec_strength": "hole",
    "snippet": "        fn rank_key(&self, k: &K) -> (result: usize)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1956,
    "function": "select_key",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "101-102",
    "spec_strength": "hole",
    "snippet": "        fn select_key(&self, i: usize) -> (result: Option<K>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1957,
    "function": "split_rank_key",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "103-105",
    "spec_strength": "hole",
    "snippet": "        fn split_rank_key(&mut self, i: usize) -> (result: (Self, Self))\n            where Self: Sized\n            ensures self@.dom().finite();"
  },
  {
    "id": 1958,
    "function": "from_sorted_entries",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "466-468",
    "spec_strength": "hole",
    "snippet": "    pub fn from_sorted_entries<K: StT + Ord, V: StT>(\n        entries: AVLTreeSeqStPerS<Pair<K, V>>,\n    ) -> (result: OrderedTableStEph<K, V>) {"
  },
  {
    "id": 1959,
    "function": "eq",
    "file": "Chap43/OrderedTableStEph.rs",
    "lines": "482-484",
    "spec_strength": "",
    "snippet": "        fn eq(&self, other: &Self) -> bool {\n            self.base_table == other.base_table\n        }"
  },
  {
    "id": 1960,
    "function": "size",
    "file": "Chap43/OrderedTableStPer.rs",
    "lines": "49-50",
    "spec_strength": "hole",
    "snippet": "        fn size(&self) -> (result: usize)\n            ensures result == self@.dom().len(), self@.dom().finite();"
  },
  {
    "id": 1961,
    "function": "empty",
    "file": "Chap43/OrderedTableStPer.rs",
    "lines": "51-52",
    "spec_strength": "hole",
    "snippet": "        fn empty() -> (result: Self)\n            ensures result@ == Map::<K::V, V::V>::empty();"
  },
  {
    "id": 1962,
    "function": "singleton",
    "file": "Chap43/OrderedTableStPer.rs",
    "lines": "53-54",
    "spec_strength": "hole",
    "snippet": "        fn singleton(k: K, v: V) -> (result: Self)\n            ensures result@ == Map::<K::V, V::V>::empty().insert(k@, v@), result@.dom().finite();"
  },
  {
    "id": 1963,
    "function": "find",
    "file": "Chap43/OrderedTableStPer.rs",
    "lines": "55",
    "spec_strength": "hole",
    "snippet": "        fn find(&self, k: &K) -> (result: Option<V>);"
  },
  {
    "id": 1964,
    "function": "insert",
    "file": "Chap43/OrderedTableStPer.rs",
    "lines": "56-57",
    "spec_strength": "hole",
    "snippet": "        fn insert(&self, k: K, v: V) -> (result: Self)\n            ensures result@.dom().finite();"
  },
  {
    "id": 1965,
    "function": "delete",
    "file": "Chap43/OrderedTableStPer.rs",
    "lines": "58-59",
    "spec_strength": "hole",
    "snippet": "        fn delete(&self, k: &K) -> (result: Self)\n            ensures result@ == self@.remove(k@), result@.dom().finite();"
  },
  {
    "id": 1966,
    "function": "domain",
    "file": "Chap43/OrderedTableStPer.rs",
    "lines": "60-61",
    "spec_strength": "hole",
    "snippet": "        fn domain(&self) -> (result: ArraySetStEph<K>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1967,
    "function": "tabulate",
    "file": "Chap43/OrderedTableStPer.rs",
    "lines": "62-63",
    "spec_strength": "hole",
    "snippet": "        fn tabulate<F: Fn(&K) -> V>(f: F, keys: &ArraySetStEph<K>) -> (result: Self)\n            ensures result@.dom().finite();"
  },
  {
    "id": 1968,
    "function": "map",
    "file": "Chap43/OrderedTableStPer.rs",
    "lines": "64-65",
    "spec_strength": "hole",
    "snippet": "        fn map<F: Fn(&V) -> V>(&self, f: F) -> (result: Self)\n            ensures result@.dom().finite();"
  },
  {
    "id": 1969,
    "function": "filter",
    "file": "Chap43/OrderedTableStPer.rs",
    "lines": "66-67",
    "spec_strength": "hole",
    "snippet": "        fn filter<F: Fn(&K, &V) -> B>(&self, f: F) -> (result: Self)\n            ensures result@.dom().finite();"
  },
  {
    "id": 1970,
    "function": "intersection",
    "file": "Chap43/OrderedTableStPer.rs",
    "lines": "68-69",
    "spec_strength": "hole",
    "snippet": "        fn intersection<F: Fn(&V, &V) -> V>(&self, other: &Self, f: F) -> (result: Self)\n            ensures result@.dom().finite();"
  },
  {
    "id": 1971,
    "function": "union",
    "file": "Chap43/OrderedTableStPer.rs",
    "lines": "70-71",
    "spec_strength": "hole",
    "snippet": "        fn union<F: Fn(&V, &V) -> V>(&self, other: &Self, f: F) -> (result: Self)\n            ensures result@.dom().finite();"
  },
  {
    "id": 1972,
    "function": "difference",
    "file": "Chap43/OrderedTableStPer.rs",
    "lines": "72-73",
    "spec_strength": "hole",
    "snippet": "        fn difference(&self, other: &Self) -> (result: Self)\n            ensures result@.dom().finite();"
  },
  {
    "id": 1973,
    "function": "restrict",
    "file": "Chap43/OrderedTableStPer.rs",
    "lines": "74-75",
    "spec_strength": "hole",
    "snippet": "        fn restrict(&self, keys: &ArraySetStEph<K>) -> (result: Self)\n            ensures result@.dom().finite();"
  },
  {
    "id": 1974,
    "function": "subtract",
    "file": "Chap43/OrderedTableStPer.rs",
    "lines": "76-77",
    "spec_strength": "hole",
    "snippet": "        fn subtract(&self, keys: &ArraySetStEph<K>) -> (result: Self)\n            ensures result@.dom().finite();"
  },
  {
    "id": 1975,
    "function": "collect",
    "file": "Chap43/OrderedTableStPer.rs",
    "lines": "78-79",
    "spec_strength": "hole",
    "snippet": "        fn collect(&self) -> (result: AVLTreeSeqStPerS<Pair<K, V>>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1976,
    "function": "first_key",
    "file": "Chap43/OrderedTableStPer.rs",
    "lines": "80-81",
    "spec_strength": "hole",
    "snippet": "        fn first_key(&self) -> (result: Option<K>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1977,
    "function": "last_key",
    "file": "Chap43/OrderedTableStPer.rs",
    "lines": "82-83",
    "spec_strength": "hole",
    "snippet": "        fn last_key(&self) -> (result: Option<K>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1978,
    "function": "previous_key",
    "file": "Chap43/OrderedTableStPer.rs",
    "lines": "84-85",
    "spec_strength": "hole",
    "snippet": "        fn previous_key(&self, k: &K) -> (result: Option<K>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1979,
    "function": "next_key",
    "file": "Chap43/OrderedTableStPer.rs",
    "lines": "86-87",
    "spec_strength": "hole",
    "snippet": "        fn next_key(&self, k: &K) -> (result: Option<K>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1980,
    "function": "split_key",
    "file": "Chap43/OrderedTableStPer.rs",
    "lines": "88-90",
    "spec_strength": "hole",
    "snippet": "        fn split_key(&self, k: &K) -> (result: (Self, Option<V>, Self))\n            where Self: Sized\n            ensures self@.dom().finite();"
  },
  {
    "id": 1981,
    "function": "join_key",
    "file": "Chap43/OrderedTableStPer.rs",
    "lines": "91-92",
    "spec_strength": "hole",
    "snippet": "        fn join_key(left: &Self, right: &Self) -> (result: Self)\n            ensures result@.dom().finite();"
  },
  {
    "id": 1982,
    "function": "get_key_range",
    "file": "Chap43/OrderedTableStPer.rs",
    "lines": "93-94",
    "spec_strength": "hole",
    "snippet": "        fn get_key_range(&self, k1: &K, k2: &K) -> (result: Self)\n            ensures result@.dom().finite();"
  },
  {
    "id": 1983,
    "function": "rank_key",
    "file": "Chap43/OrderedTableStPer.rs",
    "lines": "95-96",
    "spec_strength": "hole",
    "snippet": "        fn rank_key(&self, k: &K) -> (result: usize)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1984,
    "function": "select_key",
    "file": "Chap43/OrderedTableStPer.rs",
    "lines": "97-98",
    "spec_strength": "hole",
    "snippet": "        fn select_key(&self, i: usize) -> (result: Option<K>)\n            ensures self@.dom().finite();"
  },
  {
    "id": 1985,
    "function": "split_rank_key",
    "file": "Chap43/OrderedTableStPer.rs",
    "lines": "99-101",
    "spec_strength": "hole",
    "snippet": "        fn split_rank_key(&self, i: usize) -> (result: (Self, Self))\n            where Self: Sized\n            ensures self@.dom().finite();"
  },
  {
    "id": 1986,
    "function": "from_sorted_entries",
    "file": "Chap43/OrderedTableStPer.rs",
    "lines": "433-435",
    "spec_strength": "hole",
    "snippet": "    pub fn from_sorted_entries<K: StT + Ord, V: StT>(\n        entries: AVLTreeSeqStPerS<Pair<K, V>>,\n    ) -> OrderedTableStPer<K, V> {"
  },
  {
    "id": 1987,
    "function": "eq",
    "file": "Chap43/OrderedTableStPer.rs",
    "lines": "449-451",
    "spec_strength": "",
    "snippet": "        fn eq(&self, other: &Self) -> bool {\n            self.base_table == other.base_table\n        }"
  },
  {
    "id": 1988,
    "function": "_document_index_verified",
    "file": "Chap44/DocumentIndex.rs",
    "lines": "25",
    "spec_strength": "",
    "snippet": "        proof fn _document_index_verified() {}"
  },
  {
    "id": 1989,
    "function": "eq",
    "file": "Chap44/DocumentIndex.rs",
    "lines": "41-42",
    "spec_strength": "unknown",
    "snippet": "            fn eq(&self, other: &Self) -> (b: bool)\n                ensures b == (self.word_to_docs == other.word_to_docs)"
  },
  {
    "id": 1990,
    "function": "make_index",
    "file": "Chap44/DocumentIndex.rs",
    "lines": "53-55",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (n log n), Span (log n)\n        /// - Claude-Opus-4.6: Work (n), Span (n)  sequential nested loops over all_pairs; no Table.collect sort used\n        fn make_index(docs: &DocumentCollection)                     -> Self;"
  },
  {
    "id": 1991,
    "function": "find`",
    "file": "Chap44/DocumentIndex.rs",
    "lines": "285-287",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A  delegates to DocumentIndex::find.\n        /// - Claude-Opus-4.6: Work (log n), Span (log n)\n        fn find(&self, word: &Word)                                                     -> DocumentSet;"
  },
  {
    "id": 1992,
    "function": "query_and",
    "file": "Chap44/DocumentIndex.rs",
    "lines": "61-63",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (m log(1 + n/m)), Span (log n + log m)\n        /// - Claude-Opus-4.6: Work (m log(1 + n/m)), Span (m log(1 + n/m))  delegates to AVLTreeSetStPer.intersection (sequential)\n        fn query_and(docs_a: &DocumentSet, docs_b: &DocumentSet)     -> DocumentSet;"
  },
  {
    "id": 1993,
    "function": "query_or",
    "file": "Chap44/DocumentIndex.rs",
    "lines": "65-67",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (m log(1 + n/m)), Span (log n + log m)\n        /// - Claude-Opus-4.6: Work (m log(1 + n/m)), Span (m log(1 + n/m))  delegates to AVLTreeSetStPer.union (sequential)\n        fn query_or(docs_a: &DocumentSet, docs_b: &DocumentSet)      -> DocumentSet;"
  },
  {
    "id": 1994,
    "function": "query_and_not",
    "file": "Chap44/DocumentIndex.rs",
    "lines": "69-71",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (m log(1 + n/m)), Span (log n + log m)\n        /// - Claude-Opus-4.6: Work (m log(1 + n/m)), Span (m log(1 + n/m))  delegates to AVLTreeSetStPer.difference (sequential)\n        fn query_and_not(docs_a: &DocumentSet, docs_b: &DocumentSet) -> DocumentSet;"
  },
  {
    "id": 1995,
    "function": "size",
    "file": "Chap44/DocumentIndex.rs",
    "lines": "73-75",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (1), Span (1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)  agrees with APAS\n        fn size(docs: &DocumentSet)                                  -> usize;"
  },
  {
    "id": 1996,
    "function": "to_seq",
    "file": "Chap44/DocumentIndex.rs",
    "lines": "77-79",
    "spec_strength": "",
    "snippet": "        /// - APAS: (no cost stated)\n        /// - Claude-Opus-4.6: Work (n), Span (n)  sequential iteration over AVL tree sequence\n        fn to_seq(docs: &DocumentSet)                                -> ArraySeqStPerS<DocumentId>;"
  },
  {
    "id": 1997,
    "function": "empty",
    "file": "Chap44/DocumentIndex.rs",
    "lines": "81-83",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A  Verus-specific scaffolding.\n        /// - Claude-Opus-4.6: Work (1), Span (1)\n        fn empty()                                                   -> Self;"
  },
  {
    "id": 1998,
    "function": "get_all_words",
    "file": "Chap44/DocumentIndex.rs",
    "lines": "85-87",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A  Verus-specific scaffolding.\n        /// - Claude-Opus-4.6: Work (n), Span (n)  collects table keys into sequence\n        fn get_all_words(&self)                                      -> ArraySeqStPerS<Word>;"
  },
  {
    "id": 1999,
    "function": "word_count",
    "file": "Chap44/DocumentIndex.rs",
    "lines": "89-91",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A  Verus-specific scaffolding.\n        /// - Claude-Opus-4.6: Work (1), Span (1)  delegates to Table.size\n        fn word_count(&self)                                         -> usize;"
  },
  {
    "id": 2000,
    "function": "tokens",
    "file": "Chap44/DocumentIndex.rs",
    "lines": "195-222",
    "spec_strength": "",
    "snippet": "    /// Tokenization function: splits content into words.\n    /// - APAS: (no cost stated  tokens is a helper assumed O(m) where m = string length)\n    /// - Claude-Opus-4.6: Work (m), Span (m)  sequential character iteration\n    pub fn tokens(content: &Contents) -> ArraySeqStPerS<Word> {\n        let mut words = ArraySeqStPerS::empty();\n        let content_lower = content.to_lowercase();\n\n        // Simple tokenization: split on whitespace and punctuation\n        let mut current_word = String::new();\n\n        for ch in content_lower.chars() {\n            if ch.is_alphabetic() {\n                current_word.push(ch);\n            } else if !current_word.is_empty() {\n                let single_seq = ArraySeqStPerS::singleton(current_word.clone());\n                words = ArraySeqStPerS::append(&words, &single_seq);\n                current_word = String::new();\n            }\n        }\n\n        // Don't forget the last word\n        if !current_word.is_empty() {\n            let single_seq = ArraySeqStPerS::singleton(current_word);\n            words = ArraySeqStPerS::append(&words, &single_seq);\n        }\n\n        words\n    }"
  },
  {
    "id": 2001,
    "function": "create_finder",
    "file": "Chap44/DocumentIndex.rs",
    "lines": "224-229",
    "spec_strength": "",
    "snippet": "    /// Convenience function for staged computation pattern (Example 44.2).\n    /// - APAS: N/A  Verus-specific scaffolding.\n    /// - Claude-Opus-4.6: Work (1), Span (1)  closure capture only\n    pub fn create_finder(index: &DocumentIndex) -> impl Fn(&Word) -> DocumentSet + '_ {\n        move |word: &Word| index.find(word)\n    }"
  },
  {
    "id": 2002,
    "function": "new",
    "file": "Chap44/DocumentIndex.rs",
    "lines": "281-283",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A  Verus-specific scaffolding.\n        /// - Claude-Opus-4.6: Work (1), Span (1)\n        fn new(index: &'a DocumentIndex)                                                -> Self;"
  },
  {
    "id": 2003,
    "function": "and",
    "file": "Chap44/DocumentIndex.rs",
    "lines": "289-291",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A  delegates to DocumentIndex::query_and.\n        /// - Claude-Opus-4.6: Work (m log(1 + n/m)), Span (m log(1 + n/m))\n        fn and(&self, docs_a: DocumentSet, docs_b: DocumentSet)                         -> DocumentSet;"
  },
  {
    "id": 2004,
    "function": "or",
    "file": "Chap44/DocumentIndex.rs",
    "lines": "293-295",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A  delegates to DocumentIndex::query_or.\n        /// - Claude-Opus-4.6: Work (m log(1 + n/m)), Span (m log(1 + n/m))\n        fn or(&self, docs_a: DocumentSet, docs_b: DocumentSet)                          -> DocumentSet;"
  },
  {
    "id": 2005,
    "function": "and_not",
    "file": "Chap44/DocumentIndex.rs",
    "lines": "297-299",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A  delegates to DocumentIndex::query_and_not.\n        /// - Claude-Opus-4.6: Work (m log(1 + n/m)), Span (m log(1 + n/m))\n        fn and_not(&self, docs_a: DocumentSet, docs_b: DocumentSet)                     -> DocumentSet;"
  },
  {
    "id": 2006,
    "function": "complex_query",
    "file": "Chap44/DocumentIndex.rs",
    "lines": "301-303",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A  Verus-specific scaffolding.\n        /// - Claude-Opus-4.6: Work dominated by 4 finds + 3 set operations\n        fn complex_query(&self, word1: &Word, word2: &Word, word3: &Word, word4: &Word) -> DocumentSet;"
  },
  {
    "id": 2007,
    "function": "_example_44_1_verified",
    "file": "Chap44/Example44_1.rs",
    "lines": "14",
    "spec_strength": "",
    "snippet": "        proof fn _example_44_1_verified() {}"
  },
  {
    "id": 2008,
    "function": "create_tweet_collection",
    "file": "Chap44/Example44_1.rs",
    "lines": "17-27",
    "spec_strength": "",
    "snippet": "    /// - APAS: N/A  Example scaffolding.\n    /// - Claude-Opus-4.6: Work (n), Span (n)  builds 5-element sequence via macro\n    pub fn create_tweet_collection() -> DocumentCollection {\n        DocumentCollectionLit![\n            \"jack\" => \"chess is fun\",\n            \"mary\" => \"I had fun in dance club today\",\n            \"nick\" => \"food at the cafeteria sucks\",\n            \"josefa\" => \"rock climbing was a blast\",\n            \"peter\" => \"I had fun at the party, food was great\"\n        ]\n    }"
  },
  {
    "id": 2009,
    "function": "create_tweet_index",
    "file": "Chap44/Example44_1.rs",
    "lines": "29-35",
    "spec_strength": "",
    "snippet": "    /// Creates the document index for the tweet collection.\n    /// - APAS: N/A  Example scaffolding (cost dominated by make_index).\n    /// - Claude-Opus-4.6: Work (n), Span (n)  delegates to make_index\n    pub fn create_tweet_index() -> DocumentIndex {\n        let tweets = create_tweet_collection();\n        DocumentIndex::make_index(&tweets)\n    }"
  },
  {
    "id": 2010,
    "function": "create_tweet_finder",
    "file": "Chap44/Example44_1.rs",
    "lines": "37-44",
    "spec_strength": "",
    "snippet": "    /// Example 44.2: Staged computation pattern.\n    /// fw : word -> docs = find (makeIndex T)\n    /// - APAS: N/A  Example scaffolding (cost dominated by make_index).\n    /// - Claude-Opus-4.6: Work (n), Span (n)  builds index then returns closure\n    pub fn create_tweet_finder() -> impl Fn(&Word) -> DocumentSet {\n        let index = create_tweet_index();\n        move |word: &Word| index.find(word)\n    }"
  },
  {
    "id": 2011,
    "function": "default",
    "file": "Chap44/Example44_1.rs",
    "lines": "56",
    "spec_strength": "",
    "snippet": "        fn default() -> Self { Self::new() }"
  },
  {
    "id": 2012,
    "function": "new",
    "file": "Chap44/Example44_1.rs",
    "lines": "60-68",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A  Example scaffolding.\n        /// - Claude-Opus-4.6: Work (n), Span (n)  builds index via create_tweet_index\n        pub fn new() -> Self {\n            let index = create_tweet_index();\n            let index_clone = index.clone();\n            let fw = Box::new(move |word: &Word| index_clone.find(word));\n\n            TweetQueryExamples { index, fw }\n        }"
  },
  {
    "id": 2013,
    "function": "search_fun",
    "file": "Chap44/Example44_1.rs",
    "lines": "70-73",
    "spec_strength": "",
    "snippet": "        /// Example query: searching for 'fun' should return {\"jack\", \"mary\", \"peter\"}.\n        /// - APAS: N/A  Example scaffolding.\n        /// - Claude-Opus-4.6: Work (log n), Span (log n)  single find\n        pub fn search_fun(&self) -> DocumentSet { (self.fw)(&\"fun\".to_string()) }"
  },
  {
    "id": 2014,
    "function": "search_club",
    "file": "Chap44/Example44_1.rs",
    "lines": "75-78",
    "spec_strength": "",
    "snippet": "        /// Example query: searching for 'club' should return {\"mary\"}.\n        /// - APAS: N/A  Example scaffolding.\n        /// - Claude-Opus-4.6: Work (log n), Span (log n)  single find\n        pub fn search_club(&self) -> DocumentSet { (self.fw)(&\"club\".to_string()) }"
  },
  {
    "id": 2015,
    "function": "search_food",
    "file": "Chap44/Example44_1.rs",
    "lines": "80-83",
    "spec_strength": "",
    "snippet": "        /// Example query: searching for 'food' should return {\"nick\", \"peter\"}.\n        /// - APAS: N/A  Example scaffolding.\n        /// - Claude-Opus-4.6: Work (log n), Span (log n)  single find\n        pub fn search_food(&self) -> DocumentSet { (self.fw)(&\"food\".to_string()) }"
  },
  {
    "id": 2016,
    "function": "search_chess",
    "file": "Chap44/Example44_1.rs",
    "lines": "85-88",
    "spec_strength": "",
    "snippet": "        /// Example query: searching for 'chess' should return {\"jack\"}.\n        /// - APAS: N/A  Example scaffolding.\n        /// - Claude-Opus-4.6: Work (log n), Span (log n)  single find\n        pub fn search_chess(&self) -> DocumentSet { (self.fw)(&\"chess\".to_string()) }"
  },
  {
    "id": 2017,
    "function": "complex_query_fun_and_food_or_chess",
    "file": "Chap44/Example44_1.rs",
    "lines": "90-104",
    "spec_strength": "",
    "snippet": "        /// Complex query from textbook:\n        /// toSeq (queryAnd ((fw 'fun'), queryOr ((fw 'food'), (fw 'chess'))))\n        /// Expected result: 'jack', 'peter'\n        /// - APAS: N/A  Example scaffolding; cost is 3 finds + 2 set operations + toSeq.\n        /// - Claude-Opus-4.6: Work (m log(1+n/m)), Span (m log(1+n/m))  dominated by set operations\n        pub fn complex_query_fun_and_food_or_chess(&self) -> ArraySeqStPerS<DocumentId> {\n            let fun_docs = (self.fw)(&\"fun\".to_string());\n            let food_docs = (self.fw)(&\"food\".to_string());\n            let chess_docs = (self.fw)(&\"chess\".to_string());\n\n            let food_or_chess = DocumentIndex::query_or(&food_docs, &chess_docs);\n            let result = DocumentIndex::query_and(&fun_docs, &food_or_chess);\n\n            DocumentIndex::to_seq(&result)\n        }"
  },
  {
    "id": 2018,
    "function": "count_fun_but_not_chess",
    "file": "Chap44/Example44_1.rs",
    "lines": "106-117",
    "spec_strength": "",
    "snippet": "        /// Complex query from textbook:\n        /// size (queryAndNot ((fw 'fun'), (fw 'chess')))\n        /// Expected result: 2 (mary and peter).\n        /// - APAS: N/A  Example scaffolding; cost is 2 finds + queryAndNot + size.\n        /// - Claude-Opus-4.6: Work (m log(1+n/m)), Span (m log(1+n/m))  dominated by set difference\n        pub fn count_fun_but_not_chess(&self) -> usize {\n            let fun_docs = (self.fw)(&\"fun\".to_string());\n            let chess_docs = (self.fw)(&\"chess\".to_string());\n\n            let result = DocumentIndex::query_and_not(&fun_docs, &chess_docs);\n            DocumentIndex::size(&result)\n        }"
  },
  {
    "id": 2019,
    "function": "search_food_or_fun",
    "file": "Chap44/Example44_1.rs",
    "lines": "119-127",
    "spec_strength": "",
    "snippet": "        /// Additional example: documents with 'food' OR 'fun'.\n        /// - APAS: N/A  Example scaffolding.\n        /// - Claude-Opus-4.6: Work (m log(1+n/m)), Span (m log(1+n/m))\n        pub fn search_food_or_fun(&self) -> DocumentSet {\n            let food_docs = (self.fw)(&\"food\".to_string());\n            let fun_docs = (self.fw)(&\"fun\".to_string());\n\n            DocumentIndex::query_or(&food_docs, &fun_docs)\n        }"
  },
  {
    "id": 2020,
    "function": "search_party_and_food",
    "file": "Chap44/Example44_1.rs",
    "lines": "129-137",
    "spec_strength": "",
    "snippet": "        /// Additional example: documents with 'party' AND 'food'.\n        /// - APAS: N/A  Example scaffolding.\n        /// - Claude-Opus-4.6: Work (m log(1+n/m)), Span (m log(1+n/m))\n        pub fn search_party_and_food(&self) -> DocumentSet {\n            let party_docs = (self.fw)(&\"party\".to_string());\n            let food_docs = (self.fw)(&\"food\".to_string());\n\n            DocumentIndex::query_and(&party_docs, &food_docs)\n        }"
  },
  {
    "id": 2021,
    "function": "get_all_words",
    "file": "Chap44/Example44_1.rs",
    "lines": "139-142",
    "spec_strength": "",
    "snippet": "        /// Get all unique words in the tweet collection.\n        /// - APAS: N/A  Example scaffolding.\n        /// - Claude-Opus-4.6: Work (n), Span (n)\n        pub fn get_all_words(&self) -> ArraySeqStPerS<Word> { self.index.get_all_words() }"
  },
  {
    "id": 2022,
    "function": "get_word_count",
    "file": "Chap44/Example44_1.rs",
    "lines": "144-147",
    "spec_strength": "",
    "snippet": "        /// Get word count statistics.\n        /// - APAS: N/A  Example scaffolding.\n        /// - Claude-Opus-4.6: Work (1), Span (1)\n        pub fn get_word_count(&self) -> usize { self.index.word_count() }"
  },
  {
    "id": 2023,
    "function": "query_builder_example",
    "file": "Chap44/Example44_1.rs",
    "lines": "149-162",
    "spec_strength": "",
    "snippet": "        /// Demonstrate query builder pattern.\n        /// - APAS: N/A  Example scaffolding.\n        /// - Claude-Opus-4.6: Work dominated by 4 finds + 3 set operations\n        pub fn query_builder_example(&self) -> DocumentSet {\n            let builder = QueryBuilder::new(&self.index);\n\n            // Complex query: (fun AND party) OR (chess AND NOT food)\n            builder.complex_query(\n                &\"fun\".to_string(),\n                &\"party\".to_string(),\n                &\"chess\".to_string(),\n                &\"food\".to_string(),\n            )\n        }"
  },
  {
    "id": 2024,
    "function": "doc_set_to_sorted_vec",
    "file": "Chap44/Example44_1.rs",
    "lines": "165-178",
    "spec_strength": "",
    "snippet": "    /// - APAS: N/A  Test helper.\n    /// - Claude-Opus-4.6: Work (n log n), Span (n log n)  to_seq + sort\n    pub fn doc_set_to_sorted_vec(docs: &DocumentSet) -> Vec<DocumentId> {\n        let seq = DocumentIndex::to_seq(docs);\n        let mut result = Vec::new();\n\n        for i in 0..seq.length() {\n            let doc_id = seq.nth(i);\n            result.push(doc_id.clone());\n        }\n\n        result.sort();\n        result\n    }"
  },
  {
    "id": 2025,
    "function": "verify_textbook_examples",
    "file": "Chap44/Example44_1.rs",
    "lines": "180-220",
    "spec_strength": "",
    "snippet": "    /// Verify the expected results from the textbook examples.\n    /// - APAS: N/A  Test verification helper.\n    /// - Claude-Opus-4.6: Work (n), Span (n)  builds index, runs queries, compares results\n    pub fn verify_textbook_examples() -> bool {\n        let examples = TweetQueryExamples::new();\n\n        // Test 1: searching for 'fun' should return {\"jack\", \"mary\", \"peter\"}\n        let fun_results = doc_set_to_sorted_vec(&examples.search_fun());\n        let expected_fun = vec![\"jack\".to_string(), \"mary\".to_string(), \"peter\".to_string()];\n        if fun_results != expected_fun {\n            return false;\n        }\n\n        // Test 2: searching for 'club' should return {\"mary\"}\n        let club_results = doc_set_to_sorted_vec(&examples.search_club());\n        let expected_club = vec![\"mary\".to_string()];\n        if club_results != expected_club {\n            return false;\n        }\n\n        // Test 3: complex query should return 'jack', 'peter'\n        let complex_results = examples.complex_query_fun_and_food_or_chess();\n        let mut complex_vec = Vec::new();\n        for i in 0..complex_results.length() {\n            let doc_id = complex_results.nth(i);\n            complex_vec.push(doc_id.clone());\n        }\n        complex_vec.sort();\n        let expected_complex = vec![\"jack\".to_string(), \"peter\".to_string()];\n        if complex_vec != expected_complex {\n            return false;\n        }\n\n        // Test 4: count query should return 2\n        let count_result = examples.count_fun_but_not_chess();\n        if count_result != 2 {\n            return false;\n        }\n\n        true\n    }"
  },
  {
    "id": 2026,
    "function": "performance_comparison_demo",
    "file": "Chap44/Example44_1.rs",
    "lines": "222-236",
    "spec_strength": "",
    "snippet": "    /// Performance demonstration: compare indexed search vs brute force.\n    /// - APAS: N/A  Example scaffolding.\n    /// - Claude-Opus-4.6: Work (n), Span (n)  dominated by index construction\n    pub fn performance_comparison_demo() -> (usize, usize) {\n        let tweets = create_tweet_collection();\n        let _index = create_tweet_index();\n\n        // Indexed search work: O(log n) for find\n        let indexed_work = 1; // Represents O(log n) complexity\n\n        // Brute force work: O(n * m) where n is documents, m is average content length\n        let brute_force_work = tweets.length(); // Represents O(n) complexity\n\n        (indexed_work, brute_force_work)\n    }"
  },
  {
    "id": 2027,
    "function": "tokenization_demo",
    "file": "Chap44/Example44_1.rs",
    "lines": "238-244",
    "spec_strength": "",
    "snippet": "    /// Demonstrate the tokenization process.\n    /// - APAS: N/A  Example scaffolding.\n    /// - Claude-Opus-4.6: Work (m), Span (m)  delegates to tokens()\n    pub fn tokenization_demo() -> ArraySeqStPerS<Word> {\n        let sample_content = \"I had fun in dance club today!\";\n        tokens(&sample_content.to_string())\n    }"
  },
  {
    "id": 2028,
    "function": "index_statistics",
    "file": "Chap44/Example44_1.rs",
    "lines": "246-265",
    "spec_strength": "",
    "snippet": "    /// Show index statistics for the tweet collection.\n    /// - APAS: N/A  Example scaffolding.\n    /// - Claude-Opus-4.6: Work (n), Span (n)  builds index + iterates documents\n    pub fn index_statistics() -> (usize, usize, usize) {\n        let tweets = create_tweet_collection();\n        let index = create_tweet_index();\n\n        let document_count = tweets.length();\n        let unique_word_count = index.word_count();\n\n        // Calculate total words across all documents\n        let mut total_words = 0;\n        for i in 0..tweets.length() {\n            let doc = tweets.nth(i);\n            let word_tokens = tokens(&doc.1);\n            total_words += word_tokens.length();\n        }\n\n        (document_count, unique_word_count, total_words)\n    }"
  },
  {
    "id": 2029,
    "function": "_balanced_tree_pq_verified",
    "file": "Chap45/BalancedTreePQ.rs",
    "lines": "16",
    "spec_strength": "",
    "snippet": "        proof fn _balanced_tree_pq_verified() {}"
  },
  {
    "id": 2030,
    "function": "eq",
    "file": "Chap45/BalancedTreePQ.rs",
    "lines": "43-44",
    "spec_strength": "hole",
    "snippet": "            fn eq(&self, other: &Self) -> (r: bool)\n                ensures r == (self@ == other@)"
  },
  {
    "id": 2031,
    "function": "empty",
    "file": "Chap45/BalancedTreePQ.rs",
    "lines": "63-64",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work (1), Span (1)\n        fn empty()                                           -> Self;"
  },
  {
    "id": 2032,
    "function": "singleton",
    "file": "Chap45/BalancedTreePQ.rs",
    "lines": "66-67",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work (1), Span (1)\n        fn singleton(element: T)                             -> Self;"
  },
  {
    "id": 2033,
    "function": "find_min",
    "file": "Chap45/BalancedTreePQ.rs",
    "lines": "69-71",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)\n        /// Returns the minimum element (leftmost in balanced tree), or None if empty\n        fn find_min(&self)                                   -> Option<&T>;"
  },
  {
    "id": 2034,
    "function": "insert",
    "file": "Chap45/BalancedTreePQ.rs",
    "lines": "73-75",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)\n        /// Inserts element into balanced tree maintaining order\n        fn insert(&self, element: T)                         -> Self;"
  },
  {
    "id": 2035,
    "function": "delete_min",
    "file": "Chap45/BalancedTreePQ.rs",
    "lines": "77-81",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)\n        /// Removes minimum element (leftmost) from balanced tree\n        fn delete_min(&self)                                 -> (Self, Option<T>)\n        where\n            Self: Sized;"
  },
  {
    "id": 2036,
    "function": "meld",
    "file": "Chap45/BalancedTreePQ.rs",
    "lines": "83-85",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work (m log(1 + n/m)), Span (log n + log m)\n        /// Melds two balanced trees using union operation\n        fn meld(&self, other: &Self)                         -> Self;"
  },
  {
    "id": 2037,
    "function": "from_seq",
    "file": "Chap45/BalancedTreePQ.rs",
    "lines": "87-89",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work (n log n), Span (log n), Parallelism (n/log n)\n        /// Creates priority queue from sequence using balanced tree construction\n        fn from_seq(seq: &AVLTreeSeqStPerS<T>)               -> Self;"
  },
  {
    "id": 2038,
    "function": "size",
    "file": "Chap45/BalancedTreePQ.rs",
    "lines": "91",
    "spec_strength": "",
    "snippet": "        fn size(&self)                                       -> usize;"
  },
  {
    "id": 2039,
    "function": "is_empty",
    "file": "Chap45/BalancedTreePQ.rs",
    "lines": "92",
    "spec_strength": "",
    "snippet": "        fn is_empty(&self)                                   -> bool;"
  },
  {
    "id": 2040,
    "function": "to_seq",
    "file": "Chap45/BalancedTreePQ.rs",
    "lines": "93",
    "spec_strength": "",
    "snippet": "        fn to_seq(&self)                                     -> AVLTreeSeqStPerS<T>;"
  },
  {
    "id": 2041,
    "function": "find_max",
    "file": "Chap45/BalancedTreePQ.rs",
    "lines": "94",
    "spec_strength": "",
    "snippet": "        fn find_max(&self)                                   -> Option<&T>;"
  },
  {
    "id": 2042,
    "function": "delete_max",
    "file": "Chap45/BalancedTreePQ.rs",
    "lines": "95-97",
    "spec_strength": "",
    "snippet": "        fn delete_max(&self)                                 -> (Self, Option<T>)\n        where\n            Self: Sized;"
  },
  {
    "id": 2043,
    "function": "insert_all",
    "file": "Chap45/BalancedTreePQ.rs",
    "lines": "98",
    "spec_strength": "",
    "snippet": "        fn insert_all(&self, elements: &AVLTreeSeqStPerS<T>) -> Self;"
  },
  {
    "id": 2044,
    "function": "extract_all_sorted",
    "file": "Chap45/BalancedTreePQ.rs",
    "lines": "99",
    "spec_strength": "",
    "snippet": "        fn extract_all_sorted(&self)                         -> AVLTreeSeqStPerS<T>;"
  },
  {
    "id": 2045,
    "function": "contains",
    "file": "Chap45/BalancedTreePQ.rs",
    "lines": "100",
    "spec_strength": "",
    "snippet": "        fn contains(&self, element: &T)                      -> bool;"
  },
  {
    "id": 2046,
    "function": "remove",
    "file": "Chap45/BalancedTreePQ.rs",
    "lines": "101-103",
    "spec_strength": "",
    "snippet": "        fn remove(&self, element: &T)                        -> (Self, bool)\n        where\n            Self: Sized;"
  },
  {
    "id": 2047,
    "function": "range",
    "file": "Chap45/BalancedTreePQ.rs",
    "lines": "104",
    "spec_strength": "",
    "snippet": "        fn range(&self, min_val: &T, max_val: &T)            -> AVLTreeSeqStPerS<T>;"
  },
  {
    "id": 2048,
    "function": "from_vec",
    "file": "Chap45/BalancedTreePQ.rs",
    "lines": "105",
    "spec_strength": "",
    "snippet": "        fn from_vec(elements: Vec<T>)                        -> Self;"
  },
  {
    "id": 2049,
    "function": "to_vec",
    "file": "Chap45/BalancedTreePQ.rs",
    "lines": "106",
    "spec_strength": "",
    "snippet": "        fn to_vec(&self)                                     -> Vec<T>;"
  },
  {
    "id": 2050,
    "function": "to_sorted_vec",
    "file": "Chap45/BalancedTreePQ.rs",
    "lines": "107",
    "spec_strength": "",
    "snippet": "        fn to_sorted_vec(&self)                              -> Vec<T>;"
  },
  {
    "id": 2051,
    "function": "is_sorted",
    "file": "Chap45/BalancedTreePQ.rs",
    "lines": "108",
    "spec_strength": "",
    "snippet": "        fn is_sorted(&self)                                  -> bool;"
  },
  {
    "id": 2052,
    "function": "height",
    "file": "Chap45/BalancedTreePQ.rs",
    "lines": "109",
    "spec_strength": "",
    "snippet": "        fn height(&self)                                     -> usize;"
  },
  {
    "id": 2053,
    "function": "split",
    "file": "Chap45/BalancedTreePQ.rs",
    "lines": "110-112",
    "spec_strength": "",
    "snippet": "        fn split(&self, element: &T)                         -> (Self, bool, Self)\n        where\n            Self: Sized;"
  },
  {
    "id": 2054,
    "function": "join",
    "file": "Chap45/BalancedTreePQ.rs",
    "lines": "113",
    "spec_strength": "",
    "snippet": "        fn join(left: &Self, right: &Self)                   -> Self;"
  },
  {
    "id": 2055,
    "function": "filter",
    "file": "Chap45/BalancedTreePQ.rs",
    "lines": "114-116",
    "spec_strength": "",
    "snippet": "        fn filter<F>(&self, predicate: F)                    -> Self\n        where\n            F: Fn(&T) -> bool;"
  },
  {
    "id": 2056,
    "function": "map",
    "file": "Chap45/BalancedTreePQ.rs",
    "lines": "117-120",
    "spec_strength": "",
    "snippet": "        fn map<U, G>(&self, f: G)                           -> BalancedTreePQ<U>\n        where\n            U: StT + Ord,\n            G: Fn(&T) -> U;"
  },
  {
    "id": 2057,
    "function": "default",
    "file": "Chap45/BalancedTreePQ.rs",
    "lines": "422",
    "spec_strength": "",
    "snippet": "        fn default() -> Self { Self::empty() }"
  },
  {
    "id": 2058,
    "function": "_binary_heap_pq_verified",
    "file": "Chap45/BinaryHeapPQ.rs",
    "lines": "15",
    "spec_strength": "",
    "snippet": "        proof fn _binary_heap_pq_verified() {}"
  },
  {
    "id": 2059,
    "function": "eq",
    "file": "Chap45/BinaryHeapPQ.rs",
    "lines": "43-44",
    "spec_strength": "hole",
    "snippet": "            fn eq(&self, other: &Self) -> (r: bool)\n                ensures r == (self@ == other@)"
  },
  {
    "id": 2060,
    "function": "empty",
    "file": "Chap45/BinaryHeapPQ.rs",
    "lines": "63-64",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work (1), Span (1)\n        fn empty()                           -> Self;"
  },
  {
    "id": 2061,
    "function": "singleton",
    "file": "Chap45/BinaryHeapPQ.rs",
    "lines": "66-67",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work (1), Span (1)\n        fn singleton(element: T)             -> Self;"
  },
  {
    "id": 2062,
    "function": "find_min",
    "file": "Chap45/BinaryHeapPQ.rs",
    "lines": "69-71",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work (1), Span (1)\n        /// Returns the minimum element (root of min-heap), or None if empty\n        fn find_min(&self)                   -> Option<&T>;"
  },
  {
    "id": 2063,
    "function": "insert",
    "file": "Chap45/BinaryHeapPQ.rs",
    "lines": "73-75",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)\n        /// Inserts element and bubbles up to maintain heap property\n        fn insert(&self, element: T)         -> Self;"
  },
  {
    "id": 2064,
    "function": "delete_min",
    "file": "Chap45/BinaryHeapPQ.rs",
    "lines": "77-81",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)\n        /// Removes root (minimum) and bubbles down to maintain heap property\n        fn delete_min(&self)                 -> (Self, Option<T>)\n        where\n            Self: Sized;"
  },
  {
    "id": 2065,
    "function": "meld",
    "file": "Chap45/BinaryHeapPQ.rs",
    "lines": "83-85",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work (m + n), Span (m + n), Parallelism (1)\n        /// Melds two heaps by concatenating and re-heapifying\n        fn meld(&self, other: &Self)         -> Self;"
  },
  {
    "id": 2066,
    "function": "from_seq",
    "file": "Chap45/BinaryHeapPQ.rs",
    "lines": "87-89",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)\n        /// Creates heap from sequence using bottom-up heapify\n        fn from_seq(seq: &ArraySeqStPerS<T>) -> Self;"
  },
  {
    "id": 2067,
    "function": "size",
    "file": "Chap45/BinaryHeapPQ.rs",
    "lines": "91",
    "spec_strength": "",
    "snippet": "        fn size(&self)                       -> usize;"
  },
  {
    "id": 2068,
    "function": "is_empty",
    "file": "Chap45/BinaryHeapPQ.rs",
    "lines": "92",
    "spec_strength": "",
    "snippet": "        fn is_empty(&self)                   -> bool;"
  },
  {
    "id": 2069,
    "function": "to_seq",
    "file": "Chap45/BinaryHeapPQ.rs",
    "lines": "93",
    "spec_strength": "",
    "snippet": "        fn to_seq(&self)                     -> ArraySeqStPerS<T>;"
  },
  {
    "id": 2070,
    "function": "insert_all",
    "file": "Chap45/BinaryHeapPQ.rs",
    "lines": "94",
    "spec_strength": "",
    "snippet": "        fn insert_all(&self, elements: &ArraySeqStPerS<T>) -> Self;"
  },
  {
    "id": 2071,
    "function": "extract_all_sorted",
    "file": "Chap45/BinaryHeapPQ.rs",
    "lines": "95",
    "spec_strength": "",
    "snippet": "        fn extract_all_sorted(&self)         -> ArraySeqStPerS<T>;"
  },
  {
    "id": 2072,
    "function": "is_valid_heap",
    "file": "Chap45/BinaryHeapPQ.rs",
    "lines": "96",
    "spec_strength": "",
    "snippet": "        fn is_valid_heap(&self)              -> bool;"
  },
  {
    "id": 2073,
    "function": "height",
    "file": "Chap45/BinaryHeapPQ.rs",
    "lines": "97",
    "spec_strength": "",
    "snippet": "        fn height(&self)                     -> usize;"
  },
  {
    "id": 2074,
    "function": "level_elements",
    "file": "Chap45/BinaryHeapPQ.rs",
    "lines": "98",
    "spec_strength": "",
    "snippet": "        fn level_elements(&self, level: usize)   -> ArraySeqStPerS<T>;"
  },
  {
    "id": 2075,
    "function": "from_vec",
    "file": "Chap45/BinaryHeapPQ.rs",
    "lines": "99",
    "spec_strength": "",
    "snippet": "        fn from_vec(vec: Vec<T>)             -> Self;"
  },
  {
    "id": 2076,
    "function": "to_vec",
    "file": "Chap45/BinaryHeapPQ.rs",
    "lines": "100",
    "spec_strength": "",
    "snippet": "        fn to_vec(&self)                     -> Vec<T>;"
  },
  {
    "id": 2077,
    "function": "to_sorted_vec",
    "file": "Chap45/BinaryHeapPQ.rs",
    "lines": "101",
    "spec_strength": "",
    "snippet": "        fn to_sorted_vec(&self)              -> Vec<T>;"
  },
  {
    "id": 2078,
    "function": "left_child",
    "file": "Chap45/BinaryHeapPQ.rs",
    "lines": "104",
    "spec_strength": "",
    "snippet": "    fn left_child(i: usize) -> usize { 2 * i + 1 }"
  },
  {
    "id": 2079,
    "function": "right_child",
    "file": "Chap45/BinaryHeapPQ.rs",
    "lines": "105",
    "spec_strength": "",
    "snippet": "    fn right_child(i: usize) -> usize { 2 * i + 2 }"
  },
  {
    "id": 2080,
    "function": "parent",
    "file": "Chap45/BinaryHeapPQ.rs",
    "lines": "106",
    "spec_strength": "",
    "snippet": "    fn parent(i: usize) -> usize { if i == 0 { 0 } else { (i - 1) / 2 } }"
  },
  {
    "id": 2081,
    "function": "swap_elements",
    "file": "Chap45/BinaryHeapPQ.rs",
    "lines": "108-125",
    "spec_strength": "",
    "snippet": "    fn swap_elements<T: StT + Ord>(seq: &ArraySeqStPerS<T>, i: usize, j: usize) -> ArraySeqStPerS<T> {\n        let mut result = ArraySeqStPerS::empty();\n\n        for k in 0..seq.length() {\n            let element = if k == i {\n                seq.nth(j).clone()\n            } else if k == j {\n                seq.nth(i).clone()\n            } else {\n                seq.nth(k).clone()\n            };\n\n            let single_seq = ArraySeqStPerS::singleton(element);\n            result = ArraySeqStPerS::append(&result, &single_seq);\n        }\n\n        result\n    }"
  },
  {
    "id": 2082,
    "function": "bubble_up",
    "file": "Chap45/BinaryHeapPQ.rs",
    "lines": "127-144",
    "spec_strength": "",
    "snippet": "    fn bubble_up<T: StT + Ord>(seq: &ArraySeqStPerS<T>, mut i: usize) -> ArraySeqStPerS<T> {\n        let mut result = seq.clone();\n\n        while i > 0 {\n            let parent_idx = parent(i);\n            let current = result.nth(i);\n            let parent_val = result.nth(parent_idx);\n\n            if current >= parent_val {\n                break;\n            }\n\n            result = swap_elements(&result, i, parent_idx);\n            i = parent_idx;\n        }\n\n        result\n    }"
  },
  {
    "id": 2083,
    "function": "bubble_down",
    "file": "Chap45/BinaryHeapPQ.rs",
    "lines": "146-171",
    "spec_strength": "",
    "snippet": "    fn bubble_down<T: StT + Ord>(heap: &ArraySeqStPerS<T>, mut i: usize) -> ArraySeqStPerS<T> {\n        let mut result = heap.clone();\n\n        loop {\n            let left = left_child(i);\n            let right = right_child(i);\n            let mut smallest = i;\n\n            if left < result.length() && result.nth(left) < result.nth(smallest) {\n                smallest = left;\n            }\n\n            if right < result.length() && result.nth(right) < result.nth(smallest) {\n                smallest = right;\n            }\n\n            if smallest == i {\n                break;\n            }\n\n            result = swap_elements(&result, i, smallest);\n            i = smallest;\n        }\n\n        result\n    }"
  },
  {
    "id": 2084,
    "function": "heapify",
    "file": "Chap45/BinaryHeapPQ.rs",
    "lines": "173-186",
    "spec_strength": "",
    "snippet": "    fn heapify<T: StT + Ord>(seq: &ArraySeqStPerS<T>) -> ArraySeqStPerS<T> {\n        if seq.length() <= 1 {\n            return seq.clone();\n        }\n\n        let mut result = seq.clone();\n        let last_non_leaf = if seq.length() >= 2 { (seq.length() - 2) / 2 } else { 0 };\n\n        for i in (0..=last_non_leaf).rev() {\n            result = bubble_down(&result, i);\n        }\n\n        result\n    }"
  },
  {
    "id": 2085,
    "function": "is_heap",
    "file": "Chap45/BinaryHeapPQ.rs",
    "lines": "188-202",
    "spec_strength": "",
    "snippet": "    fn is_heap<T: StT + Ord>(elements: &ArraySeqStPerS<T>) -> bool {\n        for i in 0..elements.length() {\n            let left = left_child(i);\n            let right = right_child(i);\n\n            if left < elements.length() && elements.nth(i) > elements.nth(left) {\n                return false;\n            }\n\n            if right < elements.length() && elements.nth(i) > elements.nth(right) {\n                return false;\n            }\n        }\n        true\n    }"
  },
  {
    "id": 2086,
    "function": "default",
    "file": "Chap45/BinaryHeapPQ.rs",
    "lines": "375",
    "spec_strength": "",
    "snippet": "        fn default() -> Self { Self::empty() }"
  },
  {
    "id": 2087,
    "function": "_example_45_2_verified",
    "file": "Chap45/Example45_2.rs",
    "lines": "12",
    "spec_strength": "",
    "snippet": "        proof fn _example_45_2_verified() {}"
  },
  {
    "id": 2088,
    "function": "example_45_2_textbook_example",
    "file": "Chap45/Example45_2.rs",
    "lines": "17-19",
    "spec_strength": "",
    "snippet": "        /// Example 45.2: Textbook heapsort demonstration\n        /// APAS: Work (n log n), Span (n log n)\n        fn example_45_2_textbook_example()         -> HeapsortComparison<i32>;"
  },
  {
    "id": 2089,
    "function": "example_45_2_reverse_sorted",
    "file": "Chap45/Example45_2.rs",
    "lines": "21-23",
    "spec_strength": "",
    "snippet": "        /// Example 45.2: Reverse-sorted input demonstration\n        /// APAS: Work (n log n), Span (n log n)\n        fn example_45_2_reverse_sorted()           -> HeapsortComparison<i32>;"
  },
  {
    "id": 2090,
    "function": "example_45_2_already_sorted",
    "file": "Chap45/Example45_2.rs",
    "lines": "25-27",
    "spec_strength": "",
    "snippet": "        /// Example 45.2: Already-sorted input demonstration\n        /// APAS: Work (n log n), Span (n log n)\n        fn example_45_2_already_sorted()           -> HeapsortComparison<i32>;"
  },
  {
    "id": 2091,
    "function": "example_45_2_duplicates",
    "file": "Chap45/Example45_2.rs",
    "lines": "29-31",
    "spec_strength": "",
    "snippet": "        /// Example 45.2: Input with duplicates demonstration\n        /// APAS: Work (n log n), Span (n log n)\n        fn example_45_2_duplicates()               -> HeapsortComparison<i32>;"
  },
  {
    "id": 2092,
    "function": "example_45_2_single_element",
    "file": "Chap45/Example45_2.rs",
    "lines": "33-35",
    "spec_strength": "",
    "snippet": "        /// Example 45.2: Single element demonstration\n        /// APAS: Work (1), Span (1)\n        fn example_45_2_single_element()           -> HeapsortComparison<i32>;"
  },
  {
    "id": 2093,
    "function": "example_45_2_empty",
    "file": "Chap45/Example45_2.rs",
    "lines": "37-39",
    "spec_strength": "",
    "snippet": "        /// Example 45.2: Empty input demonstration\n        /// APAS: Work (1), Span (1)\n        fn example_45_2_empty()                    -> HeapsortComparison<i32>;"
  },
  {
    "id": 2094,
    "function": "example_45_2_efficiency_demonstration",
    "file": "Chap45/Example45_2.rs",
    "lines": "41-43",
    "spec_strength": "",
    "snippet": "        /// Example 45.2: Efficiency comparison demonstration\n        /// APAS: Work (n), Span (n) - dominated by worst implementation\n        fn example_45_2_efficiency_demonstration() -> Vec<(String, Vec<i32>)>;"
  },
  {
    "id": 2095,
    "function": "run_example_45_2",
    "file": "Chap45/Example45_2.rs",
    "lines": "45-47",
    "spec_strength": "",
    "snippet": "        /// Run comprehensive demonstration of Example 45.2\n        /// APAS: Work (n), Span (n) - dominated by worst implementation\n        fn run_example_45_2()                      -> String;"
  },
  {
    "id": 2096,
    "function": "_heapsort_example_verified",
    "file": "Chap45/HeapsortExample.rs",
    "lines": "24",
    "spec_strength": "",
    "snippet": "        proof fn _heapsort_example_verified() {}"
  },
  {
    "id": 2097,
    "function": "eq",
    "file": "Chap45/HeapsortExample.rs",
    "lines": "81-82",
    "spec_strength": "hole",
    "snippet": "            fn eq(&self, other: &Self) -> (r: bool)\n                ensures r == (self@ == other@)"
  },
  {
    "id": 2098,
    "function": "heapsort_unsorted_list",
    "file": "Chap45/HeapsortExample.rs",
    "lines": "99-101",
    "spec_strength": "",
    "snippet": "        /// Heapsort using UnsortedListPQ\n        /// Claude Work: (n), Span: (n) - inefficient due to O(n) deleteMin\n        fn heapsort_unsorted_list<T: StT + Ord>(sequence: &[T]) -> Vec<T>;"
  },
  {
    "id": 2099,
    "function": "heapsort_sorted_list",
    "file": "Chap45/HeapsortExample.rs",
    "lines": "103-105",
    "spec_strength": "",
    "snippet": "        /// Heapsort using SortedListPQ  \n        /// Claude Work: (n), Span: (n) - inefficient due to O(n) insert\n        fn heapsort_sorted_list<T: StT + Ord>(sequence: &[T])   -> Vec<T>;"
  },
  {
    "id": 2100,
    "function": "heapsort_balanced_tree",
    "file": "Chap45/HeapsortExample.rs",
    "lines": "107-109",
    "spec_strength": "",
    "snippet": "        /// Heapsort using BalancedTreePQ\n        /// Claude Work: (n log n), Span: (n log n) - optimal complexity\n        fn heapsort_balanced_tree<T: StT + Ord>(sequence: &[T]) -> Vec<T>;"
  },
  {
    "id": 2101,
    "function": "heapsort_binary_heap",
    "file": "Chap45/HeapsortExample.rs",
    "lines": "111-113",
    "spec_strength": "",
    "snippet": "        /// Heapsort using BinaryHeapPQ\n        /// Claude Work: (n log n), Span: (n log n) - optimal complexity\n        fn heapsort_binary_heap<T: StT + Ord>(sequence: &[T])   -> Vec<T>;"
  },
  {
    "id": 2102,
    "function": "heapsort_leftist_heap",
    "file": "Chap45/HeapsortExample.rs",
    "lines": "115-117",
    "spec_strength": "",
    "snippet": "        /// Heapsort using LeftistHeapPQ\n        /// Claude Work: (n log n), Span: (n log n) - optimal complexity\n        fn heapsort_leftist_heap<T: StT + Ord>(sequence: &[T])  -> Vec<T>;"
  },
  {
    "id": 2103,
    "function": "compare_all_heapsorts",
    "file": "Chap45/HeapsortExample.rs",
    "lines": "119-121",
    "spec_strength": "",
    "snippet": "        /// Compare all heapsort implementations on the same input\n        /// Claude Work: (n), Span: (n) - dominated by worst implementation\n        fn compare_all_heapsorts<T: StT + Ord>(sequence: &[T])  -> HeapsortComparison<T>;"
  },
  {
    "id": 2104,
    "function": "textbook_example",
    "file": "Chap45/HeapsortExample.rs",
    "lines": "240-241",
    "spec_strength": "",
    "snippet": "        /// Example from textbook - demonstrate heapsort on a small dataset\n        fn textbook_example()         -> HeapsortComparison<i32>;"
  },
  {
    "id": 2105,
    "function": "reverse_sorted_example",
    "file": "Chap45/HeapsortExample.rs",
    "lines": "242-243",
    "spec_strength": "",
    "snippet": "        /// Demonstrate heapsort on reverse-sorted input (worst case for some algorithms)\n        fn reverse_sorted_example()   -> HeapsortComparison<i32>;"
  },
  {
    "id": 2106,
    "function": "already_sorted_example",
    "file": "Chap45/HeapsortExample.rs",
    "lines": "244-245",
    "spec_strength": "",
    "snippet": "        /// Demonstrate heapsort on already-sorted input\n        fn already_sorted_example()   -> HeapsortComparison<i32>;"
  },
  {
    "id": 2107,
    "function": "duplicates_example",
    "file": "Chap45/HeapsortExample.rs",
    "lines": "246-247",
    "spec_strength": "",
    "snippet": "        /// Demonstrate heapsort on input with duplicates\n        fn duplicates_example()       -> HeapsortComparison<i32>;"
  },
  {
    "id": 2108,
    "function": "single_element_example",
    "file": "Chap45/HeapsortExample.rs",
    "lines": "248-249",
    "spec_strength": "",
    "snippet": "        /// Demonstrate heapsort on single element\n        fn single_element_example()   -> HeapsortComparison<i32>;"
  },
  {
    "id": 2109,
    "function": "empty_example",
    "file": "Chap45/HeapsortExample.rs",
    "lines": "250-251",
    "spec_strength": "",
    "snippet": "        /// Demonstrate heapsort on empty input\n        fn empty_example()            -> HeapsortComparison<i32>;"
  },
  {
    "id": 2110,
    "function": "large_example",
    "file": "Chap45/HeapsortExample.rs",
    "lines": "252-253",
    "spec_strength": "",
    "snippet": "        /// Generate large example for performance testing\n        fn large_example(size: usize) -> Vec<i32>;"
  },
  {
    "id": 2111,
    "function": "efficiency_demonstration",
    "file": "Chap45/HeapsortExample.rs",
    "lines": "254-255",
    "spec_strength": "",
    "snippet": "        /// Demonstrate the efficiency difference between implementations\n        fn efficiency_demonstration() -> Vec<(String, Vec<i32>)>;"
  },
  {
    "id": 2112,
    "function": "all_results_match",
    "file": "Chap45/HeapsortExample.rs",
    "lines": "259-260",
    "spec_strength": "",
    "snippet": "        /// Verify that all implementations produce the same sorted result\n        fn all_results_match(&self)  -> bool;"
  },
  {
    "id": 2113,
    "function": "all_results_sorted",
    "file": "Chap45/HeapsortExample.rs",
    "lines": "261-262",
    "spec_strength": "",
    "snippet": "        /// Check if all results are properly sorted\n        fn all_results_sorted(&self) -> bool;"
  },
  {
    "id": 2114,
    "function": "complexity_analysis",
    "file": "Chap45/HeapsortExample.rs",
    "lines": "266-267",
    "spec_strength": "",
    "snippet": "        /// Analyze the theoretical complexity of each heapsort variant\n        fn complexity_analysis()      -> Vec<(String, String, String)>;"
  },
  {
    "id": 2115,
    "function": "correctness_verification",
    "file": "Chap45/HeapsortExample.rs",
    "lines": "268-269",
    "spec_strength": "",
    "snippet": "        /// Verify that all heapsort implementations produce correct results\n        fn correctness_verification() -> bool;"
  },
  {
    "id": 2116,
    "function": "vec_to_array_seq",
    "file": "Chap45/HeapsortExample.rs",
    "lines": "273-274",
    "spec_strength": "",
    "snippet": "        /// Convert Vec to ArraySeqStPerS for use with APAS sequence types\n        fn vec_to_array_seq<T: StT>(vec: &[T])  -> ArraySeqStPerS<T>;"
  },
  {
    "id": 2117,
    "function": "vec_to_avl_seq",
    "file": "Chap45/HeapsortExample.rs",
    "lines": "275-276",
    "spec_strength": "",
    "snippet": "        /// Convert Vec to AVLTreeSeqStPerS for use with balanced tree operations\n        fn vec_to_avl_seq<T: StT>(vec: &[T])    -> AVLTreeSeqStPerS<T>;"
  },
  {
    "id": 2118,
    "function": "is_sorted",
    "file": "Chap45/HeapsortExample.rs",
    "lines": "277-278",
    "spec_strength": "",
    "snippet": "        /// Check if a sequence is sorted\n        fn is_sorted<T: Ord>(vec: &[T])         -> bool;"
  },
  {
    "id": 2119,
    "function": "generate_test_sequences",
    "file": "Chap45/HeapsortExample.rs",
    "lines": "279-280",
    "spec_strength": "",
    "snippet": "        /// Generate test sequences of various patterns\n        fn generate_test_sequences(size: usize) -> Vec<(String, Vec<i32>)>;"
  },
  {
    "id": 2120,
    "function": "_leftist_heap_pq_verified",
    "file": "Chap45/LeftistHeapPQ.rs",
    "lines": "12",
    "spec_strength": "",
    "snippet": "        proof fn _leftist_heap_pq_verified() {}"
  },
  {
    "id": 2121,
    "function": "empty",
    "file": "Chap45/LeftistHeapPQ.rs",
    "lines": "35-36",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work (1), Span (1)\n        fn empty()                       -> Self;"
  },
  {
    "id": 2122,
    "function": "singleton",
    "file": "Chap45/LeftistHeapPQ.rs",
    "lines": "38-39",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work (1), Span (1)\n        fn singleton(element: T)         -> Self;"
  },
  {
    "id": 2123,
    "function": "find_min",
    "file": "Chap45/LeftistHeapPQ.rs",
    "lines": "41-43",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work (1), Span (1)\n        /// Returns the minimum element (root of heap), or None if empty\n        fn find_min(&self)               -> Option<&T>;"
  },
  {
    "id": 2124,
    "function": "insert",
    "file": "Chap45/LeftistHeapPQ.rs",
    "lines": "45-47",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)\n        /// Inserts element by creating singleton and melding\n        fn insert(&self, element: T)     -> Self;"
  },
  {
    "id": 2125,
    "function": "delete_min",
    "file": "Chap45/LeftistHeapPQ.rs",
    "lines": "49-53",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work (log n), Span (log n), Parallelism (1)\n        /// Removes root and melds left and right subtrees\n        fn delete_min(&self)             -> (Self, Option<T>)\n        where\n            Self: Sized;"
  },
  {
    "id": 2126,
    "function": "meld",
    "file": "Chap45/LeftistHeapPQ.rs",
    "lines": "55-57",
    "spec_strength": "",
    "snippet": "        /// Claude Work: (log m + log n), Span: (log m + log n)\n        /// KEY ADVANTAGE: Efficient meld following right spines\n        fn meld(&self, other: &Self)     -> Self;"
  },
  {
    "id": 2127,
    "function": "from_seq",
    "file": "Chap45/LeftistHeapPQ.rs",
    "lines": "59-61",
    "spec_strength": "",
    "snippet": "        /// Claude Work: (n), Span: (n)\n        /// Creates heap from sequence using reduce with meld\n        fn from_seq(seq: &[T])           -> Self;"
  },
  {
    "id": 2128,
    "function": "size`",
    "file": "Chap45/LeftistHeapPQ.rs",
    "lines": "93",
    "spec_strength": "",
    "snippet": "        fn size(&self) -> usize;"
  },
  {
    "id": 2129,
    "function": "is_empty",
    "file": "Chap45/LeftistHeapPQ.rs",
    "lines": "64",
    "spec_strength": "",
    "snippet": "        fn is_empty(&self)               -> bool;"
  },
  {
    "id": 2130,
    "function": "extract_all_sorted",
    "file": "Chap45/LeftistHeapPQ.rs",
    "lines": "65",
    "spec_strength": "",
    "snippet": "        fn extract_all_sorted(&self)     -> Vec<T>;"
  },
  {
    "id": 2131,
    "function": "height`",
    "file": "Chap45/LeftistHeapPQ.rs",
    "lines": "94",
    "spec_strength": "",
    "snippet": "        fn height(&self) -> usize;"
  },
  {
    "id": 2132,
    "function": "root_rank",
    "file": "Chap45/LeftistHeapPQ.rs",
    "lines": "67",
    "spec_strength": "",
    "snippet": "        fn root_rank(&self)              -> usize;"
  },
  {
    "id": 2133,
    "function": "is_valid_leftist_heap",
    "file": "Chap45/LeftistHeapPQ.rs",
    "lines": "68",
    "spec_strength": "",
    "snippet": "        fn is_valid_leftist_heap(&self)  -> bool;"
  },
  {
    "id": 2134,
    "function": "from_vec",
    "file": "Chap45/LeftistHeapPQ.rs",
    "lines": "69",
    "spec_strength": "",
    "snippet": "        fn from_vec(vec: Vec<T>)         -> Self;"
  },
  {
    "id": 2135,
    "function": "to_vec`",
    "file": "Chap45/LeftistHeapPQ.rs",
    "lines": "97",
    "spec_strength": "",
    "snippet": "        fn to_vec(&self) -> Vec<T>;"
  },
  {
    "id": 2136,
    "function": "to_sorted_vec",
    "file": "Chap45/LeftistHeapPQ.rs",
    "lines": "71",
    "spec_strength": "",
    "snippet": "        fn to_sorted_vec(&self)          -> Vec<T>;"
  },
  {
    "id": 2137,
    "function": "meld_multiple",
    "file": "Chap45/LeftistHeapPQ.rs",
    "lines": "72-74",
    "spec_strength": "",
    "snippet": "        fn meld_multiple(heaps: &[Self]) -> Self\n        where\n            Self: Sized;"
  },
  {
    "id": 2138,
    "function": "split",
    "file": "Chap45/LeftistHeapPQ.rs",
    "lines": "75-77",
    "spec_strength": "",
    "snippet": "        fn split(&self, key: &T)         -> (Self, Self)\n        where\n            Self: Sized;"
  },
  {
    "id": 2139,
    "function": "efficient_multi_way_merge",
    "file": "Chap45/LeftistHeapPQ.rs",
    "lines": "81-83",
    "spec_strength": "",
    "snippet": "        /// Demonstrate the power of O(log n) meld operations\n        /// This would be much slower with other priority queue implementations!\n        fn efficient_multi_way_merge<T: StT + Ord>(sequences: Vec<Vec<T>>) -> Vec<T>;"
  },
  {
    "id": 2140,
    "function": "parallel_heap_construction",
    "file": "Chap45/LeftistHeapPQ.rs",
    "lines": "84-85",
    "spec_strength": "",
    "snippet": "        /// Demonstrate parallel heap construction\n        fn parallel_heap_construction<T: StT + Ord>(elements: Vec<T>)      -> LeftistHeapPQ<T>;"
  },
  {
    "id": 2141,
    "function": "rank",
    "file": "Chap45/LeftistHeapPQ.rs",
    "lines": "89",
    "spec_strength": "",
    "snippet": "        fn rank(&self) -> usize;"
  },
  {
    "id": 2142,
    "function": "make_node",
    "file": "Chap45/LeftistHeapPQ.rs",
    "lines": "90",
    "spec_strength": "",
    "snippet": "        fn make_node(key: T, left: LeftistHeapNode<T>, right: LeftistHeapNode<T>) -> Self;"
  },
  {
    "id": 2143,
    "function": "meld_nodes",
    "file": "Chap45/LeftistHeapPQ.rs",
    "lines": "91-92",
    "spec_strength": "",
    "snippet": "        /// Core meld operation following right spines (Data Structure 45.3).\n        fn meld_nodes(a: LeftistHeapNode<T>, b: LeftistHeapNode<T>) -> LeftistHeapNode<T>;"
  },
  {
    "id": 2144,
    "function": "is_leftist",
    "file": "Chap45/LeftistHeapPQ.rs",
    "lines": "95",
    "spec_strength": "",
    "snippet": "        fn is_leftist(&self) -> bool;"
  },
  {
    "id": 2145,
    "function": "is_heap",
    "file": "Chap45/LeftistHeapPQ.rs",
    "lines": "96",
    "spec_strength": "",
    "snippet": "        fn is_heap(&self) -> bool;"
  },
  {
    "id": 2146,
    "function": "default",
    "file": "Chap45/LeftistHeapPQ.rs",
    "lines": "380",
    "spec_strength": "",
    "snippet": "        fn default() -> Self { Self::empty() }"
  },
  {
    "id": 2147,
    "function": "format_node",
    "file": "Chap45/LeftistHeapPQ.rs",
    "lines": "385-396",
    "spec_strength": "",
    "snippet": "            fn format_node<T: StT + Ord>(node: &LeftistHeapNode<T>, f: &mut Formatter<'_>, depth: usize) -> Result {\n                match node {\n                    | LeftistHeapNode::Leaf => Ok(()),\n                    | LeftistHeapNode::Node { key, left, right, rank } => {\n                        let indent = \"  \".repeat(depth);\n                        writeln!(f, \"{indent}{key}(rank:{rank})\")?;\n                        format_node(left, f, depth + 1)?;\n                        format_node(right, f, depth + 1)?;\n                        Ok(())\n                    }\n                }\n            }"
  },
  {
    "id": 2148,
    "function": "_sorted_list_pq_verified",
    "file": "Chap45/SortedListPQ.rs",
    "lines": "15",
    "spec_strength": "",
    "snippet": "        proof fn _sorted_list_pq_verified() {}"
  },
  {
    "id": 2149,
    "function": "eq",
    "file": "Chap45/SortedListPQ.rs",
    "lines": "43-44",
    "spec_strength": "hole",
    "snippet": "            fn eq(&self, other: &Self) -> (r: bool)\n                ensures r == (self@ == other@)"
  },
  {
    "id": 2150,
    "function": "empty",
    "file": "Chap45/SortedListPQ.rs",
    "lines": "63-64",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work (1), Span (1)\n        fn empty()                                         -> Self;"
  },
  {
    "id": 2151,
    "function": "singleton",
    "file": "Chap45/SortedListPQ.rs",
    "lines": "66-67",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work (1), Span (1)\n        fn singleton(element: T)                           -> Self;"
  },
  {
    "id": 2152,
    "function": "find_min",
    "file": "Chap45/SortedListPQ.rs",
    "lines": "69-71",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work (1), Span (1)\n        /// Returns the minimum element (first in sorted list), or None if empty\n        fn find_min(&self)                                 -> Option<&T>;"
  },
  {
    "id": 2153,
    "function": "insert",
    "file": "Chap45/SortedListPQ.rs",
    "lines": "73-75",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)\n        /// Inserts element in correct sorted position\n        fn insert(&self, element: T)                       -> Self;"
  },
  {
    "id": 2154,
    "function": "delete_min",
    "file": "Chap45/SortedListPQ.rs",
    "lines": "77-81",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work (1), Span (1)\n        /// Removes first element (minimum) from sorted list\n        fn delete_min(&self)                               -> (Self, Option<T>)\n        where\n            Self: Sized;"
  },
  {
    "id": 2155,
    "function": "meld",
    "file": "Chap45/SortedListPQ.rs",
    "lines": "83-85",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work (m + n), Span (m + n), Parallelism (1)\n        /// Melds two sorted priority queues by merging sorted lists\n        fn meld(&self, other: &Self)                       -> Self;"
  },
  {
    "id": 2156,
    "function": "from_seq",
    "file": "Chap45/SortedListPQ.rs",
    "lines": "87-89",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work (n log n), Span (n log n), Parallelism (1)\n        /// Creates priority queue from sequence by sorting\n        fn from_seq(seq: &ArraySeqStPerS<T>)               -> Self;"
  },
  {
    "id": 2157,
    "function": "size",
    "file": "Chap45/SortedListPQ.rs",
    "lines": "91",
    "spec_strength": "",
    "snippet": "        fn size(&self)                                     -> usize;"
  },
  {
    "id": 2158,
    "function": "is_empty",
    "file": "Chap45/SortedListPQ.rs",
    "lines": "92",
    "spec_strength": "",
    "snippet": "        fn is_empty(&self)                                 -> bool;"
  },
  {
    "id": 2159,
    "function": "to_seq",
    "file": "Chap45/SortedListPQ.rs",
    "lines": "93",
    "spec_strength": "",
    "snippet": "        fn to_seq(&self)                                   -> ArraySeqStPerS<T>;"
  },
  {
    "id": 2160,
    "function": "insert_all",
    "file": "Chap45/SortedListPQ.rs",
    "lines": "94",
    "spec_strength": "",
    "snippet": "        fn insert_all(&self, elements: &ArraySeqStPerS<T>) -> Self;"
  },
  {
    "id": 2161,
    "function": "extract_all_sorted",
    "file": "Chap45/SortedListPQ.rs",
    "lines": "95",
    "spec_strength": "",
    "snippet": "        fn extract_all_sorted(&self)                       -> ArraySeqStPerS<T>;"
  },
  {
    "id": 2162,
    "function": "find_max",
    "file": "Chap45/SortedListPQ.rs",
    "lines": "96",
    "spec_strength": "",
    "snippet": "        fn find_max(&self)                                 -> Option<&T>;"
  },
  {
    "id": 2163,
    "function": "delete_max",
    "file": "Chap45/SortedListPQ.rs",
    "lines": "97-99",
    "spec_strength": "",
    "snippet": "        fn delete_max(&self)                               -> (Self, Option<T>)\n        where\n            Self: Sized;"
  },
  {
    "id": 2164,
    "function": "from_vec",
    "file": "Chap45/SortedListPQ.rs",
    "lines": "100",
    "spec_strength": "",
    "snippet": "        fn from_vec(vec: Vec<T>)                           -> Self;"
  },
  {
    "id": 2165,
    "function": "to_vec",
    "file": "Chap45/SortedListPQ.rs",
    "lines": "101",
    "spec_strength": "",
    "snippet": "        fn to_vec(&self)                                   -> Vec<T>;"
  },
  {
    "id": 2166,
    "function": "to_sorted_vec",
    "file": "Chap45/SortedListPQ.rs",
    "lines": "102",
    "spec_strength": "",
    "snippet": "        fn to_sorted_vec(&self)                            -> Vec<T>;"
  },
  {
    "id": 2167,
    "function": "is_sorted",
    "file": "Chap45/SortedListPQ.rs",
    "lines": "103",
    "spec_strength": "",
    "snippet": "        fn is_sorted(&self)                                -> bool;"
  },
  {
    "id": 2168,
    "function": "default",
    "file": "Chap45/SortedListPQ.rs",
    "lines": "322",
    "spec_strength": "",
    "snippet": "        fn default() -> Self { Self::empty() }"
  },
  {
    "id": 2169,
    "function": "_unsorted_list_pq_verified",
    "file": "Chap45/UnsortedListPQ.rs",
    "lines": "15",
    "spec_strength": "",
    "snippet": "        proof fn _unsorted_list_pq_verified() {}"
  },
  {
    "id": 2170,
    "function": "eq",
    "file": "Chap45/UnsortedListPQ.rs",
    "lines": "43-44",
    "spec_strength": "hole",
    "snippet": "            fn eq(&self, other: &Self) -> (r: bool)\n                ensures r == (self@ == other@)"
  },
  {
    "id": 2171,
    "function": "empty",
    "file": "Chap45/UnsortedListPQ.rs",
    "lines": "63-64",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work (1), Span (1)\n        fn empty()                                         -> Self;"
  },
  {
    "id": 2172,
    "function": "singleton",
    "file": "Chap45/UnsortedListPQ.rs",
    "lines": "66-67",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work (1), Span (1)\n        fn singleton(element: T)                           -> Self;"
  },
  {
    "id": 2173,
    "function": "find_min",
    "file": "Chap45/UnsortedListPQ.rs",
    "lines": "69-71",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)\n        /// Returns the minimum element, or None if empty\n        fn find_min(&self)                                 -> Option<&T>;"
  },
  {
    "id": 2174,
    "function": "insert",
    "file": "Chap45/UnsortedListPQ.rs",
    "lines": "73-75",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work (1), Span (1)\n        /// Inserts element into unsorted list\n        fn insert(&self, element: T)                       -> Self;"
  },
  {
    "id": 2175,
    "function": "delete_min",
    "file": "Chap45/UnsortedListPQ.rs",
    "lines": "77-81",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)\n        /// Removes and returns minimum element with new queue\n        fn delete_min(&self)                               -> (Self, Option<T>)\n        where\n            Self: Sized;"
  },
  {
    "id": 2176,
    "function": "meld",
    "file": "Chap45/UnsortedListPQ.rs",
    "lines": "83-85",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work (m + n), Span (m + n), Parallelism (1)\n        /// Melds two priority queues by concatenating lists\n        fn meld(&self, other: &Self)                       -> Self;"
  },
  {
    "id": 2177,
    "function": "from_seq",
    "file": "Chap45/UnsortedListPQ.rs",
    "lines": "87-89",
    "spec_strength": "",
    "snippet": "        /// claude-4-sonet: Work (n), Span (n), Parallelism (1)\n        /// Creates priority queue from sequence\n        fn from_seq(seq: &ArraySeqStPerS<T>)               -> Self;"
  },
  {
    "id": 2178,
    "function": "size",
    "file": "Chap45/UnsortedListPQ.rs",
    "lines": "91",
    "spec_strength": "",
    "snippet": "        fn size(&self)                                     -> usize;"
  },
  {
    "id": 2179,
    "function": "is_empty",
    "file": "Chap45/UnsortedListPQ.rs",
    "lines": "92",
    "spec_strength": "",
    "snippet": "        fn is_empty(&self)                                 -> bool;"
  },
  {
    "id": 2180,
    "function": "to_seq",
    "file": "Chap45/UnsortedListPQ.rs",
    "lines": "93",
    "spec_strength": "",
    "snippet": "        fn to_seq(&self)                                   -> ArraySeqStPerS<T>;"
  },
  {
    "id": 2181,
    "function": "insert_all",
    "file": "Chap45/UnsortedListPQ.rs",
    "lines": "94",
    "spec_strength": "",
    "snippet": "        fn insert_all(&self, elements: &ArraySeqStPerS<T>) -> Self;"
  },
  {
    "id": 2182,
    "function": "extract_all_sorted",
    "file": "Chap45/UnsortedListPQ.rs",
    "lines": "95",
    "spec_strength": "",
    "snippet": "        fn extract_all_sorted(&self)                       -> ArraySeqStPerS<T>;"
  },
  {
    "id": 2183,
    "function": "from_vec",
    "file": "Chap45/UnsortedListPQ.rs",
    "lines": "96",
    "spec_strength": "",
    "snippet": "        fn from_vec(vec: Vec<T>)                           -> Self;"
  },
  {
    "id": 2184,
    "function": "to_vec",
    "file": "Chap45/UnsortedListPQ.rs",
    "lines": "97",
    "spec_strength": "",
    "snippet": "        fn to_vec(&self)                                   -> Vec<T>;"
  },
  {
    "id": 2185,
    "function": "to_sorted_vec",
    "file": "Chap45/UnsortedListPQ.rs",
    "lines": "98",
    "spec_strength": "",
    "snippet": "        fn to_sorted_vec(&self)                            -> Vec<T>;"
  },
  {
    "id": 2186,
    "function": "default",
    "file": "Chap45/UnsortedListPQ.rs",
    "lines": "246",
    "spec_strength": "",
    "snippet": "        fn default() -> Self { Self::empty() }"
  },
  {
    "id": 2187,
    "function": "_chained_hash_table_verified",
    "file": "Chap47/ChainedHashTable.rs",
    "lines": "24",
    "spec_strength": "",
    "snippet": "        proof fn _chained_hash_table_verified() {}"
  },
  {
    "id": 2188,
    "function": "eq",
    "file": "Chap47/ChainedHashTable.rs",
    "lines": "52-53",
    "spec_strength": "hole",
    "snippet": "            fn eq(&self, other: &Self) -> (r: bool)\n                ensures r == (self.chain == other.chain)"
  },
  {
    "id": 2189,
    "function": "hash_index",
    "file": "Chap47/ChainedHashTable.rs",
    "lines": "72-75",
    "spec_strength": "",
    "snippet": "        /// Computes the hash index for a key.\n        /// - APAS: Work O(1), Span O(1).\n        /// - Claude-Opus-4.6: N/A  abstract trait method; cost depends on hash function.\n        fn hash_index(table: &HashTable<Key, Value, Entry, Metrics>, key: &Key) -> usize;"
  },
  {
    "id": 2190,
    "function": "insert_chained",
    "file": "Chap47/ChainedHashTable.rs",
    "lines": "77-89",
    "spec_strength": "",
    "snippet": "        /// Inserts into the chain at the hashed bucket, updating num_elements on new keys.\n        /// - APAS: Work O(1) expected, Span O(1).\n        /// - Claude-Opus-4.6: Work O(1+) expected, Span O(1+)  lookup to check existence, then chain insert.\n        fn insert_chained(table: &mut HashTable<Key, Value, Entry, Metrics>, key: Key, value: Value) {\n            let index = Self::hash_index(table, &key);\n            if index < table.table.len() {\n                let existed = table.table[index].lookup(&key).is_some();\n                table.table[index].insert(key, value);\n                if !existed {\n                    table.num_elements += 1;\n                }\n            }\n        }"
  },
  {
    "id": 2191,
    "function": "lookup_chained",
    "file": "Chap47/ChainedHashTable.rs",
    "lines": "91-101",
    "spec_strength": "",
    "snippet": "        /// Looks up in the chain at the hashed bucket.\n        /// - APAS: Work O(1+) expected, Span O(1+).\n        /// - Claude-Opus-4.6: Work O(1+) expected, Span O(1+)  agrees with APAS; hashes then linear scan of chain.\n        fn lookup_chained(table: &HashTable<Key, Value, Entry, Metrics>, key: &Key) -> Option<Value> {\n            let index = Self::hash_index(table, key);\n            if index < table.table.len() {\n                table.table[index].lookup(key)\n            } else {\n                None\n            }\n        }"
  },
  {
    "id": 2192,
    "function": "delete_chained",
    "file": "Chap47/ChainedHashTable.rs",
    "lines": "103-117",
    "spec_strength": "",
    "snippet": "        /// Deletes from the chain at the hashed bucket, updating num_elements on removal.\n        /// - APAS: Work O(1+) expected, Span O(1+).\n        /// - Claude-Opus-4.6: Work O(1+) expected, Span O(1+)  agrees with APAS; hashes then linear scan of chain.\n        fn delete_chained(table: &mut HashTable<Key, Value, Entry, Metrics>, key: &Key) -> B {\n            let index = Self::hash_index(table, key);\n            if index < table.table.len() {\n                let deleted = table.table[index].delete(key);\n                if deleted {\n                    table.num_elements -= 1;\n                }\n                deleted\n            } else {\n                false\n            }\n        }"
  },
  {
    "id": 2193,
    "function": "second_hash",
    "file": "Chap47/DoubleHashFlatHashTableStEph.rs",
    "lines": "36-62",
    "spec_strength": "",
    "snippet": "        /// Compute second hash value for double hashing.\n        /// APAS: hh(k) must be relatively prime to m.\n        /// - APAS: Work O(1), Span O(1).\n        /// - Claude-Opus-4.6: Work O(sizeof(Key)), Span O(sizeof(Key))  hashes key with SipHash.\n        /// Strategy: Always return an odd number (works for power-of-2 sizes),\n        /// and for prime sizes, ensure < m and non-zero.\n        pub fn second_hash<Key: StT + Hash>(key: &Key, table_size: usize) -> usize {\n            use std::collections::hash_map::DefaultHasher;\n            use std::hash::Hasher;\n\n            if table_size <= 2 {\n                return 1;\n            }\n\n            let mut hasher = DefaultHasher::new();\n            key.hash(&mut hasher);\n            let hash = hasher.finish();\n\n            let base = (table_size - 1) as u64;\n            let mut step = ((hash % base) + 1) as usize;\n\n            if step % 2 == 0 && step < table_size - 1 {\n                step += 1;\n            }\n\n            step\n        }"
  },
  {
    "id": 2194,
    "function": "insert",
    "file": "Chap47/DoubleHashFlatHashTableStEph.rs",
    "lines": "68-85",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1/(1)) expected, Span O(1/(1)).\n        /// - Claude-Opus-4.6: Work O(1/(1)) expected, Span O(1/(1))  double hash find_slot then O(1) write.\n        fn insert(table: &mut HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: Key, value: Value) {\n            let slot = Self::find_slot(table, &key);\n            match &table.table[slot] {\n                | FlatEntry::Occupied(k, _) if k == &key => {\n                    table.table[slot] = FlatEntry::Occupied(key, value);\n                }\n                | FlatEntry::Empty | FlatEntry::Deleted => {\n                    table.table[slot] = FlatEntry::Occupied(key, value);\n                    table.num_elements += 1;\n                }\n                | _ => {\n                    table.table[slot] = FlatEntry::Occupied(key, value);\n                    table.num_elements += 1;\n                }\n            }\n        }"
  },
  {
    "id": 2195,
    "function": "lookup",
    "file": "Chap47/DoubleHashFlatHashTableStEph.rs",
    "lines": "87-102",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1/(1)) expected, Span O(1/(1)).\n        /// - Claude-Opus-4.6: Work O(1/(1)) expected, Span O(1/(1))  double hash probe until found or empty.\n        fn lookup(table: &HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: &Key) -> Option<Value> {\n            let mut attempt = 0;\n            while attempt < table.current_size {\n                let slot = Self::probe(table, key, attempt);\n                match &table.table[slot] {\n                    | FlatEntry::Occupied(k, v) if k == key => return Some(v.clone()),\n                    | FlatEntry::Empty => return None,\n                    | FlatEntry::Deleted | FlatEntry::Occupied(_, _) => {\n                        attempt += 1;\n                    }\n                }\n            }\n            None\n        }"
  },
  {
    "id": 2196,
    "function": "delete",
    "file": "Chap47/DoubleHashFlatHashTableStEph.rs",
    "lines": "104-123",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1/(1)) expected, Span O(1/(1)).\n        /// - Claude-Opus-4.6: Work O(1/(1)) expected, Span O(1/(1))  double hash probe until found or empty, then tombstone.\n        fn delete(table: &mut HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: &Key) -> B {\n            let mut attempt = 0;\n            while attempt < table.current_size {\n                let slot = Self::probe(table, key, attempt);\n                match &table.table[slot] {\n                    | FlatEntry::Occupied(k, _) if k == key => {\n                        table.table[slot] = FlatEntry::Deleted;\n                        table.num_elements -= 1;\n                        return true;\n                    }\n                    | FlatEntry::Empty => return false,\n                    | FlatEntry::Deleted | FlatEntry::Occupied(_, _) => {\n                        attempt += 1;\n                    }\n                }\n            }\n            false\n        }"
  },
  {
    "id": 2197,
    "function": "resize",
    "file": "Chap47/DoubleHashFlatHashTableStEph.rs",
    "lines": "125-156",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(n + m + m'), Span O(n + m + m').\n        /// - Claude-Opus-4.6: Work O(n + m + m'), Span O(n + m + m')  collects n pairs, creates m' slots, reinserts.\n        fn resize(\n            table: &HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>,\n            new_size: usize,\n        ) -> HashTable<Key, Value, FlatEntry<Key, Value>, Metrics> {\n            let mut pairs = Vec::new();\n            for entry in &table.table {\n                if let FlatEntry::Occupied(k, v) = entry {\n                    pairs.push((k.clone(), v.clone()));\n                }\n            }\n\n            let new_table_vec = (0..new_size).map(|_| FlatEntry::new()).collect();\n            let new_hash_fn = (table.hash_fn_gen)(new_size);\n            let mut new_table = HashTable {\n                table: new_table_vec,\n                hash_fn_gen: table.hash_fn_gen.clone(),\n                hash_fn: new_hash_fn,\n                initial_size: table.initial_size,\n                current_size: new_size,\n                num_elements: 0,\n                metrics: Metrics::default(),\n                _phantom: PhantomData,\n            };\n\n            for (key, value) in pairs {\n                Self::insert(&mut new_table, key, value);\n            }\n\n            new_table\n        }"
  },
  {
    "id": 2198,
    "function": "probe",
    "file": "Chap47/DoubleHashFlatHashTableStEph.rs",
    "lines": "162-168",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1), Span O(1).\n        /// - Claude-Opus-4.6: Work O(1), Span O(1)  two hash values + arithmetic + modulo.\n        fn probe(table: &HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: &Key, attempt: usize) -> usize {\n            let hash1 = (table.hash_fn)(key);\n            let step = Self::second_hash(key, table.current_size);\n            (hash1 + (attempt * step)) % table.current_size\n        }"
  },
  {
    "id": 2199,
    "function": "find_slot",
    "file": "Chap47/DoubleHashFlatHashTableStEph.rs",
    "lines": "170-183",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1/(1)) expected, Span O(1/(1)).\n        /// - Claude-Opus-4.6: Work O(1/(1)) expected, Span O(1/(1))  double hash probe until empty/deleted/matching.\n        fn find_slot(table: &HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: &Key) -> usize {\n            let mut attempt = 0;\n            while attempt < table.current_size {\n                let slot = Self::probe(table, key, attempt);\n                match &table.table[slot] {\n                    | FlatEntry::Empty | FlatEntry::Deleted => return slot,\n                    | FlatEntry::Occupied(k, _) if k == key => return slot,\n                    | _ => attempt += 1,\n                }\n            }\n            Self::probe(table, key, 0)\n        }"
  },
  {
    "id": 2200,
    "function": "new",
    "file": "Chap47/FlatHashTable.rs",
    "lines": "53",
    "spec_strength": "",
    "snippet": "        fn new() -> Self { FlatEntry::Empty }"
  },
  {
    "id": 2201,
    "function": "insert",
    "file": "Chap47/FlatHashTable.rs",
    "lines": "57",
    "spec_strength": "",
    "snippet": "        fn insert(&mut self, key: Key, value: Value) { *self = FlatEntry::Occupied(key, value); }"
  },
  {
    "id": 2202,
    "function": "lookup",
    "file": "Chap47/FlatHashTable.rs",
    "lines": "61",
    "spec_strength": "",
    "snippet": "        fn lookup(&self, key: &Key) -> Option<Value> {"
  },
  {
    "id": 2203,
    "function": "delete",
    "file": "Chap47/FlatHashTable.rs",
    "lines": "72",
    "spec_strength": "",
    "snippet": "        fn delete(&mut self, key: &Key) -> B {"
  },
  {
    "id": 2204,
    "function": "probe",
    "file": "Chap47/FlatHashTable.rs",
    "lines": "97-100",
    "spec_strength": "",
    "snippet": "        /// Probes for the next slot in the sequence.\n        /// - APAS: Work O(1), Span O(1).\n        /// - Claude-Opus-4.6: N/A  abstract trait method; cost depends on probing strategy.\n        fn probe(table: &HashTable<Key, Value, Entry, Metrics>, key: &Key, attempt: usize) -> usize;"
  },
  {
    "id": 2205,
    "function": "find_slot",
    "file": "Chap47/FlatHashTable.rs",
    "lines": "102-105",
    "spec_strength": "",
    "snippet": "        /// Finds the first available slot (Empty or Deleted) for insertion.\n        /// - APAS: Work O(1/(1)) expected, Span O(1/(1)).\n        /// - Claude-Opus-4.6: N/A  abstract trait method; cost depends on probing strategy.\n        fn find_slot(table: &HashTable<Key, Value, Entry, Metrics>, key: &Key) -> usize;"
  },
  {
    "id": 2206,
    "function": "insert_with_probe",
    "file": "Chap47/FlatHashTable.rs",
    "lines": "107-115",
    "spec_strength": "",
    "snippet": "        /// Inserts using linear probing as default.\n        /// - APAS: Work O(1/(1)) expected, Span O(1/(1)).\n        /// - Claude-Opus-4.6: Work O(1/(1)) expected, Span O(1/(1))  delegates to find_slot then O(1) write.\n        fn insert_with_probe(table: &mut HashTable<Key, Value, Entry, Metrics>, key: Key, value: Value) {\n            let slot = Self::find_slot(table, &key);\n            if slot < table.table.len() {\n                table.table[slot].insert(key, value);\n            }\n        }"
  },
  {
    "id": 2207,
    "function": "lookup_with_probe",
    "file": "Chap47/FlatHashTable.rs",
    "lines": "117-130",
    "spec_strength": "",
    "snippet": "        /// Looks up using probe sequence.\n        /// - APAS: Work O(1/(1)) expected, Span O(1/(1)).\n        /// - Claude-Opus-4.6: Work O(1/(1)) expected, Span O(1/(1))  iterates probe sequence until found or empty.\n        fn lookup_with_probe(table: &HashTable<Key, Value, Entry, Metrics>, key: &Key) -> Option<Value> {\n            for attempt in 0..table.current_size {\n                let slot = Self::probe(table, key, attempt);\n                if slot < table.table.len() {\n                    if let Some(val) = table.table[slot].lookup(key) {\n                        return Some(val);\n                    }\n                }\n            }\n            None\n        }"
  },
  {
    "id": 2208,
    "function": "insert",
    "file": "Chap47/LinProbFlatHashTableStEph.rs",
    "lines": "35-52",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1/(1)) expected, Span O(1/(1)).\n        /// - Claude-Opus-4.6: Work O(1/(1)) expected, Span O(1/(1))  linear probe find_slot then O(1) write.\n        fn insert(table: &mut HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: Key, value: Value) {\n            let slot = Self::find_slot(table, &key);\n            match &table.table[slot] {\n                | FlatEntry::Occupied(k, _) if k == &key => {\n                    table.table[slot] = FlatEntry::Occupied(key, value);\n                }\n                | FlatEntry::Empty | FlatEntry::Deleted => {\n                    table.table[slot] = FlatEntry::Occupied(key, value);\n                    table.num_elements += 1;\n                }\n                | _ => {\n                    table.table[slot] = FlatEntry::Occupied(key, value);\n                    table.num_elements += 1;\n                }\n            }\n        }"
  },
  {
    "id": 2209,
    "function": "lookup",
    "file": "Chap47/LinProbFlatHashTableStEph.rs",
    "lines": "54-69",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1/(1)) expected, Span O(1/(1)).\n        /// - Claude-Opus-4.6: Work O(1/(1)) expected, Span O(1/(1))  linear probe sequence until found or empty.\n        fn lookup(table: &HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: &Key) -> Option<Value> {\n            let mut attempt = 0;\n            while attempt < table.current_size {\n                let slot = Self::probe(table, key, attempt);\n                match &table.table[slot] {\n                    | FlatEntry::Occupied(k, v) if k == key => return Some(v.clone()),\n                    | FlatEntry::Empty => return None,\n                    | FlatEntry::Deleted | FlatEntry::Occupied(_, _) => {\n                        attempt += 1;\n                    }\n                }\n            }\n            None\n        }"
  },
  {
    "id": 2210,
    "function": "delete",
    "file": "Chap47/LinProbFlatHashTableStEph.rs",
    "lines": "71-90",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1/(1)) expected, Span O(1/(1)).\n        /// - Claude-Opus-4.6: Work O(1/(1)) expected, Span O(1/(1))  linear probe until found or empty, then tombstone.\n        fn delete(table: &mut HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: &Key) -> B {\n            let mut attempt = 0;\n            while attempt < table.current_size {\n                let slot = Self::probe(table, key, attempt);\n                match &table.table[slot] {\n                    | FlatEntry::Occupied(k, _) if k == key => {\n                        table.table[slot] = FlatEntry::Deleted;\n                        table.num_elements -= 1;\n                        return true;\n                    }\n                    | FlatEntry::Empty => return false,\n                    | FlatEntry::Deleted | FlatEntry::Occupied(_, _) => {\n                        attempt += 1;\n                    }\n                }\n            }\n            false\n        }"
  },
  {
    "id": 2211,
    "function": "resize",
    "file": "Chap47/LinProbFlatHashTableStEph.rs",
    "lines": "92-123",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(n + m + m'), Span O(n + m + m').\n        /// - Claude-Opus-4.6: Work O(n + m + m'), Span O(n + m + m')  collects n pairs from m slots, creates m' new slots, reinserts n pairs.\n        fn resize(\n            table: &HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>,\n            new_size: usize,\n        ) -> HashTable<Key, Value, FlatEntry<Key, Value>, Metrics> {\n            let mut pairs = Vec::new();\n            for entry in &table.table {\n                if let FlatEntry::Occupied(k, v) = entry {\n                    pairs.push((k.clone(), v.clone()));\n                }\n            }\n\n            let new_table_vec = (0..new_size).map(|_| FlatEntry::new()).collect();\n            let new_hash_fn = (table.hash_fn_gen)(new_size);\n            let mut new_table = HashTable {\n                table: new_table_vec,\n                hash_fn_gen: table.hash_fn_gen.clone(),\n                hash_fn: new_hash_fn,\n                initial_size: table.initial_size,\n                current_size: new_size,\n                num_elements: 0,\n                metrics: Metrics::default(),\n                _phantom: PhantomData,\n            };\n\n            for (key, value) in pairs {\n                Self::insert(&mut new_table, key, value);\n            }\n\n            new_table\n        }"
  },
  {
    "id": 2212,
    "function": "probe",
    "file": "Chap47/LinProbFlatHashTableStEph.rs",
    "lines": "129-134",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1), Span O(1).\n        /// - Claude-Opus-4.6: Work O(1), Span O(1)  hash + addition + modulo.\n        fn probe(table: &HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: &Key, attempt: usize) -> usize {\n            let hash_val = (table.hash_fn)(key);\n            (hash_val + attempt) % table.current_size\n        }"
  },
  {
    "id": 2213,
    "function": "find_slot",
    "file": "Chap47/LinProbFlatHashTableStEph.rs",
    "lines": "136-149",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1/(1)) expected, Span O(1/(1)).\n        /// - Claude-Opus-4.6: Work O(1/(1)) expected, Span O(1/(1))  linear probe until empty/deleted/matching slot.\n        fn find_slot(table: &HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: &Key) -> usize {\n            let mut attempt = 0;\n            while attempt < table.current_size {\n                let slot = Self::probe(table, key, attempt);\n                match &table.table[slot] {\n                    | FlatEntry::Empty | FlatEntry::Deleted => return slot,\n                    | FlatEntry::Occupied(k, _) if k == key => return slot,\n                    | _ => attempt += 1,\n                }\n            }\n            Self::probe(table, key, 0)\n        }"
  },
  {
    "id": 2214,
    "function": "_linked_list_chained_hash_table_verified",
    "file": "Chap47/LinkedListChainedHashTableStEph.rs",
    "lines": "23",
    "spec_strength": "",
    "snippet": "        proof fn _linked_list_chained_hash_table_verified() {}"
  },
  {
    "id": 2215,
    "function": "new",
    "file": "Chap47/LinkedListChainedHashTableStEph.rs",
    "lines": "27-29",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1), Span O(1).\n        /// - Claude-Opus-4.6: Work O(1), Span O(1)  empty LinkedList construction.\n        fn new() -> Self { LinkedList::new() }"
  },
  {
    "id": 2216,
    "function": "insert`",
    "file": "Chap47/LinkedListChainedHashTableStEph.rs",
    "lines": "31-41",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1+) expected, Span O(1+).\n        /// - Claude-Opus-4.6: Work O(n), Span O(n)  linear scan for duplicate key, n = chain length.\n        fn insert(&mut self, key: Key, value: Value) {\n            for (k, v) in self.iter_mut() {\n                if k == &key {\n                    *v = value;\n                    return;\n                }\n            }\n            self.push_back((key, value));\n        }"
  },
  {
    "id": 2217,
    "function": "lookup`",
    "file": "Chap47/LinkedListChainedHashTableStEph.rs",
    "lines": "43-52",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1+) expected, Span O(1+).\n        /// - Claude-Opus-4.6: Work O(n), Span O(n)  linear scan of chain, n = chain length.\n        fn lookup(&self, key: &Key) -> Option<Value> {\n            for (k, v) in self.iter() {\n                if k == key {\n                    return Some(v.clone());\n                }\n            }\n            None\n        }"
  },
  {
    "id": 2218,
    "function": "delete`",
    "file": "Chap47/LinkedListChainedHashTableStEph.rs",
    "lines": "54-72",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1+) expected, Span O(1+).\n        /// - Claude-Opus-4.6: Work O(n), Span O(n)  linear scan + split_off/append, n = chain length.\n        fn delete(&mut self, key: &Key) -> B {\n            let mut found_idx = None;\n            for (idx, (k, _)) in self.iter().enumerate() {\n                if k == key {\n                    found_idx = Some(idx);\n                    break;\n                }\n            }\n            if let Some(idx) = found_idx {\n                let mut split_off = self.split_off(idx);\n                split_off.pop_front();\n                self.append(&mut split_off);\n                true\n            } else {\n                false\n            }\n        }"
  },
  {
    "id": 2219,
    "function": "resize",
    "file": "Chap47/LinkedListChainedHashTableStEph.rs",
    "lines": "101-132",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(n + m + m'), Span O(n + m + m').\n        /// - Claude-Opus-4.6: Work O(n + m + m'), Span O(n + m + m')  collects n pairs, creates m' lists, reinserts.\n        fn resize(\n            table: &HashTable<Key, Value, LinkedList<(Key, Value)>, Metrics>,\n            new_size: usize,\n        ) -> HashTable<Key, Value, LinkedList<(Key, Value)>, Metrics> {\n            let mut pairs = Vec::new();\n            for chain in &table.table {\n                for (k, v) in chain.iter() {\n                    pairs.push((k.clone(), v.clone()));\n                }\n            }\n\n            let new_table_vec = (0..new_size).map(|_| LinkedList::new()).collect();\n            let new_hash_fn = (table.hash_fn_gen)(new_size);\n            let mut new_table = HashTable {\n                table: new_table_vec,\n                hash_fn_gen: table.hash_fn_gen.clone(),\n                hash_fn: new_hash_fn,\n                initial_size: table.initial_size,\n                current_size: new_size,\n                num_elements: 0,\n                metrics: Metrics::default(),\n                _phantom: PhantomData,\n            };\n\n            for (key, value) in pairs {\n                Self::insert(&mut new_table, key, value);\n            }\n\n            new_table\n        }"
  },
  {
    "id": 2220,
    "function": "hash_index",
    "file": "Chap47/LinkedListChainedHashTableStEph.rs",
    "lines": "138-142",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1), Span O(1).\n        /// - Claude-Opus-4.6: Work O(1), Span O(1)  delegates to stored hash function.\n        fn hash_index(table: &HashTable<Key, Value, LinkedList<(Key, Value)>, Metrics>, key: &Key) -> usize {\n            (table.hash_fn)(key) % table.current_size\n        }"
  },
  {
    "id": 2221,
    "function": "new",
    "file": "Chap47/ParaHashTableStEph.rs",
    "lines": "49",
    "spec_strength": "",
    "snippet": "        fn new()                        -> Self;"
  },
  {
    "id": 2222,
    "function": "insert`",
    "file": "Chap47/ParaHashTableStEph.rs",
    "lines": "100-103",
    "spec_strength": "",
    "snippet": "        /// Inserts a key-value pair into the hash table.\n        /// - APAS: Work O(1) expected, Span O(1).\n        /// - Claude-Opus-4.6: N/A  abstract trait method; cost depends on implementation.\n        fn insert(table: &mut HashTable<Key, Value, Entry, Metrics>, key: Key, value: Value);"
  },
  {
    "id": 2223,
    "function": "lookup`",
    "file": "Chap47/ParaHashTableStEph.rs",
    "lines": "105-108",
    "spec_strength": "",
    "snippet": "        /// Looks up a key in the hash table, returning its value if found.\n        /// - APAS: Work O(1) expected, Span O(1).\n        /// - Claude-Opus-4.6: N/A  abstract trait method; cost depends on implementation.\n        fn lookup(table: &HashTable<Key, Value, Entry, Metrics>, key: &Key)     -> Option<Value>;"
  },
  {
    "id": 2224,
    "function": "delete`",
    "file": "Chap47/ParaHashTableStEph.rs",
    "lines": "110-113",
    "spec_strength": "",
    "snippet": "        /// Deletes a key from the hash table if it exists.\n        /// - APAS: Work O(1) expected, Span O(1).\n        /// - Claude-Opus-4.6: N/A  abstract trait method; cost depends on implementation.\n        fn delete(table: &mut HashTable<Key, Value, Entry, Metrics>, key: &Key) -> B;"
  },
  {
    "id": 2225,
    "function": "createTable",
    "file": "Chap47/ParaHashTableStEph.rs",
    "lines": "81-98",
    "spec_strength": "",
    "snippet": "        /// Creates an empty hash table with the given initial size.\n        /// Takes a hash function generator that produces hash functions for different table sizes.\n        /// - APAS: Work O(m), Span O(m) where m is initial size.\n        /// - Claude-Opus-4.6: Work O(m), Span O(m)  agrees with APAS; iterates m times to create entries.\n        fn createTable(hash_fn_gen: HashFunGen<Key>, initial_size: usize)           -> HashTable<Key, Value, Entry, Metrics> {\n            let table = (0..initial_size).map(|_| Entry::new()).collect();\n            let hash_fn = hash_fn_gen(initial_size);\n            HashTable {\n                table,\n                hash_fn_gen,\n                hash_fn,\n                initial_size,\n                current_size: initial_size,\n                num_elements: 0,\n                metrics: Metrics::default(),\n                _phantom: PhantomData,\n            }\n        }"
  },
  {
    "id": 2226,
    "function": "metrics",
    "file": "Chap47/ParaHashTableStEph.rs",
    "lines": "115-118",
    "spec_strength": "",
    "snippet": "        /// Accessor for metrics field.\n        /// - APAS: N/A  Verus-specific scaffolding.\n        /// - Claude-Opus-4.6: Work O(1), Span O(1)  field access.\n        fn metrics(table: &HashTable<Key, Value, Entry, Metrics>)               -> &Metrics { &table.metrics }"
  },
  {
    "id": 2227,
    "function": "loadAndSize",
    "file": "Chap47/ParaHashTableStEph.rs",
    "lines": "120-134",
    "spec_strength": "",
    "snippet": "        /// Returns the load (number of entries) and size (table capacity).\n        /// Load factor  = load/size = num_elements/size\n        /// - APAS: Work O(1), Span O(1).\n        /// - Claude-Opus-4.6: Work O(1), Span O(1)  agrees with APAS; field reads and one division.\n        fn loadAndSize(table: &HashTable<Key, Value, Entry, Metrics>)           -> LoadAndSize {\n            let load_factor = if table.current_size == 0 {\n                0.0\n            } else {\n                table.num_elements as f64 / table.current_size as f64\n            };\n            LoadAndSize {\n                load: load_factor,\n                size: table.current_size,\n            }\n        }"
  },
  {
    "id": 2228,
    "function": "resize",
    "file": "Chap47/ParaHashTableStEph.rs",
    "lines": "136-141",
    "spec_strength": "",
    "snippet": "        /// Resizes the hash table to a new size and rehashes all entries.\n        /// Uses the stored hash function generator to create a new hash function for the new size.\n        /// - APAS: Work O(n + m + m'), Span O(n + m + m') where n is number of elements,\n        ///   m is old size, m' is new size.\n        /// - Claude-Opus-4.6: N/A  abstract trait method; cost depends on implementation.\n        fn resize(table: &HashTable<Key, Value, Entry, Metrics>, new_size: usize)   -> HashTable<Key, Value, Entry, Metrics>;"
  },
  {
    "id": 2229,
    "function": "insert",
    "file": "Chap47/QuadProbFlatHashTableStEph.rs",
    "lines": "36-53",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1/(1)) expected, Span O(1/(1)).\n        /// - Claude-Opus-4.6: Work O(1/(1)) expected, Span O(1/(1))  quadratic probe find_slot then O(1) write.\n        fn insert(table: &mut HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: Key, value: Value) {\n            let slot = Self::find_slot(table, &key);\n            match &table.table[slot] {\n                | FlatEntry::Occupied(k, _) if k == &key => {\n                    table.table[slot] = FlatEntry::Occupied(key, value);\n                }\n                | FlatEntry::Empty | FlatEntry::Deleted => {\n                    table.table[slot] = FlatEntry::Occupied(key, value);\n                    table.num_elements += 1;\n                }\n                | _ => {\n                    table.table[slot] = FlatEntry::Occupied(key, value);\n                    table.num_elements += 1;\n                }\n            }\n        }"
  },
  {
    "id": 2230,
    "function": "lookup",
    "file": "Chap47/QuadProbFlatHashTableStEph.rs",
    "lines": "55-71",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1/(1)) expected, Span O(1/(1)).\n        /// - Claude-Opus-4.6: Work O(1/(1)) expected, Span O(1/(1))  quadratic probe up to m/2 attempts (Lemma 47.1).\n        fn lookup(table: &HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: &Key) -> Option<Value> {\n            let mut attempt = 0;\n            let max_attempts = table.current_size.div_ceil(2);\n            while attempt < max_attempts {\n                let slot = Self::probe(table, key, attempt);\n                match &table.table[slot] {\n                    | FlatEntry::Occupied(k, v) if k == key => return Some(v.clone()),\n                    | FlatEntry::Empty => return None,\n                    | FlatEntry::Deleted | FlatEntry::Occupied(_, _) => {\n                        attempt += 1;\n                    }\n                }\n            }\n            None\n        }"
  },
  {
    "id": 2231,
    "function": "delete",
    "file": "Chap47/QuadProbFlatHashTableStEph.rs",
    "lines": "73-93",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1/(1)) expected, Span O(1/(1)).\n        /// - Claude-Opus-4.6: Work O(1/(1)) expected, Span O(1/(1))  quadratic probe until found or empty, then tombstone.\n        fn delete(table: &mut HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: &Key) -> B {\n            let mut attempt = 0;\n            let max_attempts = table.current_size.div_ceil(2);\n            while attempt < max_attempts {\n                let slot = Self::probe(table, key, attempt);\n                match &table.table[slot] {\n                    | FlatEntry::Occupied(k, _) if k == key => {\n                        table.table[slot] = FlatEntry::Deleted;\n                        table.num_elements -= 1;\n                        return true;\n                    }\n                    | FlatEntry::Empty => return false,\n                    | FlatEntry::Deleted | FlatEntry::Occupied(_, _) => {\n                        attempt += 1;\n                    }\n                }\n            }\n            false\n        }"
  },
  {
    "id": 2232,
    "function": "resize",
    "file": "Chap47/QuadProbFlatHashTableStEph.rs",
    "lines": "95-126",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(n + m + m'), Span O(n + m + m').\n        /// - Claude-Opus-4.6: Work O(n + m + m'), Span O(n + m + m')  collects n pairs from m slots, creates m' new slots, reinserts n pairs.\n        fn resize(\n            table: &HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>,\n            new_size: usize,\n        ) -> HashTable<Key, Value, FlatEntry<Key, Value>, Metrics> {\n            let mut pairs = Vec::new();\n            for entry in &table.table {\n                if let FlatEntry::Occupied(k, v) = entry {\n                    pairs.push((k.clone(), v.clone()));\n                }\n            }\n\n            let new_table_vec = (0..new_size).map(|_| FlatEntry::new()).collect();\n            let new_hash_fn = (table.hash_fn_gen)(new_size);\n            let mut new_table = HashTable {\n                table: new_table_vec,\n                hash_fn_gen: table.hash_fn_gen.clone(),\n                hash_fn: new_hash_fn,\n                initial_size: table.initial_size,\n                current_size: new_size,\n                num_elements: 0,\n                metrics: Metrics::default(),\n                _phantom: PhantomData,\n            };\n\n            for (key, value) in pairs {\n                Self::insert(&mut new_table, key, value);\n            }\n\n            new_table\n        }"
  },
  {
    "id": 2233,
    "function": "probe",
    "file": "Chap47/QuadProbFlatHashTableStEph.rs",
    "lines": "132-137",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1), Span O(1).\n        /// - Claude-Opus-4.6: Work O(1), Span O(1)  hash + i + modulo.\n        fn probe(table: &HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: &Key, attempt: usize) -> usize {\n            let hash_val = (table.hash_fn)(key);\n            (hash_val + (attempt * attempt)) % table.current_size\n        }"
  },
  {
    "id": 2234,
    "function": "find_slot",
    "file": "Chap47/QuadProbFlatHashTableStEph.rs",
    "lines": "139-153",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1/(1)) expected, Span O(1/(1)).\n        /// - Claude-Opus-4.6: Work O(1/(1)) expected, Span O(1/(1))  quadratic probe up to m/2 (Lemma 47.1).\n        fn find_slot(table: &HashTable<Key, Value, FlatEntry<Key, Value>, Metrics>, key: &Key) -> usize {\n            let mut attempt = 0;\n            let max_attempts = table.current_size.div_ceil(2);\n            while attempt < max_attempts {\n                let slot = Self::probe(table, key, attempt);\n                match &table.table[slot] {\n                    | FlatEntry::Empty | FlatEntry::Deleted => return slot,\n                    | FlatEntry::Occupied(k, _) if k == key => return slot,\n                    | _ => attempt += 1,\n                }\n            }\n            Self::probe(table, key, 0)\n        }"
  },
  {
    "id": 2235,
    "function": "_struct_chained_hash_table_verified",
    "file": "Chap47/StructChainedHashTable.rs",
    "lines": "24",
    "spec_strength": "",
    "snippet": "        proof fn _struct_chained_hash_table_verified() {}"
  },
  {
    "id": 2236,
    "function": "new",
    "file": "Chap47/StructChainedHashTable.rs",
    "lines": "44-46",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1), Span O(1).\n        /// - Claude-Opus-4.6: Work O(1), Span O(1)  empty list construction.\n        fn new() -> Self { ChainList { head: None } }"
  },
  {
    "id": 2237,
    "function": "insert`",
    "file": "Chap47/StructChainedHashTable.rs",
    "lines": "48-65",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1+) expected, Span O(1+).\n        /// - Claude-Opus-4.6: Work O(n), Span O(n)  linear scan for duplicate key, then head insert, n = chain length.\n        fn insert(&mut self, key: Key, value: Value) {\n            let mut current = &mut self.head;\n            while let Some(node) = current {\n                if node.key == key {\n                    node.value = value;\n                    return;\n                }\n                current = &mut node.next;\n            }\n            let new_node = Box::new(Node {\n                key,\n                value,\n                next: self.head.take(),\n            });\n            self.head = Some(new_node);\n        }"
  },
  {
    "id": 2238,
    "function": "lookup`",
    "file": "Chap47/StructChainedHashTable.rs",
    "lines": "67-78",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1+) expected, Span O(1+).\n        /// - Claude-Opus-4.6: Work O(n), Span O(n)  linear scan of linked list, n = chain length.\n        fn lookup(&self, key: &Key) -> Option<Value> {\n            let mut current = &self.head;\n            while let Some(node) = current {\n                if &node.key == key {\n                    return Some(node.value.clone());\n                }\n                current = &node.next;\n            }\n            None\n        }"
  },
  {
    "id": 2239,
    "function": "delete`",
    "file": "Chap47/StructChainedHashTable.rs",
    "lines": "80-96",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1+) expected, Span O(1+).\n        /// - Claude-Opus-4.6: Work O(n), Span O(n)  linear scan + pointer surgery, n = chain length.\n        fn delete(&mut self, key: &Key) -> B {\n            let mut current = &mut self.head;\n            loop {\n                match current {\n                    | None => return false,\n                    | Some(node) if &node.key == key => {\n                        *current = node.next.take();\n                        return true;\n                    }\n                    | Some(node) => {\n                        current = &mut node.next;\n                    }\n                }\n            }\n        }"
  },
  {
    "id": 2240,
    "function": "default",
    "file": "Chap47/StructChainedHashTable.rs",
    "lines": "100-102",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A  Verus-specific scaffolding.\n        /// - Claude-Opus-4.6: Work O(1), Span O(1)  empty list construction.\n        fn default() -> Self { ChainList { head: None } }"
  },
  {
    "id": 2241,
    "function": "resize",
    "file": "Chap47/StructChainedHashTable.rs",
    "lines": "131-164",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(n + m + m'), Span O(n + m + m').\n        /// - Claude-Opus-4.6: Work O(n + m + m'), Span O(n + m + m')  traverses all chains, creates m' lists, reinserts.\n        fn resize(\n            table: &HashTable<Key, Value, ChainList<Key, Value>, Metrics>,\n            new_size: usize,\n        ) -> HashTable<Key, Value, ChainList<Key, Value>, Metrics> {\n            let mut pairs = Vec::new();\n            for chain in &table.table {\n                let mut current = &chain.head;\n                while let Some(node) = current {\n                    pairs.push((node.key.clone(), node.value.clone()));\n                    current = &node.next;\n                }\n            }\n\n            let new_table_vec = (0..new_size).map(|_| ChainList::new()).collect();\n            let new_hash_fn = (table.hash_fn_gen)(new_size);\n            let mut new_table = HashTable {\n                table: new_table_vec,\n                hash_fn_gen: table.hash_fn_gen.clone(),\n                hash_fn: new_hash_fn,\n                initial_size: table.initial_size,\n                current_size: new_size,\n                num_elements: 0,\n                metrics: Metrics::default(),\n                _phantom: PhantomData,\n            };\n\n            for (key, value) in pairs {\n                Self::insert(&mut new_table, key, value);\n            }\n\n            new_table\n        }"
  },
  {
    "id": 2242,
    "function": "hash_index",
    "file": "Chap47/StructChainedHashTable.rs",
    "lines": "170-174",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1), Span O(1).\n        /// - Claude-Opus-4.6: Work O(1), Span O(1)  delegates to stored hash function.\n        fn hash_index(table: &HashTable<Key, Value, ChainList<Key, Value>, Metrics>, key: &Key) -> usize {\n            (table.hash_fn)(key) % table.current_size\n        }"
  },
  {
    "id": 2243,
    "function": "_vec_chained_hash_table_verified",
    "file": "Chap47/VecChainedHashTableStEph.rs",
    "lines": "22",
    "spec_strength": "",
    "snippet": "        proof fn _vec_chained_hash_table_verified() {}"
  },
  {
    "id": 2244,
    "function": "new",
    "file": "Chap47/VecChainedHashTableStEph.rs",
    "lines": "28-30",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1), Span O(1).\n        /// - Claude-Opus-4.6: Work O(1), Span O(1)  empty Vec construction.\n        fn new() -> Self { Vec::new() }"
  },
  {
    "id": 2245,
    "function": "insert`",
    "file": "Chap47/VecChainedHashTableStEph.rs",
    "lines": "32-42",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1+) expected, Span O(1+).\n        /// - Claude-Opus-4.6: Work O(n) worst case, Span O(n)  linear scan for duplicate key, n = chain length.\n        fn insert(&mut self, key: Key, value: Value) {\n            for (k, v) in self.iter_mut() {\n                if k == &key {\n                    *v = value;\n                    return;\n                }\n            }\n            self.push((key, value));\n        }"
  },
  {
    "id": 2246,
    "function": "lookup`",
    "file": "Chap47/VecChainedHashTableStEph.rs",
    "lines": "44-53",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1+) expected, Span O(1+).\n        /// - Claude-Opus-4.6: Work O(n), Span O(n)  linear scan of chain, n = chain length.\n        fn lookup(&self, key: &Key) -> Option<Value> {\n            for (k, v) in self.iter() {\n                if k == key {\n                    return Some(v.clone());\n                }\n            }\n            None\n        }"
  },
  {
    "id": 2247,
    "function": "delete`",
    "file": "Chap47/VecChainedHashTableStEph.rs",
    "lines": "55-64",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1+) expected, Span O(1+).\n        /// - Claude-Opus-4.6: Work O(n), Span O(n)  linear scan + Vec::remove (shifts elements), n = chain length.\n        fn delete(&mut self, key: &Key) -> B {\n            if let Some(pos) = self.iter().position(|(k, _)| k == key) {\n                self.remove(pos);\n                true\n            } else {\n                false\n            }\n        }"
  },
  {
    "id": 2248,
    "function": "resize",
    "file": "Chap47/VecChainedHashTableStEph.rs",
    "lines": "95-126",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(n + m + m'), Span O(n + m + m').\n        /// - Claude-Opus-4.6: Work O(n + m + m'), Span O(n + m + m')  collects n pairs, creates m' chains, reinserts.\n        fn resize(\n            table: &HashTable<Key, Value, Vec<(Key, Value)>, Metrics>,\n            new_size: usize,\n        ) -> HashTable<Key, Value, Vec<(Key, Value)>, Metrics> {\n            let mut pairs = Vec::new();\n            for chain in &table.table {\n                for (k, v) in chain.iter() {\n                    pairs.push((k.clone(), v.clone()));\n                }\n            }\n\n            let new_table_vec = (0..new_size).map(|_| Vec::new()).collect();\n            let new_hash_fn = (table.hash_fn_gen)(new_size);\n            let mut new_table = HashTable {\n                table: new_table_vec,\n                hash_fn_gen: table.hash_fn_gen.clone(),\n                hash_fn: new_hash_fn,\n                initial_size: table.initial_size,\n                current_size: new_size,\n                num_elements: 0,\n                metrics: Metrics::default(),\n                _phantom: PhantomData,\n            };\n\n            for (key, value) in pairs {\n                Self::insert(&mut new_table, key, value);\n            }\n\n            new_table\n        }"
  },
  {
    "id": 2249,
    "function": "hash_index",
    "file": "Chap47/VecChainedHashTableStEph.rs",
    "lines": "132-136",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work O(1), Span O(1).\n        /// - Claude-Opus-4.6: Work O(1), Span O(1)  delegates to stored hash function.\n        fn hash_index(table: &HashTable<Key, Value, Vec<(Key, Value)>, Metrics>, key: &Key) -> usize {\n            (table.hash_fn)(key) % table.current_size\n        }"
  },
  {
    "id": 2250,
    "function": "new_min_edit_dist_eph_lock",
    "file": "Chap49/MinEditDistMtEph.rs",
    "lines": "30",
    "spec_strength": "hole",
    "snippet": "        fn new_min_edit_dist_eph_lock(val: HashMap<(usize, usize), usize>) -> (lock: RwLock<HashMap<(usize, usize), usize>, MinEditDistMtEphWf>) {"
  },
  {
    "id": 2251,
    "function": "new",
    "file": "Chap49/MinEditDistMtEph.rs",
    "lines": "48-53",
    "spec_strength": "",
    "snippet": "        /// Create new minimum edit distance solver\n        /// - APAS: not specified\n        /// - Claude-Opus-4.6: Work (1), Span (1)  outside verus!, not verified\n        fn new()                                                                -> Self\n        where\n            T: Default;"
  },
  {
    "id": 2252,
    "function": "from_sequences",
    "file": "Chap49/MinEditDistMtEph.rs",
    "lines": "55-58",
    "spec_strength": "",
    "snippet": "        /// Create from source and target sequences\n        /// - APAS: not specified\n        /// - Claude-Opus-4.6: Work (1), Span (1)  outside verus!, not verified\n        fn from_sequences(source: ArraySeqMtEphS<T>, target: ArraySeqMtEphS<T>) -> Self;"
  },
  {
    "id": 2253,
    "function": "min_edit_distance",
    "file": "Chap49/MinEditDistMtEph.rs",
    "lines": "60-64",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (|S||T|), Span (|S|+|T|)\n        /// - Claude-Opus-4.6: Work (|S||T|), Span (|S|+|T|)  agrees with APAS; thread::spawn on delete/insert; outside verus!, not verified\n        fn min_edit_distance(&mut self)                                         -> usize\n        where\n            T: Send + Sync + 'static;"
  },
  {
    "id": 2254,
    "function": "source",
    "file": "Chap49/MinEditDistMtEph.rs",
    "lines": "66-69",
    "spec_strength": "",
    "snippet": "        /// Get the source sequence\n        /// - APAS: not specified\n        /// - Claude-Opus-4.6: Work (1), Span (1)  outside verus!, not verified\n        fn source(&self)                                                        -> &ArraySeqMtEphS<T>;"
  },
  {
    "id": 2255,
    "function": "target",
    "file": "Chap49/MinEditDistMtEph.rs",
    "lines": "71-74",
    "spec_strength": "",
    "snippet": "        /// Get the target sequence\n        /// - APAS: not specified\n        /// - Claude-Opus-4.6: Work (1), Span (1)  outside verus!, not verified\n        fn target(&self)                                                        -> &ArraySeqMtEphS<T>;"
  },
  {
    "id": 2256,
    "function": "source_mut",
    "file": "Chap49/MinEditDistMtEph.rs",
    "lines": "76-79",
    "spec_strength": "",
    "snippet": "        /// Get mutable source sequence (ephemeral allows mutation)\n        /// - APAS: not specified\n        /// - Claude-Opus-4.6: Work (1), Span (1)  outside verus!, not verified\n        fn source_mut(&mut self)                                                -> &mut ArraySeqMtEphS<T>;"
  },
  {
    "id": 2257,
    "function": "target_mut",
    "file": "Chap49/MinEditDistMtEph.rs",
    "lines": "81-84",
    "spec_strength": "",
    "snippet": "        /// Get mutable target sequence (ephemeral allows mutation)\n        /// - APAS: not specified\n        /// - Claude-Opus-4.6: Work (1), Span (1)  outside verus!, not verified\n        fn target_mut(&mut self)                                                -> &mut ArraySeqMtEphS<T>;"
  },
  {
    "id": 2258,
    "function": "set_source",
    "file": "Chap49/MinEditDistMtEph.rs",
    "lines": "86-89",
    "spec_strength": "",
    "snippet": "        /// Set element in source sequence\n        /// - APAS: not specified\n        /// - Claude-Opus-4.6: Work (1), Span (1)  outside verus!, not verified\n        fn set_source(&mut self, index: usize, value: T);"
  },
  {
    "id": 2259,
    "function": "set_target",
    "file": "Chap49/MinEditDistMtEph.rs",
    "lines": "91-94",
    "spec_strength": "",
    "snippet": "        /// Set element in target sequence\n        /// - APAS: not specified\n        /// - Claude-Opus-4.6: Work (1), Span (1)  outside verus!, not verified\n        fn set_target(&mut self, index: usize, value: T);"
  },
  {
    "id": 2260,
    "function": "clear_memo",
    "file": "Chap49/MinEditDistMtEph.rs",
    "lines": "96-99",
    "spec_strength": "",
    "snippet": "        /// Clear memoization table\n        /// - APAS: not specified\n        /// - Claude-Opus-4.6: Work (1), Span (1)  outside verus!, not verified\n        fn clear_memo(&mut self);"
  },
  {
    "id": 2261,
    "function": "memo_size",
    "file": "Chap49/MinEditDistMtEph.rs",
    "lines": "101-104",
    "spec_strength": "",
    "snippet": "        /// Get memoization table size\n        /// - APAS: not specified\n        /// - Claude-Opus-4.6: Work (1), Span (1)  outside verus!, not verified\n        fn memo_size(&self)                                                     -> usize;"
  },
  {
    "id": 2262,
    "function": "min_edit_distance_rec",
    "file": "Chap49/MinEditDistMtEph.rs",
    "lines": "109-160",
    "spec_strength": "",
    "snippet": "    fn min_edit_distance_rec<T: MtVal + Send + Sync + 'static>(\n        source: &ArraySeqMtEphS<T>,\n        target: &ArraySeqMtEphS<T>,\n        memo: &Arc<RwLock<HashMap<(usize, usize), usize>, MinEditDistMtEphWf>>,\n        i: usize,\n        j: usize,\n    ) -> usize {\n        {\n            let handle = memo.acquire_read();\n            let found = handle.borrow().get(&(i, j)).copied();\n            handle.release_read();\n            if let Some(result) = found {\n                return result;\n            }\n        }\n\n        let result = match (i, j) {\n            | (i, 0) => i,\n            | (0, j) => j,\n            | (i, j) => {\n                let source_char = source.nth(i - 1).clone();\n                let target_char = target.nth(j - 1).clone();\n\n                if source_char == target_char {\n                    min_edit_distance_rec(source, target, memo, i - 1, j - 1)\n                } else {\n                    let source1 = source.clone();\n                    let target1 = target.clone();\n                    let memo1 = Arc::clone(memo);\n                    let source2 = source.clone();\n                    let target2 = target.clone();\n                    let memo2 = Arc::clone(memo);\n\n                    let handle1 = thread::spawn(move || min_edit_distance_rec(&source1, &target1, &memo1, i - 1, j));\n                    let handle2 = thread::spawn(move || min_edit_distance_rec(&source2, &target2, &memo2, i, j - 1));\n\n                    let delete_cost = handle1.join().unwrap();\n                    let insert_cost = handle2.join().unwrap();\n\n                    1 + std::cmp::min(delete_cost, insert_cost)\n                }\n            }\n        };\n\n        {\n            let (mut current, write_handle) = memo.acquire_write();\n            current.insert((i, j), result);\n            write_handle.release_write(current);\n        }\n\n        result\n    }"
  },
  {
    "id": 2263,
    "function": "eq",
    "file": "Chap49/MinEditDistMtEph.rs",
    "lines": "237",
    "spec_strength": "",
    "snippet": "        fn eq(&self, other: &Self) -> bool { self.source == other.source && self.target == other.target }"
  },
  {
    "id": 2264,
    "function": "new_min_edit_dist_per_lock",
    "file": "Chap49/MinEditDistMtPer.rs",
    "lines": "29",
    "spec_strength": "hole",
    "snippet": "        fn new_min_edit_dist_per_lock(val: HashMap<(usize, usize), usize>) -> (lock: RwLock<HashMap<(usize, usize), usize>, MinEditDistMtPerWf>) {"
  },
  {
    "id": 2265,
    "function": "new",
    "file": "Chap49/MinEditDistMtPer.rs",
    "lines": "47-52",
    "spec_strength": "",
    "snippet": "        /// Create new minimum edit distance solver\n        /// - APAS: not specified\n        /// - Claude-Opus-4.6: Work (1), Span (1)  outside verus!, not verified\n        fn new()                                                                -> Self\n        where\n            T: Default;"
  },
  {
    "id": 2266,
    "function": "from_sequences",
    "file": "Chap49/MinEditDistMtPer.rs",
    "lines": "54-57",
    "spec_strength": "",
    "snippet": "        /// Create from source and target sequences\n        /// - APAS: not specified\n        /// - Claude-Opus-4.6: Work (1), Span (1)  outside verus!, not verified\n        fn from_sequences(source: ArraySeqMtPerS<T>, target: ArraySeqMtPerS<T>) -> Self;"
  },
  {
    "id": 2267,
    "function": "min_edit_distance",
    "file": "Chap49/MinEditDistMtPer.rs",
    "lines": "59-63",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (|S||T|), Span (|S|+|T|)\n        /// - Claude-Opus-4.6: Work (|S||T|), Span (|S|+|T|)  agrees with APAS; thread::spawn on delete/insert; outside verus!, not verified\n        fn min_edit_distance(&self)                                             -> usize\n        where\n            T: Send + Sync + 'static;"
  },
  {
    "id": 2268,
    "function": "source",
    "file": "Chap49/MinEditDistMtPer.rs",
    "lines": "65-68",
    "spec_strength": "",
    "snippet": "        /// Get the source sequence\n        /// - APAS: not specified\n        /// - Claude-Opus-4.6: Work (1), Span (1)  outside verus!, not verified\n        fn source(&self)                                                        -> &ArraySeqMtPerS<T>;"
  },
  {
    "id": 2269,
    "function": "target",
    "file": "Chap49/MinEditDistMtPer.rs",
    "lines": "70-73",
    "spec_strength": "",
    "snippet": "        /// Get the target sequence\n        /// - APAS: not specified\n        /// - Claude-Opus-4.6: Work (1), Span (1)  outside verus!, not verified\n        fn target(&self)                                                        -> &ArraySeqMtPerS<T>;"
  },
  {
    "id": 2270,
    "function": "memo_size",
    "file": "Chap49/MinEditDistMtPer.rs",
    "lines": "75-78",
    "spec_strength": "",
    "snippet": "        /// Get memoization table size\n        /// - APAS: not specified\n        /// - Claude-Opus-4.6: Work (1), Span (1)  outside verus!, not verified\n        fn memo_size(&self)                                                     -> usize;"
  },
  {
    "id": 2271,
    "function": "min_edit_distance_rec",
    "file": "Chap49/MinEditDistMtPer.rs",
    "lines": "83-130",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work (|S||T|), Span (|S|+|T|)\n    /// - Claude-Opus-4.6: Work (|S||T|), Span (|S|+|T|)  parallel fork on delete/insert branches; outside verus!, not verified\n    fn min_edit_distance_rec<T: MtVal + Send + Sync + 'static>(\n        table: &MinEditDistMtPerS<T>,\n        i: usize,\n        j: usize,\n    ) -> usize {\n        {\n            let handle = table.memo.acquire_read();\n            let found = handle.borrow().get(&(i, j)).copied();\n            handle.release_read();\n            if let Some(result) = found {\n                return result;\n            }\n        }\n\n        let result = match (i, j) {\n            | (i, 0) => i,\n            | (0, j) => j,\n            | (i, j) => {\n                let source_char = table.source.nth(i - 1);\n                let target_char = table.target.nth(j - 1);\n\n                if source_char == target_char {\n                    min_edit_distance_rec(table, i - 1, j - 1)\n                } else {\n                    let table_clone1 = table.clone();\n                    let table_clone2 = table.clone();\n\n                    let handle1 = thread::spawn(move || min_edit_distance_rec(&table_clone1, i - 1, j));\n                    let handle2 = thread::spawn(move || min_edit_distance_rec(&table_clone2, i, j - 1));\n\n                    let delete_cost = handle1.join().unwrap();\n                    let insert_cost = handle2.join().unwrap();\n\n                    1 + std::cmp::min(delete_cost, insert_cost)\n                }\n            }\n        };\n\n        {\n            let (mut current, write_handle) = table.memo.acquire_write();\n            current.insert((i, j), result);\n            write_handle.release_write(current);\n        }\n\n        result\n    }"
  },
  {
    "id": 2272,
    "function": "eq",
    "file": "Chap49/MinEditDistMtPer.rs",
    "lines": "183",
    "spec_strength": "",
    "snippet": "        fn eq(&self, other: &Self) -> bool { self.source == other.source && self.target == other.target }"
  },
  {
    "id": 2273,
    "function": "_min_edit_dist_st_eph_verified",
    "file": "Chap49/MinEditDistStEph.rs",
    "lines": "23",
    "spec_strength": "",
    "snippet": "        proof fn _min_edit_dist_st_eph_verified() {}"
  },
  {
    "id": 2274,
    "function": "new",
    "file": "Chap49/MinEditDistStEph.rs",
    "lines": "40-45",
    "spec_strength": "",
    "snippet": "        /// Create new minimum edit distance solver\n        /// - APAS: not specified\n        /// - Claude-Opus-4.6: Work (1), Span (1)  outside verus!, not verified\n        fn new()                                                                -> Self\n        where\n            T: Default;"
  },
  {
    "id": 2275,
    "function": "from_sequences",
    "file": "Chap49/MinEditDistStEph.rs",
    "lines": "47-50",
    "spec_strength": "",
    "snippet": "        /// Create from source and target sequences\n        /// - APAS: not specified\n        /// - Claude-Opus-4.6: Work (1), Span (1)  outside verus!, not verified\n        fn from_sequences(source: ArraySeqStEphS<T>, target: ArraySeqStEphS<T>) -> Self;"
  },
  {
    "id": 2276,
    "function": "min_edit_distance",
    "file": "Chap49/MinEditDistStEph.rs",
    "lines": "52-54",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (|S||T|), Span (|S|+|T|)\n        /// - Claude-Opus-4.6: Work (|S||T|), Span (|S||T|)  sequential, span equals work; outside verus!, not verified\n        fn min_edit_distance(&mut self)                                         -> usize;"
  },
  {
    "id": 2277,
    "function": "source",
    "file": "Chap49/MinEditDistStEph.rs",
    "lines": "56-59",
    "spec_strength": "",
    "snippet": "        /// Get the source sequence\n        /// - APAS: not specified\n        /// - Claude-Opus-4.6: Work (1), Span (1)  outside verus!, not verified\n        fn source(&self)                                                        -> &ArraySeqStEphS<T>;"
  },
  {
    "id": 2278,
    "function": "target",
    "file": "Chap49/MinEditDistStEph.rs",
    "lines": "61-64",
    "spec_strength": "",
    "snippet": "        /// Get the target sequence\n        /// - APAS: not specified\n        /// - Claude-Opus-4.6: Work (1), Span (1)  outside verus!, not verified\n        fn target(&self)                                                        -> &ArraySeqStEphS<T>;"
  },
  {
    "id": 2279,
    "function": "source_mut",
    "file": "Chap49/MinEditDistStEph.rs",
    "lines": "66-69",
    "spec_strength": "",
    "snippet": "        /// Get mutable source sequence (ephemeral allows mutation)\n        /// - APAS: not specified\n        /// - Claude-Opus-4.6: Work (1), Span (1)  outside verus!, not verified\n        fn source_mut(&mut self)                                                -> &mut ArraySeqStEphS<T>;"
  },
  {
    "id": 2280,
    "function": "target_mut",
    "file": "Chap49/MinEditDistStEph.rs",
    "lines": "71-74",
    "spec_strength": "",
    "snippet": "        /// Get mutable target sequence (ephemeral allows mutation)\n        /// - APAS: not specified\n        /// - Claude-Opus-4.6: Work (1), Span (1)  outside verus!, not verified\n        fn target_mut(&mut self)                                                -> &mut ArraySeqStEphS<T>;"
  },
  {
    "id": 2281,
    "function": "set_source",
    "file": "Chap49/MinEditDistStEph.rs",
    "lines": "76-79",
    "spec_strength": "",
    "snippet": "        /// Set element in source sequence\n        /// - APAS: not specified\n        /// - Claude-Opus-4.6: Work (1), Span (1)  outside verus!, not verified\n        fn set_source(&mut self, index: usize, value: T);"
  },
  {
    "id": 2282,
    "function": "set_target",
    "file": "Chap49/MinEditDistStEph.rs",
    "lines": "81-84",
    "spec_strength": "",
    "snippet": "        /// Set element in target sequence\n        /// - APAS: not specified\n        /// - Claude-Opus-4.6: Work (1), Span (1)  outside verus!, not verified\n        fn set_target(&mut self, index: usize, value: T);"
  },
  {
    "id": 2283,
    "function": "clear_memo",
    "file": "Chap49/MinEditDistStEph.rs",
    "lines": "86-89",
    "spec_strength": "",
    "snippet": "        /// Clear memoization table\n        /// - APAS: not specified\n        /// - Claude-Opus-4.6: Work (1), Span (1)  outside verus!, not verified\n        fn clear_memo(&mut self);"
  },
  {
    "id": 2284,
    "function": "memo_size",
    "file": "Chap49/MinEditDistStEph.rs",
    "lines": "91-94",
    "spec_strength": "",
    "snippet": "        /// Get memoization table size\n        /// - APAS: not specified\n        /// - Claude-Opus-4.6: Work (1), Span (1)  outside verus!, not verified\n        fn memo_size(&self)                                                     -> usize;"
  },
  {
    "id": 2285,
    "function": "min_edit_distance_rec",
    "file": "Chap49/MinEditDistStEph.rs",
    "lines": "99-126",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work (|S||T|), Span (|S|+|T|)\n    /// - Claude-Opus-4.6: Work (|S||T|), Span (|S||T|)  sequential memoized recursion; outside verus!, not verified\n    fn min_edit_distance_rec<T: StT>(table: &mut MinEditDistStEphS<T>, i: usize, j: usize) -> usize {\n        if let Some(&result) = table.memo.get(&(i, j)) {\n            return result;\n        }\n\n        let result = match (i, j) {\n            | (i, 0) => i,\n            | (0, j) => j,\n            | (i, j) => {\n                let source_char = table.source.nth(i - 1);\n                let target_char = table.target.nth(j - 1);\n\n                if source_char == target_char {\n                    min_edit_distance_rec(table, i - 1, j - 1)\n                } else {\n                    let delete_cost = min_edit_distance_rec(table, i - 1, j);\n                    let insert_cost = min_edit_distance_rec(table, i, j - 1);\n\n                    1 + std::cmp::min(delete_cost, insert_cost)\n                }\n            }\n        };\n\n        table.memo.insert((i, j), result);\n        result\n    }"
  },
  {
    "id": 2286,
    "function": "_min_edit_dist_st_per_verified",
    "file": "Chap49/MinEditDistStPer.rs",
    "lines": "22",
    "spec_strength": "",
    "snippet": "        proof fn _min_edit_dist_st_per_verified() {}"
  },
  {
    "id": 2287,
    "function": "new",
    "file": "Chap49/MinEditDistStPer.rs",
    "lines": "39-44",
    "spec_strength": "",
    "snippet": "        /// Create new minimum edit distance solver\n        /// - APAS: not specified\n        /// - Claude-Opus-4.6: Work (1), Span (1)  outside verus!, not verified\n        fn new()                                                                -> Self\n        where\n            T: Default;"
  },
  {
    "id": 2288,
    "function": "from_sequences",
    "file": "Chap49/MinEditDistStPer.rs",
    "lines": "46-49",
    "spec_strength": "",
    "snippet": "        /// Create from source and target sequences\n        /// - APAS: not specified\n        /// - Claude-Opus-4.6: Work (1), Span (1)  outside verus!, not verified\n        fn from_sequences(source: ArraySeqStPerS<T>, target: ArraySeqStPerS<T>) -> Self;"
  },
  {
    "id": 2289,
    "function": "min_edit_distance",
    "file": "Chap49/MinEditDistStPer.rs",
    "lines": "51-53",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (|S||T|), Span (|S|+|T|)\n        /// - Claude-Opus-4.6: Work (|S||T|), Span (|S||T|)  sequential, span equals work; outside verus!, not verified\n        fn min_edit_distance(&self)                                             -> usize;"
  },
  {
    "id": 2290,
    "function": "source",
    "file": "Chap49/MinEditDistStPer.rs",
    "lines": "55-58",
    "spec_strength": "",
    "snippet": "        /// Get the source sequence\n        /// - APAS: not specified\n        /// - Claude-Opus-4.6: Work (1), Span (1)  outside verus!, not verified\n        fn source(&self)                                                        -> &ArraySeqStPerS<T>;"
  },
  {
    "id": 2291,
    "function": "target",
    "file": "Chap49/MinEditDistStPer.rs",
    "lines": "60-63",
    "spec_strength": "",
    "snippet": "        /// Get the target sequence\n        /// - APAS: not specified\n        /// - Claude-Opus-4.6: Work (1), Span (1)  outside verus!, not verified\n        fn target(&self)                                                        -> &ArraySeqStPerS<T>;"
  },
  {
    "id": 2292,
    "function": "memo_size",
    "file": "Chap49/MinEditDistStPer.rs",
    "lines": "65-68",
    "spec_strength": "",
    "snippet": "        /// Get memoization table size\n        /// - APAS: not specified\n        /// - Claude-Opus-4.6: Work (1), Span (1)  outside verus!, not verified\n        fn memo_size(&self)                                                     -> usize;"
  },
  {
    "id": 2293,
    "function": "min_edit_distance_rec",
    "file": "Chap49/MinEditDistStPer.rs",
    "lines": "73-100",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work (|S||T|), Span (|S|+|T|)\n    /// - Claude-Opus-4.6: Work (|S||T|), Span (|S||T|)  sequential memoized recursion; outside verus!, not verified\n    fn min_edit_distance_rec<T: StT>(table: &mut MinEditDistStPerS<T>, i: usize, j: usize) -> usize {\n        if let Some(&result) = table.memo.get(&(i, j)) {\n            return result;\n        }\n\n        let result = match (i, j) {\n            | (i, 0) => i,\n            | (0, j) => j,\n            | (i, j) => {\n                let source_char = table.source.nth(i - 1);\n                let target_char = table.target.nth(j - 1);\n\n                if source_char == target_char {\n                    min_edit_distance_rec(table, i - 1, j - 1)\n                } else {\n                    let delete_cost = min_edit_distance_rec(table, i - 1, j);\n                    let insert_cost = min_edit_distance_rec(table, i, j - 1);\n\n                    1 + std::cmp::min(delete_cost, insert_cost)\n                }\n            }\n        };\n\n        table.memo.insert((i, j), result);\n        result\n    }"
  },
  {
    "id": 2294,
    "function": "new_subset_sum_eph_lock",
    "file": "Chap49/SubsetSumMtEph.rs",
    "lines": "30",
    "spec_strength": "hole",
    "snippet": "        fn new_subset_sum_eph_lock(val: HashMap<(usize, i32), bool>) -> (lock: RwLock<HashMap<(usize, i32), bool>, SubsetSumMtEphWf>) {"
  },
  {
    "id": 2295,
    "function": "new",
    "file": "Chap49/SubsetSumMtEph.rs",
    "lines": "47-52",
    "spec_strength": "",
    "snippet": "        /// Create new subset sum solver\n        /// - APAS: not specified\n        /// - Claude-Opus-4.6: Work (1), Span (1)  outside verus!, not verified\n        fn new()                                      -> Self\n        where\n            T: Default;"
  },
  {
    "id": 2296,
    "function": "from_multiset",
    "file": "Chap49/SubsetSumMtEph.rs",
    "lines": "54-57",
    "spec_strength": "",
    "snippet": "        /// Create from multiset\n        /// - APAS: not specified\n        /// - Claude-Opus-4.6: Work (1), Span (1)  outside verus!, not verified\n        fn from_multiset(multiset: ArraySeqMtEphS<T>) -> Self;"
  },
  {
    "id": 2297,
    "function": "subset_sum",
    "file": "Chap49/SubsetSumMtEph.rs",
    "lines": "59-63",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (k|S|), Span (|S|)\n        /// - Claude-Opus-4.6: Work (k|S|), Span (|S|)  agrees with APAS; thread::spawn on both branches; outside verus!, not verified\n        fn subset_sum(&mut self, target: i32)         -> bool\n        where\n            T: Into<i32> + Copy + Send + Sync + 'static;"
  },
  {
    "id": 2298,
    "function": "multiset",
    "file": "Chap49/SubsetSumMtEph.rs",
    "lines": "65-68",
    "spec_strength": "",
    "snippet": "        /// Get the multiset\n        /// - APAS: not specified\n        /// - Claude-Opus-4.6: Work (1), Span (1)  outside verus!, not verified\n        fn multiset(&self)                            -> &ArraySeqMtEphS<T>;"
  },
  {
    "id": 2299,
    "function": "multiset_mut",
    "file": "Chap49/SubsetSumMtEph.rs",
    "lines": "70-73",
    "spec_strength": "",
    "snippet": "        /// Get mutable multiset (ephemeral allows mutation)\n        /// - APAS: not specified\n        /// - Claude-Opus-4.6: Work (1), Span (1)  outside verus!, not verified\n        fn multiset_mut(&mut self)                    -> &mut ArraySeqMtEphS<T>;"
  },
  {
    "id": 2300,
    "function": "set",
    "file": "Chap49/SubsetSumMtEph.rs",
    "lines": "75-78",
    "spec_strength": "",
    "snippet": "        /// Set element at index (ephemeral mutation)\n        /// - APAS: not specified\n        /// - Claude-Opus-4.6: Work (1), Span (1)  outside verus!, not verified\n        fn set(&mut self, index: usize, value: T);"
  },
  {
    "id": 2301,
    "function": "clear_memo",
    "file": "Chap49/SubsetSumMtEph.rs",
    "lines": "80-83",
    "spec_strength": "",
    "snippet": "        /// Clear memoization table\n        /// - APAS: not specified\n        /// - Claude-Opus-4.6: Work (1), Span (1)  outside verus!, not verified\n        fn clear_memo(&mut self);"
  },
  {
    "id": 2302,
    "function": "memo_size",
    "file": "Chap49/SubsetSumMtEph.rs",
    "lines": "85-88",
    "spec_strength": "",
    "snippet": "        /// Get memoization table size\n        /// - APAS: not specified\n        /// - Claude-Opus-4.6: Work (1), Span (1)  outside verus!, not verified\n        fn memo_size(&self)                           -> usize;"
  },
  {
    "id": 2303,
    "function": "subset_sum_rec",
    "file": "Chap49/SubsetSumMtEph.rs",
    "lines": "93-138",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work (k|S|), Span (|S|)\n    /// - Claude-Opus-4.6: Work (k|S|), Span (|S|)  parallel fork on include/exclude branches; outside verus!, not verified\n    fn subset_sum_rec<T: MtVal + Into<i32> + Copy + Send + Sync + 'static>(\n        table: &SubsetSumMtEphS<T>,\n        i: usize,\n        j: i32,\n    ) -> bool {\n        {\n            let handle = table.memo.acquire_read();\n            let found = handle.borrow().get(&(i, j)).copied();\n            handle.release_read();\n            if let Some(result) = found {\n                return result;\n            }\n        }\n\n        let result = match (i, j) {\n            | (_, 0) => true,\n            | (0, _) => false,\n            | (i, j) => {\n                let element_value: i32 = (*table.multiset.nth(i - 1)).clone().into();\n                if element_value > j {\n                    subset_sum_rec(table, i - 1, j)\n                } else {\n                    let table_clone1 = table.clone();\n                    let table_clone2 = table.clone();\n\n                    let handle1 = thread::spawn(move || subset_sum_rec(&table_clone1, i - 1, j - element_value));\n                    let handle2 = thread::spawn(move || subset_sum_rec(&table_clone2, i - 1, j));\n\n                    let result1 = handle1.join().unwrap();\n                    let result2 = handle2.join().unwrap();\n\n                    result1 || result2\n                }\n            }\n        };\n\n        {\n            let (mut current, write_handle) = table.memo.acquire_write();\n            current.insert((i, j), result);\n            write_handle.release_write(current);\n        }\n\n        result\n    }"
  },
  {
    "id": 2304,
    "function": "eq",
    "file": "Chap49/SubsetSumMtEph.rs",
    "lines": "204",
    "spec_strength": "",
    "snippet": "        fn eq(&self, other: &Self) -> bool { self.multiset == other.multiset }"
  },
  {
    "id": 2305,
    "function": "new_subset_sum_per_lock",
    "file": "Chap49/SubsetSumMtPer.rs",
    "lines": "29",
    "spec_strength": "hole",
    "snippet": "        fn new_subset_sum_per_lock(val: HashMap<(usize, i32), bool>) -> (lock: RwLock<HashMap<(usize, i32), bool>, SubsetSumMtPerWf>) {"
  },
  {
    "id": 2306,
    "function": "new",
    "file": "Chap49/SubsetSumMtPer.rs",
    "lines": "46-51",
    "spec_strength": "",
    "snippet": "        /// Create new subset sum solver\n        /// - APAS: not specified\n        /// - Claude-Opus-4.6: Work (1), Span (1)  outside verus!, not verified\n        fn new()                                      -> Self\n        where\n            T: Default;"
  },
  {
    "id": 2307,
    "function": "from_multiset",
    "file": "Chap49/SubsetSumMtPer.rs",
    "lines": "53-56",
    "spec_strength": "",
    "snippet": "        /// Create from multiset\n        /// - APAS: not specified\n        /// - Claude-Opus-4.6: Work (1), Span (1)  outside verus!, not verified\n        fn from_multiset(multiset: ArraySeqMtPerS<T>) -> Self;"
  },
  {
    "id": 2308,
    "function": "subset_sum",
    "file": "Chap49/SubsetSumMtPer.rs",
    "lines": "58-62",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (k|S|), Span (|S|)\n        /// - Claude-Opus-4.6: Work (k|S|), Span (|S|)  agrees with APAS; thread::spawn on both branches; outside verus!, not verified\n        fn subset_sum(&self, target: i32)             -> bool\n        where\n            T: Into<i32> + Copy + Send + Sync + 'static;"
  },
  {
    "id": 2309,
    "function": "multiset",
    "file": "Chap49/SubsetSumMtPer.rs",
    "lines": "64-67",
    "spec_strength": "",
    "snippet": "        /// Get the multiset\n        /// - APAS: not specified\n        /// - Claude-Opus-4.6: Work (1), Span (1)  outside verus!, not verified\n        fn multiset(&self)                            -> &ArraySeqMtPerS<T>;"
  },
  {
    "id": 2310,
    "function": "memo_size",
    "file": "Chap49/SubsetSumMtPer.rs",
    "lines": "69-72",
    "spec_strength": "",
    "snippet": "        /// Get memoization table size\n        /// - APAS: not specified\n        /// - Claude-Opus-4.6: Work (1), Span (1)  outside verus!, not verified\n        fn memo_size(&self)                           -> usize;"
  },
  {
    "id": 2311,
    "function": "subset_sum_rec",
    "file": "Chap49/SubsetSumMtPer.rs",
    "lines": "77-122",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work (k|S|), Span (|S|)\n    /// - Claude-Opus-4.6: Work (k|S|), Span (|S|)  parallel fork on include/exclude branches; outside verus!, not verified\n    fn subset_sum_rec<T: MtVal + Into<i32> + Copy + Send + Sync + 'static>(\n        table: &SubsetSumMtPerS<T>,\n        i: usize,\n        j: i32,\n    ) -> bool {\n        {\n            let handle = table.memo.acquire_read();\n            let found = handle.borrow().get(&(i, j)).copied();\n            handle.release_read();\n            if let Some(result) = found {\n                return result;\n            }\n        }\n\n        let result = match (i, j) {\n            | (_, 0) => true,\n            | (0, _) => false,\n            | (i, j) => {\n                let element_value: i32 = (*table.multiset.nth(i - 1)).into();\n                if element_value > j {\n                    subset_sum_rec(table, i - 1, j)\n                } else {\n                    let table_clone1 = table.clone();\n                    let table_clone2 = table.clone();\n\n                    let handle1 = thread::spawn(move || subset_sum_rec(&table_clone1, i - 1, j - element_value));\n                    let handle2 = thread::spawn(move || subset_sum_rec(&table_clone2, i - 1, j));\n\n                    let result1 = handle1.join().unwrap();\n                    let result2 = handle2.join().unwrap();\n\n                    result1 || result2\n                }\n            }\n        };\n\n        {\n            let (mut current, write_handle) = table.memo.acquire_write();\n            current.insert((i, j), result);\n            write_handle.release_write(current);\n        }\n\n        result\n    }"
  },
  {
    "id": 2312,
    "function": "eq",
    "file": "Chap49/SubsetSumMtPer.rs",
    "lines": "173",
    "spec_strength": "",
    "snippet": "        fn eq(&self, other: &Self) -> bool { self.multiset == other.multiset }"
  },
  {
    "id": 2313,
    "function": "_subset_sum_st_eph_verified",
    "file": "Chap49/SubsetSumStEph.rs",
    "lines": "21",
    "spec_strength": "",
    "snippet": "        proof fn _subset_sum_st_eph_verified() {}"
  },
  {
    "id": 2314,
    "function": "new",
    "file": "Chap49/SubsetSumStEph.rs",
    "lines": "37-42",
    "spec_strength": "",
    "snippet": "        /// Create new subset sum solver\n        /// - APAS: not specified\n        /// - Claude-Opus-4.6: Work (1), Span (1)  outside verus!, not verified\n        fn new()                                      -> Self\n        where\n            T: Default;"
  },
  {
    "id": 2315,
    "function": "from_multiset",
    "file": "Chap49/SubsetSumStEph.rs",
    "lines": "44-47",
    "spec_strength": "",
    "snippet": "        /// Create from multiset\n        /// - APAS: not specified\n        /// - Claude-Opus-4.6: Work (1), Span (1)  outside verus!, not verified\n        fn from_multiset(multiset: ArraySeqStEphS<T>) -> Self;"
  },
  {
    "id": 2316,
    "function": "subset_sum",
    "file": "Chap49/SubsetSumStEph.rs",
    "lines": "49-53",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (k|S|), Span (|S|)\n        /// - Claude-Opus-4.6: Work (k|S|), Span (k|S|)  sequential, span equals work; outside verus!, not verified\n        fn subset_sum(&mut self, target: i32)         -> bool\n        where\n            T: Into<i32> + Copy;"
  },
  {
    "id": 2317,
    "function": "multiset",
    "file": "Chap49/SubsetSumStEph.rs",
    "lines": "55-58",
    "spec_strength": "",
    "snippet": "        /// Get the multiset\n        /// - APAS: not specified\n        /// - Claude-Opus-4.6: Work (1), Span (1)  outside verus!, not verified\n        fn multiset(&self)                            -> &ArraySeqStEphS<T>;"
  },
  {
    "id": 2318,
    "function": "multiset_mut",
    "file": "Chap49/SubsetSumStEph.rs",
    "lines": "60-63",
    "spec_strength": "",
    "snippet": "        /// Get mutable multiset (ephemeral allows mutation)\n        /// - APAS: not specified\n        /// - Claude-Opus-4.6: Work (1), Span (1)  outside verus!, not verified\n        fn multiset_mut(&mut self)                    -> &mut ArraySeqStEphS<T>;"
  },
  {
    "id": 2319,
    "function": "set",
    "file": "Chap49/SubsetSumStEph.rs",
    "lines": "65-68",
    "spec_strength": "",
    "snippet": "        /// Set element at index (ephemeral mutation)\n        /// - APAS: not specified\n        /// - Claude-Opus-4.6: Work (1), Span (1)  outside verus!, not verified\n        fn set(&mut self, index: usize, value: T);"
  },
  {
    "id": 2320,
    "function": "clear_memo",
    "file": "Chap49/SubsetSumStEph.rs",
    "lines": "70-73",
    "spec_strength": "",
    "snippet": "        /// Clear memoization table\n        /// - APAS: not specified\n        /// - Claude-Opus-4.6: Work (1), Span (1)  outside verus!, not verified\n        fn clear_memo(&mut self);"
  },
  {
    "id": 2321,
    "function": "memo_size",
    "file": "Chap49/SubsetSumStEph.rs",
    "lines": "75-78",
    "spec_strength": "",
    "snippet": "        /// Get memoization table size\n        /// - APAS: not specified\n        /// - Claude-Opus-4.6: Work (1), Span (1)  outside verus!, not verified\n        fn memo_size(&self)                           -> usize;"
  },
  {
    "id": 2322,
    "function": "subset_sum_rec",
    "file": "Chap49/SubsetSumStEph.rs",
    "lines": "83-105",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work (k|S|), Span (|S|)\n    /// - Claude-Opus-4.6: Work (k|S|), Span (k|S|)  sequential memoized recursion; outside verus!, not verified\n    fn subset_sum_rec<T: StT + Into<i32> + Copy>(table: &mut SubsetSumStEphS<T>, i: usize, j: i32) -> bool {\n        if let Some(&result) = table.memo.get(&(i, j)) {\n            return result;\n        }\n\n        let result = match (i, j) {\n            | (_, 0) => true,\n            | (0, _) => false,\n            | (i, j) => {\n                let element_value: i32 = (*table.multiset.nth(i - 1)).into();\n                if element_value > j {\n                    subset_sum_rec(table, i - 1, j)\n                } else {\n                    subset_sum_rec(table, i - 1, j - element_value) || subset_sum_rec(table, i - 1, j)\n                }\n            }\n        };\n\n        table.memo.insert((i, j), result);\n        result\n    }"
  },
  {
    "id": 2323,
    "function": "_subset_sum_st_per_verified",
    "file": "Chap49/SubsetSumStPer.rs",
    "lines": "21",
    "spec_strength": "",
    "snippet": "        proof fn _subset_sum_st_per_verified() {}"
  },
  {
    "id": 2324,
    "function": "new",
    "file": "Chap49/SubsetSumStPer.rs",
    "lines": "37-42",
    "spec_strength": "",
    "snippet": "        /// Create new subset sum solver\n        /// - APAS: not specified\n        /// - Claude-Opus-4.6: Work (1), Span (1)  outside verus!, not verified\n        fn new()                                      -> Self\n        where\n            T: Default;"
  },
  {
    "id": 2325,
    "function": "from_multiset",
    "file": "Chap49/SubsetSumStPer.rs",
    "lines": "44-47",
    "spec_strength": "",
    "snippet": "        /// Create from multiset\n        /// - APAS: not specified\n        /// - Claude-Opus-4.6: Work (1), Span (1)  outside verus!, not verified\n        fn from_multiset(multiset: ArraySeqStPerS<T>) -> Self;"
  },
  {
    "id": 2326,
    "function": "subset_sum",
    "file": "Chap49/SubsetSumStPer.rs",
    "lines": "49-53",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (k|S|), Span (|S|)\n        /// - Claude-Opus-4.6: Work (k|S|), Span (k|S|)  sequential, span equals work; outside verus!, not verified\n        fn subset_sum(&self, target: i32)             -> bool\n        where\n            T: Into<i32> + Copy;"
  },
  {
    "id": 2327,
    "function": "multiset",
    "file": "Chap49/SubsetSumStPer.rs",
    "lines": "55-58",
    "spec_strength": "",
    "snippet": "        /// Get the multiset\n        /// - APAS: not specified\n        /// - Claude-Opus-4.6: Work (1), Span (1)  outside verus!, not verified\n        fn multiset(&self)                            -> &ArraySeqStPerS<T>;"
  },
  {
    "id": 2328,
    "function": "memo_size",
    "file": "Chap49/SubsetSumStPer.rs",
    "lines": "60-63",
    "spec_strength": "",
    "snippet": "        /// Get memoization table size\n        /// - APAS: not specified\n        /// - Claude-Opus-4.6: Work (1), Span (1)  outside verus!, not verified\n        fn memo_size(&self)                           -> usize;"
  },
  {
    "id": 2329,
    "function": "subset_sum_rec",
    "file": "Chap49/SubsetSumStPer.rs",
    "lines": "68-90",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work (k|S|), Span (|S|)\n    /// - Claude-Opus-4.6: Work (k|S|), Span (k|S|)  sequential memoized recursion; outside verus!, not verified\n    fn subset_sum_rec<T: StT + Into<i32> + Copy>(table: &mut SubsetSumStPerS<T>, i: usize, j: i32) -> bool {\n        if let Some(&result) = table.memo.get(&(i, j)) {\n            return result;\n        }\n\n        let result = match (i, j) {\n            | (_, 0) => true,\n            | (0, _) => false,\n            | (i, j) => {\n                let element_value: i32 = (*table.multiset.nth(i - 1)).into();\n                if element_value > j {\n                    subset_sum_rec(table, i - 1, j)\n                } else {\n                    subset_sum_rec(table, i - 1, j - element_value) || subset_sum_rec(table, i - 1, j)\n                }\n            }\n        };\n\n        table.memo.insert((i, j), result);\n        result\n    }"
  },
  {
    "id": 2330,
    "function": "eq`",
    "file": "Chap50/MatrixChainMtEph.rs",
    "lines": "54-55",
    "spec_strength": "hole",
    "snippet": "        fn eq(&self, other: &Self) -> (r: bool)\n            ensures r == (self@ == other@)"
  },
  {
    "id": 2331,
    "function": "new_mceph_dim_lock",
    "file": "Chap50/MatrixChainMtEph.rs",
    "lines": "68",
    "spec_strength": "hole",
    "snippet": "        fn new_mceph_dim_lock(val: Vec<MatrixDim>) -> (lock: RwLock<Vec<MatrixDim>, McEphDimWf>) {"
  },
  {
    "id": 2332,
    "function": "new_mceph_memo_lock",
    "file": "Chap50/MatrixChainMtEph.rs",
    "lines": "77",
    "spec_strength": "hole",
    "snippet": "        fn new_mceph_memo_lock(val: HashMap<(usize, usize), usize>) -> (lock: RwLock<HashMap<(usize, usize), usize>, McEphMemoWf>) {"
  },
  {
    "id": 2333,
    "function": "new",
    "file": "Chap50/MatrixChainMtEph.rs",
    "lines": "92-94",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (1), Span (1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)  allocate Arc<RwLock> wrappers\n        fn new()                                              -> Self;"
  },
  {
    "id": 2334,
    "function": "from_dimensions",
    "file": "Chap50/MatrixChainMtEph.rs",
    "lines": "96-98",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (1), Span (1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)  wrap Vec in Arc<RwLock>\n        fn from_dimensions(dimensions: Vec<MatrixDim>)        -> Self;"
  },
  {
    "id": 2335,
    "function": "from_dim_pairs",
    "file": "Chap50/MatrixChainMtEph.rs",
    "lines": "100-102",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (n), Span (n)\n        /// - Claude-Opus-4.6: Work (n), Span (n)  map n pairs then wrap in Arc<RwLock>\n        fn from_dim_pairs(dim_pairs: Vec<Pair<usize, usize>>) -> Self;"
  },
  {
    "id": 2336,
    "function": "optimal_cost",
    "file": "Chap50/MatrixChainMtEph.rs",
    "lines": "104-106",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (n), Span (n lg n)\n        /// - Claude-Opus-4.6: Work (n), Span (n lg n)  memoized DP with parallel min reduction\n        fn optimal_cost(&mut self)                            -> usize;"
  },
  {
    "id": 2337,
    "function": "dimensions",
    "file": "Chap50/MatrixChainMtEph.rs",
    "lines": "108-110",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (n), Span (n)\n        /// - Claude-Opus-4.6: Work (n), Span (n)  clone Vec under read lock\n        fn dimensions(&self)                                  -> Vec<MatrixDim>;"
  },
  {
    "id": 2338,
    "function": "set_dimension",
    "file": "Chap50/MatrixChainMtEph.rs",
    "lines": "112-114",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (1), Span (1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)  write under lock plus memo clear\n        fn set_dimension(&mut self, index: usize, dim: MatrixDim);"
  },
  {
    "id": 2339,
    "function": "update_dimension",
    "file": "Chap50/MatrixChainMtEph.rs",
    "lines": "116-118",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (1), Span (1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)  write under lock plus memo clear\n        fn update_dimension(&mut self, index: usize, rows: usize, cols: usize);"
  },
  {
    "id": 2340,
    "function": "num_matrices",
    "file": "Chap50/MatrixChainMtEph.rs",
    "lines": "120-122",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (1), Span (1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)  Vec::len under read lock\n        fn num_matrices(&self)                                -> usize;"
  },
  {
    "id": 2341,
    "function": "clear_memo",
    "file": "Chap50/MatrixChainMtEph.rs",
    "lines": "124-126",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (1), Span (1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)  HashMap::clear under write lock\n        fn clear_memo(&mut self);"
  },
  {
    "id": 2342,
    "function": "memo_size",
    "file": "Chap50/MatrixChainMtEph.rs",
    "lines": "128-130",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (1), Span (1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)  HashMap::len under read lock\n        fn memo_size(&self)                                   -> usize;"
  },
  {
    "id": 2343,
    "function": "multiply_cost_mt_eph",
    "file": "Chap50/MatrixChainMtEph.rs",
    "lines": "135-142",
    "spec_strength": "",
    "snippet": "    fn multiply_cost_mt_eph(s: &MatrixChainMtEphS, i: usize, k: usize, j: usize) -> usize {\n        let handle = s.dimensions.acquire_read();\n        let left_rows = handle.borrow()[i].rows;\n        let split_cols = handle.borrow()[k].cols;\n        let right_cols = handle.borrow()[j].cols;\n        handle.release_read();\n        left_rows * split_cols * right_cols\n    }"
  },
  {
    "id": 2344,
    "function": "parallel_min_reduction",
    "file": "Chap50/MatrixChainMtEph.rs",
    "lines": "144-166",
    "spec_strength": "",
    "snippet": "    fn parallel_min_reduction(s: &MatrixChainMtEphS, costs: Vec<usize>) -> usize {\n        if costs.is_empty() {\n            return usize::MAX;\n        }\n        if costs.len() == 1 {\n            return costs[0];\n        }\n\n        let mid = costs.len() / 2;\n        let left_costs = costs[..mid].to_vec();\n        let right_costs = costs[mid..].to_vec();\n\n        let s1 = s.clone();\n        let s2 = s.clone();\n\n        let handle1 = thread::spawn(move || parallel_min_reduction(&s1, left_costs));\n        let handle2 = thread::spawn(move || parallel_min_reduction(&s2, right_costs));\n\n        let left_min = handle1.join().unwrap();\n        let right_min = handle2.join().unwrap();\n\n        left_min.min(right_min)\n    }"
  },
  {
    "id": 2345,
    "function": "matrix_chain_rec_mt_eph",
    "file": "Chap50/MatrixChainMtEph.rs",
    "lines": "168-200",
    "spec_strength": "",
    "snippet": "    fn matrix_chain_rec_mt_eph(s: &MatrixChainMtEphS, i: usize, j: usize) -> usize {\n        {\n            let handle = s.memo.acquire_read();\n            let cached = handle.borrow().get(&(i, j)).copied();\n            handle.release_read();\n            if let Some(result) = cached {\n                return result;\n            }\n        }\n\n        let result = if i == j {\n            0\n        } else {\n            let costs = (i..j)\n                .map(|k| {\n                    let left_cost = matrix_chain_rec_mt_eph(s, i, k);\n                    let right_cost = matrix_chain_rec_mt_eph(s, k + 1, j);\n                    let split_cost = multiply_cost_mt_eph(s, i, k, j);\n                    left_cost + right_cost + split_cost\n                })\n                .collect::<Vec<usize>>();\n\n            parallel_min_reduction(s, costs)\n        };\n\n        {\n            let (mut memo, write_handle) = s.memo.acquire_write();\n            memo.insert((i, j), result);\n            write_handle.release_write(memo);\n        }\n\n        result\n    }"
  },
  {
    "id": 2346,
    "function": "eq`",
    "file": "Chap50/MatrixChainMtPer.rs",
    "lines": "56-57",
    "spec_strength": "hole",
    "snippet": "        fn eq(&self, other: &Self) -> (r: bool)\n            ensures r == (self@ == other@)"
  },
  {
    "id": 2347,
    "function": "new_mcper_memo_lock",
    "file": "Chap50/MatrixChainMtPer.rs",
    "lines": "70",
    "spec_strength": "hole",
    "snippet": "        fn new_mcper_memo_lock(val: HashMap<(usize, usize), usize>) -> (lock: RwLock<HashMap<(usize, usize), usize>, McPerMemoWf>) {"
  },
  {
    "id": 2348,
    "function": "new",
    "file": "Chap50/MatrixChainMtPer.rs",
    "lines": "85-87",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (1), Span (1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)  allocate Arc wrappers\n        fn new()                                              -> Self;"
  },
  {
    "id": 2349,
    "function": "from_dimensions",
    "file": "Chap50/MatrixChainMtPer.rs",
    "lines": "89-91",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (1), Span (1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)  wrap Vec in Arc\n        fn from_dimensions(dimensions: Vec<MatrixDim>)        -> Self;"
  },
  {
    "id": 2350,
    "function": "from_dim_pairs",
    "file": "Chap50/MatrixChainMtPer.rs",
    "lines": "93-95",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (n), Span (n)\n        /// - Claude-Opus-4.6: Work (n), Span (n)  map n pairs then wrap in Arc\n        fn from_dim_pairs(dim_pairs: Vec<Pair<usize, usize>>) -> Self;"
  },
  {
    "id": 2351,
    "function": "optimal_cost",
    "file": "Chap50/MatrixChainMtPer.rs",
    "lines": "97-99",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (n), Span (n lg n)\n        /// - Claude-Opus-4.6: Work (n), Span (n lg n)  memoized DP with parallel min reduction\n        fn optimal_cost(&self)                                -> usize;"
  },
  {
    "id": 2352,
    "function": "dimensions",
    "file": "Chap50/MatrixChainMtPer.rs",
    "lines": "101-103",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (1), Span (1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)  Arc reference access\n        fn dimensions(&self)                                  -> &Arc<Vec<MatrixDim>>;"
  },
  {
    "id": 2353,
    "function": "num_matrices",
    "file": "Chap50/MatrixChainMtPer.rs",
    "lines": "105-107",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (1), Span (1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)  Vec::len through Arc\n        fn num_matrices(&self)                                -> usize;"
  },
  {
    "id": 2354,
    "function": "memo_size",
    "file": "Chap50/MatrixChainMtPer.rs",
    "lines": "109-111",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (1), Span (1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)  HashMap::len under read lock\n        fn memo_size(&self)                                   -> usize;"
  },
  {
    "id": 2355,
    "function": "multiply_cost_mt_per",
    "file": "Chap50/MatrixChainMtPer.rs",
    "lines": "116-121",
    "spec_strength": "",
    "snippet": "    fn multiply_cost_mt_per(s: &MatrixChainMtPerS, i: usize, k: usize, j: usize) -> usize {\n        let left_rows = s.dimensions[i].rows;\n        let split_cols = s.dimensions[k].cols;\n        let right_cols = s.dimensions[j].cols;\n        left_rows * split_cols * right_cols\n    }"
  },
  {
    "id": 2356,
    "function": "parallel_min_reduction_mt_per",
    "file": "Chap50/MatrixChainMtPer.rs",
    "lines": "123-145",
    "spec_strength": "",
    "snippet": "    fn parallel_min_reduction_mt_per(s: &MatrixChainMtPerS, costs: Vec<usize>) -> usize {\n        if costs.is_empty() {\n            return usize::MAX;\n        }\n        if costs.len() == 1 {\n            return costs[0];\n        }\n\n        let mid = costs.len() / 2;\n        let left_costs = costs[..mid].to_vec();\n        let right_costs = costs[mid..].to_vec();\n\n        let s1 = s.clone();\n        let s2 = s.clone();\n\n        let handle1 = thread::spawn(move || parallel_min_reduction_mt_per(&s1, left_costs));\n        let handle2 = thread::spawn(move || parallel_min_reduction_mt_per(&s2, right_costs));\n\n        let left_min = handle1.join().unwrap();\n        let right_min = handle2.join().unwrap();\n\n        left_min.min(right_min)\n    }"
  },
  {
    "id": 2357,
    "function": "matrix_chain_rec_mt_per",
    "file": "Chap50/MatrixChainMtPer.rs",
    "lines": "147-179",
    "spec_strength": "",
    "snippet": "    fn matrix_chain_rec_mt_per(s: &MatrixChainMtPerS, i: usize, j: usize) -> usize {\n        {\n            let handle = s.memo.acquire_read();\n            let cached = handle.borrow().get(&(i, j)).copied();\n            handle.release_read();\n            if let Some(result) = cached {\n                return result;\n            }\n        }\n\n        let result = if i == j {\n            0\n        } else {\n            let costs = (i..j)\n                .map(|k| {\n                    let left_cost = matrix_chain_rec_mt_per(s, i, k);\n                    let right_cost = matrix_chain_rec_mt_per(s, k + 1, j);\n                    let split_cost = multiply_cost_mt_per(s, i, k, j);\n                    left_cost + right_cost + split_cost\n                })\n                .collect::<Vec<usize>>();\n\n            parallel_min_reduction_mt_per(s, costs)\n        };\n\n        {\n            let (mut memo, write_handle) = s.memo.acquire_write();\n            memo.insert((i, j), result);\n            write_handle.release_write(memo);\n        }\n\n        result\n    }"
  },
  {
    "id": 2358,
    "function": "eq",
    "file": "Chap50/MatrixChainStEph.rs",
    "lines": "51-52",
    "spec_strength": "hole",
    "snippet": "        fn eq(&self, other: &Self) -> (r: bool)\n            ensures r == (self@ == other@)"
  },
  {
    "id": 2359,
    "function": "new",
    "file": "Chap50/MatrixChainStEph.rs",
    "lines": "75-77",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (1), Span (1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)  allocate empty collections\n        fn new()                                              -> Self;"
  },
  {
    "id": 2360,
    "function": "from_dimensions",
    "file": "Chap50/MatrixChainStEph.rs",
    "lines": "79-81",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (1), Span (1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)  move ownership of Vec\n        fn from_dimensions(dimensions: Vec<MatrixDim>)        -> Self;"
  },
  {
    "id": 2361,
    "function": "from_dim_pairs",
    "file": "Chap50/MatrixChainStEph.rs",
    "lines": "83-85",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (n), Span (n)\n        /// - Claude-Opus-4.6: Work (n), Span (n)  map n pairs to MatrixDim\n        fn from_dim_pairs(dim_pairs: Vec<Pair<usize, usize>>) -> Self;"
  },
  {
    "id": 2362,
    "function": "optimal_cost",
    "file": "Chap50/MatrixChainStEph.rs",
    "lines": "87-89",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (n), Span (n)\n        /// - Claude-Opus-4.6: Work (n), Span (n)  memoized DP, n subproblems  O(n) each, sequential\n        fn optimal_cost(&mut self)                            -> usize;"
  },
  {
    "id": 2363,
    "function": "dimensions",
    "file": "Chap50/MatrixChainStEph.rs",
    "lines": "91-93",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (1), Span (1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)  reference access\n        fn dimensions(&self)                                  -> &Vec<MatrixDim>;"
  },
  {
    "id": 2364,
    "function": "dimensions_mut",
    "file": "Chap50/MatrixChainStEph.rs",
    "lines": "95-97",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (1), Span (1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)  mutable reference access\n        fn dimensions_mut(&mut self)                          -> &mut Vec<MatrixDim>;"
  },
  {
    "id": 2365,
    "function": "set_dimension",
    "file": "Chap50/MatrixChainStEph.rs",
    "lines": "99-101",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (1), Span (1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)  array write plus memo clear\n        fn set_dimension(&mut self, index: usize, dim: MatrixDim);"
  },
  {
    "id": 2366,
    "function": "update_dimension",
    "file": "Chap50/MatrixChainStEph.rs",
    "lines": "103-105",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (1), Span (1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)  array write plus memo clear\n        fn update_dimension(&mut self, index: usize, rows: usize, cols: usize);"
  },
  {
    "id": 2367,
    "function": "num_matrices",
    "file": "Chap50/MatrixChainStEph.rs",
    "lines": "107-109",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (1), Span (1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)  Vec::len\n        fn num_matrices(&self)                                -> usize;"
  },
  {
    "id": 2368,
    "function": "clear_memo",
    "file": "Chap50/MatrixChainStEph.rs",
    "lines": "111-113",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (1), Span (1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)  HashMap::clear\n        fn clear_memo(&mut self);"
  },
  {
    "id": 2369,
    "function": "memo_size",
    "file": "Chap50/MatrixChainStEph.rs",
    "lines": "115-117",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (1), Span (1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)  HashMap::len\n        fn memo_size(&self)                                   -> usize;"
  },
  {
    "id": 2370,
    "function": "multiply_cost_st_eph",
    "file": "Chap50/MatrixChainStEph.rs",
    "lines": "122-127",
    "spec_strength": "",
    "snippet": "    fn multiply_cost_st_eph(s: &MatrixChainStEphS, i: usize, k: usize, j: usize) -> usize {\n        let left_rows = s.dimensions[i].rows;\n        let split_cols = s.dimensions[k].cols;\n        let right_cols = s.dimensions[j].cols;\n        left_rows * split_cols * right_cols\n    }"
  },
  {
    "id": 2371,
    "function": "matrix_chain_rec_st_eph",
    "file": "Chap50/MatrixChainStEph.rs",
    "lines": "129-150",
    "spec_strength": "",
    "snippet": "    fn matrix_chain_rec_st_eph(s: &mut MatrixChainStEphS, i: usize, j: usize) -> usize {\n        if let Some(&result) = s.memo.get(&(i, j)) {\n            return result;\n        }\n\n        let result = if i == j {\n            0\n        } else {\n            (i..j)\n                .map(|k| {\n                    let left_cost = matrix_chain_rec_st_eph(s, i, k);\n                    let right_cost = matrix_chain_rec_st_eph(s, k + 1, j);\n                    let split_cost = multiply_cost_st_eph(s, i, k, j);\n                    left_cost + right_cost + split_cost\n                })\n                .min()\n                .unwrap_or(0)\n        };\n\n        s.memo.insert((i, j), result);\n        result\n    }"
  },
  {
    "id": 2372,
    "function": "eq",
    "file": "Chap50/MatrixChainStPer.rs",
    "lines": "53-54",
    "spec_strength": "hole",
    "snippet": "        fn eq(&self, other: &Self) -> (r: bool)\n            ensures r == (self@ == other@)"
  },
  {
    "id": 2373,
    "function": "new",
    "file": "Chap50/MatrixChainStPer.rs",
    "lines": "77-79",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (1), Span (1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)  allocate empty collections\n        fn new()                                              -> Self;"
  },
  {
    "id": 2374,
    "function": "from_dimensions",
    "file": "Chap50/MatrixChainStPer.rs",
    "lines": "81-83",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (1), Span (1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)  move ownership of Vec\n        fn from_dimensions(dimensions: Vec<MatrixDim>)        -> Self;"
  },
  {
    "id": 2375,
    "function": "from_dim_pairs",
    "file": "Chap50/MatrixChainStPer.rs",
    "lines": "85-87",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (n), Span (n)\n        /// - Claude-Opus-4.6: Work (n), Span (n)  map n pairs to MatrixDim\n        fn from_dim_pairs(dim_pairs: Vec<Pair<usize, usize>>) -> Self;"
  },
  {
    "id": 2376,
    "function": "optimal_cost",
    "file": "Chap50/MatrixChainStPer.rs",
    "lines": "89-91",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (n), Span (n)\n        /// - Claude-Opus-4.6: Work (n), Span (n)  clones self then invokes memoized DP, sequential\n        fn optimal_cost(&self)                                -> usize;"
  },
  {
    "id": 2377,
    "function": "dimensions",
    "file": "Chap50/MatrixChainStPer.rs",
    "lines": "93-95",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (1), Span (1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)  reference access\n        fn dimensions(&self)                                  -> &Vec<MatrixDim>;"
  },
  {
    "id": 2378,
    "function": "num_matrices",
    "file": "Chap50/MatrixChainStPer.rs",
    "lines": "97-99",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (1), Span (1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)  Vec::len\n        fn num_matrices(&self)                                -> usize;"
  },
  {
    "id": 2379,
    "function": "memo_size",
    "file": "Chap50/MatrixChainStPer.rs",
    "lines": "101-103",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (1), Span (1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)  HashMap::len\n        fn memo_size(&self)                                   -> usize;"
  },
  {
    "id": 2380,
    "function": "multiply_cost_st_per",
    "file": "Chap50/MatrixChainStPer.rs",
    "lines": "108-113",
    "spec_strength": "",
    "snippet": "    fn multiply_cost_st_per(s: &MatrixChainStPerS, i: usize, k: usize, j: usize) -> usize {\n        let left_rows = s.dimensions[i].rows;\n        let split_cols = s.dimensions[k].cols;\n        let right_cols = s.dimensions[j].cols;\n        left_rows * split_cols * right_cols\n    }"
  },
  {
    "id": 2381,
    "function": "matrix_chain_rec_st_per",
    "file": "Chap50/MatrixChainStPer.rs",
    "lines": "115-136",
    "spec_strength": "",
    "snippet": "    fn matrix_chain_rec_st_per(s: &mut MatrixChainStPerS, i: usize, j: usize) -> usize {\n        if let Some(&result) = s.memo.get(&(i, j)) {\n            return result;\n        }\n\n        let result = if i == j {\n            0\n        } else {\n            (i..j)\n                .map(|k| {\n                    let left_cost = matrix_chain_rec_st_per(s, i, k);\n                    let right_cost = matrix_chain_rec_st_per(s, k + 1, j);\n                    let split_cost = multiply_cost_st_per(s, i, k, j);\n                    left_cost + right_cost + split_cost\n                })\n                .min()\n                .unwrap_or(0)\n        };\n\n        s.memo.insert((i, j), result);\n        result\n    }"
  },
  {
    "id": 2382,
    "function": "new_obst_eph_keys_lock",
    "file": "Chap50/OptBinSearchTreeMtEph.rs",
    "lines": "46",
    "spec_strength": "hole",
    "snippet": "        fn new_obst_eph_keys_lock<T: MtVal>(val: Vec<KeyProb<T>>) -> (lock: RwLock<Vec<KeyProb<T>>, ObstEphKeysWf>) {"
  },
  {
    "id": 2383,
    "function": "new_obst_eph_memo_lock",
    "file": "Chap50/OptBinSearchTreeMtEph.rs",
    "lines": "55",
    "spec_strength": "hole",
    "snippet": "        fn new_obst_eph_memo_lock(val: HashMap<(usize, usize), Probability>) -> (lock: RwLock<HashMap<(usize, usize), Probability>, ObstEphMemoWf>) {"
  },
  {
    "id": 2384,
    "function": "new",
    "file": "Chap50/OptBinSearchTreeMtEph.rs",
    "lines": "63-65",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (1), Span (1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)  allocate Arc<RwLock> wrappers\n        fn new()                                                  -> Self;"
  },
  {
    "id": 2385,
    "function": "from_keys_probs",
    "file": "Chap50/OptBinSearchTreeMtEph.rs",
    "lines": "67-69",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (n), Span (n)\n        /// - Claude-Opus-4.6: Work (n), Span (n)  zip n keys with probabilities then wrap in Arc<RwLock>\n        fn from_keys_probs(keys: Vec<T>, probs: Vec<Probability>) -> Self;"
  },
  {
    "id": 2386,
    "function": "from_key_probs",
    "file": "Chap50/OptBinSearchTreeMtEph.rs",
    "lines": "71-73",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (1), Span (1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)  wrap Vec in Arc<RwLock>\n        fn from_key_probs(key_probs: Vec<KeyProb<T>>)             -> Self;"
  },
  {
    "id": 2387,
    "function": "optimal_cost",
    "file": "Chap50/OptBinSearchTreeMtEph.rs",
    "lines": "75-79",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (n), Span (n lg n)\n        /// - Claude-Opus-4.6: Work (n), Span (n lg n)  memoized DP with parallel min reduction\n        fn optimal_cost(&mut self)                                -> Probability\n        where\n            T: Send + Sync + 'static;"
  },
  {
    "id": 2388,
    "function": "keys",
    "file": "Chap50/OptBinSearchTreeMtEph.rs",
    "lines": "81-83",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (n), Span (n)\n        /// - Claude-Opus-4.6: Work (n), Span (n)  clone Vec under read lock\n        fn keys(&self)                                            -> Vec<KeyProb<T>>;"
  },
  {
    "id": 2389,
    "function": "set_key_prob",
    "file": "Chap50/OptBinSearchTreeMtEph.rs",
    "lines": "85-87",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (1), Span (1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)  write under lock plus memo clear\n        fn set_key_prob(&mut self, index: usize, key_prob: KeyProb<T>);"
  },
  {
    "id": 2390,
    "function": "update_prob",
    "file": "Chap50/OptBinSearchTreeMtEph.rs",
    "lines": "89-91",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (1), Span (1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)  field write under lock plus memo clear\n        fn update_prob(&mut self, index: usize, prob: Probability);"
  },
  {
    "id": 2391,
    "function": "num_keys",
    "file": "Chap50/OptBinSearchTreeMtEph.rs",
    "lines": "93-95",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (1), Span (1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)  Vec::len under read lock\n        fn num_keys(&self)                                        -> usize;"
  },
  {
    "id": 2392,
    "function": "clear_memo",
    "file": "Chap50/OptBinSearchTreeMtEph.rs",
    "lines": "97-99",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (1), Span (1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)  HashMap::clear under write lock\n        fn clear_memo(&mut self);"
  },
  {
    "id": 2393,
    "function": "memo_size",
    "file": "Chap50/OptBinSearchTreeMtEph.rs",
    "lines": "101-103",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (1), Span (1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)  HashMap::len under read lock\n        fn memo_size(&self)                                       -> usize;"
  },
  {
    "id": 2394,
    "function": "parallel_min_reduction",
    "file": "Chap50/OptBinSearchTreeMtEph.rs",
    "lines": "106-132",
    "spec_strength": "",
    "snippet": "    // 9. impls\n    /// - APAS: Work (n), Span (lg n)\n    /// - Claude-Opus-4.6: Work (n), Span (lg n)  parallel divide-and-conquer min reduction\n    fn parallel_min_reduction<T: MtVal>(table: &OBSTMtEphS<T>, costs: Vec<Probability>) -> Probability {\n        if costs.is_empty() {\n            return Probability::infinity();\n        }\n        if costs.len() == 1 {\n            return costs[0];\n        }\n\n        let mid = costs.len() / 2;\n        let left_costs = costs[..mid].to_vec();\n        let right_costs = costs[mid..].to_vec();\n\n        let table_clone1 = table.clone();\n        let table_clone2 = table.clone();\n\n        let handle1 = thread::spawn(move || parallel_min_reduction(&table_clone1, left_costs));\n\n        let handle2 = thread::spawn(move || parallel_min_reduction(&table_clone2, right_costs));\n\n        let left_min = handle1.join().unwrap();\n        let right_min = handle2.join().unwrap();\n\n        std::cmp::min(left_min, right_min)\n    }"
  },
  {
    "id": 2395,
    "function": "obst_rec",
    "file": "Chap50/OptBinSearchTreeMtEph.rs",
    "lines": "134-178",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work (n), Span (n lg n)\n    /// - Claude-Opus-4.6: Work (n), Span (n lg n)  memoized DP per Algorithm 50.3, parallel min reduction per subproblem\n    fn obst_rec<T: MtVal + Send + Sync + 'static>(table: &OBSTMtEphS<T>, i: usize, l: usize) -> Probability {\n        {\n            let handle = table.memo.acquire_read();\n            let cached = handle.borrow().get(&(i, l)).copied();\n            handle.release_read();\n            if let Some(result) = cached {\n                return result;\n            }\n        }\n\n        let result = if l == 0 {\n            Probability::zero()\n        } else {\n            let prob_sum = {\n                let handle = table.keys.acquire_read();\n                let keys = handle.borrow();\n                let sum = (0..l)\n                    .map(|k| keys[i + k].prob)\n                    .fold(Probability::zero(), |acc, p| acc + p);\n                handle.release_read();\n                sum\n            };\n\n            let costs = (0..l)\n                .map(|k| {\n                    let left_cost = obst_rec(table, i, k);\n                    let right_cost = obst_rec(table, i + k + 1, l - k - 1);\n                    left_cost + right_cost\n                }).collect::<Vec<Probability>>();\n\n            let min_cost = parallel_min_reduction(table, costs);\n\n            prob_sum + min_cost\n        };\n\n        {\n            let (mut memo, write_handle) = table.memo.acquire_write();\n            memo.insert((i, l), result);\n            write_handle.release_write(memo);\n        }\n\n        result\n    }"
  },
  {
    "id": 2396,
    "function": "eq`",
    "file": "Chap50/OptBinSearchTreeMtEph.rs",
    "lines": "303-312",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (n), Span (n)\n        /// - Claude-Opus-4.6: Work (n), Span (n)  compare Vec contents under read locks\n        fn eq(&self, other: &Self) -> bool {\n            let self_handle = self.keys.acquire_read();\n            let other_handle = other.keys.acquire_read();\n            let result = *self_handle.borrow() == *other_handle.borrow();\n            other_handle.release_read();\n            self_handle.release_read();\n            result\n        }"
  },
  {
    "id": 2397,
    "function": "new_obst_per_memo_lock",
    "file": "Chap50/OptBinSearchTreeMtPer.rs",
    "lines": "44",
    "spec_strength": "hole",
    "snippet": "        fn new_obst_per_memo_lock(val: HashMap<(usize, usize), Probability>) -> (lock: RwLock<HashMap<(usize, usize), Probability>, ObstPerMemoWf>) {"
  },
  {
    "id": 2398,
    "function": "new",
    "file": "Chap50/OptBinSearchTreeMtPer.rs",
    "lines": "52-54",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (1), Span (1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)  allocate Arc wrappers\n        fn new()                                                  -> Self;"
  },
  {
    "id": 2399,
    "function": "from_keys_probs",
    "file": "Chap50/OptBinSearchTreeMtPer.rs",
    "lines": "56-58",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (n), Span (n)\n        /// - Claude-Opus-4.6: Work (n), Span (n)  zip n keys with probabilities then wrap in Arc\n        fn from_keys_probs(keys: Vec<T>, probs: Vec<Probability>) -> Self;"
  },
  {
    "id": 2400,
    "function": "from_key_probs",
    "file": "Chap50/OptBinSearchTreeMtPer.rs",
    "lines": "60-62",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (1), Span (1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)  wrap Vec in Arc\n        fn from_key_probs(key_probs: Vec<KeyProb<T>>)             -> Self;"
  },
  {
    "id": 2401,
    "function": "optimal_cost",
    "file": "Chap50/OptBinSearchTreeMtPer.rs",
    "lines": "64-68",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (n), Span (n lg n)\n        /// - Claude-Opus-4.6: Work (n), Span (n lg n)  memoized DP with parallel min reduction\n        fn optimal_cost(&self)                                    -> Probability\n        where\n            T: Send + Sync + 'static;"
  },
  {
    "id": 2402,
    "function": "keys",
    "file": "Chap50/OptBinSearchTreeMtPer.rs",
    "lines": "70-72",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (1), Span (1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)  Arc reference access\n        fn keys(&self)                                            -> &Arc<Vec<KeyProb<T>>>;"
  },
  {
    "id": 2403,
    "function": "num_keys",
    "file": "Chap50/OptBinSearchTreeMtPer.rs",
    "lines": "74-76",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (1), Span (1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)  Vec::len through Arc\n        fn num_keys(&self)                                        -> usize;"
  },
  {
    "id": 2404,
    "function": "memo_size",
    "file": "Chap50/OptBinSearchTreeMtPer.rs",
    "lines": "78-80",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (1), Span (1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)  HashMap::len under read lock\n        fn memo_size(&self)                                       -> usize;"
  },
  {
    "id": 2405,
    "function": "parallel_min_reduction",
    "file": "Chap50/OptBinSearchTreeMtPer.rs",
    "lines": "83-109",
    "spec_strength": "",
    "snippet": "    // 9. impls\n    /// - APAS: Work (n), Span (lg n)\n    /// - Claude-Opus-4.6: Work (n), Span (lg n)  parallel divide-and-conquer min reduction\n    fn parallel_min_reduction<T: MtVal>(table: &OBSTMtPerS<T>, costs: Vec<Probability>) -> Probability {\n        if costs.is_empty() {\n            return Probability::infinity();\n        }\n        if costs.len() == 1 {\n            return costs[0];\n        }\n\n        let mid = costs.len() / 2;\n        let left_costs = costs[..mid].to_vec();\n        let right_costs = costs[mid..].to_vec();\n\n        let table_clone1 = table.clone();\n        let table_clone2 = table.clone();\n\n        let handle1 = thread::spawn(move || parallel_min_reduction(&table_clone1, left_costs));\n\n        let handle2 = thread::spawn(move || parallel_min_reduction(&table_clone2, right_costs));\n\n        let left_min = handle1.join().unwrap();\n        let right_min = handle2.join().unwrap();\n\n        std::cmp::min(left_min, right_min)\n    }"
  },
  {
    "id": 2406,
    "function": "obst_rec",
    "file": "Chap50/OptBinSearchTreeMtPer.rs",
    "lines": "111-149",
    "spec_strength": "",
    "snippet": "    /// - APAS: Work (n), Span (n lg n)\n    /// - Claude-Opus-4.6: Work (n), Span (n lg n)  memoized DP per Algorithm 50.3, parallel min reduction per subproblem\n    fn obst_rec<T: MtVal + Send + Sync + 'static>(table: &OBSTMtPerS<T>, i: usize, l: usize) -> Probability {\n        {\n            let handle = table.memo.acquire_read();\n            let cached = handle.borrow().get(&(i, l)).copied();\n            handle.release_read();\n            if let Some(result) = cached {\n                return result;\n            }\n        }\n\n        let result = if l == 0 {\n            Probability::zero()\n        } else {\n            let prob_sum = (0..l)\n                .map(|k| table.keys[i + k].prob)\n                .fold(Probability::zero(), |acc, p| acc + p);\n\n            let costs = (0..l)\n                .map(|k| {\n                    let left_cost = obst_rec(table, i, k);\n                    let right_cost = obst_rec(table, i + k + 1, l - k - 1);\n                    left_cost + right_cost\n                }).collect::<Vec<Probability>>();\n\n            let min_cost = parallel_min_reduction(table, costs);\n\n            prob_sum + min_cost\n        };\n\n        {\n            let (mut memo, write_handle) = table.memo.acquire_write();\n            memo.insert((i, l), result);\n            write_handle.release_write(memo);\n        }\n\n        result\n    }"
  },
  {
    "id": 2407,
    "function": "eq`",
    "file": "Chap50/OptBinSearchTreeMtPer.rs",
    "lines": "224-226",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (n), Span (n)\n        /// - Claude-Opus-4.6: Work (n), Span (n)  compare Arc<Vec> contents\n        fn eq(&self, other: &Self) -> bool { self.keys == other.keys }"
  },
  {
    "id": 2408,
    "function": "new",
    "file": "Chap50/OptBinSearchTreeStEph.rs",
    "lines": "50-52",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (1), Span (1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)  allocate empty collections\n        fn new()                                                  -> Self;"
  },
  {
    "id": 2409,
    "function": "from_keys_probs",
    "file": "Chap50/OptBinSearchTreeStEph.rs",
    "lines": "54-56",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (n), Span (n)\n        /// - Claude-Opus-4.6: Work (n), Span (n)  zip and map n keys with probabilities\n        fn from_keys_probs(keys: Vec<T>, probs: Vec<Probability>) -> Self;"
  },
  {
    "id": 2410,
    "function": "from_key_probs",
    "file": "Chap50/OptBinSearchTreeStEph.rs",
    "lines": "58-60",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (1), Span (1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)  move ownership of Vec\n        fn from_key_probs(key_probs: Vec<KeyProb<T>>)             -> Self;"
  },
  {
    "id": 2411,
    "function": "optimal_cost",
    "file": "Chap50/OptBinSearchTreeStEph.rs",
    "lines": "62-64",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (n), Span (n)\n        /// - Claude-Opus-4.6: Work (n), Span (n)  memoized DP, n subproblems  O(n) each, sequential\n        fn optimal_cost(&mut self)                                -> Probability;"
  },
  {
    "id": 2412,
    "function": "keys",
    "file": "Chap50/OptBinSearchTreeStEph.rs",
    "lines": "66-68",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (1), Span (1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)  reference access\n        fn keys(&self)                                            -> &Vec<KeyProb<T>>;"
  },
  {
    "id": 2413,
    "function": "keys_mut",
    "file": "Chap50/OptBinSearchTreeStEph.rs",
    "lines": "70-72",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (1), Span (1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)  mutable reference access\n        fn keys_mut(&mut self)                                    -> &mut Vec<KeyProb<T>>;"
  },
  {
    "id": 2414,
    "function": "set_key_prob",
    "file": "Chap50/OptBinSearchTreeStEph.rs",
    "lines": "74-76",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (1), Span (1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)  array write plus memo clear\n        fn set_key_prob(&mut self, index: usize, key_prob: KeyProb<T>);"
  },
  {
    "id": 2415,
    "function": "update_prob",
    "file": "Chap50/OptBinSearchTreeStEph.rs",
    "lines": "78-80",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (1), Span (1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)  field write plus memo clear\n        fn update_prob(&mut self, index: usize, prob: Probability);"
  },
  {
    "id": 2416,
    "function": "num_keys",
    "file": "Chap50/OptBinSearchTreeStEph.rs",
    "lines": "82-84",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (1), Span (1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)  Vec::len\n        fn num_keys(&self)                                        -> usize;"
  },
  {
    "id": 2417,
    "function": "clear_memo",
    "file": "Chap50/OptBinSearchTreeStEph.rs",
    "lines": "86-88",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (1), Span (1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)  HashMap::clear\n        fn clear_memo(&mut self);"
  },
  {
    "id": 2418,
    "function": "memo_size",
    "file": "Chap50/OptBinSearchTreeStEph.rs",
    "lines": "90-92",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (1), Span (1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)  HashMap::len\n        fn memo_size(&self)                                       -> usize;"
  },
  {
    "id": 2419,
    "function": "obst_rec_st_eph",
    "file": "Chap50/OptBinSearchTreeStEph.rs",
    "lines": "97-122",
    "spec_strength": "",
    "snippet": "    fn obst_rec_st_eph<T: StT>(s: &mut OBSTStEphS<T>, i: usize, l: usize) -> Probability {\n        if let Some(&result) = s.memo.get(&(i, l)) {\n            return result;\n        }\n\n        let result = if l == 0 {\n            Probability::zero()\n        } else {\n            let prob_sum = (0..l)\n                .map(|k| s.keys[i + k].prob)\n                .fold(Probability::zero(), |acc, p| acc + p);\n\n            let min_cost = (0..l)\n                .map(|k| {\n                    let left_cost = obst_rec_st_eph(s, i, k);\n                    let right_cost = obst_rec_st_eph(s, i + k + 1, l - k - 1);\n                    left_cost + right_cost\n                })\n                .fold(Probability::infinity(), min);\n\n            prob_sum + min_cost\n        };\n\n        s.memo.insert((i, l), result);\n        result\n    }"
  },
  {
    "id": 2420,
    "function": "new",
    "file": "Chap50/OptBinSearchTreeStPer.rs",
    "lines": "50-52",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (1), Span (1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)  allocate empty collections\n        fn new()                                                  -> Self;"
  },
  {
    "id": 2421,
    "function": "from_keys_probs",
    "file": "Chap50/OptBinSearchTreeStPer.rs",
    "lines": "54-56",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (n), Span (n)\n        /// - Claude-Opus-4.6: Work (n), Span (n)  zip and map n keys with probabilities\n        fn from_keys_probs(keys: Vec<T>, probs: Vec<Probability>) -> Self;"
  },
  {
    "id": 2422,
    "function": "from_key_probs",
    "file": "Chap50/OptBinSearchTreeStPer.rs",
    "lines": "58-60",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (1), Span (1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)  move ownership of Vec\n        fn from_key_probs(key_probs: Vec<KeyProb<T>>)             -> Self;"
  },
  {
    "id": 2423,
    "function": "optimal_cost",
    "file": "Chap50/OptBinSearchTreeStPer.rs",
    "lines": "62-64",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (n), Span (n)\n        /// - Claude-Opus-4.6: Work (n), Span (n)  clones self then invokes memoized DP, sequential\n        fn optimal_cost(&self)                                    -> Probability;"
  },
  {
    "id": 2424,
    "function": "keys",
    "file": "Chap50/OptBinSearchTreeStPer.rs",
    "lines": "66-68",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (1), Span (1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)  reference access\n        fn keys(&self)                                            -> &Vec<KeyProb<T>>;"
  },
  {
    "id": 2425,
    "function": "num_keys",
    "file": "Chap50/OptBinSearchTreeStPer.rs",
    "lines": "70-72",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (1), Span (1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)  Vec::len\n        fn num_keys(&self)                                        -> usize;"
  },
  {
    "id": 2426,
    "function": "memo_size",
    "file": "Chap50/OptBinSearchTreeStPer.rs",
    "lines": "74-76",
    "spec_strength": "",
    "snippet": "        /// - APAS: Work (1), Span (1)\n        /// - Claude-Opus-4.6: Work (1), Span (1)  HashMap::len\n        fn memo_size(&self)                                       -> usize;"
  },
  {
    "id": 2427,
    "function": "obst_rec_st_per",
    "file": "Chap50/OptBinSearchTreeStPer.rs",
    "lines": "81-106",
    "spec_strength": "",
    "snippet": "    fn obst_rec_st_per<T: StT>(s: &mut OBSTStPerS<T>, i: usize, l: usize) -> Probability {\n        if let Some(&result) = s.memo.get(&(i, l)) {\n            return result;\n        }\n\n        let result = if l == 0 {\n            Probability::zero()\n        } else {\n            let prob_sum = (0..l)\n                .map(|k| s.keys[i + k].prob)\n                .fold(Probability::zero(), |acc, p| acc + p);\n\n            let min_cost = (0..l)\n                .map(|k| {\n                    let left_cost = obst_rec_st_per(s, i, k);\n                    let right_cost = obst_rec_st_per(s, i + k + 1, l - k - 1);\n                    left_cost + right_cost\n                })\n                .fold(Probability::infinity(), min);\n\n            prob_sum + min_cost\n        };\n\n        s.memo.insert((i, l), result);\n        result\n    }"
  },
  {
    "id": 2428,
    "function": "new",
    "file": "Chap50/Probability.rs",
    "lines": "29",
    "spec_strength": "hole",
    "snippet": "        fn new(value: f64) -> Self;"
  },
  {
    "id": 2429,
    "function": "value",
    "file": "Chap50/Probability.rs",
    "lines": "33",
    "spec_strength": "hole",
    "snippet": "        fn value(&self) -> f64;"
  },
  {
    "id": 2430,
    "function": "infinity",
    "file": "Chap50/Probability.rs",
    "lines": "37",
    "spec_strength": "hole",
    "snippet": "        fn infinity() -> Self;"
  },
  {
    "id": 2431,
    "function": "zero",
    "file": "Chap50/Probability.rs",
    "lines": "41",
    "spec_strength": "hole",
    "snippet": "        fn zero() -> Self;"
  },
  {
    "id": 2432,
    "function": "default",
    "file": "Chap50/Probability.rs",
    "lines": "65",
    "spec_strength": "hole",
    "snippet": "        fn default() -> Self { <Probability as ProbabilityTrait>::zero() }"
  },
  {
    "id": 2433,
    "function": "eq",
    "file": "Chap50/Probability.rs",
    "lines": "72",
    "spec_strength": "hole",
    "snippet": "        fn eq(&self, other: &Self) -> bool {"
  },
  {
    "id": 2434,
    "function": "partial_cmp",
    "file": "Chap50/Probability.rs",
    "lines": "81",
    "spec_strength": "hole",
    "snippet": "        fn partial_cmp(&self, other: &Self) -> Option<Ordering> { Some(self.cmp(other)) }"
  },
  {
    "id": 2435,
    "function": "cmp",
    "file": "Chap50/Probability.rs",
    "lines": "88",
    "spec_strength": "hole",
    "snippet": "        fn cmp(&self, other: &Self) -> Ordering {"
  },
  {
    "id": 2436,
    "function": "hash",
    "file": "Chap50/Probability.rs",
    "lines": "110",
    "spec_strength": "hole",
    "snippet": "        fn hash<H: Hasher>(&self, state: &mut H) { self.0.to_bits().hash(state); }"
  },
  {
    "id": 2437,
    "function": "from`",
    "file": "Chap50/Probability.rs",
    "lines": "117",
    "spec_strength": "hole",
    "snippet": "        fn from(value: f64) -> Self { Probability(value) }"
  },
  {
    "id": 2438,
    "function": "add",
    "file": "Chap50/Probability.rs",
    "lines": "131",
    "spec_strength": "hole",
    "snippet": "        fn add(self, other: Self) -> Self { Probability(self.0 + other.0) }"
  },
  {
    "id": 2439,
    "function": "sub",
    "file": "Chap50/Probability.rs",
    "lines": "138",
    "spec_strength": "hole",
    "snippet": "        fn sub(self, other: Self) -> Self { Probability(self.0 - other.0) }"
  },
  {
    "id": 2440,
    "function": "mul",
    "file": "Chap50/Probability.rs",
    "lines": "145",
    "spec_strength": "hole",
    "snippet": "        fn mul(self, other: Self) -> Self { Probability(self.0 * other.0) }"
  },
  {
    "id": 2441,
    "function": "div",
    "file": "Chap50/Probability.rs",
    "lines": "152",
    "spec_strength": "hole",
    "snippet": "        fn div(self, other: Self) -> Self { Probability(self.0 / other.0) }"
  },
  {
    "id": 2442,
    "function": "new_bu_eph_lock",
    "file": "Chap51/BottomUpDPMtEph.rs",
    "lines": "43",
    "spec_strength": "hole",
    "snippet": "    fn new_bu_eph_lock(val: Vec<Vec<usize>>) -> (lock: RwLock<Vec<Vec<usize>>, BottomUpDPMtEphWf>) {"
  },
  {
    "id": 2443,
    "function": "new",
    "file": "Chap51/BottomUpDPMtEph.rs",
    "lines": "52",
    "spec_strength": "",
    "snippet": "        fn new(s: ArraySeqMtEphS<char>, t: ArraySeqMtEphS<char>) -> Self;"
  },
  {
    "id": 2444,
    "function": "s_length",
    "file": "Chap51/BottomUpDPMtEph.rs",
    "lines": "53",
    "spec_strength": "",
    "snippet": "        fn s_length(&self) -> usize;"
  },
  {
    "id": 2445,
    "function": "t_length",
    "file": "Chap51/BottomUpDPMtEph.rs",
    "lines": "54",
    "spec_strength": "",
    "snippet": "        fn t_length(&self) -> usize;"
  },
  {
    "id": 2446,
    "function": "is_empty",
    "file": "Chap51/BottomUpDPMtEph.rs",
    "lines": "55",
    "spec_strength": "",
    "snippet": "        fn is_empty(&self) -> bool;"
  },
  {
    "id": 2447,
    "function": "set_s",
    "file": "Chap51/BottomUpDPMtEph.rs",
    "lines": "56",
    "spec_strength": "",
    "snippet": "        fn set_s(&mut self, s: ArraySeqMtEphS<char>);"
  },
  {
    "id": 2448,
    "function": "set_t",
    "file": "Chap51/BottomUpDPMtEph.rs",
    "lines": "57",
    "spec_strength": "",
    "snippet": "        fn set_t(&mut self, t: ArraySeqMtEphS<char>);"
  },
  {
    "id": 2449,
    "function": "med_bottom_up_parallel",
    "file": "Chap51/BottomUpDPMtEph.rs",
    "lines": "58",
    "spec_strength": "",
    "snippet": "        fn med_bottom_up_parallel(&mut self) -> usize;"
  },
  {
    "id": 2450,
    "function": "initialize_base_cases",
    "file": "Chap51/BottomUpDPMtEph.rs",
    "lines": "59",
    "spec_strength": "",
    "snippet": "        fn initialize_base_cases(&self) -> Vec<Vec<usize>>;"
  },
  {
    "id": 2451,
    "function": "compute_diagonal_parallel",
    "file": "Chap51/BottomUpDPMtEph.rs",
    "lines": "60",
    "spec_strength": "",
    "snippet": "        fn compute_diagonal_parallel(&self, table: Arc<RwLock<Vec<Vec<usize>>, BottomUpDPMtEphWf>>, k: usize);"
  },
  {
    "id": 2452,
    "function": "compute_cell_value_static",
    "file": "Chap51/BottomUpDPMtEph.rs",
    "lines": "61-67",
    "spec_strength": "",
    "snippet": "        fn compute_cell_value_static(\n            seq_s: &ArraySeqMtEphS<char>,\n            seq_t: &ArraySeqMtEphS<char>,\n            table: &Arc<RwLock<Vec<Vec<usize>>, BottomUpDPMtEphWf>>,\n            i: usize,\n            j: usize,\n        ) -> usize;"
  },
  {
    "id": 2453,
    "function": "eq",
    "file": "Chap51/BottomUpDPMtEph.rs",
    "lines": "182-184",
    "spec_strength": "",
    "snippet": "        fn eq(&self, other: &Self) -> bool {\n            self.seq_s == other.seq_s && self.seq_t == other.seq_t\n        }"
  },
  {
    "id": 2454,
    "function": "default",
    "file": "Chap51/BottomUpDPMtEph.rs",
    "lines": "190-194",
    "spec_strength": "",
    "snippet": "        fn default() -> Self {\n            let empty_s = ArraySeqMtEphS::new(0, ' ');\n            let empty_t = ArraySeqMtEphS::new(0, ' ');\n            Self::new(empty_s, empty_t)\n        }"
  },
  {
    "id": 2455,
    "function": "new_bu_per_lock",
    "file": "Chap51/BottomUpDPMtPer.rs",
    "lines": "43",
    "spec_strength": "hole",
    "snippet": "    fn new_bu_per_lock(val: Vec<Vec<usize>>) -> (lock: RwLock<Vec<Vec<usize>>, BottomUpDPMtPerWf>) {"
  },
  {
    "id": 2456,
    "function": "new",
    "file": "Chap51/BottomUpDPMtPer.rs",
    "lines": "52",
    "spec_strength": "",
    "snippet": "        fn new(s: ArraySeqMtPerS<char>, t: ArraySeqMtPerS<char>) -> Self;"
  },
  {
    "id": 2457,
    "function": "s_length",
    "file": "Chap51/BottomUpDPMtPer.rs",
    "lines": "53",
    "spec_strength": "",
    "snippet": "        fn s_length(&self) -> usize;"
  },
  {
    "id": 2458,
    "function": "t_length",
    "file": "Chap51/BottomUpDPMtPer.rs",
    "lines": "54",
    "spec_strength": "",
    "snippet": "        fn t_length(&self) -> usize;"
  },
  {
    "id": 2459,
    "function": "is_empty",
    "file": "Chap51/BottomUpDPMtPer.rs",
    "lines": "55",
    "spec_strength": "",
    "snippet": "        fn is_empty(&self) -> bool;"
  },
  {
    "id": 2460,
    "function": "med_bottom_up_parallel",
    "file": "Chap51/BottomUpDPMtPer.rs",
    "lines": "56",
    "spec_strength": "",
    "snippet": "        fn med_bottom_up_parallel(&self) -> usize;"
  },
  {
    "id": 2461,
    "function": "initialize_base_cases",
    "file": "Chap51/BottomUpDPMtPer.rs",
    "lines": "57",
    "spec_strength": "",
    "snippet": "        fn initialize_base_cases(&self) -> Vec<Vec<usize>>;"
  },
  {
    "id": 2462,
    "function": "compute_diagonal_parallel",
    "file": "Chap51/BottomUpDPMtPer.rs",
    "lines": "58",
    "spec_strength": "",
    "snippet": "        fn compute_diagonal_parallel(&self, table: Arc<RwLock<Vec<Vec<usize>>, BottomUpDPMtPerWf>>, k: usize);"
  },
  {
    "id": 2463,
    "function": "compute_cell_value_static",
    "file": "Chap51/BottomUpDPMtPer.rs",
    "lines": "59-65",
    "spec_strength": "",
    "snippet": "        fn compute_cell_value_static(\n            seq_s: &ArraySeqMtPerS<char>,\n            seq_t: &ArraySeqMtPerS<char>,\n            table: &Arc<RwLock<Vec<Vec<usize>>, BottomUpDPMtPerWf>>,\n            i: usize,\n            j: usize,\n        ) -> usize;"
  },
  {
    "id": 2464,
    "function": "eq",
    "file": "Chap51/BottomUpDPMtPer.rs",
    "lines": "178-180",
    "spec_strength": "",
    "snippet": "        fn eq(&self, other: &Self) -> bool {\n            self.seq_s == other.seq_s && self.seq_t == other.seq_t\n        }"
  },
  {
    "id": 2465,
    "function": "default",
    "file": "Chap51/BottomUpDPMtPer.rs",
    "lines": "186-190",
    "spec_strength": "",
    "snippet": "        fn default() -> Self {\n            let empty_s = ArraySeqMtPerS::new(0, ' ');\n            let empty_t = ArraySeqMtPerS::new(0, ' ');\n            Self::new(empty_s, empty_t)\n        }"
  },
  {
    "id": 2466,
    "function": "new",
    "file": "Chap51/BottomUpDPStEph.rs",
    "lines": "39",
    "spec_strength": "",
    "snippet": "        fn new(s: ArraySeqStEphS<char>, t: ArraySeqStEphS<char>) -> Self;"
  },
  {
    "id": 2467,
    "function": "s_length",
    "file": "Chap51/BottomUpDPStEph.rs",
    "lines": "40",
    "spec_strength": "",
    "snippet": "        fn s_length(&self) -> usize;"
  },
  {
    "id": 2468,
    "function": "t_length",
    "file": "Chap51/BottomUpDPStEph.rs",
    "lines": "41",
    "spec_strength": "",
    "snippet": "        fn t_length(&self) -> usize;"
  },
  {
    "id": 2469,
    "function": "is_empty",
    "file": "Chap51/BottomUpDPStEph.rs",
    "lines": "42",
    "spec_strength": "",
    "snippet": "        fn is_empty(&self) -> bool;"
  },
  {
    "id": 2470,
    "function": "set_s",
    "file": "Chap51/BottomUpDPStEph.rs",
    "lines": "43",
    "spec_strength": "",
    "snippet": "        fn set_s(&mut self, s: ArraySeqStEphS<char>);"
  },
  {
    "id": 2471,
    "function": "set_t",
    "file": "Chap51/BottomUpDPStEph.rs",
    "lines": "44",
    "spec_strength": "",
    "snippet": "        fn set_t(&mut self, t: ArraySeqStEphS<char>);"
  },
  {
    "id": 2472,
    "function": "med_bottom_up",
    "file": "Chap51/BottomUpDPStEph.rs",
    "lines": "45",
    "spec_strength": "",
    "snippet": "        fn med_bottom_up(&mut self) -> usize;"
  },
  {
    "id": 2473,
    "function": "initialize_base_cases",
    "file": "Chap51/BottomUpDPStEph.rs",
    "lines": "46",
    "spec_strength": "",
    "snippet": "        fn initialize_base_cases(&self) -> Vec<Vec<usize>>;"
  },
  {
    "id": 2474,
    "function": "compute_diagonal",
    "file": "Chap51/BottomUpDPStEph.rs",
    "lines": "47",
    "spec_strength": "",
    "snippet": "        fn compute_diagonal(&self, table: &mut [Vec<usize>], k: usize);"
  },
  {
    "id": 2475,
    "function": "compute_cell_value",
    "file": "Chap51/BottomUpDPStEph.rs",
    "lines": "48",
    "spec_strength": "",
    "snippet": "        fn compute_cell_value(&self, table: &[Vec<usize>], i: usize, j: usize) -> usize;"
  },
  {
    "id": 2476,
    "function": "eq",
    "file": "Chap51/BottomUpDPStEph.rs",
    "lines": "132-134",
    "spec_strength": "",
    "snippet": "        fn eq(&self, other: &Self) -> bool {\n            self.seq_s == other.seq_s && self.seq_t == other.seq_t\n        }"
  },
  {
    "id": 2477,
    "function": "default",
    "file": "Chap51/BottomUpDPStEph.rs",
    "lines": "140-144",
    "spec_strength": "",
    "snippet": "        fn default() -> Self {\n            let empty_s = ArraySeqStEphS::new(0, ' ');\n            let empty_t = ArraySeqStEphS::new(0, ' ');\n            Self::new(empty_s, empty_t)\n        }"
  },
  {
    "id": 2478,
    "function": "new",
    "file": "Chap51/BottomUpDPStPer.rs",
    "lines": "39",
    "spec_strength": "",
    "snippet": "        fn new(s: ArraySeqStPerS<char>, t: ArraySeqStPerS<char>) -> Self;"
  },
  {
    "id": 2479,
    "function": "s_length",
    "file": "Chap51/BottomUpDPStPer.rs",
    "lines": "40",
    "spec_strength": "",
    "snippet": "        fn s_length(&self) -> usize;"
  },
  {
    "id": 2480,
    "function": "t_length",
    "file": "Chap51/BottomUpDPStPer.rs",
    "lines": "41",
    "spec_strength": "",
    "snippet": "        fn t_length(&self) -> usize;"
  },
  {
    "id": 2481,
    "function": "is_empty",
    "file": "Chap51/BottomUpDPStPer.rs",
    "lines": "42",
    "spec_strength": "",
    "snippet": "        fn is_empty(&self) -> bool;"
  },
  {
    "id": 2482,
    "function": "med_bottom_up",
    "file": "Chap51/BottomUpDPStPer.rs",
    "lines": "43",
    "spec_strength": "",
    "snippet": "        fn med_bottom_up(&self) -> usize;"
  },
  {
    "id": 2483,
    "function": "initialize_base_cases",
    "file": "Chap51/BottomUpDPStPer.rs",
    "lines": "44",
    "spec_strength": "",
    "snippet": "        fn initialize_base_cases(&self) -> Vec<Vec<usize>>;"
  },
  {
    "id": 2484,
    "function": "compute_diagonal",
    "file": "Chap51/BottomUpDPStPer.rs",
    "lines": "45",
    "spec_strength": "",
    "snippet": "        fn compute_diagonal(&self, table: Vec<Vec<usize>>, k: usize) -> Vec<Vec<usize>>;"
  },
  {
    "id": 2485,
    "function": "compute_cell_value",
    "file": "Chap51/BottomUpDPStPer.rs",
    "lines": "46",
    "spec_strength": "",
    "snippet": "        fn compute_cell_value(&self, table: &[Vec<usize>], i: usize, j: usize) -> usize;"
  },
  {
    "id": 2486,
    "function": "eq",
    "file": "Chap51/BottomUpDPStPer.rs",
    "lines": "131-133",
    "spec_strength": "",
    "snippet": "        fn eq(&self, other: &Self) -> bool {\n            self.seq_s == other.seq_s && self.seq_t == other.seq_t\n        }"
  },
  {
    "id": 2487,
    "function": "default",
    "file": "Chap51/BottomUpDPStPer.rs",
    "lines": "139-143",
    "spec_strength": "",
    "snippet": "        fn default() -> Self {\n            let empty_s = ArraySeqStPerS::new(0, ' ');\n            let empty_t = ArraySeqStPerS::new(0, ' ');\n            Self::new(empty_s, empty_t)\n        }"
  },
  {
    "id": 2488,
    "function": "new_td_eph_lock",
    "file": "Chap51/TopDownDPMtEph.rs",
    "lines": "37",
    "spec_strength": "hole",
    "snippet": "    fn new_td_eph_lock(val: HashMap<(usize, usize), usize>) -> (lock: RwLock<HashMap<(usize, usize), usize>, TopDownDPMtEphWf>) {"
  },
  {
    "id": 2489,
    "function": "new",
    "file": "Chap51/TopDownDPMtEph.rs",
    "lines": "57",
    "spec_strength": "",
    "snippet": "        fn new(s: ArraySeqMtEphS<char>, t: ArraySeqMtEphS<char>) -> Self;"
  },
  {
    "id": 2490,
    "function": "med_memoized_concurrent",
    "file": "Chap51/TopDownDPMtEph.rs",
    "lines": "58",
    "spec_strength": "",
    "snippet": "        fn med_memoized_concurrent(&mut self) -> usize;"
  },
  {
    "id": 2491,
    "function": "med_memoized_parallel",
    "file": "Chap51/TopDownDPMtEph.rs",
    "lines": "59",
    "spec_strength": "",
    "snippet": "        fn med_memoized_parallel(&mut self) -> usize;"
  },
  {
    "id": 2492,
    "function": "memo_size",
    "file": "Chap51/TopDownDPMtEph.rs",
    "lines": "60",
    "spec_strength": "",
    "snippet": "        fn memo_size(&self) -> usize;"
  },
  {
    "id": 2493,
    "function": "is_memoized",
    "file": "Chap51/TopDownDPMtEph.rs",
    "lines": "61",
    "spec_strength": "",
    "snippet": "        fn is_memoized(&self, i: usize, j: usize) -> bool;"
  },
  {
    "id": 2494,
    "function": "get_memoized",
    "file": "Chap51/TopDownDPMtEph.rs",
    "lines": "62",
    "spec_strength": "",
    "snippet": "        fn get_memoized(&self, i: usize, j: usize) -> Option<usize>;"
  },
  {
    "id": 2495,
    "function": "insert_memo",
    "file": "Chap51/TopDownDPMtEph.rs",
    "lines": "63",
    "spec_strength": "",
    "snippet": "        fn insert_memo(&mut self, i: usize, j: usize, value: usize);"
  },
  {
    "id": 2496,
    "function": "s_length",
    "file": "Chap51/TopDownDPMtEph.rs",
    "lines": "64",
    "spec_strength": "",
    "snippet": "        fn s_length(&self) -> usize;"
  },
  {
    "id": 2497,
    "function": "t_length",
    "file": "Chap51/TopDownDPMtEph.rs",
    "lines": "65",
    "spec_strength": "",
    "snippet": "        fn t_length(&self) -> usize;"
  },
  {
    "id": 2498,
    "function": "is_empty",
    "file": "Chap51/TopDownDPMtEph.rs",
    "lines": "66",
    "spec_strength": "",
    "snippet": "        fn is_empty(&self) -> bool;"
  },
  {
    "id": 2499,
    "function": "clear_memo",
    "file": "Chap51/TopDownDPMtEph.rs",
    "lines": "67",
    "spec_strength": "",
    "snippet": "        fn clear_memo(&mut self);"
  },
  {
    "id": 2500,
    "function": "set_s",
    "file": "Chap51/TopDownDPMtEph.rs",
    "lines": "68",
    "spec_strength": "",
    "snippet": "        fn set_s(&mut self, s: ArraySeqMtEphS<char>);"
  },
  {
    "id": 2501,
    "function": "set_t",
    "file": "Chap51/TopDownDPMtEph.rs",
    "lines": "69",
    "spec_strength": "",
    "snippet": "        fn set_t(&mut self, t: ArraySeqMtEphS<char>);"
  },
  {
    "id": 2502,
    "function": "med_recursive_concurrent",
    "file": "Chap51/TopDownDPMtEph.rs",
    "lines": "70",
    "spec_strength": "",
    "snippet": "        fn med_recursive_concurrent(&self, i: usize, j: usize) -> usize;"
  },
  {
    "id": 2503,
    "function": "med_recursive_parallel",
    "file": "Chap51/TopDownDPMtEph.rs",
    "lines": "71",
    "spec_strength": "",
    "snippet": "        fn med_recursive_parallel(&self, i: usize, j: usize) -> usize;"
  },
  {
    "id": 2504,
    "function": "eq",
    "file": "Chap51/TopDownDPMtEph.rs",
    "lines": "225-235",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A  infrastructure.\n        /// - Claude-Opus-4.6: Work (|S|+|T|+|memo|), Span (|S|+|T|+|memo|)\n        fn eq(&self, other: &Self) -> bool {\n            let self_handle = self.memo_table.acquire_read();\n            let other_handle = other.memo_table.acquire_read();\n            let result = self.seq_s == other.seq_s && self.seq_t == other.seq_t\n                && *self_handle.borrow() == *other_handle.borrow();\n            other_handle.release_read();\n            self_handle.release_read();\n            result\n        }"
  },
  {
    "id": 2505,
    "function": "default",
    "file": "Chap51/TopDownDPMtEph.rs",
    "lines": "239-245",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A  infrastructure.\n        /// - Claude-Opus-4.6: Work (1), Span (1)\n        fn default() -> Self {\n            let empty_s = ArraySeqMtEphS::new(0, ' ');\n            let empty_t = ArraySeqMtEphS::new(0, ' ');\n            Self::new(empty_s, empty_t)\n        }"
  },
  {
    "id": 2506,
    "function": "new_td_per_lock",
    "file": "Chap51/TopDownDPMtPer.rs",
    "lines": "37",
    "spec_strength": "hole",
    "snippet": "    fn new_td_per_lock(val: HashMap<(usize, usize), usize>) -> (lock: RwLock<HashMap<(usize, usize), usize>, TopDownDPMtPerWf>) {"
  },
  {
    "id": 2507,
    "function": "new",
    "file": "Chap51/TopDownDPMtPer.rs",
    "lines": "57",
    "spec_strength": "",
    "snippet": "        fn new(s: ArraySeqMtPerS<char>, t: ArraySeqMtPerS<char>) -> Self;"
  },
  {
    "id": 2508,
    "function": "med_memoized_concurrent",
    "file": "Chap51/TopDownDPMtPer.rs",
    "lines": "58",
    "spec_strength": "",
    "snippet": "        fn med_memoized_concurrent(&self) -> usize;"
  },
  {
    "id": 2509,
    "function": "med_memoized_parallel",
    "file": "Chap51/TopDownDPMtPer.rs",
    "lines": "59",
    "spec_strength": "",
    "snippet": "        fn med_memoized_parallel(&self) -> usize;"
  },
  {
    "id": 2510,
    "function": "with_memo_table",
    "file": "Chap51/TopDownDPMtPer.rs",
    "lines": "60",
    "spec_strength": "",
    "snippet": "        fn with_memo_table(self, memo: HashMap<(usize, usize), usize>) -> Self;"
  },
  {
    "id": 2511,
    "function": "memo_size",
    "file": "Chap51/TopDownDPMtPer.rs",
    "lines": "61",
    "spec_strength": "",
    "snippet": "        fn memo_size(&self) -> usize;"
  },
  {
    "id": 2512,
    "function": "is_memoized",
    "file": "Chap51/TopDownDPMtPer.rs",
    "lines": "62",
    "spec_strength": "",
    "snippet": "        fn is_memoized(&self, i: usize, j: usize) -> bool;"
  },
  {
    "id": 2513,
    "function": "get_memoized",
    "file": "Chap51/TopDownDPMtPer.rs",
    "lines": "63",
    "spec_strength": "",
    "snippet": "        fn get_memoized(&self, i: usize, j: usize) -> Option<usize>;"
  },
  {
    "id": 2514,
    "function": "s_length",
    "file": "Chap51/TopDownDPMtPer.rs",
    "lines": "64",
    "spec_strength": "",
    "snippet": "        fn s_length(&self) -> usize;"
  },
  {
    "id": 2515,
    "function": "t_length",
    "file": "Chap51/TopDownDPMtPer.rs",
    "lines": "65",
    "spec_strength": "",
    "snippet": "        fn t_length(&self) -> usize;"
  },
  {
    "id": 2516,
    "function": "is_empty",
    "file": "Chap51/TopDownDPMtPer.rs",
    "lines": "66",
    "spec_strength": "",
    "snippet": "        fn is_empty(&self) -> bool;"
  },
  {
    "id": 2517,
    "function": "clear_memo",
    "file": "Chap51/TopDownDPMtPer.rs",
    "lines": "67",
    "spec_strength": "",
    "snippet": "        fn clear_memo(self) -> Self;"
  },
  {
    "id": 2518,
    "function": "med_recursive_concurrent",
    "file": "Chap51/TopDownDPMtPer.rs",
    "lines": "68",
    "spec_strength": "",
    "snippet": "        fn med_recursive_concurrent(&self, i: usize, j: usize) -> usize;"
  },
  {
    "id": 2519,
    "function": "med_recursive_parallel",
    "file": "Chap51/TopDownDPMtPer.rs",
    "lines": "69",
    "spec_strength": "",
    "snippet": "        fn med_recursive_parallel(&self, i: usize, j: usize) -> usize;"
  },
  {
    "id": 2520,
    "function": "eq",
    "file": "Chap51/TopDownDPMtPer.rs",
    "lines": "217-227",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A  infrastructure.\n        /// - Claude-Opus-4.6: Work (|S|+|T|+|memo|), Span (|S|+|T|+|memo|)\n        fn eq(&self, other: &Self) -> bool {\n            let self_handle = self.memo_table.acquire_read();\n            let other_handle = other.memo_table.acquire_read();\n            let result = self.seq_s == other.seq_s && self.seq_t == other.seq_t\n                && *self_handle.borrow() == *other_handle.borrow();\n            other_handle.release_read();\n            self_handle.release_read();\n            result\n        }"
  },
  {
    "id": 2521,
    "function": "default",
    "file": "Chap51/TopDownDPMtPer.rs",
    "lines": "231-237",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A  infrastructure.\n        /// - Claude-Opus-4.6: Work (1), Span (1)\n        fn default() -> Self {\n            let empty_s = ArraySeqMtPerS::new(0, ' ');\n            let empty_t = ArraySeqMtPerS::new(0, ' ');\n            Self::new(empty_s, empty_t)\n        }"
  },
  {
    "id": 2522,
    "function": "new",
    "file": "Chap51/TopDownDPStEph.rs",
    "lines": "43",
    "spec_strength": "",
    "snippet": "        fn new(s: ArraySeqStEphS<char>, t: ArraySeqStEphS<char>) -> Self;"
  },
  {
    "id": 2523,
    "function": "med_memoized",
    "file": "Chap51/TopDownDPStEph.rs",
    "lines": "44",
    "spec_strength": "",
    "snippet": "        fn med_memoized(&mut self) -> usize;"
  },
  {
    "id": 2524,
    "function": "memo_size",
    "file": "Chap51/TopDownDPStEph.rs",
    "lines": "45",
    "spec_strength": "",
    "snippet": "        fn memo_size(&self) -> usize;"
  },
  {
    "id": 2525,
    "function": "is_memoized",
    "file": "Chap51/TopDownDPStEph.rs",
    "lines": "46",
    "spec_strength": "",
    "snippet": "        fn is_memoized(&self, i: usize, j: usize) -> bool;"
  },
  {
    "id": 2526,
    "function": "get_memoized",
    "file": "Chap51/TopDownDPStEph.rs",
    "lines": "47",
    "spec_strength": "",
    "snippet": "        fn get_memoized(&self, i: usize, j: usize) -> Option<usize>;"
  },
  {
    "id": 2527,
    "function": "insert_memo",
    "file": "Chap51/TopDownDPStEph.rs",
    "lines": "48",
    "spec_strength": "",
    "snippet": "        fn insert_memo(&mut self, i: usize, j: usize, value: usize);"
  },
  {
    "id": 2528,
    "function": "s_length",
    "file": "Chap51/TopDownDPStEph.rs",
    "lines": "49",
    "spec_strength": "",
    "snippet": "        fn s_length(&self) -> usize;"
  },
  {
    "id": 2529,
    "function": "t_length",
    "file": "Chap51/TopDownDPStEph.rs",
    "lines": "50",
    "spec_strength": "",
    "snippet": "        fn t_length(&self) -> usize;"
  },
  {
    "id": 2530,
    "function": "is_empty",
    "file": "Chap51/TopDownDPStEph.rs",
    "lines": "51",
    "spec_strength": "",
    "snippet": "        fn is_empty(&self) -> bool;"
  },
  {
    "id": 2531,
    "function": "clear_memo",
    "file": "Chap51/TopDownDPStEph.rs",
    "lines": "52",
    "spec_strength": "",
    "snippet": "        fn clear_memo(&mut self);"
  },
  {
    "id": 2532,
    "function": "set_s",
    "file": "Chap51/TopDownDPStEph.rs",
    "lines": "53",
    "spec_strength": "",
    "snippet": "        fn set_s(&mut self, s: ArraySeqStEphS<char>);"
  },
  {
    "id": 2533,
    "function": "set_t",
    "file": "Chap51/TopDownDPStEph.rs",
    "lines": "54",
    "spec_strength": "",
    "snippet": "        fn set_t(&mut self, t: ArraySeqStEphS<char>);"
  },
  {
    "id": 2534,
    "function": "med_recursive",
    "file": "Chap51/TopDownDPStEph.rs",
    "lines": "55",
    "spec_strength": "",
    "snippet": "        fn med_recursive(&mut self, i: usize, j: usize) -> usize;"
  },
  {
    "id": 2535,
    "function": "default",
    "file": "Chap51/TopDownDPStEph.rs",
    "lines": "128-134",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A  infrastructure.\n        /// - Claude-Opus-4.6: Work (1), Span (1)\n        fn default() -> Self {\n            let empty_s = ArraySeqStEphS::new(0, ' ');\n            let empty_t = ArraySeqStEphS::new(0, ' ');\n            Self::new(empty_s, empty_t)\n        }"
  },
  {
    "id": 2536,
    "function": "new",
    "file": "Chap51/TopDownDPStPer.rs",
    "lines": "43",
    "spec_strength": "",
    "snippet": "        fn new(s: ArraySeqStPerS<char>, t: ArraySeqStPerS<char>) -> Self;"
  },
  {
    "id": 2537,
    "function": "med_memoized",
    "file": "Chap51/TopDownDPStPer.rs",
    "lines": "44",
    "spec_strength": "",
    "snippet": "        fn med_memoized(&self) -> usize;"
  },
  {
    "id": 2538,
    "function": "with_memo_table",
    "file": "Chap51/TopDownDPStPer.rs",
    "lines": "45",
    "spec_strength": "",
    "snippet": "        fn with_memo_table(self, memo: HashMap<(usize, usize), usize>) -> Self;"
  },
  {
    "id": 2539,
    "function": "memo_size",
    "file": "Chap51/TopDownDPStPer.rs",
    "lines": "46",
    "spec_strength": "",
    "snippet": "        fn memo_size(&self) -> usize;"
  },
  {
    "id": 2540,
    "function": "is_memoized",
    "file": "Chap51/TopDownDPStPer.rs",
    "lines": "47",
    "spec_strength": "",
    "snippet": "        fn is_memoized(&self, i: usize, j: usize) -> bool;"
  },
  {
    "id": 2541,
    "function": "get_memoized",
    "file": "Chap51/TopDownDPStPer.rs",
    "lines": "48",
    "spec_strength": "",
    "snippet": "        fn get_memoized(&self, i: usize, j: usize) -> Option<usize>;"
  },
  {
    "id": 2542,
    "function": "s_length",
    "file": "Chap51/TopDownDPStPer.rs",
    "lines": "49",
    "spec_strength": "",
    "snippet": "        fn s_length(&self) -> usize;"
  },
  {
    "id": 2543,
    "function": "t_length",
    "file": "Chap51/TopDownDPStPer.rs",
    "lines": "50",
    "spec_strength": "",
    "snippet": "        fn t_length(&self) -> usize;"
  },
  {
    "id": 2544,
    "function": "is_empty",
    "file": "Chap51/TopDownDPStPer.rs",
    "lines": "51",
    "spec_strength": "",
    "snippet": "        fn is_empty(&self) -> bool;"
  },
  {
    "id": 2545,
    "function": "clear_memo",
    "file": "Chap51/TopDownDPStPer.rs",
    "lines": "52",
    "spec_strength": "",
    "snippet": "        fn clear_memo(self) -> Self;"
  },
  {
    "id": 2546,
    "function": "med_recursive",
    "file": "Chap51/TopDownDPStPer.rs",
    "lines": "53",
    "spec_strength": "",
    "snippet": "        fn med_recursive(&self, i: usize, j: usize, memo: &mut HashMap<(usize, usize), usize>) -> usize;"
  },
  {
    "id": 2547,
    "function": "default",
    "file": "Chap51/TopDownDPStPer.rs",
    "lines": "122-128",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A  infrastructure.\n        /// - Claude-Opus-4.6: Work (1), Span (1)\n        fn default() -> Self {\n            let empty_s = ArraySeqStPerS::new(0, ' ');\n            let empty_t = ArraySeqStPerS::new(0, ' ');\n            Self::new(empty_s, empty_t)\n        }"
  },
  {
    "id": 2548,
    "function": "lemma_count_true_monotone",
    "file": "Chap52/AdjMatrixGraphMtEph.rs",
    "lines": "65-68",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_count_true_monotone(f: spec_fn(int) -> bool, i: int, n: int)\n        requires 0 <= i <= n\n        ensures spec_count_true(f, i) <= spec_count_true(f, n)\n        decreases n - i"
  },
  {
    "id": 2549,
    "function": "lemma_sum_of_monotone",
    "file": "Chap52/AdjMatrixGraphMtEph.rs",
    "lines": "75-78",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_sum_of_monotone(i: int, n: int, f: spec_fn(int) -> nat)\n        requires 0 <= i <= n\n        ensures spec_sum_of(i, f) <= spec_sum_of(n, f)\n        decreases n - i"
  },
  {
    "id": 2550,
    "function": "lemma_count_true_bound",
    "file": "Chap52/AdjMatrixGraphMtEph.rs",
    "lines": "85-88",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_count_true_bound(f: spec_fn(int) -> bool, n: int)\n        requires n >= 0\n        ensures spec_count_true(f, n) <= n as nat\n        decreases n"
  },
  {
    "id": 2551,
    "function": "new",
    "file": "Chap52/AdjMatrixGraphMtEph.rs",
    "lines": "104-109",
    "spec_strength": "unknown",
    "snippet": "        fn new(n: N) -> (result: Self)\n            ensures\n                result.spec_wf(),\n                result.spec_n() == n,\n                forall|u: int, v: int| #![auto]\n                    0 <= u < n && 0 <= v < n ==> !result.spec_edge(u, v);"
  },
  {
    "id": 2552,
    "function": "from_matrix",
    "file": "Chap52/AdjMatrixGraphMtEph.rs",
    "lines": "112-121",
    "spec_strength": "unknown",
    "snippet": "        fn from_matrix(matrix: ArraySeqMtEphS<ArraySeqMtEphS<bool>>) -> (result: Self)\n            requires\n                forall|i: int| #![auto] 0 <= i < matrix.spec_len() ==>\n                    matrix.spec_index(i).spec_len() == matrix.spec_len()\n            ensures\n                result.spec_wf(),\n                result.spec_n() == matrix.spec_len(),\n                forall|u: int, v: int| #![auto]\n                    0 <= u < matrix.spec_len() && 0 <= v < matrix.spec_len()\n                    ==> result.spec_edge(u, v) == matrix.spec_index(u).spec_index(v);"
  },
  {
    "id": 2553,
    "function": "num_vertices",
    "file": "Chap52/AdjMatrixGraphMtEph.rs",
    "lines": "124-126",
    "spec_strength": "unknown",
    "snippet": "        fn num_vertices(&self) -> (n: N)\n            requires self.spec_wf()\n            ensures n as nat == self.spec_n();"
  },
  {
    "id": 2554,
    "function": "num_edges",
    "file": "Chap52/AdjMatrixGraphMtEph.rs",
    "lines": "129-140",
    "spec_strength": "unknown",
    "snippet": "        fn num_edges(&self) -> (m: N)\n            requires\n                self.spec_wf(),\n                spec_sum_of(\n                    self.spec_n() as int,\n                    |u: int| spec_count_true(|v: int| self.spec_edge(u, v), self.spec_n() as int),\n                ) <= usize::MAX as nat\n            ensures\n                m as nat == spec_sum_of(\n                    self.spec_n() as int,\n                    |u: int| spec_count_true(|v: int| self.spec_edge(u, v), self.spec_n() as int),\n                );"
  },
  {
    "id": 2555,
    "function": "has_edge",
    "file": "Chap52/AdjMatrixGraphMtEph.rs",
    "lines": "143-145",
    "spec_strength": "unknown",
    "snippet": "        fn has_edge(&self, u: N, v: N) -> (found: B)\n            requires self.spec_wf(), u < self.spec_n(), v < self.spec_n()\n            ensures found == self.spec_edge(u as int, v as int);"
  },
  {
    "id": 2556,
    "function": "out_neighbors",
    "file": "Chap52/AdjMatrixGraphMtEph.rs",
    "lines": "148-156",
    "spec_strength": "unknown",
    "snippet": "        fn out_neighbors(&self, u: N) -> (neighbors: ArraySeqMtEphS<N>)\n            requires self.spec_wf(), u < self.spec_n()\n            ensures\n                forall|k: int| #![auto] 0 <= k < neighbors.spec_len()\n                    ==> neighbors.spec_index(k) < self.spec_n()\n                        && self.spec_edge(u as int, neighbors.spec_index(k) as int),\n                forall|v: int| #![auto] 0 <= v < self.spec_n() && self.spec_edge(u as int, v)\n                    ==> exists|k: int| #![auto]\n                        0 <= k < neighbors.spec_len() && neighbors.spec_index(k) == v as N;"
  },
  {
    "id": 2557,
    "function": "out_degree",
    "file": "Chap52/AdjMatrixGraphMtEph.rs",
    "lines": "159-164",
    "spec_strength": "unknown",
    "snippet": "        fn out_degree(&self, u: N) -> (d: N)\n            requires self.spec_wf(), u < self.spec_n()\n            ensures d as nat == spec_count_true(\n                |v: int| self.spec_edge(u as int, v),\n                self.spec_n() as int,\n            );"
  },
  {
    "id": 2558,
    "function": "set_edge",
    "file": "Chap52/AdjMatrixGraphMtEph.rs",
    "lines": "167-179",
    "spec_strength": "unknown",
    "snippet": "        fn set_edge(&mut self, u: N, v: N, exists: B)\n            requires\n                old(self).spec_wf(),\n                u < old(self).spec_n(),\n                v < old(self).spec_n(),\n            ensures\n                self.spec_wf(),\n                self.spec_n() == old(self).spec_n(),\n                self.spec_edge(u as int, v as int) == exists,\n                forall|i: int, j: int| #![auto]\n                    0 <= i < old(self).spec_n() && 0 <= j < old(self).spec_n()\n                    && !(i == u as int && j == v as int)\n                    ==> self.spec_edge(i, j) == old(self).spec_edge(i, j);"
  },
  {
    "id": 2559,
    "function": "complement",
    "file": "Chap52/AdjMatrixGraphMtEph.rs",
    "lines": "182-189",
    "spec_strength": "unknown",
    "snippet": "        fn complement(&self) -> (result: Self)\n            requires self.spec_wf()\n            ensures\n                result.spec_wf(),\n                result.spec_n() == self.spec_n(),\n                forall|i: int, j: int| #![auto]\n                    0 <= i < self.spec_n() && 0 <= j < self.spec_n()\n                    ==> result.spec_edge(i, j) == (i != j && !self.spec_edge(i, j));"
  },
  {
    "id": 2560,
    "function": "lemma_count_true_monotone",
    "file": "Chap52/AdjMatrixGraphMtPer.rs",
    "lines": "66-69",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_count_true_monotone(f: spec_fn(int) -> bool, i: int, n: int)\n        requires 0 <= i <= n\n        ensures spec_count_true(f, i) <= spec_count_true(f, n)\n        decreases n - i"
  },
  {
    "id": 2561,
    "function": "lemma_sum_of_monotone",
    "file": "Chap52/AdjMatrixGraphMtPer.rs",
    "lines": "76-79",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_sum_of_monotone(i: int, n: int, f: spec_fn(int) -> nat)\n        requires 0 <= i <= n\n        ensures spec_sum_of(i, f) <= spec_sum_of(n, f)\n        decreases n - i"
  },
  {
    "id": 2562,
    "function": "lemma_count_true_bound",
    "file": "Chap52/AdjMatrixGraphMtPer.rs",
    "lines": "86-89",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_count_true_bound(f: spec_fn(int) -> bool, n: int)\n        requires n >= 0\n        ensures spec_count_true(f, n) <= n as nat\n        decreases n"
  },
  {
    "id": 2563,
    "function": "new",
    "file": "Chap52/AdjMatrixGraphMtPer.rs",
    "lines": "105-110",
    "spec_strength": "unknown",
    "snippet": "        fn new(n: N) -> (result: Self)\n            ensures\n                result.spec_wf(),\n                result.spec_n() == n,\n                forall|u: int, v: int| #![auto]\n                    0 <= u < n && 0 <= v < n ==> !result.spec_edge(u, v);"
  },
  {
    "id": 2564,
    "function": "num_vertices",
    "file": "Chap52/AdjMatrixGraphMtPer.rs",
    "lines": "113-115",
    "spec_strength": "unknown",
    "snippet": "        fn num_vertices(&self) -> (n: N)\n            requires self.spec_wf()\n            ensures n as nat == self.spec_n();"
  },
  {
    "id": 2565,
    "function": "num_edges",
    "file": "Chap52/AdjMatrixGraphMtPer.rs",
    "lines": "118-129",
    "spec_strength": "unknown",
    "snippet": "        fn num_edges(&self) -> (m: N)\n            requires\n                self.spec_wf(),\n                spec_sum_of(\n                    self.spec_n() as int,\n                    |u: int| spec_count_true(|v: int| self.spec_edge(u, v), self.spec_n() as int),\n                ) <= usize::MAX as nat\n            ensures\n                m as nat == spec_sum_of(\n                    self.spec_n() as int,\n                    |u: int| spec_count_true(|v: int| self.spec_edge(u, v), self.spec_n() as int),\n                );"
  },
  {
    "id": 2566,
    "function": "has_edge",
    "file": "Chap52/AdjMatrixGraphMtPer.rs",
    "lines": "132-136",
    "spec_strength": "unknown",
    "snippet": "        fn has_edge(&self, u: N, v: N) -> (found: B)\n            requires self.spec_wf()\n            ensures\n                u < self.spec_n() && v < self.spec_n() ==> found == self.spec_edge(u as int, v as int),\n                (u >= self.spec_n() || v >= self.spec_n()) ==> !found;"
  },
  {
    "id": 2567,
    "function": "out_neighbors",
    "file": "Chap52/AdjMatrixGraphMtPer.rs",
    "lines": "139-150",
    "spec_strength": "unknown",
    "snippet": "        fn out_neighbors(&self, u: N) -> (neighbors: ArraySeqMtPerS<N>)\n            requires self.spec_wf()\n            ensures\n                u < self.spec_n() ==> (\n                    (forall|k: int| #![auto] 0 <= k < neighbors.spec_len()\n                        ==> neighbors.spec_index(k) < self.spec_n()\n                            && self.spec_edge(u as int, neighbors.spec_index(k) as int))\n                    && (forall|v: int| #![auto] 0 <= v < self.spec_n() && self.spec_edge(u as int, v)\n                        ==> exists|k: int| #![auto]\n                            0 <= k < neighbors.spec_len() && neighbors.spec_index(k) == v as N)\n                ),\n                u >= self.spec_n() ==> neighbors.spec_len() == 0;"
  },
  {
    "id": 2568,
    "function": "out_degree",
    "file": "Chap52/AdjMatrixGraphMtPer.rs",
    "lines": "153-160",
    "spec_strength": "unknown",
    "snippet": "        fn out_degree(&self, u: N) -> (d: N)\n            requires self.spec_wf()\n            ensures\n                u < self.spec_n() ==> d as nat == spec_count_true(\n                    |v: int| self.spec_edge(u as int, v),\n                    self.spec_n() as int,\n                ),\n                u >= self.spec_n() ==> d == 0;"
  },
  {
    "id": 2569,
    "function": "complement",
    "file": "Chap52/AdjMatrixGraphMtPer.rs",
    "lines": "163-170",
    "spec_strength": "unknown",
    "snippet": "        fn complement(&self) -> (result: Self)\n            requires self.spec_wf()\n            ensures\n                result.spec_wf(),\n                result.spec_n() == self.spec_n(),\n                forall|i: int, j: int| #![auto]\n                    0 <= i < self.spec_n() && 0 <= j < self.spec_n()\n                    ==> result.spec_edge(i, j) == (i != j && !self.spec_edge(i, j));"
  },
  {
    "id": 2570,
    "function": "lemma_count_true_monotone",
    "file": "Chap52/AdjMatrixGraphStEph.rs",
    "lines": "65-68",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_count_true_monotone(f: spec_fn(int) -> bool, i: int, n: int)\n        requires 0 <= i <= n\n        ensures spec_count_true(f, i) <= spec_count_true(f, n)\n        decreases n - i"
  },
  {
    "id": 2571,
    "function": "lemma_sum_of_monotone",
    "file": "Chap52/AdjMatrixGraphStEph.rs",
    "lines": "75-78",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_sum_of_monotone(i: int, n: int, f: spec_fn(int) -> nat)\n        requires 0 <= i <= n\n        ensures spec_sum_of(i, f) <= spec_sum_of(n, f)\n        decreases n - i"
  },
  {
    "id": 2572,
    "function": "lemma_count_true_bound",
    "file": "Chap52/AdjMatrixGraphStEph.rs",
    "lines": "85-88",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_count_true_bound(f: spec_fn(int) -> bool, n: int)\n        requires n >= 0\n        ensures spec_count_true(f, n) <= n as nat\n        decreases n"
  },
  {
    "id": 2573,
    "function": "new",
    "file": "Chap52/AdjMatrixGraphStEph.rs",
    "lines": "104-109",
    "spec_strength": "unknown",
    "snippet": "        fn new(n: N) -> (result: Self)\n            ensures\n                result.spec_wf(),\n                result.spec_n() == n,\n                forall|u: int, v: int| #![auto]\n                    0 <= u < n && 0 <= v < n ==> !result.spec_edge(u, v);"
  },
  {
    "id": 2574,
    "function": "from_matrix",
    "file": "Chap52/AdjMatrixGraphStEph.rs",
    "lines": "112-121",
    "spec_strength": "unknown",
    "snippet": "        fn from_matrix(matrix: ArraySeqStEphS<ArraySeqStEphS<bool>>) -> (result: Self)\n            requires\n                forall|i: int| #![auto] 0 <= i < matrix.spec_len() ==>\n                    matrix.spec_index(i).spec_len() == matrix.spec_len()\n            ensures\n                result.spec_wf(),\n                result.spec_n() == matrix.spec_len(),\n                forall|u: int, v: int| #![auto]\n                    0 <= u < matrix.spec_len() && 0 <= v < matrix.spec_len()\n                    ==> result.spec_edge(u, v) == matrix.spec_index(u).spec_index(v);"
  },
  {
    "id": 2575,
    "function": "num_vertices",
    "file": "Chap52/AdjMatrixGraphStEph.rs",
    "lines": "124-126",
    "spec_strength": "unknown",
    "snippet": "        fn num_vertices(&self) -> (n: N)\n            requires self.spec_wf()\n            ensures n as nat == self.spec_n();"
  },
  {
    "id": 2576,
    "function": "num_edges",
    "file": "Chap52/AdjMatrixGraphStEph.rs",
    "lines": "129-140",
    "spec_strength": "unknown",
    "snippet": "        fn num_edges(&self) -> (m: N)\n            requires\n                self.spec_wf(),\n                spec_sum_of(\n                    self.spec_n() as int,\n                    |u: int| spec_count_true(|v: int| self.spec_edge(u, v), self.spec_n() as int),\n                ) <= usize::MAX as nat\n            ensures\n                m as nat == spec_sum_of(\n                    self.spec_n() as int,\n                    |u: int| spec_count_true(|v: int| self.spec_edge(u, v), self.spec_n() as int),\n                );"
  },
  {
    "id": 2577,
    "function": "has_edge",
    "file": "Chap52/AdjMatrixGraphStEph.rs",
    "lines": "143-145",
    "spec_strength": "unknown",
    "snippet": "        fn has_edge(&self, u: N, v: N) -> (found: B)\n            requires self.spec_wf(), u < self.spec_n(), v < self.spec_n()\n            ensures found == self.spec_edge(u as int, v as int);"
  },
  {
    "id": 2578,
    "function": "out_neighbors",
    "file": "Chap52/AdjMatrixGraphStEph.rs",
    "lines": "148-156",
    "spec_strength": "unknown",
    "snippet": "        fn out_neighbors(&self, u: N) -> (neighbors: ArraySeqStEphS<N>)\n            requires self.spec_wf(), u < self.spec_n()\n            ensures\n                forall|k: int| #![auto] 0 <= k < neighbors.spec_len()\n                    ==> neighbors.spec_index(k) < self.spec_n()\n                        && self.spec_edge(u as int, neighbors.spec_index(k) as int),\n                forall|v: int| #![auto] 0 <= v < self.spec_n() && self.spec_edge(u as int, v)\n                    ==> exists|k: int| #![auto]\n                        0 <= k < neighbors.spec_len() && neighbors.spec_index(k) == v as N;"
  },
  {
    "id": 2579,
    "function": "out_degree",
    "file": "Chap52/AdjMatrixGraphStEph.rs",
    "lines": "159-164",
    "spec_strength": "unknown",
    "snippet": "        fn out_degree(&self, u: N) -> (d: N)\n            requires self.spec_wf(), u < self.spec_n()\n            ensures d as nat == spec_count_true(\n                |v: int| self.spec_edge(u as int, v),\n                self.spec_n() as int,\n            );"
  },
  {
    "id": 2580,
    "function": "set_edge",
    "file": "Chap52/AdjMatrixGraphStEph.rs",
    "lines": "167-179",
    "spec_strength": "unknown",
    "snippet": "        fn set_edge(&mut self, u: N, v: N, exists: B)\n            requires\n                old(self).spec_wf(),\n                u < old(self).spec_n(),\n                v < old(self).spec_n(),\n            ensures\n                self.spec_wf(),\n                self.spec_n() == old(self).spec_n(),\n                self.spec_edge(u as int, v as int) == exists,\n                forall|i: int, j: int| #![auto]\n                    0 <= i < old(self).spec_n() && 0 <= j < old(self).spec_n()\n                    && !(i == u as int && j == v as int)\n                    ==> self.spec_edge(i, j) == old(self).spec_edge(i, j);"
  },
  {
    "id": 2581,
    "function": "complement",
    "file": "Chap52/AdjMatrixGraphStEph.rs",
    "lines": "182-189",
    "spec_strength": "unknown",
    "snippet": "        fn complement(&self) -> (result: Self)\n            requires self.spec_wf()\n            ensures\n                result.spec_wf(),\n                result.spec_n() == self.spec_n(),\n                forall|i: int, j: int| #![auto]\n                    0 <= i < self.spec_n() && 0 <= j < self.spec_n()\n                    ==> result.spec_edge(i, j) == (i != j && !self.spec_edge(i, j));"
  },
  {
    "id": 2582,
    "function": "lemma_count_true_monotone",
    "file": "Chap52/AdjMatrixGraphStPer.rs",
    "lines": "68-71",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_count_true_monotone(f: spec_fn(int) -> bool, i: int, n: int)\n        requires 0 <= i <= n\n        ensures spec_count_true(f, i) <= spec_count_true(f, n)\n        decreases n - i"
  },
  {
    "id": 2583,
    "function": "lemma_sum_of_monotone",
    "file": "Chap52/AdjMatrixGraphStPer.rs",
    "lines": "78-81",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_sum_of_monotone(i: int, n: int, f: spec_fn(int) -> nat)\n        requires 0 <= i <= n\n        ensures spec_sum_of(i, f) <= spec_sum_of(n, f)\n        decreases n - i"
  },
  {
    "id": 2584,
    "function": "lemma_count_true_bound",
    "file": "Chap52/AdjMatrixGraphStPer.rs",
    "lines": "88-91",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_count_true_bound(f: spec_fn(int) -> bool, n: int)\n        requires n >= 0\n        ensures spec_count_true(f, n) <= n as nat\n        decreases n"
  },
  {
    "id": 2585,
    "function": "new",
    "file": "Chap52/AdjMatrixGraphStPer.rs",
    "lines": "107-112",
    "spec_strength": "unknown",
    "snippet": "        fn new(n: N) -> (result: Self)\n            ensures\n                result.spec_wf(),\n                result.spec_n() == n,\n                forall|u: int, v: int| #![auto]\n                    0 <= u < n && 0 <= v < n ==> !result.spec_edge(u, v);"
  },
  {
    "id": 2586,
    "function": "from_matrix",
    "file": "Chap52/AdjMatrixGraphStPer.rs",
    "lines": "115-124",
    "spec_strength": "unknown",
    "snippet": "        fn from_matrix(matrix: ArraySeqStPerS<ArraySeqStPerS<bool>>) -> (result: Self)\n            requires\n                forall|i: int| #![auto] 0 <= i < matrix.spec_len() ==>\n                    matrix.spec_index(i).spec_len() == matrix.spec_len()\n            ensures\n                result.spec_wf(),\n                result.spec_n() == matrix.spec_len(),\n                forall|u: int, v: int| #![auto]\n                    0 <= u < matrix.spec_len() && 0 <= v < matrix.spec_len()\n                    ==> result.spec_edge(u, v) == matrix.spec_index(u).spec_index(v);"
  },
  {
    "id": 2587,
    "function": "num_vertices",
    "file": "Chap52/AdjMatrixGraphStPer.rs",
    "lines": "127-129",
    "spec_strength": "unknown",
    "snippet": "        fn num_vertices(&self) -> (n: N)\n            requires self.spec_wf()\n            ensures n as nat == self.spec_n();"
  },
  {
    "id": 2588,
    "function": "num_edges",
    "file": "Chap52/AdjMatrixGraphStPer.rs",
    "lines": "132-143",
    "spec_strength": "unknown",
    "snippet": "        fn num_edges(&self) -> (m: N)\n            requires\n                self.spec_wf(),\n                spec_sum_of(\n                    self.spec_n() as int,\n                    |u: int| spec_count_true(|v: int| self.spec_edge(u, v), self.spec_n() as int),\n                ) <= usize::MAX as nat\n            ensures\n                m as nat == spec_sum_of(\n                    self.spec_n() as int,\n                    |u: int| spec_count_true(|v: int| self.spec_edge(u, v), self.spec_n() as int),\n                );"
  },
  {
    "id": 2589,
    "function": "has_edge",
    "file": "Chap52/AdjMatrixGraphStPer.rs",
    "lines": "146-148",
    "spec_strength": "unknown",
    "snippet": "        fn has_edge(&self, u: N, v: N) -> (found: B)\n            requires self.spec_wf(), u < self.spec_n(), v < self.spec_n()\n            ensures found == self.spec_edge(u as int, v as int);"
  },
  {
    "id": 2590,
    "function": "out_neighbors",
    "file": "Chap52/AdjMatrixGraphStPer.rs",
    "lines": "151-159",
    "spec_strength": "unknown",
    "snippet": "        fn out_neighbors(&self, u: N) -> (neighbors: ArraySeqStPerS<N>)\n            requires self.spec_wf(), u < self.spec_n()\n            ensures\n                forall|k: int| #![auto] 0 <= k < neighbors.spec_len()\n                    ==> neighbors.spec_index(k) < self.spec_n()\n                        && self.spec_edge(u as int, neighbors.spec_index(k) as int),\n                forall|v: int| #![auto] 0 <= v < self.spec_n() && self.spec_edge(u as int, v)\n                    ==> exists|k: int| #![auto]\n                        0 <= k < neighbors.spec_len() && neighbors.spec_index(k) == v as N;"
  },
  {
    "id": 2591,
    "function": "out_degree",
    "file": "Chap52/AdjMatrixGraphStPer.rs",
    "lines": "162-167",
    "spec_strength": "unknown",
    "snippet": "        fn out_degree(&self, u: N) -> (d: N)\n            requires self.spec_wf(), u < self.spec_n()\n            ensures d as nat == spec_count_true(\n                |v: int| self.spec_edge(u as int, v),\n                self.spec_n() as int,\n            );"
  },
  {
    "id": 2592,
    "function": "set_edge",
    "file": "Chap52/AdjMatrixGraphStPer.rs",
    "lines": "170-182",
    "spec_strength": "unknown",
    "snippet": "        fn set_edge(&self, u: N, v: N, exists: B) -> (result: Self)\n            requires\n                self.spec_wf(),\n                u < self.spec_n(),\n                v < self.spec_n(),\n            ensures\n                result.spec_wf(),\n                result.spec_n() == self.spec_n(),\n                result.spec_edge(u as int, v as int) == exists,\n                forall|i: int, j: int| #![auto]\n                    0 <= i < self.spec_n() && 0 <= j < self.spec_n()\n                    && !(i == u as int && j == v as int)\n                    ==> result.spec_edge(i, j) == self.spec_edge(i, j);"
  },
  {
    "id": 2593,
    "function": "complement",
    "file": "Chap52/AdjMatrixGraphStPer.rs",
    "lines": "185-192",
    "spec_strength": "unknown",
    "snippet": "        fn complement(&self) -> (result: Self)\n            requires self.spec_wf()\n            ensures\n                result.spec_wf(),\n                result.spec_n() == self.spec_n(),\n                forall|i: int, j: int| #![auto]\n                    0 <= i < self.spec_n() && 0 <= j < self.spec_n()\n                    ==> result.spec_edge(i, j) == (i != j && !self.spec_edge(i, j));"
  },
  {
    "id": 2594,
    "function": "lemma_sum_of_monotone",
    "file": "Chap52/AdjSeqGraphMtEph.rs",
    "lines": "55-58",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_sum_of_monotone(i: int, n: int, f: spec_fn(int) -> nat)\n        requires 0 <= i <= n\n        ensures spec_sum_of(i, f) <= spec_sum_of(n, f)\n        decreases n - i"
  },
  {
    "id": 2595,
    "function": "lemma_sum_of_unfold",
    "file": "Chap52/AdjSeqGraphMtEph.rs",
    "lines": "66-68",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_sum_of_unfold(i: int, f: spec_fn(int) -> nat)\n        requires i >= 0\n        ensures spec_sum_of(i + 1, f) == f(i) + spec_sum_of(i, f)"
  },
  {
    "id": 2596,
    "function": "new",
    "file": "Chap52/AdjSeqGraphMtEph.rs",
    "lines": "82-85",
    "spec_strength": "unknown",
    "snippet": "        fn new(n: N) -> (result: Self)\n            ensures\n                result.spec_num_vertices() == n,\n                forall|i: int| #![auto] 0 <= i < n ==> result.spec_degree(i) == 0;"
  },
  {
    "id": 2597,
    "function": "num_vertices",
    "file": "Chap52/AdjSeqGraphMtEph.rs",
    "lines": "88-89",
    "spec_strength": "unknown",
    "snippet": "        fn num_vertices(&self) -> (n: N)\n            ensures n as nat == self.spec_num_vertices();"
  },
  {
    "id": 2598,
    "function": "num_edges",
    "file": "Chap52/AdjSeqGraphMtEph.rs",
    "lines": "92-102",
    "spec_strength": "unknown",
    "snippet": "        fn num_edges(&self) -> (m: N)\n            requires\n                spec_sum_of(\n                    self.spec_num_vertices() as int,\n                    |i: int| self.spec_degree(i),\n                ) <= usize::MAX as nat\n            ensures\n                m as nat == spec_sum_of(\n                    self.spec_num_vertices() as int,\n                    |i: int| self.spec_degree(i),\n                );"
  },
  {
    "id": 2599,
    "function": "has_edge",
    "file": "Chap52/AdjSeqGraphMtEph.rs",
    "lines": "105-109",
    "spec_strength": "unknown",
    "snippet": "        fn has_edge(&self, u: N, v: N) -> (found: B)\n            requires u < self.spec_num_vertices()\n            ensures found == exists|j: int|\n                #![auto] 0 <= j < self.spec_degree(u as int)\n                && self.spec_neighbor(u as int, j) == v;"
  },
  {
    "id": 2600,
    "function": "out_neighbors",
    "file": "Chap52/AdjSeqGraphMtEph.rs",
    "lines": "112-117",
    "spec_strength": "unknown",
    "snippet": "        fn out_neighbors(&self, u: N) -> (neighbors: ArraySeqMtEphS<N>)\n            requires u < self.spec_num_vertices()\n            ensures\n                neighbors.spec_len() == self.spec_degree(u as int),\n                forall|j: int| #![auto] 0 <= j < neighbors.spec_len()\n                    ==> neighbors.spec_index(j) == self.spec_neighbor(u as int, j);"
  },
  {
    "id": 2601,
    "function": "out_degree",
    "file": "Chap52/AdjSeqGraphMtEph.rs",
    "lines": "120-122",
    "spec_strength": "unknown",
    "snippet": "        fn out_degree(&self, u: N) -> (d: N)\n            requires u < self.spec_num_vertices()\n            ensures d as nat == self.spec_degree(u as int);"
  },
  {
    "id": 2602,
    "function": "set_edge",
    "file": "Chap52/AdjSeqGraphMtEph.rs",
    "lines": "125-142",
    "spec_strength": "unknown",
    "snippet": "        fn set_edge(&mut self, u: N, v: N, exists: B)\n            requires\n                u < old(self).spec_num_vertices(),\n                v < old(self).spec_num_vertices(),\n            ensures\n                self.spec_num_vertices() == old(self).spec_num_vertices(),\n                forall|i: int| #![auto] 0 <= i < old(self).spec_num_vertices() && i != u as int\n                    ==> self.spec_degree(i) == old(self).spec_degree(i),\n                forall|i: int, j: int| #![auto]\n                    0 <= i < old(self).spec_num_vertices() && i != u as int\n                    && 0 <= j < old(self).spec_degree(i)\n                    ==> self.spec_neighbor(i, j) == old(self).spec_neighbor(i, j),\n                exists ==> (exists|j: int| #![auto]\n                    0 <= j < self.spec_degree(u as int)\n                    && self.spec_neighbor(u as int, j) == v),\n                !exists ==> forall|j: int| #![auto]\n                    0 <= j < self.spec_degree(u as int)\n                    ==> self.spec_neighbor(u as int, j) != v;"
  },
  {
    "id": 2603,
    "function": "lemma_sum_of_monotone",
    "file": "Chap52/AdjSeqGraphMtPer.rs",
    "lines": "51-54",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_sum_of_monotone(i: int, n: int, f: spec_fn(int) -> nat)\n        requires 0 <= i <= n\n        ensures spec_sum_of(i, f) <= spec_sum_of(n, f)\n        decreases n - i"
  },
  {
    "id": 2604,
    "function": "lemma_sum_of_unfold",
    "file": "Chap52/AdjSeqGraphMtPer.rs",
    "lines": "61-63",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_sum_of_unfold(i: int, f: spec_fn(int) -> nat)\n        requires i >= 0\n        ensures spec_sum_of(i + 1, f) == f(i) + spec_sum_of(i, f)"
  },
  {
    "id": 2605,
    "function": "new",
    "file": "Chap52/AdjSeqGraphMtPer.rs",
    "lines": "77-80",
    "spec_strength": "unknown",
    "snippet": "        fn new(n: N) -> (result: Self)\n            ensures\n                result.spec_num_vertices() == n,\n                forall|i: int| #![auto] 0 <= i < n ==> result.spec_degree(i) == 0;"
  },
  {
    "id": 2606,
    "function": "num_vertices",
    "file": "Chap52/AdjSeqGraphMtPer.rs",
    "lines": "83-84",
    "spec_strength": "unknown",
    "snippet": "        fn num_vertices(&self) -> (n: N)\n            ensures n as nat == self.spec_num_vertices();"
  },
  {
    "id": 2607,
    "function": "num_edges",
    "file": "Chap52/AdjSeqGraphMtPer.rs",
    "lines": "87-97",
    "spec_strength": "unknown",
    "snippet": "        fn num_edges(&self) -> (m: N)\n            requires\n                spec_sum_of(\n                    self.spec_num_vertices() as int,\n                    |i: int| self.spec_degree(i),\n                ) <= usize::MAX as nat\n            ensures\n                m as nat == spec_sum_of(\n                    self.spec_num_vertices() as int,\n                    |i: int| self.spec_degree(i),\n                );"
  },
  {
    "id": 2608,
    "function": "has_edge",
    "file": "Chap52/AdjSeqGraphMtPer.rs",
    "lines": "100-104",
    "spec_strength": "unknown",
    "snippet": "        fn has_edge(&self, u: N, v: N) -> (found: B)\n            requires u < self.spec_num_vertices()\n            ensures found == exists|j: int|\n                #![auto] 0 <= j < self.spec_degree(u as int)\n                && self.spec_neighbor(u as int, j) == v;"
  },
  {
    "id": 2609,
    "function": "out_neighbors",
    "file": "Chap52/AdjSeqGraphMtPer.rs",
    "lines": "107-112",
    "spec_strength": "unknown",
    "snippet": "        fn out_neighbors(&self, u: N) -> (neighbors: &ArraySeqMtPerS<N>)\n            requires u < self.spec_num_vertices()\n            ensures\n                neighbors.spec_len() == self.spec_degree(u as int),\n                forall|j: int| #![auto] 0 <= j < neighbors.spec_len()\n                    ==> neighbors.spec_index(j) == self.spec_neighbor(u as int, j);"
  },
  {
    "id": 2610,
    "function": "out_degree",
    "file": "Chap52/AdjSeqGraphMtPer.rs",
    "lines": "115-117",
    "spec_strength": "unknown",
    "snippet": "        fn out_degree(&self, u: N) -> (d: N)\n            requires u < self.spec_num_vertices()\n            ensures d as nat == self.spec_degree(u as int);"
  },
  {
    "id": 2611,
    "function": "lemma_sum_of_monotone",
    "file": "Chap52/AdjSeqGraphStEph.rs",
    "lines": "53-56",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_sum_of_monotone(i: int, n: int, f: spec_fn(int) -> nat)\n        requires 0 <= i <= n\n        ensures spec_sum_of(i, f) <= spec_sum_of(n, f)\n        decreases n - i"
  },
  {
    "id": 2612,
    "function": "lemma_sum_of_unfold",
    "file": "Chap52/AdjSeqGraphStEph.rs",
    "lines": "64-66",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_sum_of_unfold(i: int, f: spec_fn(int) -> nat)\n        requires i >= 0\n        ensures spec_sum_of(i + 1, f) == f(i) + spec_sum_of(i, f)"
  },
  {
    "id": 2613,
    "function": "new",
    "file": "Chap52/AdjSeqGraphStEph.rs",
    "lines": "80-83",
    "spec_strength": "unknown",
    "snippet": "        fn new(n: N) -> (result: Self)\n            ensures\n                result.spec_num_vertices() == n,\n                forall|i: int| #![auto] 0 <= i < n ==> result.spec_degree(i) == 0;"
  },
  {
    "id": 2614,
    "function": "from_seq",
    "file": "Chap52/AdjSeqGraphStEph.rs",
    "lines": "86-93",
    "spec_strength": "unknown",
    "snippet": "        fn from_seq(adj: ArraySeqStEphS<ArraySeqStEphS<N>>) -> (result: Self)\n            ensures\n                result.spec_num_vertices() == adj.spec_len(),\n                forall|i: int| #![auto] 0 <= i < adj.spec_len() ==>\n                    result.spec_degree(i) == adj.spec_index(i).spec_len(),\n                forall|i: int, j: int| #![auto] 0 <= i < adj.spec_len()\n                    && 0 <= j < adj.spec_index(i).spec_len()\n                    ==> result.spec_neighbor(i, j) == adj.spec_index(i).spec_index(j);"
  },
  {
    "id": 2615,
    "function": "num_vertices",
    "file": "Chap52/AdjSeqGraphStEph.rs",
    "lines": "96-97",
    "spec_strength": "unknown",
    "snippet": "        fn num_vertices(&self) -> (n: N)\n            ensures n as nat == self.spec_num_vertices();"
  },
  {
    "id": 2616,
    "function": "num_edges",
    "file": "Chap52/AdjSeqGraphStEph.rs",
    "lines": "100-110",
    "spec_strength": "unknown",
    "snippet": "        fn num_edges(&self) -> (m: N)\n            requires\n                spec_sum_of(\n                    self.spec_num_vertices() as int,\n                    |i: int| self.spec_degree(i),\n                ) <= usize::MAX as nat\n            ensures\n                m as nat == spec_sum_of(\n                    self.spec_num_vertices() as int,\n                    |i: int| self.spec_degree(i),\n                );"
  },
  {
    "id": 2617,
    "function": "has_edge",
    "file": "Chap52/AdjSeqGraphStEph.rs",
    "lines": "113-117",
    "spec_strength": "unknown",
    "snippet": "        fn has_edge(&self, u: N, v: N) -> (found: B)\n            requires u < self.spec_num_vertices()\n            ensures found == exists|j: int|\n                #![auto] 0 <= j < self.spec_degree(u as int)\n                && self.spec_neighbor(u as int, j) == v;"
  },
  {
    "id": 2618,
    "function": "out_neighbors",
    "file": "Chap52/AdjSeqGraphStEph.rs",
    "lines": "120-125",
    "spec_strength": "unknown",
    "snippet": "        fn out_neighbors(&self, u: N) -> (neighbors: ArraySeqStEphS<N>)\n            requires u < self.spec_num_vertices()\n            ensures\n                neighbors.spec_len() == self.spec_degree(u as int),\n                forall|j: int| #![auto] 0 <= j < neighbors.spec_len()\n                    ==> neighbors.spec_index(j) == self.spec_neighbor(u as int, j);"
  },
  {
    "id": 2619,
    "function": "out_degree",
    "file": "Chap52/AdjSeqGraphStEph.rs",
    "lines": "128-130",
    "spec_strength": "unknown",
    "snippet": "        fn out_degree(&self, u: N) -> (d: N)\n            requires u < self.spec_num_vertices()\n            ensures d as nat == self.spec_degree(u as int);"
  },
  {
    "id": 2620,
    "function": "set_neighbors",
    "file": "Chap52/AdjSeqGraphStEph.rs",
    "lines": "133-145",
    "spec_strength": "unknown",
    "snippet": "        fn set_neighbors(&mut self, v: N, neighbors: ArraySeqStEphS<N>)\n            requires v < old(self).spec_num_vertices()\n            ensures\n                self.spec_num_vertices() == old(self).spec_num_vertices(),\n                self.spec_degree(v as int) == neighbors.spec_len(),\n                forall|j: int| #![auto] 0 <= j < neighbors.spec_len()\n                    ==> self.spec_neighbor(v as int, j) == neighbors.spec_index(j),\n                forall|i: int| #![auto] 0 <= i < old(self).spec_num_vertices() && i != v as int\n                    ==> self.spec_degree(i) == old(self).spec_degree(i),\n                forall|i: int, j: int| #![auto]\n                    0 <= i < old(self).spec_num_vertices() && i != v as int\n                    && 0 <= j < old(self).spec_degree(i)\n                    ==> self.spec_neighbor(i, j) == old(self).spec_neighbor(i, j);"
  },
  {
    "id": 2621,
    "function": "set_edge",
    "file": "Chap52/AdjSeqGraphStEph.rs",
    "lines": "148-165",
    "spec_strength": "unknown",
    "snippet": "        fn set_edge(&mut self, u: N, v: N, exists: B)\n            requires\n                u < old(self).spec_num_vertices(),\n                v < old(self).spec_num_vertices(),\n            ensures\n                self.spec_num_vertices() == old(self).spec_num_vertices(),\n                forall|i: int| #![auto] 0 <= i < old(self).spec_num_vertices() && i != u as int\n                    ==> self.spec_degree(i) == old(self).spec_degree(i),\n                forall|i: int, j: int| #![auto]\n                    0 <= i < old(self).spec_num_vertices() && i != u as int\n                    && 0 <= j < old(self).spec_degree(i)\n                    ==> self.spec_neighbor(i, j) == old(self).spec_neighbor(i, j),\n                exists ==> (exists|j: int| #![auto]\n                    0 <= j < self.spec_degree(u as int)\n                    && self.spec_neighbor(u as int, j) == v),\n                !exists ==> forall|j: int| #![auto]\n                    0 <= j < self.spec_degree(u as int)\n                    ==> self.spec_neighbor(u as int, j) != v;"
  },
  {
    "id": 2622,
    "function": "lemma_sum_of_monotone",
    "file": "Chap52/AdjSeqGraphStPer.rs",
    "lines": "54-57",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_sum_of_monotone(i: int, n: int, f: spec_fn(int) -> nat)\n        requires 0 <= i <= n\n        ensures spec_sum_of(i, f) <= spec_sum_of(n, f)\n        decreases n - i"
  },
  {
    "id": 2623,
    "function": "lemma_sum_of_unfold",
    "file": "Chap52/AdjSeqGraphStPer.rs",
    "lines": "65-67",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_sum_of_unfold(i: int, f: spec_fn(int) -> nat)\n        requires i >= 0\n        ensures spec_sum_of(i + 1, f) == f(i) + spec_sum_of(i, f)"
  },
  {
    "id": 2624,
    "function": "new",
    "file": "Chap52/AdjSeqGraphStPer.rs",
    "lines": "81-84",
    "spec_strength": "unknown",
    "snippet": "        fn new(n: N) -> (result: Self)\n            ensures\n                result.spec_num_vertices() == n,\n                forall|i: int| #![auto] 0 <= i < n ==> result.spec_degree(i) == 0;"
  },
  {
    "id": 2625,
    "function": "from_seq",
    "file": "Chap52/AdjSeqGraphStPer.rs",
    "lines": "87-94",
    "spec_strength": "unknown",
    "snippet": "        fn from_seq(adj: ArraySeqStPerS<ArraySeqStPerS<N>>) -> (result: Self)\n            ensures\n                result.spec_num_vertices() == adj.spec_len(),\n                forall|i: int| #![auto] 0 <= i < adj.spec_len() ==>\n                    result.spec_degree(i) == adj.spec_index(i).spec_len(),\n                forall|i: int, j: int| #![auto] 0 <= i < adj.spec_len()\n                    && 0 <= j < adj.spec_index(i).spec_len()\n                    ==> result.spec_neighbor(i, j) == adj.spec_index(i).spec_index(j);"
  },
  {
    "id": 2626,
    "function": "num_vertices",
    "file": "Chap52/AdjSeqGraphStPer.rs",
    "lines": "97-98",
    "spec_strength": "unknown",
    "snippet": "        fn num_vertices(&self) -> (n: N)\n            ensures n as nat == self.spec_num_vertices();"
  },
  {
    "id": 2627,
    "function": "num_edges",
    "file": "Chap52/AdjSeqGraphStPer.rs",
    "lines": "101-111",
    "spec_strength": "unknown",
    "snippet": "        fn num_edges(&self) -> (m: N)\n            requires\n                spec_sum_of(\n                    self.spec_num_vertices() as int,\n                    |i: int| self.spec_degree(i),\n                ) <= usize::MAX as nat\n            ensures\n                m as nat == spec_sum_of(\n                    self.spec_num_vertices() as int,\n                    |i: int| self.spec_degree(i),\n                );"
  },
  {
    "id": 2628,
    "function": "has_edge",
    "file": "Chap52/AdjSeqGraphStPer.rs",
    "lines": "114-118",
    "spec_strength": "unknown",
    "snippet": "        fn has_edge(&self, u: N, v: N) -> (found: B)\n            requires u < self.spec_num_vertices()\n            ensures found == exists|j: int|\n                #![auto] 0 <= j < self.spec_degree(u as int)\n                && self.spec_neighbor(u as int, j) == v;"
  },
  {
    "id": 2629,
    "function": "out_neighbors",
    "file": "Chap52/AdjSeqGraphStPer.rs",
    "lines": "121-126",
    "spec_strength": "unknown",
    "snippet": "        fn out_neighbors(&self, u: N) -> (neighbors: &ArraySeqStPerS<N>)\n            requires u < self.spec_num_vertices()\n            ensures\n                neighbors.spec_len() == self.spec_degree(u as int),\n                forall|j: int| #![auto] 0 <= j < neighbors.spec_len()\n                    ==> neighbors.spec_index(j) == self.spec_neighbor(u as int, j);"
  },
  {
    "id": 2630,
    "function": "out_degree",
    "file": "Chap52/AdjSeqGraphStPer.rs",
    "lines": "129-131",
    "spec_strength": "unknown",
    "snippet": "        fn out_degree(&self, u: N) -> (d: N)\n            requires u < self.spec_num_vertices()\n            ensures d as nat == self.spec_degree(u as int);"
  },
  {
    "id": 2631,
    "function": "insert_edge",
    "file": "Chap52/AdjSeqGraphStPer.rs",
    "lines": "134-148",
    "spec_strength": "unknown",
    "snippet": "        fn insert_edge(&self, u: N, v: N) -> (result: Self)\n            requires\n                u < self.spec_num_vertices(),\n                v < self.spec_num_vertices(),\n            ensures\n                result.spec_num_vertices() == self.spec_num_vertices(),\n                forall|i: int| #![auto] 0 <= i < self.spec_num_vertices() && i != u as int\n                    ==> result.spec_degree(i) == self.spec_degree(i),\n                forall|i: int, j: int| #![auto]\n                    0 <= i < self.spec_num_vertices() && i != u as int\n                    && 0 <= j < self.spec_degree(i)\n                    ==> result.spec_neighbor(i, j) == self.spec_neighbor(i, j),\n                exists|j: int| #![auto]\n                    0 <= j < result.spec_degree(u as int)\n                    && result.spec_neighbor(u as int, j) == v;"
  },
  {
    "id": 2632,
    "function": "delete_edge",
    "file": "Chap52/AdjSeqGraphStPer.rs",
    "lines": "151-163",
    "spec_strength": "unknown",
    "snippet": "        fn delete_edge(&self, u: N, v: N) -> (result: Self)\n            requires u < self.spec_num_vertices()\n            ensures\n                result.spec_num_vertices() == self.spec_num_vertices(),\n                forall|i: int| #![auto] 0 <= i < self.spec_num_vertices() && i != u as int\n                    ==> result.spec_degree(i) == self.spec_degree(i),\n                forall|i: int, j: int| #![auto]\n                    0 <= i < self.spec_num_vertices() && i != u as int\n                    && 0 <= j < self.spec_degree(i)\n                    ==> result.spec_neighbor(i, j) == self.spec_neighbor(i, j),\n                forall|j: int| #![auto]\n                    0 <= j < result.spec_degree(u as int)\n                    ==> result.spec_neighbor(u as int, j) != v;"
  },
  {
    "id": 2633,
    "function": "empty",
    "file": "Chap52/AdjTableGraphMtPer.rs",
    "lines": "59",
    "spec_strength": "",
    "snippet": "        fn empty()                          -> Self;"
  },
  {
    "id": 2634,
    "function": "num_vertices",
    "file": "Chap52/AdjTableGraphMtPer.rs",
    "lines": "61",
    "spec_strength": "",
    "snippet": "        fn num_vertices(&self)              -> N;"
  },
  {
    "id": 2635,
    "function": "num_edges",
    "file": "Chap52/AdjTableGraphMtPer.rs",
    "lines": "63-65",
    "spec_strength": "unknown",
    "snippet": "        fn num_edges(&self) -> (m: N)\n            requires self.spec_num_edges() <= usize::MAX as nat\n            ensures m as nat == self.spec_num_edges();"
  },
  {
    "id": 2636,
    "function": "has_edge",
    "file": "Chap52/AdjTableGraphMtPer.rs",
    "lines": "67-68",
    "spec_strength": "unknown",
    "snippet": "        fn has_edge(&self, u: &V, v: &V) -> (found: B)\n            ensures found == (self.spec_adj().dom().contains(u@) && self.spec_adj()[u@].contains(v@));"
  },
  {
    "id": 2637,
    "function": "out_neighbors",
    "file": "Chap52/AdjTableGraphMtPer.rs",
    "lines": "70-73",
    "spec_strength": "unknown",
    "snippet": "        fn out_neighbors(&self, u: &V) -> (result: AVLTreeSetMtPer<V>)\n            ensures\n                self.spec_adj().dom().contains(u@) ==> result@ == self.spec_adj()[u@],\n                !self.spec_adj().dom().contains(u@) ==> result@ == Set::<<V as View>::V>::empty();"
  },
  {
    "id": 2638,
    "function": "out_degree",
    "file": "Chap52/AdjTableGraphMtPer.rs",
    "lines": "75",
    "spec_strength": "",
    "snippet": "        fn out_degree(&self, u: &V)         -> N;"
  },
  {
    "id": 2639,
    "function": "insert_vertex",
    "file": "Chap52/AdjTableGraphMtPer.rs",
    "lines": "77-78",
    "spec_strength": "unknown",
    "snippet": "        fn insert_vertex(&self, v: V) -> (result: Self)\n            ensures result.spec_adj().dom().contains(v@);"
  },
  {
    "id": 2640,
    "function": "delete_vertex",
    "file": "Chap52/AdjTableGraphMtPer.rs",
    "lines": "80-81",
    "spec_strength": "hole",
    "snippet": "        fn delete_vertex(&self, v: &V) -> (result: Self)\n            ensures !result.spec_adj().dom().contains(v@);"
  },
  {
    "id": 2641,
    "function": "insert_edge",
    "file": "Chap52/AdjTableGraphMtPer.rs",
    "lines": "83-87",
    "spec_strength": "unknown",
    "snippet": "        fn insert_edge(&self, u: V, v: V) -> (result: Self)\n            ensures\n                result.spec_adj().dom().contains(u@),\n                result.spec_adj().dom().contains(v@),\n                result.spec_adj()[u@].contains(v@);"
  },
  {
    "id": 2642,
    "function": "delete_edge",
    "file": "Chap52/AdjTableGraphMtPer.rs",
    "lines": "89-92",
    "spec_strength": "unknown",
    "snippet": "        fn delete_edge(&self, u: &V, v: &V) -> (result: Self)\n            ensures\n                !result.spec_adj().dom().contains(u@)\n                    || !result.spec_adj()[u@].contains(v@);"
  },
  {
    "id": 2643,
    "function": "default",
    "file": "Chap52/AdjTableGraphMtPer.rs",
    "lines": "269",
    "spec_strength": "",
    "snippet": "        fn default() -> Self { Self::empty() }"
  },
  {
    "id": 2644,
    "function": "lemma_sum_adj_sizes_monotone",
    "file": "Chap52/AdjTableGraphStEph.rs",
    "lines": "67-69",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_sum_adj_sizes_monotone<VV>(m: Map<VV, Set<VV>>, sub: Set<VV>)\n        requires m.dom().finite(), sub.finite(), sub.subset_of(m.dom())\n        ensures spec_sum_adj_sizes(m) >= 0"
  },
  {
    "id": 2645,
    "function": "empty",
    "file": "Chap52/AdjTableGraphStEph.rs",
    "lines": "80",
    "spec_strength": "",
    "snippet": "        fn empty()                                                     -> Self;"
  },
  {
    "id": 2646,
    "function": "from_table",
    "file": "Chap52/AdjTableGraphStEph.rs",
    "lines": "82",
    "spec_strength": "",
    "snippet": "        fn from_table(table: OrderedTableStEph<V, AVLTreeSetStEph<V>>) -> Self;"
  },
  {
    "id": 2647,
    "function": "num_vertices",
    "file": "Chap52/AdjTableGraphStEph.rs",
    "lines": "84",
    "spec_strength": "",
    "snippet": "        fn num_vertices(&self)                                         -> N;"
  },
  {
    "id": 2648,
    "function": "num_edges",
    "file": "Chap52/AdjTableGraphStEph.rs",
    "lines": "86-88",
    "spec_strength": "unknown",
    "snippet": "        fn num_edges(&self) -> (m: N)\n            requires self.spec_num_edges() <= usize::MAX as nat\n            ensures m as nat == self.spec_num_edges();"
  },
  {
    "id": 2649,
    "function": "vertices",
    "file": "Chap52/AdjTableGraphStEph.rs",
    "lines": "90",
    "spec_strength": "unknown",
    "snippet": "        fn vertices(&self)                                             -> AVLTreeSetStEph<V>;"
  },
  {
    "id": 2650,
    "function": "has_edge",
    "file": "Chap52/AdjTableGraphStEph.rs",
    "lines": "92",
    "spec_strength": "unknown",
    "snippet": "        fn has_edge(&self, u: &V, v: &V)                               -> B;"
  },
  {
    "id": 2651,
    "function": "out_neighbors",
    "file": "Chap52/AdjTableGraphStEph.rs",
    "lines": "94",
    "spec_strength": "unknown",
    "snippet": "        fn out_neighbors(&self, u: &V)                                 -> AVLTreeSetStEph<V>;"
  },
  {
    "id": 2652,
    "function": "out_degree",
    "file": "Chap52/AdjTableGraphStEph.rs",
    "lines": "96",
    "spec_strength": "",
    "snippet": "        fn out_degree(&self, u: &V)                                    -> N;"
  },
  {
    "id": 2653,
    "function": "insert_vertex",
    "file": "Chap52/AdjTableGraphStEph.rs",
    "lines": "98",
    "spec_strength": "unknown",
    "snippet": "        fn insert_vertex(&mut self, v: V);"
  },
  {
    "id": 2654,
    "function": "delete_vertex",
    "file": "Chap52/AdjTableGraphStEph.rs",
    "lines": "100",
    "spec_strength": "unknown",
    "snippet": "        fn delete_vertex(&mut self, v: &V);"
  },
  {
    "id": 2655,
    "function": "insert_edge",
    "file": "Chap52/AdjTableGraphStEph.rs",
    "lines": "102",
    "spec_strength": "unknown",
    "snippet": "        fn insert_edge(&mut self, u: V, v: V);"
  },
  {
    "id": 2656,
    "function": "delete_edge",
    "file": "Chap52/AdjTableGraphStEph.rs",
    "lines": "104",
    "spec_strength": "unknown",
    "snippet": "        fn delete_edge(&mut self, u: &V, v: &V);"
  },
  {
    "id": 2657,
    "function": "empty",
    "file": "Chap52/AdjTableGraphStPer.rs",
    "lines": "48",
    "spec_strength": "",
    "snippet": "        fn empty()                                                     -> Self;"
  },
  {
    "id": 2658,
    "function": "from_table",
    "file": "Chap52/AdjTableGraphStPer.rs",
    "lines": "50",
    "spec_strength": "",
    "snippet": "        fn from_table(table: OrderedTableStPer<V, AVLTreeSetStPer<V>>) -> Self;"
  },
  {
    "id": 2659,
    "function": "num_vertices",
    "file": "Chap52/AdjTableGraphStPer.rs",
    "lines": "52",
    "spec_strength": "",
    "snippet": "        fn num_vertices(&self)                                         -> N;"
  },
  {
    "id": 2660,
    "function": "num_edges",
    "file": "Chap52/AdjTableGraphStPer.rs",
    "lines": "54-56",
    "spec_strength": "unknown",
    "snippet": "        fn num_edges(&self) -> (m: N)\n            requires self.spec_num_edges() <= usize::MAX as nat\n            ensures m as nat == self.spec_num_edges();"
  },
  {
    "id": 2661,
    "function": "vertices",
    "file": "Chap52/AdjTableGraphStPer.rs",
    "lines": "58-59",
    "spec_strength": "unknown",
    "snippet": "        fn vertices(&self) -> (result: AVLTreeSetStPer<V>)\n            ensures result@ == self.spec_adj().dom();"
  },
  {
    "id": 2662,
    "function": "has_edge",
    "file": "Chap52/AdjTableGraphStPer.rs",
    "lines": "61-62",
    "spec_strength": "unknown",
    "snippet": "        fn has_edge(&self, u: &V, v: &V) -> (found: B)\n            ensures found == (self.spec_adj().dom().contains(u@) && self.spec_adj()[u@].contains(v@));"
  },
  {
    "id": 2663,
    "function": "out_neighbors",
    "file": "Chap52/AdjTableGraphStPer.rs",
    "lines": "64-67",
    "spec_strength": "unknown",
    "snippet": "        fn out_neighbors(&self, u: &V) -> (result: AVLTreeSetStPer<V>)\n            ensures\n                self.spec_adj().dom().contains(u@) ==> result@ == self.spec_adj()[u@],\n                !self.spec_adj().dom().contains(u@) ==> result@ == Set::<<V as View>::V>::empty();"
  },
  {
    "id": 2664,
    "function": "out_degree",
    "file": "Chap52/AdjTableGraphStPer.rs",
    "lines": "69",
    "spec_strength": "",
    "snippet": "        fn out_degree(&self, u: &V)                                    -> N;"
  },
  {
    "id": 2665,
    "function": "insert_vertex",
    "file": "Chap52/AdjTableGraphStPer.rs",
    "lines": "71-72",
    "spec_strength": "unknown",
    "snippet": "        fn insert_vertex(&self, v: V) -> (result: Self)\n            ensures result.spec_adj().dom().contains(v@);"
  },
  {
    "id": 2666,
    "function": "delete_vertex",
    "file": "Chap52/AdjTableGraphStPer.rs",
    "lines": "74-75",
    "spec_strength": "unknown",
    "snippet": "        fn delete_vertex(&self, v: &V) -> (result: Self)\n            ensures !result.spec_adj().dom().contains(v@);"
  },
  {
    "id": 2667,
    "function": "insert_edge",
    "file": "Chap52/AdjTableGraphStPer.rs",
    "lines": "77-81",
    "spec_strength": "unknown",
    "snippet": "        fn insert_edge(&self, u: V, v: V) -> (result: Self)\n            ensures\n                result.spec_adj().dom().contains(u@),\n                result.spec_adj().dom().contains(v@),\n                result.spec_adj()[u@].contains(v@);"
  },
  {
    "id": 2668,
    "function": "delete_edge",
    "file": "Chap52/AdjTableGraphStPer.rs",
    "lines": "83-86",
    "spec_strength": "unknown",
    "snippet": "        fn delete_edge(&self, u: &V, v: &V) -> (result: Self)\n            ensures\n                !result.spec_adj().dom().contains(u@)\n                    || !result.spec_adj()[u@].contains(v@);"
  },
  {
    "id": 2669,
    "function": "empty",
    "file": "Chap52/EdgeSetGraphMtPer.rs",
    "lines": "50",
    "spec_strength": "",
    "snippet": "        fn empty()                                                                        -> Self;"
  },
  {
    "id": 2670,
    "function": "from_vertices_and_edges",
    "file": "Chap52/EdgeSetGraphMtPer.rs",
    "lines": "52",
    "spec_strength": "",
    "snippet": "        fn from_vertices_and_edges(v: AVLTreeSetMtPer<V>, e: AVLTreeSetMtPer<Pair<V, V>>) -> Self;"
  },
  {
    "id": 2671,
    "function": "num_vertices",
    "file": "Chap52/EdgeSetGraphMtPer.rs",
    "lines": "54",
    "spec_strength": "",
    "snippet": "        fn num_vertices(&self)                                                            -> N;"
  },
  {
    "id": 2672,
    "function": "num_edges",
    "file": "Chap52/EdgeSetGraphMtPer.rs",
    "lines": "56",
    "spec_strength": "",
    "snippet": "        fn num_edges(&self)                                                               -> N;"
  },
  {
    "id": 2673,
    "function": "vertices",
    "file": "Chap52/EdgeSetGraphMtPer.rs",
    "lines": "58",
    "spec_strength": "",
    "snippet": "        fn vertices(&self)                                                                -> &AVLTreeSetMtPer<V>;"
  },
  {
    "id": 2674,
    "function": "edges",
    "file": "Chap52/EdgeSetGraphMtPer.rs",
    "lines": "60",
    "spec_strength": "",
    "snippet": "        fn edges(&self)                                                                   -> &AVLTreeSetMtPer<Pair<V, V>>;"
  },
  {
    "id": 2675,
    "function": "has_edge",
    "file": "Chap52/EdgeSetGraphMtPer.rs",
    "lines": "62",
    "spec_strength": "",
    "snippet": "        fn has_edge(&self, u: &V, v: &V)                                                  -> B;"
  },
  {
    "id": 2676,
    "function": "out_neighbors",
    "file": "Chap52/EdgeSetGraphMtPer.rs",
    "lines": "64-65",
    "spec_strength": "hole",
    "snippet": "        fn out_neighbors(&self, u: &V) -> (result: AVLTreeSetMtPer<V>)\n            ensures result@ == Set::new(|v: <V as View>::V| self.edges@.contains((u@, v)));"
  },
  {
    "id": 2677,
    "function": "out_degree",
    "file": "Chap52/EdgeSetGraphMtPer.rs",
    "lines": "67",
    "spec_strength": "",
    "snippet": "        fn out_degree(&self, u: &V)                                                       -> N;"
  },
  {
    "id": 2678,
    "function": "insert_vertex",
    "file": "Chap52/EdgeSetGraphMtPer.rs",
    "lines": "69",
    "spec_strength": "",
    "snippet": "        fn insert_vertex(&self, v: V)                                                     -> Self;"
  },
  {
    "id": 2679,
    "function": "delete_vertex",
    "file": "Chap52/EdgeSetGraphMtPer.rs",
    "lines": "71-72",
    "spec_strength": "unknown",
    "snippet": "        fn delete_vertex(&self, v: &V) -> (result: Self)\n            ensures !result.vertices@.contains(v@);"
  },
  {
    "id": 2680,
    "function": "insert_edge",
    "file": "Chap52/EdgeSetGraphMtPer.rs",
    "lines": "74",
    "spec_strength": "",
    "snippet": "        fn insert_edge(&self, u: V, v: V)                                                 -> Self;"
  },
  {
    "id": 2681,
    "function": "delete_edge",
    "file": "Chap52/EdgeSetGraphMtPer.rs",
    "lines": "76",
    "spec_strength": "",
    "snippet": "        fn delete_edge(&self, u: &V, v: &V)                                               -> Self;"
  },
  {
    "id": 2682,
    "function": "default",
    "file": "Chap52/EdgeSetGraphMtPer.rs",
    "lines": "184",
    "spec_strength": "",
    "snippet": "        fn default() -> Self { Self::empty() }"
  },
  {
    "id": 2683,
    "function": "empty",
    "file": "Chap52/EdgeSetGraphStEph.rs",
    "lines": "46",
    "spec_strength": "",
    "snippet": "        fn empty()                                                                        -> Self;"
  },
  {
    "id": 2684,
    "function": "from_vertices_and_edges",
    "file": "Chap52/EdgeSetGraphStEph.rs",
    "lines": "48",
    "spec_strength": "",
    "snippet": "        fn from_vertices_and_edges(v: AVLTreeSetStEph<V>, e: AVLTreeSetStEph<Pair<V, V>>) -> Self;"
  },
  {
    "id": 2685,
    "function": "num_vertices",
    "file": "Chap52/EdgeSetGraphStEph.rs",
    "lines": "50",
    "spec_strength": "",
    "snippet": "        fn num_vertices(&self)                                                            -> N;"
  },
  {
    "id": 2686,
    "function": "num_edges",
    "file": "Chap52/EdgeSetGraphStEph.rs",
    "lines": "52",
    "spec_strength": "",
    "snippet": "        fn num_edges(&self)                                                               -> N;"
  },
  {
    "id": 2687,
    "function": "vertices",
    "file": "Chap52/EdgeSetGraphStEph.rs",
    "lines": "54",
    "spec_strength": "",
    "snippet": "        fn vertices(&self)                                                                -> &AVLTreeSetStEph<V>;"
  },
  {
    "id": 2688,
    "function": "edges",
    "file": "Chap52/EdgeSetGraphStEph.rs",
    "lines": "56",
    "spec_strength": "",
    "snippet": "        fn edges(&self)                                                                   -> &AVLTreeSetStEph<Pair<V, V>>;"
  },
  {
    "id": 2689,
    "function": "has_edge",
    "file": "Chap52/EdgeSetGraphStEph.rs",
    "lines": "58",
    "spec_strength": "",
    "snippet": "        fn has_edge(&self, u: &V, v: &V)                                                  -> B;"
  },
  {
    "id": 2690,
    "function": "out_neighbors",
    "file": "Chap52/EdgeSetGraphStEph.rs",
    "lines": "60-61",
    "spec_strength": "unknown",
    "snippet": "        fn out_neighbors(&self, u: &V) -> (result: AVLTreeSetStEph<V>)\n            ensures result@ == self.spec_out_neighbors(u@);"
  },
  {
    "id": 2691,
    "function": "out_degree",
    "file": "Chap52/EdgeSetGraphStEph.rs",
    "lines": "63",
    "spec_strength": "",
    "snippet": "        fn out_degree(&self, u: &V)                                                       -> N;"
  },
  {
    "id": 2692,
    "function": "insert_vertex",
    "file": "Chap52/EdgeSetGraphStEph.rs",
    "lines": "65",
    "spec_strength": "",
    "snippet": "        fn insert_vertex(&mut self, v: V);"
  },
  {
    "id": 2693,
    "function": "delete_vertex",
    "file": "Chap52/EdgeSetGraphStEph.rs",
    "lines": "67-68",
    "spec_strength": "unknown",
    "snippet": "        fn delete_vertex(&mut self, v: &V)\n            ensures !self.spec_vertices().contains(v@);"
  },
  {
    "id": 2694,
    "function": "insert_edge",
    "file": "Chap52/EdgeSetGraphStEph.rs",
    "lines": "70",
    "spec_strength": "",
    "snippet": "        fn insert_edge(&mut self, u: V, v: V);"
  },
  {
    "id": 2695,
    "function": "delete_edge",
    "file": "Chap52/EdgeSetGraphStEph.rs",
    "lines": "72",
    "spec_strength": "",
    "snippet": "        fn delete_edge(&mut self, u: &V, v: &V);"
  },
  {
    "id": 2696,
    "function": "empty",
    "file": "Chap52/EdgeSetGraphStPer.rs",
    "lines": "48",
    "spec_strength": "",
    "snippet": "        fn empty()                                                                        -> Self;"
  },
  {
    "id": 2697,
    "function": "from_vertices_and_edges",
    "file": "Chap52/EdgeSetGraphStPer.rs",
    "lines": "50",
    "spec_strength": "",
    "snippet": "        fn from_vertices_and_edges(v: AVLTreeSetStPer<V>, e: AVLTreeSetStPer<Pair<V, V>>) -> Self;"
  },
  {
    "id": 2698,
    "function": "num_vertices",
    "file": "Chap52/EdgeSetGraphStPer.rs",
    "lines": "52",
    "spec_strength": "",
    "snippet": "        fn num_vertices(&self)                                                            -> N;"
  },
  {
    "id": 2699,
    "function": "num_edges",
    "file": "Chap52/EdgeSetGraphStPer.rs",
    "lines": "54",
    "spec_strength": "",
    "snippet": "        fn num_edges(&self)                                                               -> N;"
  },
  {
    "id": 2700,
    "function": "vertices",
    "file": "Chap52/EdgeSetGraphStPer.rs",
    "lines": "56",
    "spec_strength": "",
    "snippet": "        fn vertices(&self)                                                                -> &AVLTreeSetStPer<V>;"
  },
  {
    "id": 2701,
    "function": "edges",
    "file": "Chap52/EdgeSetGraphStPer.rs",
    "lines": "58",
    "spec_strength": "",
    "snippet": "        fn edges(&self)                                                                   -> &AVLTreeSetStPer<Pair<V, V>>;"
  },
  {
    "id": 2702,
    "function": "has_edge",
    "file": "Chap52/EdgeSetGraphStPer.rs",
    "lines": "60",
    "spec_strength": "",
    "snippet": "        fn has_edge(&self, u: &V, v: &V)                                                  -> B;"
  },
  {
    "id": 2703,
    "function": "out_neighbors",
    "file": "Chap52/EdgeSetGraphStPer.rs",
    "lines": "62-63",
    "spec_strength": "unknown",
    "snippet": "        fn out_neighbors(&self, u: &V) -> (result: AVLTreeSetStPer<V>)\n            ensures result@ == self.spec_out_neighbors(u@);"
  },
  {
    "id": 2704,
    "function": "out_degree",
    "file": "Chap52/EdgeSetGraphStPer.rs",
    "lines": "65",
    "spec_strength": "",
    "snippet": "        fn out_degree(&self, u: &V)                                                       -> N;"
  },
  {
    "id": 2705,
    "function": "insert_vertex",
    "file": "Chap52/EdgeSetGraphStPer.rs",
    "lines": "67",
    "spec_strength": "",
    "snippet": "        fn insert_vertex(&self, v: V)                                                     -> Self;"
  },
  {
    "id": 2706,
    "function": "delete_vertex",
    "file": "Chap52/EdgeSetGraphStPer.rs",
    "lines": "69-70",
    "spec_strength": "unknown",
    "snippet": "        fn delete_vertex(&self, v: &V) -> (result: Self)\n            ensures !result.vertices@.contains(v@);"
  },
  {
    "id": 2707,
    "function": "insert_edge",
    "file": "Chap52/EdgeSetGraphStPer.rs",
    "lines": "72",
    "spec_strength": "",
    "snippet": "        fn insert_edge(&self, u: V, v: V)                                                 -> Self;"
  },
  {
    "id": 2708,
    "function": "delete_edge",
    "file": "Chap52/EdgeSetGraphStPer.rs",
    "lines": "74",
    "spec_strength": "",
    "snippet": "        fn delete_edge(&self, u: &V, v: &V)                                               -> Self;"
  },
  {
    "id": 2709,
    "function": "select`",
    "file": "Chap53/GraphSearchMtPer.rs",
    "lines": "30",
    "spec_strength": "hole",
    "snippet": "        fn select(&self, frontier: &AVLTreeSetMtPer<V>) -> (AVLTreeSetMtPer<V>, B);"
  },
  {
    "id": 2710,
    "function": "graph_search",
    "file": "Chap53/GraphSearchMtPer.rs",
    "lines": "36-39",
    "spec_strength": "hole",
    "snippet": "        fn graph_search<G, S>(graph: &G, source: V, strategy: &S)                         -> SearchResult<V>\n        where\n            G: Fn(&V) -> AVLTreeSetMtPer<V>,\n            S: SelectionStrategy<V>;"
  },
  {
    "id": 2711,
    "function": "graph_search_multi",
    "file": "Chap53/GraphSearchMtPer.rs",
    "lines": "43-46",
    "spec_strength": "hole",
    "snippet": "        fn graph_search_multi<G, S>(graph: &G, sources: AVLTreeSetMtPer<V>, strategy: &S) -> SearchResult<V>\n        where\n            G: Fn(&V) -> AVLTreeSetMtPer<V>,\n            S: SelectionStrategy<V>;"
  },
  {
    "id": 2712,
    "function": "reachable",
    "file": "Chap53/GraphSearchMtPer.rs",
    "lines": "50-52",
    "spec_strength": "hole",
    "snippet": "        fn reachable<G>(graph: &G, source: V)                                             -> AVLTreeSetMtPer<V>\n        where\n            G: Fn(&V) -> AVLTreeSetMtPer<V>;"
  },
  {
    "id": 2713,
    "function": "explore",
    "file": "Chap53/GraphSearchMtPer.rs",
    "lines": "99-108",
    "spec_strength": "",
    "snippet": "        fn explore<V, G, S>(\n            graph: &G,\n            strategy: &S,\n            visited: AVLTreeSetMtPer<V>,\n            frontier: AVLTreeSetMtPer<V>,\n        ) -> AVLTreeSetMtPer<V>\n        where\n            V: StTInMtT + Ord + 'static,\n            G: Fn(&V) -> AVLTreeSetMtPer<V>,\n            S: SelectionStrategy<V>,"
  },
  {
    "id": 2714,
    "function": "select`",
    "file": "Chap53/GraphSearchStEph.rs",
    "lines": "25",
    "spec_strength": "hole",
    "snippet": "        fn select(&self, frontier: &AVLTreeSetStEph<V>) -> (AVLTreeSetStEph<V>, B);"
  },
  {
    "id": 2715,
    "function": "graph_search",
    "file": "Chap53/GraphSearchStEph.rs",
    "lines": "31-34",
    "spec_strength": "hole",
    "snippet": "        fn graph_search<G, S>(graph: &G, source: V, strategy: &S)                         -> SearchResult<V>\n        where\n            G: Fn(&V) -> AVLTreeSetStEph<V>,\n            S: SelectionStrategy<V>;"
  },
  {
    "id": 2716,
    "function": "graph_search_multi",
    "file": "Chap53/GraphSearchStEph.rs",
    "lines": "38-41",
    "spec_strength": "hole",
    "snippet": "        fn graph_search_multi<G, S>(graph: &G, sources: AVLTreeSetStEph<V>, strategy: &S) -> SearchResult<V>\n        where\n            G: Fn(&V) -> AVLTreeSetStEph<V>,\n            S: SelectionStrategy<V>;"
  },
  {
    "id": 2717,
    "function": "reachable",
    "file": "Chap53/GraphSearchStEph.rs",
    "lines": "45-47",
    "spec_strength": "hole",
    "snippet": "        fn reachable<G>(graph: &G, source: V)                                             -> AVLTreeSetStEph<V>\n        where\n            G: Fn(&V) -> AVLTreeSetStEph<V>;"
  },
  {
    "id": 2718,
    "function": "explore",
    "file": "Chap53/GraphSearchStEph.rs",
    "lines": "91-100",
    "spec_strength": "",
    "snippet": "        fn explore<V, G, S>(\n            graph: &G,\n            strategy: &S,\n            visited: AVLTreeSetStEph<V>,\n            frontier: AVLTreeSetStEph<V>,\n        ) -> AVLTreeSetStEph<V>\n        where\n            V: StT + Ord,\n            G: Fn(&V) -> AVLTreeSetStEph<V>,\n            S: SelectionStrategy<V>,"
  },
  {
    "id": 2719,
    "function": "select`",
    "file": "Chap53/GraphSearchStPer.rs",
    "lines": "33",
    "spec_strength": "hole",
    "snippet": "        fn select(&self, frontier: &AVLTreeSetStPer<V>) -> (AVLTreeSetStPer<V>, B);"
  },
  {
    "id": 2720,
    "function": "graph_search",
    "file": "Chap53/GraphSearchStPer.rs",
    "lines": "39-42",
    "spec_strength": "hole",
    "snippet": "        fn graph_search<G, S>(graph: &G, source: V, strategy: &S)                         -> SearchResult<V>\n        where\n            G: Fn(&V) -> AVLTreeSetStPer<V>,\n            S: SelectionStrategy<V>;"
  },
  {
    "id": 2721,
    "function": "graph_search_multi",
    "file": "Chap53/GraphSearchStPer.rs",
    "lines": "46-49",
    "spec_strength": "hole",
    "snippet": "        fn graph_search_multi<G, S>(graph: &G, sources: AVLTreeSetStPer<V>, strategy: &S) -> SearchResult<V>\n        where\n            G: Fn(&V) -> AVLTreeSetStPer<V>,\n            S: SelectionStrategy<V>;"
  },
  {
    "id": 2722,
    "function": "reachable",
    "file": "Chap53/GraphSearchStPer.rs",
    "lines": "53-55",
    "spec_strength": "hole",
    "snippet": "        fn reachable<G>(graph: &G, source: V)                                             -> AVLTreeSetStPer<V>\n        where\n            G: Fn(&V) -> AVLTreeSetStPer<V>;"
  },
  {
    "id": 2723,
    "function": "explore",
    "file": "Chap53/GraphSearchStPer.rs",
    "lines": "103-112",
    "spec_strength": "",
    "snippet": "        fn explore<V, G, S>(\n            graph: &G,\n            strategy: &S,\n            visited: AVLTreeSetStPer<V>,\n            frontier: AVLTreeSetStPer<V>,\n        ) -> AVLTreeSetStPer<V>\n        where\n            V: StT + Ord,\n            G: Fn(&V) -> AVLTreeSetStPer<V>,\n            S: SelectionStrategy<V>,"
  },
  {
    "id": 2724,
    "function": "priority",
    "file": "Chap53/PQMinStEph.rs",
    "lines": "30",
    "spec_strength": "hole",
    "snippet": "        fn priority(&self, v: &V) -> P;"
  },
  {
    "id": 2725,
    "function": "pq_min",
    "file": "Chap53/PQMinStEph.rs",
    "lines": "36-39",
    "spec_strength": "hole",
    "snippet": "        fn pq_min<G, PF>(graph: &G, source: V, priority_fn: &PF)                         -> PQMinResult<V, P>\n        where\n            G: Fn(&V) -> AVLTreeSetStEph<V>,\n            PF: PriorityFn<V, P>;"
  },
  {
    "id": 2726,
    "function": "pq_min_multi",
    "file": "Chap53/PQMinStEph.rs",
    "lines": "43-46",
    "spec_strength": "hole",
    "snippet": "        fn pq_min_multi<G, PF>(graph: &G, sources: AVLTreeSetStEph<V>, priority_fn: &PF) -> PQMinResult<V, P>\n        where\n            G: Fn(&V) -> AVLTreeSetStEph<V>,\n            PF: PriorityFn<V, P>;"
  },
  {
    "id": 2727,
    "function": "new",
    "file": "Chap53/PQMinStEph.rs",
    "lines": "50",
    "spec_strength": "hole",
    "snippet": "        fn new(f: F) -> Self;"
  },
  {
    "id": 2728,
    "function": "find_min_priority",
    "file": "Chap53/PQMinStEph.rs",
    "lines": "95",
    "spec_strength": "",
    "snippet": "        fn find_min_priority<V: StT + Ord, P: StT + Ord>(frontier: &AVLTreeSetStEph<Pair<Pair<P, V>, V>>) -> Option<V> {"
  },
  {
    "id": 2729,
    "function": "explore",
    "file": "Chap53/PQMinStEph.rs",
    "lines": "104-114",
    "spec_strength": "",
    "snippet": "        fn explore<V, P, G, PF>(\n            graph: &G,\n            priority_fn: &PF,\n            visited: AVLTreeSetStEph<V>,\n            frontier: AVLTreeSetStEph<Pair<Pair<P, V>, V>>,\n        ) -> (AVLTreeSetStEph<V>, AVLTreeSetStEph<Pair<V, P>>)\n        where\n            V: StT + Ord,\n            P: StT + Ord,\n            G: Fn(&V) -> AVLTreeSetStEph<V>,\n            PF: PriorityFn<V, P>,"
  },
  {
    "id": 2730,
    "function": "priority",
    "file": "Chap53/PQMinStPer.rs",
    "lines": "29",
    "spec_strength": "hole",
    "snippet": "        fn priority(&self, v: &V) -> P;"
  },
  {
    "id": 2731,
    "function": "pq_min",
    "file": "Chap53/PQMinStPer.rs",
    "lines": "42-45",
    "spec_strength": "hole",
    "snippet": "        fn pq_min<G, PF>(graph: &G, source: V, priority_fn: &PF)                         -> PQMinResult<V, P>\n        where\n            G: Fn(&V) -> AVLTreeSetStPer<V>,\n            PF: PriorityFn<V, P>;"
  },
  {
    "id": 2732,
    "function": "pq_min_multi",
    "file": "Chap53/PQMinStPer.rs",
    "lines": "49-52",
    "spec_strength": "hole",
    "snippet": "        fn pq_min_multi<G, PF>(graph: &G, sources: AVLTreeSetStPer<V>, priority_fn: &PF) -> PQMinResult<V, P>\n        where\n            G: Fn(&V) -> AVLTreeSetStPer<V>,\n            PF: PriorityFn<V, P>;"
  },
  {
    "id": 2733,
    "function": "new",
    "file": "Chap53/PQMinStPer.rs",
    "lines": "56",
    "spec_strength": "hole",
    "snippet": "        fn new(f: F) -> Self;"
  },
  {
    "id": 2734,
    "function": "find_min_priority",
    "file": "Chap53/PQMinStPer.rs",
    "lines": "101",
    "spec_strength": "",
    "snippet": "        fn find_min_priority<V: StT + Ord, P: StT + Ord>(frontier: &AVLTreeSetStPer<Pair<Pair<P, V>, V>>) -> Option<V> {"
  },
  {
    "id": 2735,
    "function": "explore",
    "file": "Chap53/PQMinStPer.rs",
    "lines": "112-122",
    "spec_strength": "",
    "snippet": "        fn explore<V, P, G, PF>(\n            graph: &G,\n            priority_fn: &PF,\n            visited: AVLTreeSetStPer<V>,\n            frontier: AVLTreeSetStPer<Pair<Pair<P, V>, V>>, // ((priority, vertex), vertex)\n        ) -> (AVLTreeSetStPer<V>, AVLTreeSetStPer<Pair<V, P>>)\n        where\n            V: StT + Ord,\n            P: StT + Ord,\n            G: Fn(&V) -> AVLTreeSetStPer<V>,\n            PF: PriorityFn<V, P>,"
  },
  {
    "id": 2736,
    "function": "lemma_tabulate_all_no_parent",
    "file": "Chap54/BFSMtEph.rs",
    "lines": "55-60",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_tabulate_all_no_parent(parents: &ArraySeqMtEphS<N>, n: int)\n        requires\n            parents.spec_len() == n,\n            forall|i: int| #![auto] 0 <= i < n ==> parents.spec_index(i) == NO_PARENT,\n        ensures\n            spec_parents_bounded(parents, n),"
  },
  {
    "id": 2737,
    "function": "lemma_set_preserves_parents_bounded",
    "file": "Chap54/BFSMtEph.rs",
    "lines": "63-80",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_set_preserves_parents_bounded(\n        parents: &ArraySeqMtEphS<N>,\n        old_parents: &ArraySeqMtEphS<N>,\n        v: int,\n        new_val: N,\n        n: int,\n    )\n        requires\n            parents.spec_len() == n,\n            old_parents.spec_len() == n,\n            0 <= v < n,\n            new_val < n,\n            parents.spec_index(v) == new_val,\n            forall|j: int| #![auto] 0 <= j < n && j != v ==>\n                parents.spec_index(j) == old_parents.spec_index(j),\n            spec_parents_bounded(old_parents, n),\n        ensures\n            spec_parents_bounded(parents, n),"
  },
  {
    "id": 2738,
    "function": "lemma_copy_preserves_parents_bounded",
    "file": "Chap54/BFSMtEph.rs",
    "lines": "94-105",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_copy_preserves_parents_bounded(\n        original: &ArraySeqMtEphS<N>,\n        copy: &ArraySeqMtEphS<N>,\n        n: int,\n    )\n        requires\n            spec_parents_bounded(original, n),\n            copy.spec_len() == original.spec_len(),\n            forall|i: int| #![auto] 0 <= i < original.spec_len() ==>\n                copy.spec_index(i) == original.spec_index(i),\n        ensures\n            spec_parents_bounded(copy, n),"
  },
  {
    "id": 2739,
    "function": "lemma_tabulate_all_unreachable",
    "file": "Chap54/BFSMtEph.rs",
    "lines": "115-121",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_tabulate_all_unreachable(distances: &ArraySeqMtEphS<N>, n: int)\n        requires\n            distances.spec_len() == n,\n            forall|i: int| #![auto] 0 <= i < n ==>\n                distances.spec_index(i) == UNREACHABLE,\n        ensures\n            spec_distances_bounded(distances, n),"
  },
  {
    "id": 2740,
    "function": "lemma_set_preserves_bounded",
    "file": "Chap54/BFSMtEph.rs",
    "lines": "125-142",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_set_preserves_bounded(\n        distances: &ArraySeqMtEphS<N>,\n        old_distances: &ArraySeqMtEphS<N>,\n        v: int,\n        new_val: N,\n        n: int,\n    )\n        requires\n            distances.spec_len() == n,\n            old_distances.spec_len() == n,\n            0 <= v < n,\n            new_val < n,\n            distances.spec_index(v) == new_val,\n            forall|j: int| #![auto] 0 <= j < n && j != v ==>\n                distances.spec_index(j) == old_distances.spec_index(j),\n            spec_distances_bounded(old_distances, n),\n        ensures\n            spec_distances_bounded(distances, n),"
  },
  {
    "id": 2741,
    "function": "copy_distances",
    "file": "Chap54/BFSMtEph.rs",
    "lines": "157-162",
    "spec_strength": "unknown",
    "snippet": "    fn copy_distances(distances: &ArraySeqMtEphS<N>) -> (result: ArraySeqMtEphS<N>)\n        requires distances.spec_len() <= usize::MAX,\n        ensures\n            result.spec_len() == distances.spec_len(),\n            forall|i: int| #![auto] 0 <= i < distances.spec_len() ==>\n                result.spec_index(i) == distances.spec_index(i),"
  },
  {
    "id": 2742,
    "function": "copy_graph",
    "file": "Chap54/BFSMtEph.rs",
    "lines": "175-183",
    "spec_strength": "unknown",
    "snippet": "    fn copy_graph(graph: &ArraySeqMtEphS<ArraySeqMtEphS<N>>) -> (result: ArraySeqMtEphS<ArraySeqMtEphS<N>>)\n        requires graph.spec_len() <= usize::MAX,\n        ensures\n            result.spec_len() == graph.spec_len(),\n            forall|u: int| #![auto] 0 <= u < graph.spec_len() ==>\n                result.spec_index(u).spec_len() == graph.spec_index(u).spec_len(),\n            forall|u: int, i: int| #![auto]\n                0 <= u < graph.spec_len() && 0 <= i < graph.spec_index(u).spec_len() ==>\n                result.spec_index(u).spec_index(i) == graph.spec_index(u).spec_index(i),"
  },
  {
    "id": 2743,
    "function": "lemma_copy_preserves_wf",
    "file": "Chap54/BFSMtEph.rs",
    "lines": "208-221",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_copy_preserves_wf(\n        original: &ArraySeqMtEphS<ArraySeqMtEphS<N>>,\n        copy: &ArraySeqMtEphS<ArraySeqMtEphS<N>>,\n    )\n        requires\n            spec_wf_graph(original),\n            copy.spec_len() == original.spec_len(),\n            forall|u: int| #![auto] 0 <= u < original.spec_len() ==>\n                copy.spec_index(u).spec_len() == original.spec_index(u).spec_len(),\n            forall|u: int, i: int| #![auto]\n                0 <= u < original.spec_len() && 0 <= i < original.spec_index(u).spec_len() ==>\n                copy.spec_index(u).spec_index(i) == original.spec_index(u).spec_index(i),\n        ensures\n            spec_wf_graph(copy),"
  },
  {
    "id": 2744,
    "function": "lemma_copy_preserves_bounded",
    "file": "Chap54/BFSMtEph.rs",
    "lines": "233-244",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_copy_preserves_bounded(\n        original: &ArraySeqMtEphS<N>,\n        copy: &ArraySeqMtEphS<N>,\n        n: int,\n    )\n        requires\n            spec_distances_bounded(original, n),\n            copy.spec_len() == original.spec_len(),\n            forall|i: int| #![auto] 0 <= i < original.spec_len() ==>\n                copy.spec_index(i) == original.spec_index(i),\n        ensures\n            spec_distances_bounded(copy, n),"
  },
  {
    "id": 2745,
    "function": "top_down_order",
    "file": "Chap54/BFSMtEph.rs",
    "lines": "259-264",
    "spec_strength": "unknown",
    "snippet": "        fn top_down_order(&self) -> (result: &ArraySeqMtEphS<N>)\n            ensures\n                result.spec_len() == self.spec_order().spec_len(),\n                forall|i: int| #![auto] 0 <= i < result.spec_len() ==>\n                    result.spec_index(i) == self.spec_order().spec_index(i),\n        ;"
  },
  {
    "id": 2746,
    "function": "bottom_up_order",
    "file": "Chap54/BFSMtEph.rs",
    "lines": "267-273",
    "spec_strength": "unknown",
    "snippet": "        fn bottom_up_order(&self) -> (result: ArraySeqMtEphS<N>)\n            requires self.spec_order().spec_len() <= usize::MAX,\n            ensures\n                result.spec_len() == self.spec_order().spec_len(),\n                forall|i: int| #![auto] 0 <= i < result.spec_len() ==>\n                    result.spec_index(i) == self.spec_order().spec_index(self.spec_order().spec_len() - 1 - i),\n        ;"
  },
  {
    "id": 2747,
    "function": "bfs",
    "file": "Chap54/BFSMtEph.rs",
    "lines": "277-287",
    "spec_strength": "unknown",
    "snippet": "        fn bfs(graph: &ArraySeqMtEphS<ArraySeqMtEphS<N>>, source: N) -> (result: ArraySeqMtEphS<N>)\n            requires\n                source < graph.spec_len(),\n                graph.spec_len() > 0,\n                graph.spec_len() < usize::MAX,\n                spec_wf_graph(graph),\n            ensures\n                result.spec_len() == graph.spec_len(),\n                result.spec_index(source as int) == 0usize,\n                spec_distances_bounded(&result, graph.spec_len() as int),\n        ;"
  },
  {
    "id": 2748,
    "function": "bfs_tree",
    "file": "Chap54/BFSMtEph.rs",
    "lines": "291-305",
    "spec_strength": "unknown",
    "snippet": "        fn bfs_tree(graph: &ArraySeqMtEphS<ArraySeqMtEphS<N>>, source: N) -> (result: BFSTreeS)\n            requires\n                source < graph.spec_len(),\n                graph.spec_len() > 0,\n                graph.spec_len() < usize::MAX,\n                spec_wf_graph(graph),\n            ensures\n                result.parents.spec_len() == graph.spec_len(),\n                result.parents.spec_index(source as int) == source,\n                result.order.spec_len() > 0,\n                result.order.spec_index(0) == source,\n                forall|i: int| #![auto] 0 <= i < result.order.spec_len()\n                    ==> result.order.spec_index(i) < graph.spec_len(),\n                spec_parents_bounded(&result.parents, graph.spec_len() as int),\n        ;"
  },
  {
    "id": 2749,
    "function": "process_frontier_parallel",
    "file": "Chap54/BFSMtEph.rs",
    "lines": "311-333",
    "spec_strength": "unknown",
    "snippet": "    fn process_frontier_parallel(\n        graph: ArraySeqMtEphS<ArraySeqMtEphS<N>>,\n        distances: ArraySeqMtEphS<N>,\n        frontier: Vec<N>,\n        next_dist: N,\n    ) -> (result: (Vec<N>, Vec<Pair<N, N>>))\n        requires\n            graph.spec_len() > 0,\n            graph.spec_len() < usize::MAX,\n            spec_wf_graph(&graph),\n            distances.spec_len() == graph.spec_len(),\n            spec_distances_bounded(&distances, graph.spec_len() as int),\n            next_dist < graph.spec_len(),\n            forall|j: int| #![auto] 0 <= j < frontier@.len() ==>\n                frontier@[j] < graph.spec_len(),\n        ensures\n            forall|j: int| #![auto] 0 <= j < result.0@.len() ==>\n                result.0@[j] < graph.spec_len(),\n            forall|j: int| #![auto] 0 <= j < result.1@.len() ==>\n                result.1@[j].0 < graph.spec_len()\n                && result.1@[j].1 == next_dist\n                && distances.spec_index(result.1@[j].0 as int) == UNREACHABLE,\n        decreases frontier@.len()"
  },
  {
    "id": 2750,
    "function": "process_frontier_tree_parallel",
    "file": "Chap54/BFSMtEph.rs",
    "lines": "595-613",
    "spec_strength": "unknown",
    "snippet": "    fn process_frontier_tree_parallel(\n        graph: ArraySeqMtEphS<ArraySeqMtEphS<N>>,\n        parents: ArraySeqMtEphS<N>,\n        frontier: Vec<N>,\n    ) -> (result: Vec<Pair<N, N>>)\n        requires\n            graph.spec_len() > 0,\n            graph.spec_len() < usize::MAX,\n            spec_wf_graph(&graph),\n            parents.spec_len() == graph.spec_len(),\n            spec_parents_bounded(&parents, graph.spec_len() as int),\n            forall|j: int| #![auto] 0 <= j < frontier@.len() ==>\n                frontier@[j] < graph.spec_len(),\n        ensures\n            forall|j: int| #![auto] 0 <= j < result@.len() ==>\n                result@[j].0 < graph.spec_len()\n                && result@[j].1 < graph.spec_len()\n                && parents.spec_index(result@[j].0 as int) == NO_PARENT,\n        decreases frontier@.len()"
  },
  {
    "id": 2751,
    "function": "lemma_tabulate_all_no_parent",
    "file": "Chap54/BFSMtPer.rs",
    "lines": "55-60",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_tabulate_all_no_parent(parents: &ArraySeqMtPerS<N>, n: int)\n        requires\n            parents.spec_len() == n,\n            forall|i: int| #![auto] 0 <= i < n ==> parents.spec_index(i) == NO_PARENT,\n        ensures\n            spec_parents_bounded(parents, n),"
  },
  {
    "id": 2752,
    "function": "lemma_update_preserves_parents_bounded",
    "file": "Chap54/BFSMtPer.rs",
    "lines": "63-80",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_update_preserves_parents_bounded(\n        parents: &ArraySeqMtPerS<N>,\n        old_parents: &ArraySeqMtPerS<N>,\n        v: int,\n        new_val: N,\n        n: int,\n    )\n        requires\n            parents.spec_len() == n,\n            old_parents.spec_len() == n,\n            0 <= v < n,\n            new_val < n,\n            parents.spec_index(v) == new_val,\n            forall|j: int| #![auto] 0 <= j < n && j != v ==>\n                parents.spec_index(j) == old_parents.spec_index(j),\n            spec_parents_bounded(old_parents, n),\n        ensures\n            spec_parents_bounded(parents, n),"
  },
  {
    "id": 2753,
    "function": "lemma_copy_preserves_parents_bounded",
    "file": "Chap54/BFSMtPer.rs",
    "lines": "94-105",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_copy_preserves_parents_bounded(\n        original: &ArraySeqMtPerS<N>,\n        copy: &ArraySeqMtPerS<N>,\n        n: int,\n    )\n        requires\n            spec_parents_bounded(original, n),\n            copy.spec_len() == original.spec_len(),\n            forall|i: int| #![auto] 0 <= i < original.spec_len() ==>\n                copy.spec_index(i) == original.spec_index(i),\n        ensures\n            spec_parents_bounded(copy, n),"
  },
  {
    "id": 2754,
    "function": "lemma_tabulate_all_unreachable",
    "file": "Chap54/BFSMtPer.rs",
    "lines": "115-121",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_tabulate_all_unreachable(distances: &ArraySeqMtPerS<N>, n: int)\n        requires\n            distances.spec_len() == n,\n            forall|i: int| #![auto] 0 <= i < n ==>\n                distances.spec_index(i) == UNREACHABLE,\n        ensures\n            spec_distances_bounded(distances, n),"
  },
  {
    "id": 2755,
    "function": "lemma_update_preserves_bounded",
    "file": "Chap54/BFSMtPer.rs",
    "lines": "125-142",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_update_preserves_bounded(\n        distances: &ArraySeqMtPerS<N>,\n        old_distances: &ArraySeqMtPerS<N>,\n        v: int,\n        new_val: N,\n        n: int,\n    )\n        requires\n            distances.spec_len() == n,\n            old_distances.spec_len() == n,\n            0 <= v < n,\n            new_val < n,\n            distances.spec_index(v) == new_val,\n            forall|j: int| #![auto] 0 <= j < n && j != v ==>\n                distances.spec_index(j) == old_distances.spec_index(j),\n            spec_distances_bounded(old_distances, n),\n        ensures\n            spec_distances_bounded(distances, n),"
  },
  {
    "id": 2756,
    "function": "copy_distances",
    "file": "Chap54/BFSMtPer.rs",
    "lines": "157-162",
    "spec_strength": "unknown",
    "snippet": "    fn copy_distances(distances: &ArraySeqMtPerS<N>) -> (result: ArraySeqMtPerS<N>)\n        requires distances.spec_len() <= usize::MAX,\n        ensures\n            result.spec_len() == distances.spec_len(),\n            forall|i: int| #![auto] 0 <= i < distances.spec_len() ==>\n                result.spec_index(i) == distances.spec_index(i),"
  },
  {
    "id": 2757,
    "function": "copy_graph",
    "file": "Chap54/BFSMtPer.rs",
    "lines": "175-183",
    "spec_strength": "unknown",
    "snippet": "    fn copy_graph(graph: &ArraySeqMtPerS<ArraySeqMtPerS<N>>) -> (result: ArraySeqMtPerS<ArraySeqMtPerS<N>>)\n        requires graph.spec_len() <= usize::MAX,\n        ensures\n            result.spec_len() == graph.spec_len(),\n            forall|u: int| #![auto] 0 <= u < graph.spec_len() ==>\n                result.spec_index(u).spec_len() == graph.spec_index(u).spec_len(),\n            forall|u: int, i: int| #![auto]\n                0 <= u < graph.spec_len() && 0 <= i < graph.spec_index(u).spec_len() ==>\n                result.spec_index(u).spec_index(i) == graph.spec_index(u).spec_index(i),"
  },
  {
    "id": 2758,
    "function": "lemma_copy_preserves_wf",
    "file": "Chap54/BFSMtPer.rs",
    "lines": "209-222",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_copy_preserves_wf(\n        original: &ArraySeqMtPerS<ArraySeqMtPerS<N>>,\n        copy: &ArraySeqMtPerS<ArraySeqMtPerS<N>>,\n    )\n        requires\n            spec_wf_graph(original),\n            copy.spec_len() == original.spec_len(),\n            forall|u: int| #![auto] 0 <= u < original.spec_len() ==>\n                copy.spec_index(u).spec_len() == original.spec_index(u).spec_len(),\n            forall|u: int, i: int| #![auto]\n                0 <= u < original.spec_len() && 0 <= i < original.spec_index(u).spec_len() ==>\n                copy.spec_index(u).spec_index(i) == original.spec_index(u).spec_index(i),\n        ensures\n            spec_wf_graph(copy),"
  },
  {
    "id": 2759,
    "function": "lemma_copy_preserves_bounded",
    "file": "Chap54/BFSMtPer.rs",
    "lines": "235-246",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_copy_preserves_bounded(\n        original: &ArraySeqMtPerS<N>,\n        copy: &ArraySeqMtPerS<N>,\n        n: int,\n    )\n        requires\n            spec_distances_bounded(original, n),\n            copy.spec_len() == original.spec_len(),\n            forall|i: int| #![auto] 0 <= i < original.spec_len() ==>\n                copy.spec_index(i) == original.spec_index(i),\n        ensures\n            spec_distances_bounded(copy, n),"
  },
  {
    "id": 2760,
    "function": "top_down_order",
    "file": "Chap54/BFSMtPer.rs",
    "lines": "261-266",
    "spec_strength": "unknown",
    "snippet": "        fn top_down_order(&self) -> (result: &ArraySeqMtPerS<N>)\n            ensures\n                result.spec_len() == self.spec_order().spec_len(),\n                forall|i: int| #![auto] 0 <= i < result.spec_len() ==>\n                    result.spec_index(i) == self.spec_order().spec_index(i),\n        ;"
  },
  {
    "id": 2761,
    "function": "bottom_up_order",
    "file": "Chap54/BFSMtPer.rs",
    "lines": "269-275",
    "spec_strength": "unknown",
    "snippet": "        fn bottom_up_order(&self) -> (result: ArraySeqMtPerS<N>)\n            requires self.spec_order().spec_len() <= usize::MAX,\n            ensures\n                result.spec_len() == self.spec_order().spec_len(),\n                forall|i: int| #![auto] 0 <= i < result.spec_len() ==>\n                    result.spec_index(i) == self.spec_order().spec_index(self.spec_order().spec_len() - 1 - i),\n        ;"
  },
  {
    "id": 2762,
    "function": "bfs",
    "file": "Chap54/BFSMtPer.rs",
    "lines": "279-289",
    "spec_strength": "unknown",
    "snippet": "        fn bfs(graph: &ArraySeqMtPerS<ArraySeqMtPerS<N>>, source: N) -> (result: ArraySeqMtPerS<N>)\n            requires\n                source < graph.spec_len(),\n                graph.spec_len() > 0,\n                graph.spec_len() < usize::MAX,\n                spec_wf_graph(graph),\n            ensures\n                result.spec_len() == graph.spec_len(),\n                result.spec_index(source as int) == 0usize,\n                spec_distances_bounded(&result, graph.spec_len() as int),\n        ;"
  },
  {
    "id": 2763,
    "function": "bfs_tree",
    "file": "Chap54/BFSMtPer.rs",
    "lines": "293-307",
    "spec_strength": "unknown",
    "snippet": "        fn bfs_tree(graph: &ArraySeqMtPerS<ArraySeqMtPerS<N>>, source: N) -> (result: BFSTreeS)\n            requires\n                source < graph.spec_len(),\n                graph.spec_len() > 0,\n                graph.spec_len() < usize::MAX,\n                spec_wf_graph(graph),\n            ensures\n                result.parents.spec_len() == graph.spec_len(),\n                result.parents.spec_index(source as int) == source,\n                result.order.spec_len() > 0,\n                result.order.spec_index(0) == source,\n                forall|i: int| #![auto] 0 <= i < result.order.spec_len()\n                    ==> result.order.spec_index(i) < graph.spec_len(),\n                spec_parents_bounded(&result.parents, graph.spec_len() as int),\n        ;"
  },
  {
    "id": 2764,
    "function": "process_frontier_parallel",
    "file": "Chap54/BFSMtPer.rs",
    "lines": "314-336",
    "spec_strength": "unknown",
    "snippet": "    fn process_frontier_parallel(\n        graph: ArraySeqMtPerS<ArraySeqMtPerS<N>>,\n        distances: ArraySeqMtPerS<N>,\n        frontier: Vec<N>,\n        next_dist: N,\n    ) -> (result: (Vec<N>, Vec<Pair<N, N>>))\n        requires\n            graph.spec_len() > 0,\n            graph.spec_len() < usize::MAX,\n            spec_wf_graph(&graph),\n            distances.spec_len() == graph.spec_len(),\n            spec_distances_bounded(&distances, graph.spec_len() as int),\n            next_dist < graph.spec_len(),\n            forall|j: int| #![auto] 0 <= j < frontier@.len() ==>\n                frontier@[j] < graph.spec_len(),\n        ensures\n            forall|j: int| #![auto] 0 <= j < result.0@.len() ==>\n                result.0@[j] < graph.spec_len(),\n            forall|j: int| #![auto] 0 <= j < result.1@.len() ==>\n                result.1@[j].0 < graph.spec_len()\n                && result.1@[j].1 == next_dist\n                && distances.spec_index(result.1@[j].0 as int) == UNREACHABLE,\n        decreases frontier@.len()"
  },
  {
    "id": 2765,
    "function": "process_frontier_tree_parallel",
    "file": "Chap54/BFSMtPer.rs",
    "lines": "612-630",
    "spec_strength": "unknown",
    "snippet": "    fn process_frontier_tree_parallel(\n        graph: ArraySeqMtPerS<ArraySeqMtPerS<N>>,\n        parents: ArraySeqMtPerS<N>,\n        frontier: Vec<N>,\n    ) -> (result: Vec<Pair<N, N>>)\n        requires\n            graph.spec_len() > 0,\n            graph.spec_len() < usize::MAX,\n            spec_wf_graph(&graph),\n            parents.spec_len() == graph.spec_len(),\n            spec_parents_bounded(&parents, graph.spec_len() as int),\n            forall|j: int| #![auto] 0 <= j < frontier@.len() ==>\n                frontier@[j] < graph.spec_len(),\n        ensures\n            forall|j: int| #![auto] 0 <= j < result@.len() ==>\n                result@[j].0 < graph.spec_len()\n                && result@[j].1 < graph.spec_len()\n                && parents.spec_index(result@[j].0 as int) == NO_PARENT,\n        decreases frontier@.len()"
  },
  {
    "id": 2766,
    "function": "lemma_tabulate_all_no_parent",
    "file": "Chap54/BFSStEph.rs",
    "lines": "57-62",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_tabulate_all_no_parent(parents: &ArraySeqStEphS<N>, n: int)\n        requires\n            parents.spec_len() == n,\n            forall|i: int| #![auto] 0 <= i < n ==> parents.spec_index(i) == NO_PARENT,\n        ensures\n            spec_parents_bounded(parents, n),"
  },
  {
    "id": 2767,
    "function": "lemma_set_preserves_parents_bounded",
    "file": "Chap54/BFSStEph.rs",
    "lines": "65-82",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_set_preserves_parents_bounded(\n        parents: &ArraySeqStEphS<N>,\n        old_parents: &ArraySeqStEphS<N>,\n        v: int,\n        new_val: N,\n        n: int,\n    )\n        requires\n            parents.spec_len() == n,\n            old_parents.spec_len() == n,\n            0 <= v < n,\n            new_val < n,\n            parents.spec_index(v) == new_val,\n            forall|j: int| #![auto] 0 <= j < n && j != v ==>\n                parents.spec_index(j) == old_parents.spec_index(j),\n            spec_parents_bounded(old_parents, n),\n        ensures\n            spec_parents_bounded(parents, n),"
  },
  {
    "id": 2768,
    "function": "bfs",
    "file": "Chap54/BFSStEph.rs",
    "lines": "99-109",
    "spec_strength": "unknown",
    "snippet": "        fn bfs(graph: &ArraySeqStEphS<ArraySeqStEphS<N>>, source: N) -> (result: ArraySeqStEphS<N>)\n            requires\n                source < graph.spec_len(),\n                graph.spec_len() > 0,\n                graph.spec_len() < usize::MAX,\n                spec_wf_graph(graph),\n            ensures\n                result.spec_len() == graph.spec_len(),\n                result.spec_index(source as int) == 0usize,\n                spec_distances_bounded(&result, graph.spec_len() as int),\n        ;"
  },
  {
    "id": 2769,
    "function": "bfs_tree",
    "file": "Chap54/BFSStEph.rs",
    "lines": "113-127",
    "spec_strength": "unknown",
    "snippet": "        fn bfs_tree(graph: &ArraySeqStEphS<ArraySeqStEphS<N>>, source: N) -> (result: BFSTreeS)\n            requires\n                source < graph.spec_len(),\n                graph.spec_len() > 0,\n                graph.spec_len() < usize::MAX,\n                spec_wf_graph(graph),\n            ensures\n                result.parents.spec_len() == graph.spec_len(),\n                result.parents.spec_index(source as int) == source,\n                result.order.spec_len() > 0,\n                result.order.spec_index(0) == source,\n                forall|i: int| #![auto] 0 <= i < result.order.spec_len()\n                    ==> result.order.spec_index(i) < graph.spec_len(),\n                spec_parents_bounded(&result.parents, graph.spec_len() as int),\n        ;"
  },
  {
    "id": 2770,
    "function": "top_down_order",
    "file": "Chap54/BFSStEph.rs",
    "lines": "133-137",
    "spec_strength": "unknown",
    "snippet": "        fn top_down_order(&self) -> (result: &ArraySeqStEphS<N>)\n            ensures\n                result.spec_len() == self.spec_order().spec_len(),\n                forall|i: int| #![auto] 0 <= i < result.spec_len() ==>\n                    result.spec_index(i) == self.spec_order().spec_index(i);"
  },
  {
    "id": 2771,
    "function": "bottom_up_order",
    "file": "Chap54/BFSStEph.rs",
    "lines": "139-144",
    "spec_strength": "unknown",
    "snippet": "        fn bottom_up_order(&self) -> (result: ArraySeqStEphS<N>)\n            requires self.spec_order().spec_len() <= usize::MAX,\n            ensures\n                result.spec_len() == self.spec_order().spec_len(),\n                forall|i: int| #![auto] 0 <= i < result.spec_len() ==>\n                    result.spec_index(i) == self.spec_order().spec_index(self.spec_order().spec_len() - 1 - i);"
  },
  {
    "id": 2772,
    "function": "lemma_tabulate_all_unreachable",
    "file": "Chap54/BFSStEph.rs",
    "lines": "149-155",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_tabulate_all_unreachable(distances: &ArraySeqStEphS<N>, n: int)\n        requires\n            distances.spec_len() == n,\n            forall|i: int| #![auto] 0 <= i < n ==>\n                distances.spec_index(i) == UNREACHABLE,\n        ensures\n            spec_distances_bounded(distances, n),"
  },
  {
    "id": 2773,
    "function": "lemma_set_preserves_bounded",
    "file": "Chap54/BFSStEph.rs",
    "lines": "160-177",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_set_preserves_bounded(\n        distances: &ArraySeqStEphS<N>,\n        old_distances: &ArraySeqStEphS<N>,\n        v: int,\n        new_val: N,\n        n: int,\n    )\n        requires\n            distances.spec_len() == n,\n            old_distances.spec_len() == n,\n            0 <= v < n,\n            new_val < n,\n            distances.spec_index(v) == new_val,\n            forall|j: int| #![auto] 0 <= j < n && j != v ==>\n                distances.spec_index(j) == old_distances.spec_index(j),\n            spec_distances_bounded(old_distances, n),\n        ensures\n            spec_distances_bounded(distances, n),"
  },
  {
    "id": 2774,
    "function": "lemma_tabulate_all_no_parent",
    "file": "Chap54/BFSStPer.rs",
    "lines": "57-62",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_tabulate_all_no_parent(parents: &ArraySeqStPerS<N>, n: int)\n        requires\n            parents.spec_len() == n,\n            forall|i: int| #![auto] 0 <= i < n ==> parents.spec_index(i) == NO_PARENT,\n        ensures\n            spec_parents_bounded(parents, n),"
  },
  {
    "id": 2775,
    "function": "lemma_update_preserves_parents_bounded",
    "file": "Chap54/BFSStPer.rs",
    "lines": "65-82",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_update_preserves_parents_bounded(\n        parents: &ArraySeqStPerS<N>,\n        old_parents: &ArraySeqStPerS<N>,\n        v: int,\n        new_val: N,\n        n: int,\n    )\n        requires\n            parents.spec_len() == n,\n            old_parents.spec_len() == n,\n            0 <= v < n,\n            new_val < n,\n            parents.spec_index(v) == new_val,\n            forall|j: int| #![auto] 0 <= j < n && j != v ==>\n                parents.spec_index(j) == old_parents.spec_index(j),\n            spec_parents_bounded(old_parents, n),\n        ensures\n            spec_parents_bounded(parents, n),"
  },
  {
    "id": 2776,
    "function": "lemma_tabulate_all_unreachable",
    "file": "Chap54/BFSStPer.rs",
    "lines": "96-102",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_tabulate_all_unreachable(distances: &ArraySeqStPerS<N>, n: int)\n        requires\n            distances.spec_len() == n,\n            forall|i: int| #![auto] 0 <= i < n ==>\n                distances.spec_index(i) == UNREACHABLE,\n        ensures\n            spec_distances_bounded(distances, n),"
  },
  {
    "id": 2777,
    "function": "lemma_update_preserves_bounded",
    "file": "Chap54/BFSStPer.rs",
    "lines": "106-123",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_update_preserves_bounded(\n        distances: &ArraySeqStPerS<N>,\n        old_distances: &ArraySeqStPerS<N>,\n        v: int,\n        new_val: N,\n        n: int,\n    )\n        requires\n            distances.spec_len() == n,\n            old_distances.spec_len() == n,\n            0 <= v < n,\n            new_val < n,\n            distances.spec_index(v) == new_val,\n            forall|j: int| #![auto] 0 <= j < n && j != v ==>\n                distances.spec_index(j) == old_distances.spec_index(j),\n            spec_distances_bounded(old_distances, n),\n        ensures\n            spec_distances_bounded(distances, n),"
  },
  {
    "id": 2778,
    "function": "bfs",
    "file": "Chap54/BFSStPer.rs",
    "lines": "140-150",
    "spec_strength": "unknown",
    "snippet": "        fn bfs(graph: &ArraySeqStPerS<ArraySeqStPerS<N>>, source: N) -> (result: ArraySeqStPerS<N>)\n            requires\n                source < graph.spec_len(),\n                graph.spec_len() > 0,\n                graph.spec_len() < usize::MAX,\n                spec_wf_graph(graph),\n            ensures\n                result.spec_len() == graph.spec_len(),\n                result.spec_index(source as int) == 0usize,\n                spec_distances_bounded(&result, graph.spec_len() as int),\n        ;"
  },
  {
    "id": 2779,
    "function": "bfs_tree",
    "file": "Chap54/BFSStPer.rs",
    "lines": "154-168",
    "spec_strength": "unknown",
    "snippet": "        fn bfs_tree(graph: &ArraySeqStPerS<ArraySeqStPerS<N>>, source: N) -> (result: BFSTreeS)\n            requires\n                source < graph.spec_len(),\n                graph.spec_len() > 0,\n                graph.spec_len() < usize::MAX,\n                spec_wf_graph(graph),\n            ensures\n                result.parents.spec_len() == graph.spec_len(),\n                result.parents.spec_index(source as int) == source,\n                result.order.spec_len() > 0,\n                result.order.spec_index(0) == source,\n                forall|i: int| #![auto] 0 <= i < result.order.spec_len()\n                    ==> result.order.spec_index(i) < graph.spec_len(),\n                spec_parents_bounded(&result.parents, graph.spec_len() as int),\n        ;"
  },
  {
    "id": 2780,
    "function": "top_down_order",
    "file": "Chap54/BFSStPer.rs",
    "lines": "174-178",
    "spec_strength": "unknown",
    "snippet": "        fn top_down_order(&self) -> (result: &ArraySeqStPerS<N>)\n            ensures\n                result.spec_len() == self.spec_order().spec_len(),\n                forall|i: int| #![auto] 0 <= i < result.spec_len() ==>\n                    result.spec_index(i) == self.spec_order().spec_index(i);"
  },
  {
    "id": 2781,
    "function": "bottom_up_order",
    "file": "Chap54/BFSStPer.rs",
    "lines": "180-185",
    "spec_strength": "unknown",
    "snippet": "        fn bottom_up_order(&self) -> (result: ArraySeqStPerS<N>)\n            requires self.spec_order().spec_len() <= usize::MAX,\n            ensures\n                result.spec_len() == self.spec_order().spec_len(),\n                forall|i: int| #![auto] 0 <= i < result.spec_len() ==>\n                    result.spec_index(i) == self.spec_order().spec_index(self.spec_order().spec_len() - 1 - i);"
  },
  {
    "id": 2782,
    "function": "has_cycle",
    "file": "Chap55/CycleDetectStEph.rs",
    "lines": "28",
    "spec_strength": "unknown",
    "snippet": "        fn has_cycle(graph: &ArraySeqStEphS<ArraySeqStEphS<N>>) -> B;"
  },
  {
    "id": 2783,
    "function": "dfs_check_cycle",
    "file": "Chap55/CycleDetectStEph.rs",
    "lines": "35-53",
    "spec_strength": "unknown",
    "snippet": "    fn dfs_check_cycle(\n        graph: &ArraySeqStEphS<ArraySeqStEphS<N>>,\n        visited: &mut ArraySeqStEphS<B>,\n        ancestors: &mut ArraySeqStEphS<B>,\n        vertex: N,\n    ) -> (has_cycle: B)\n        requires\n            vertex < old(visited)@.len(),\n            old(visited)@.len() == graph@.len(),\n            old(ancestors)@.len() == graph@.len(),\n            spec_wf_adj_list(graph),\n        ensures\n            visited@.len() == old(visited)@.len(),\n            ancestors@.len() == old(ancestors)@.len(),\n            forall|j: int| #![auto]\n                0 <= j < visited@.len() && old(visited)@[j]\n                ==> visited@[j],\n            spec_num_false(visited@) <= spec_num_false(old(visited)@),\n        decreases spec_num_false(old(visited)@),"
  },
  {
    "id": 2784,
    "function": "has_cycle",
    "file": "Chap55/CycleDetectStPer.rs",
    "lines": "38",
    "spec_strength": "unknown",
    "snippet": "        fn has_cycle(graph: &ArraySeqStPerS<ArraySeqStPerS<N>>) -> B;"
  },
  {
    "id": 2785,
    "function": "dfs_check_cycle",
    "file": "Chap55/CycleDetectStPer.rs",
    "lines": "45-63",
    "spec_strength": "unknown",
    "snippet": "    fn dfs_check_cycle(\n        graph: &ArraySeqStPerS<ArraySeqStPerS<N>>,\n        visited: &mut Vec<bool>,\n        ancestors: &mut Vec<bool>,\n        vertex: N,\n    ) -> (has_cycle: B)\n        requires\n            vertex < old(visited)@.len(),\n            old(visited)@.len() == graph@.len(),\n            old(ancestors)@.len() == graph@.len(),\n            spec_wf_adj_list_per(graph),\n        ensures\n            visited@.len() == old(visited)@.len(),\n            ancestors@.len() == old(ancestors)@.len(),\n            forall|j: int| #![auto]\n                0 <= j < visited@.len() && old(visited)@[j]\n                ==> visited@[j],\n            spec_num_false(visited@) <= spec_num_false(old(visited)@),\n        decreases spec_num_false(old(visited)@),"
  },
  {
    "id": 2786,
    "function": "dfs",
    "file": "Chap55/DFSStEph.rs",
    "lines": "21",
    "spec_strength": "unknown",
    "snippet": "        fn dfs(graph: &ArraySeqStEphS<ArraySeqStEphS<N>>, source: N) -> AVLTreeSetStEph<N>;"
  },
  {
    "id": 2787,
    "function": "dfs_recursive",
    "file": "Chap55/DFSStEph.rs",
    "lines": "25-41",
    "spec_strength": "unknown",
    "snippet": "    fn dfs_recursive(\n        graph: &ArraySeqStEphS<ArraySeqStEphS<N>>,\n        visited: &mut ArraySeqStEphS<B>,\n        result: &mut AVLTreeSetStEph<N>,\n        vertex: N,\n    )\n        requires\n            vertex < old(visited)@.len(),\n            old(visited)@.len() == graph@.len(),\n            spec_wf_adj_list(graph),\n        ensures\n            visited@.len() == old(visited)@.len(),\n            forall|j: int| #![auto]\n                0 <= j < visited@.len() && old(visited)@[j]\n                ==> visited@[j],\n            spec_num_false(visited@) <= spec_num_false(old(visited)@),\n        decreases spec_num_false(old(visited)@),"
  },
  {
    "id": 2788,
    "function": "dfs",
    "file": "Chap55/DFSStPer.rs",
    "lines": "22",
    "spec_strength": "unknown",
    "snippet": "        fn dfs(graph: &ArraySeqStPerS<ArraySeqStPerS<N>>, source: N) -> AVLTreeSetStPer<N>;"
  },
  {
    "id": 2789,
    "function": "dfs_recursive",
    "file": "Chap55/DFSStPer.rs",
    "lines": "27-43",
    "spec_strength": "unknown",
    "snippet": "    fn dfs_recursive(\n        graph: &ArraySeqStPerS<ArraySeqStPerS<N>>,\n        visited_bool: &mut Vec<bool>,\n        result: AVLTreeSetStPer<N>,\n        vertex: N,\n    ) -> (out: AVLTreeSetStPer<N>)\n        requires\n            vertex < old(visited_bool)@.len(),\n            old(visited_bool)@.len() == graph@.len(),\n            spec_wf_adj_list_per(graph),\n        ensures\n            visited_bool@.len() == old(visited_bool)@.len(),\n            forall|j: int| #![auto]\n                0 <= j < visited_bool@.len() && old(visited_bool)@[j]\n                ==> visited_bool@[j],\n            spec_num_false(visited_bool@) <= spec_num_false(old(visited_bool)@),\n        decreases spec_num_false(old(visited_bool)@),"
  },
  {
    "id": 2790,
    "function": "scc",
    "file": "Chap55/SCCStEph.rs",
    "lines": "33-34",
    "spec_strength": "unknown",
    "snippet": "        fn scc(graph: &ArraySeqStEphS<ArraySeqStEphS<N>>) -> AVLTreeSeqStEphS<AVLTreeSetStEph<N>>\n            requires spec_wf_adj_list(graph);"
  },
  {
    "id": 2791,
    "function": "compute_finish_order",
    "file": "Chap55/SCCStEph.rs",
    "lines": "40-41",
    "spec_strength": "unknown",
    "snippet": "    fn compute_finish_order(graph: &ArraySeqStEphS<ArraySeqStEphS<N>>) -> AVLTreeSeqStEphS<N>\n        requires spec_wf_adj_list(graph),"
  },
  {
    "id": 2792,
    "function": "transpose_graph",
    "file": "Chap55/SCCStEph.rs",
    "lines": "77-79",
    "spec_strength": "unknown",
    "snippet": "    fn transpose_graph(graph: &ArraySeqStEphS<ArraySeqStEphS<N>>) -> (result: ArraySeqStEphS<ArraySeqStEphS<N>>)\n        requires spec_wf_adj_list(graph),\n        ensures result@.len() == graph@.len(),"
  },
  {
    "id": 2793,
    "function": "check_wf_adj_list_eph",
    "file": "Chap55/SCCStEph.rs",
    "lines": "139-140",
    "spec_strength": "unknown",
    "snippet": "    fn check_wf_adj_list_eph(graph: &ArraySeqStEphS<ArraySeqStEphS<N>>) -> (result: bool)\n        ensures result ==> spec_wf_adj_list(graph),"
  },
  {
    "id": 2794,
    "function": "dfs_reach",
    "file": "Chap55/SCCStEph.rs",
    "lines": "219-235",
    "spec_strength": "unknown",
    "snippet": "    fn dfs_reach(\n        graph: &ArraySeqStEphS<ArraySeqStEphS<N>>,\n        visited: &mut ArraySeqStEphS<B>,\n        component: &mut AVLTreeSetStEph<N>,\n        vertex: N,\n    )\n        requires\n            vertex < old(visited)@.len(),\n            old(visited)@.len() == graph@.len(),\n            spec_wf_adj_list(graph),\n        ensures\n            visited@.len() == old(visited)@.len(),\n            forall|j: int| #![auto]\n                0 <= j < visited@.len() && old(visited)@[j]\n                ==> visited@[j],\n            spec_num_false(visited@) <= spec_num_false(old(visited)@),\n        decreases spec_num_false(old(visited)@),"
  },
  {
    "id": 2795,
    "function": "scc",
    "file": "Chap55/SCCStPer.rs",
    "lines": "31-32",
    "spec_strength": "unknown",
    "snippet": "        fn scc(graph: &ArraySeqStPerS<ArraySeqStPerS<N>>) -> AVLTreeSeqStPerS<AVLTreeSetStPer<N>>\n            requires spec_wf_adj_list_per(graph);"
  },
  {
    "id": 2796,
    "function": "dfs_finish_order",
    "file": "Chap55/SCCStPer.rs",
    "lines": "38-54",
    "spec_strength": "unknown",
    "snippet": "    fn dfs_finish_order(\n        graph: &ArraySeqStPerS<ArraySeqStPerS<N>>,\n        visited: &mut Vec<bool>,\n        result: &mut Vec<N>,\n        vertex: N,\n    )\n        requires\n            vertex < old(visited)@.len(),\n            old(visited)@.len() == graph@.len(),\n            spec_wf_adj_list_per(graph),\n        ensures\n            visited@.len() == old(visited)@.len(),\n            forall|j: int| #![auto]\n                0 <= j < visited@.len() && old(visited)@[j]\n                ==> visited@[j],\n            spec_num_false(visited@) <= spec_num_false(old(visited)@),\n        decreases spec_num_false(old(visited)@),"
  },
  {
    "id": 2797,
    "function": "compute_finish_order",
    "file": "Chap55/SCCStPer.rs",
    "lines": "89-90",
    "spec_strength": "unknown",
    "snippet": "    fn compute_finish_order(graph: &ArraySeqStPerS<ArraySeqStPerS<N>>) -> AVLTreeSeqStPerS<N>\n        requires spec_wf_adj_list_per(graph),"
  },
  {
    "id": 2798,
    "function": "transpose_graph",
    "file": "Chap55/SCCStPer.rs",
    "lines": "134-136",
    "spec_strength": "unknown",
    "snippet": "    fn transpose_graph(graph: &ArraySeqStPerS<ArraySeqStPerS<N>>) -> (result: ArraySeqStPerS<ArraySeqStPerS<N>>)\n        requires spec_wf_adj_list_per(graph),\n        ensures result@.len() == graph@.len(),"
  },
  {
    "id": 2799,
    "function": "check_wf_adj_list_per",
    "file": "Chap55/SCCStPer.rs",
    "lines": "194-195",
    "spec_strength": "unknown",
    "snippet": "    fn check_wf_adj_list_per(graph: &ArraySeqStPerS<ArraySeqStPerS<N>>) -> (result: bool)\n        ensures result ==> spec_wf_adj_list_per(graph),"
  },
  {
    "id": 2800,
    "function": "dfs_reach",
    "file": "Chap55/SCCStPer.rs",
    "lines": "238-254",
    "spec_strength": "unknown",
    "snippet": "    fn dfs_reach(\n        graph: &ArraySeqStPerS<ArraySeqStPerS<N>>,\n        visited_bool: &mut Vec<bool>,\n        component: AVLTreeSetStPer<N>,\n        vertex: N,\n    ) -> (out: AVLTreeSetStPer<N>)\n        requires\n            vertex < old(visited_bool)@.len(),\n            old(visited_bool)@.len() == graph@.len(),\n            spec_wf_adj_list_per(graph),\n        ensures\n            visited_bool@.len() == old(visited_bool)@.len(),\n            forall|j: int| #![auto]\n                0 <= j < visited_bool@.len() && old(visited_bool)@[j]\n                ==> visited_bool@[j],\n            spec_num_false(visited_bool@) <= spec_num_false(old(visited_bool)@),\n        decreases spec_num_false(old(visited_bool)@),"
  },
  {
    "id": 2801,
    "function": "lemma_set_true_decreases_num_false",
    "file": "Chap55/TopoSortStEph.rs",
    "lines": "46-52",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_set_true_decreases_num_false(s: Seq<bool>, idx: int)\n        requires\n            0 <= idx < s.len(),\n            !s[idx],\n        ensures\n            spec_num_false(s.update(idx, true)) < spec_num_false(s),\n        decreases s.len(),"
  },
  {
    "id": 2802,
    "function": "topo_sort",
    "file": "Chap55/TopoSortStEph.rs",
    "lines": "68",
    "spec_strength": "unknown",
    "snippet": "        fn topo_sort(graph: &ArraySeqStEphS<ArraySeqStEphS<N>>) -> AVLTreeSeqStEphS<N>;"
  },
  {
    "id": 2803,
    "function": "dfs_finish_order",
    "file": "Chap55/TopoSortStEph.rs",
    "lines": "75-91",
    "spec_strength": "unknown",
    "snippet": "    pub fn dfs_finish_order(\n        graph: &ArraySeqStEphS<ArraySeqStEphS<N>>,\n        visited: &mut ArraySeqStEphS<B>,\n        result: &mut Vec<N>,\n        vertex: N,\n    )\n        requires\n            vertex < old(visited)@.len(),\n            old(visited)@.len() == graph@.len(),\n            spec_wf_adj_list(graph),\n        ensures\n            visited@.len() == old(visited)@.len(),\n            forall|j: int| #![auto]\n                0 <= j < visited@.len() && old(visited)@[j]\n                ==> visited@[j],\n            spec_num_false(visited@) <= spec_num_false(old(visited)@),\n        decreases spec_num_false(old(visited)@),"
  },
  {
    "id": 2804,
    "function": "dfs_finish_order_cycle_detect",
    "file": "Chap55/TopoSortStEph.rs",
    "lines": "128-147",
    "spec_strength": "unknown",
    "snippet": "    fn dfs_finish_order_cycle_detect(\n        graph: &ArraySeqStEphS<ArraySeqStEphS<N>>,\n        visited: &mut ArraySeqStEphS<B>,\n        rec_stack: &mut ArraySeqStEphS<B>,\n        result: &mut Vec<N>,\n        vertex: N,\n    ) -> (cycle_free: bool)\n        requires\n            vertex < old(visited)@.len(),\n            old(visited)@.len() == graph@.len(),\n            old(rec_stack)@.len() == graph@.len(),\n            spec_wf_adj_list(graph),\n        ensures\n            visited@.len() == old(visited)@.len(),\n            rec_stack@.len() == old(rec_stack)@.len(),\n            forall|j: int| #![auto]\n                0 <= j < visited@.len() && old(visited)@[j]\n                ==> visited@[j],\n            spec_num_false(visited@) <= spec_num_false(old(visited)@),\n        decreases spec_num_false(old(visited)@),"
  },
  {
    "id": 2805,
    "function": "topological_sort_opt",
    "file": "Chap55/TopoSortStEph.rs",
    "lines": "196-197",
    "spec_strength": "unknown",
    "snippet": "    pub fn topological_sort_opt(graph: &ArraySeqStEphS<ArraySeqStEphS<N>>) -> Option<AVLTreeSeqStEphS<N>>\n        requires spec_wf_adj_list(graph),"
  },
  {
    "id": 2806,
    "function": "topo_sort",
    "file": "Chap55/TopoSortStPer.rs",
    "lines": "39",
    "spec_strength": "unknown",
    "snippet": "        fn topo_sort(graph: &ArraySeqStPerS<ArraySeqStPerS<N>>) -> AVLTreeSeqStPerS<N>;"
  },
  {
    "id": 2807,
    "function": "dfs_finish_order",
    "file": "Chap55/TopoSortStPer.rs",
    "lines": "45-61",
    "spec_strength": "unknown",
    "snippet": "    fn dfs_finish_order(\n        graph: &ArraySeqStPerS<ArraySeqStPerS<N>>,\n        visited: &mut Vec<bool>,\n        result: &mut Vec<N>,\n        vertex: N,\n    )\n        requires\n            vertex < old(visited)@.len(),\n            old(visited)@.len() == graph@.len(),\n            spec_wf_adj_list_per(graph),\n        ensures\n            visited@.len() == old(visited)@.len(),\n            forall|j: int| #![auto]\n                0 <= j < visited@.len() && old(visited)@[j]\n                ==> visited@[j],\n            spec_num_false(visited@) <= spec_num_false(old(visited)@),\n        decreases spec_num_false(old(visited)@),"
  },
  {
    "id": 2808,
    "function": "dfs_finish_order_cycle_detect",
    "file": "Chap55/TopoSortStPer.rs",
    "lines": "97-116",
    "spec_strength": "unknown",
    "snippet": "    fn dfs_finish_order_cycle_detect(\n        graph: &ArraySeqStPerS<ArraySeqStPerS<N>>,\n        visited: &mut Vec<bool>,\n        rec_stack: &mut Vec<bool>,\n        result: &mut Vec<N>,\n        vertex: N,\n    ) -> (cycle_free: bool)\n        requires\n            vertex < old(visited)@.len(),\n            old(visited)@.len() == graph@.len(),\n            old(rec_stack)@.len() == graph@.len(),\n            spec_wf_adj_list_per(graph),\n        ensures\n            visited@.len() == old(visited)@.len(),\n            rec_stack@.len() == old(rec_stack)@.len(),\n            forall|j: int| #![auto]\n                0 <= j < visited@.len() && old(visited)@[j]\n                ==> visited@[j],\n            spec_num_false(visited@) <= spec_num_false(old(visited)@),\n        decreases spec_num_false(old(visited)@),"
  },
  {
    "id": 2809,
    "function": "topological_sort_opt",
    "file": "Chap55/TopoSortStPer.rs",
    "lines": "162-163",
    "spec_strength": "unknown",
    "snippet": "    pub fn topological_sort_opt(graph: &ArraySeqStPerS<ArraySeqStPerS<N>>) -> Option<AVLTreeSeqStPerS<N>>\n        requires spec_wf_adj_list_per(graph),"
  },
  {
    "id": 2810,
    "function": "new",
    "file": "Chap56/AllPairsResultStEphF64.rs",
    "lines": "36",
    "spec_strength": "unknown",
    "snippet": "        fn new(n: usize) -> (result: Self);"
  },
  {
    "id": 2811,
    "function": "get_distance",
    "file": "Chap56/AllPairsResultStEphF64.rs",
    "lines": "38",
    "spec_strength": "",
    "snippet": "        fn get_distance(&self, u: usize, v: usize) -> (dist: F64Dist);"
  },
  {
    "id": 2812,
    "function": "set_distance",
    "file": "Chap56/AllPairsResultStEphF64.rs",
    "lines": "40",
    "spec_strength": "unknown",
    "snippet": "        fn set_distance(&mut self, u: usize, v: usize, dist: F64Dist);"
  },
  {
    "id": 2813,
    "function": "get_predecessor",
    "file": "Chap56/AllPairsResultStEphF64.rs",
    "lines": "42",
    "spec_strength": "",
    "snippet": "        fn get_predecessor(&self, u: usize, v: usize) -> (result: Option<usize>);"
  },
  {
    "id": 2814,
    "function": "set_predecessor",
    "file": "Chap56/AllPairsResultStEphF64.rs",
    "lines": "44",
    "spec_strength": "unknown",
    "snippet": "        fn set_predecessor(&mut self, u: usize, v: usize, pred: usize);"
  },
  {
    "id": 2815,
    "function": "is_reachable",
    "file": "Chap56/AllPairsResultStEphF64.rs",
    "lines": "46",
    "spec_strength": "",
    "snippet": "        fn is_reachable(&self, u: usize, v: usize) -> (result: bool);"
  },
  {
    "id": 2816,
    "function": "extract_path",
    "file": "Chap56/AllPairsResultStEphF64.rs",
    "lines": "48",
    "spec_strength": "",
    "snippet": "        fn extract_path(&self, u: usize, v: usize) -> (result: Option<ArraySeqStPerS<usize>>);"
  },
  {
    "id": 2817,
    "function": "new",
    "file": "Chap56/AllPairsResultStEphI64.rs",
    "lines": "26",
    "spec_strength": "unknown",
    "snippet": "        fn new(n: usize) -> (result: Self);"
  },
  {
    "id": 2818,
    "function": "get_distance",
    "file": "Chap56/AllPairsResultStEphI64.rs",
    "lines": "28",
    "spec_strength": "unknown",
    "snippet": "        fn get_distance(&self, u: usize, v: usize) -> (dist: i64);"
  },
  {
    "id": 2819,
    "function": "set_distance",
    "file": "Chap56/AllPairsResultStEphI64.rs",
    "lines": "30",
    "spec_strength": "unknown",
    "snippet": "        fn set_distance(&mut self, u: usize, v: usize, dist: i64);"
  },
  {
    "id": 2820,
    "function": "get_predecessor",
    "file": "Chap56/AllPairsResultStEphI64.rs",
    "lines": "32",
    "spec_strength": "unknown",
    "snippet": "        fn get_predecessor(&self, u: usize, v: usize) -> (pred: Option<usize>);"
  },
  {
    "id": 2821,
    "function": "set_predecessor",
    "file": "Chap56/AllPairsResultStEphI64.rs",
    "lines": "34",
    "spec_strength": "unknown",
    "snippet": "        fn set_predecessor(&mut self, u: usize, v: usize, pred: usize);"
  },
  {
    "id": 2822,
    "function": "is_reachable",
    "file": "Chap56/AllPairsResultStEphI64.rs",
    "lines": "36",
    "spec_strength": "",
    "snippet": "        fn is_reachable(&self, u: usize, v: usize) -> (b: bool);"
  },
  {
    "id": 2823,
    "function": "extract_path",
    "file": "Chap56/AllPairsResultStEphI64.rs",
    "lines": "38",
    "spec_strength": "",
    "snippet": "        fn extract_path(&self, u: usize, v: usize) -> (result: Option<ArraySeqStPerS<usize>>);"
  },
  {
    "id": 2824,
    "function": "new",
    "file": "Chap56/AllPairsResultStPerF64.rs",
    "lines": "35",
    "spec_strength": "unknown",
    "snippet": "        fn new(n: usize) -> (result: Self);"
  },
  {
    "id": 2825,
    "function": "get_distance",
    "file": "Chap56/AllPairsResultStPerF64.rs",
    "lines": "37",
    "spec_strength": "",
    "snippet": "        fn get_distance(&self, u: usize, v: usize) -> (dist: F64Dist);"
  },
  {
    "id": 2826,
    "function": "set_distance",
    "file": "Chap56/AllPairsResultStPerF64.rs",
    "lines": "39",
    "spec_strength": "unknown",
    "snippet": "        fn set_distance(self, u: usize, v: usize, dist: F64Dist) -> (result: Self);"
  },
  {
    "id": 2827,
    "function": "get_predecessor",
    "file": "Chap56/AllPairsResultStPerF64.rs",
    "lines": "41",
    "spec_strength": "",
    "snippet": "        fn get_predecessor(&self, u: usize, v: usize) -> (result: Option<usize>);"
  },
  {
    "id": 2828,
    "function": "set_predecessor",
    "file": "Chap56/AllPairsResultStPerF64.rs",
    "lines": "43",
    "spec_strength": "unknown",
    "snippet": "        fn set_predecessor(self, u: usize, v: usize, pred: usize) -> (result: Self);"
  },
  {
    "id": 2829,
    "function": "is_reachable",
    "file": "Chap56/AllPairsResultStPerF64.rs",
    "lines": "45",
    "spec_strength": "",
    "snippet": "        fn is_reachable(&self, u: usize, v: usize) -> (result: bool);"
  },
  {
    "id": 2830,
    "function": "extract_path",
    "file": "Chap56/AllPairsResultStPerF64.rs",
    "lines": "47",
    "spec_strength": "",
    "snippet": "        fn extract_path(&self, u: usize, v: usize) -> (result: Option<ArraySeqStPerS<usize>>);"
  },
  {
    "id": 2831,
    "function": "new",
    "file": "Chap56/AllPairsResultStPerI64.rs",
    "lines": "25",
    "spec_strength": "unknown",
    "snippet": "        fn new(n: usize) -> (result: Self);"
  },
  {
    "id": 2832,
    "function": "get_distance",
    "file": "Chap56/AllPairsResultStPerI64.rs",
    "lines": "27",
    "spec_strength": "unknown",
    "snippet": "        fn get_distance(&self, u: usize, v: usize) -> (dist: i64);"
  },
  {
    "id": 2833,
    "function": "set_distance",
    "file": "Chap56/AllPairsResultStPerI64.rs",
    "lines": "29",
    "spec_strength": "unknown",
    "snippet": "        fn set_distance(self, u: usize, v: usize, dist: i64) -> (result: Self);"
  },
  {
    "id": 2834,
    "function": "get_predecessor",
    "file": "Chap56/AllPairsResultStPerI64.rs",
    "lines": "31",
    "spec_strength": "unknown",
    "snippet": "        fn get_predecessor(&self, u: usize, v: usize) -> (pred: Option<usize>);"
  },
  {
    "id": 2835,
    "function": "set_predecessor",
    "file": "Chap56/AllPairsResultStPerI64.rs",
    "lines": "33",
    "spec_strength": "unknown",
    "snippet": "        fn set_predecessor(self, u: usize, v: usize, pred: usize) -> (result: Self);"
  },
  {
    "id": 2836,
    "function": "is_reachable",
    "file": "Chap56/AllPairsResultStPerI64.rs",
    "lines": "35",
    "spec_strength": "",
    "snippet": "        fn is_reachable(&self, u: usize, v: usize) -> (b: bool);"
  },
  {
    "id": 2837,
    "function": "extract_path",
    "file": "Chap56/AllPairsResultStPerI64.rs",
    "lines": "37",
    "spec_strength": "",
    "snippet": "        fn extract_path(&self, u: usize, v: usize) -> (result: Option<ArraySeqStPerS<usize>>);"
  },
  {
    "id": 2838,
    "function": "example_path_weight_int",
    "file": "Chap56/Example56_1.rs",
    "lines": "28",
    "spec_strength": "hole",
    "snippet": "        fn example_path_weight_int();"
  },
  {
    "id": 2839,
    "function": "example_path_weight_float",
    "file": "Chap56/Example56_1.rs",
    "lines": "32",
    "spec_strength": "hole",
    "snippet": "        fn example_path_weight_float();"
  },
  {
    "id": 2840,
    "function": "example_negative_weights",
    "file": "Chap56/Example56_1.rs",
    "lines": "36",
    "spec_strength": "hole",
    "snippet": "        fn example_negative_weights();"
  },
  {
    "id": 2841,
    "function": "example_negative_cycle",
    "file": "Chap56/Example56_3.rs",
    "lines": "28",
    "spec_strength": "hole",
    "snippet": "        fn example_negative_cycle();"
  },
  {
    "id": 2842,
    "function": "example_undefined_shortest_path",
    "file": "Chap56/Example56_3.rs",
    "lines": "32",
    "spec_strength": "hole",
    "snippet": "        fn example_undefined_shortest_path();"
  },
  {
    "id": 2843,
    "function": "path_weight_int",
    "file": "Chap56/PathWeightUtilsStEph.rs",
    "lines": "37",
    "spec_strength": "",
    "snippet": "        fn path_weight_int(path: &ArraySeqStPerS<usize>, weights: &ArraySeqStEphS<ArraySeqStEphS<i64>>) -> Option<i64>;"
  },
  {
    "id": 2844,
    "function": "path_weight_float",
    "file": "Chap56/PathWeightUtilsStEph.rs",
    "lines": "39-42",
    "spec_strength": "",
    "snippet": "        fn path_weight_float(\n            path: &ArraySeqStPerS<usize>,\n            weights: &ArraySeqStEphS<ArraySeqStEphS<F64Dist>>,\n        ) -> Option<F64Dist>;"
  },
  {
    "id": 2845,
    "function": "validate_subpath_property_int",
    "file": "Chap56/PathWeightUtilsStEph.rs",
    "lines": "44-48",
    "spec_strength": "",
    "snippet": "        fn validate_subpath_property_int(\n            path: &ArraySeqStPerS<usize>,\n            distances: &ArraySeqStEphS<i64>,\n            weights: &ArraySeqStEphS<ArraySeqStEphS<i64>>,\n        ) -> bool;"
  },
  {
    "id": 2846,
    "function": "validate_subpath_property_float",
    "file": "Chap56/PathWeightUtilsStEph.rs",
    "lines": "50-54",
    "spec_strength": "",
    "snippet": "        fn validate_subpath_property_float(\n            path: &ArraySeqStPerS<usize>,\n            distances: &ArraySeqStEphS<F64Dist>,\n            weights: &ArraySeqStEphS<ArraySeqStEphS<F64Dist>>,\n        ) -> bool;"
  },
  {
    "id": 2847,
    "function": "f64_approx_eq",
    "file": "Chap56/PathWeightUtilsStEph.rs",
    "lines": "164",
    "spec_strength": "hole",
    "snippet": "    fn f64_approx_eq(a: &F64Dist, b: &F64Dist) -> bool {"
  },
  {
    "id": 2848,
    "function": "path_weight_int",
    "file": "Chap56/PathWeightUtilsStPer.rs",
    "lines": "36",
    "spec_strength": "",
    "snippet": "        fn path_weight_int(path: &ArraySeqStPerS<usize>, weights: &ArraySeqStPerS<ArraySeqStPerS<i64>>) -> Option<i64>;"
  },
  {
    "id": 2849,
    "function": "path_weight_float",
    "file": "Chap56/PathWeightUtilsStPer.rs",
    "lines": "38-41",
    "spec_strength": "",
    "snippet": "        fn path_weight_float(\n            path: &ArraySeqStPerS<usize>,\n            weights: &ArraySeqStPerS<ArraySeqStPerS<F64Dist>>,\n        ) -> Option<F64Dist>;"
  },
  {
    "id": 2850,
    "function": "validate_subpath_property_int",
    "file": "Chap56/PathWeightUtilsStPer.rs",
    "lines": "43-47",
    "spec_strength": "",
    "snippet": "        fn validate_subpath_property_int(\n            path: &ArraySeqStPerS<usize>,\n            distances: &ArraySeqStPerS<i64>,\n            weights: &ArraySeqStPerS<ArraySeqStPerS<i64>>,\n        ) -> bool;"
  },
  {
    "id": 2851,
    "function": "validate_subpath_property_float",
    "file": "Chap56/PathWeightUtilsStPer.rs",
    "lines": "49-53",
    "spec_strength": "",
    "snippet": "        fn validate_subpath_property_float(\n            path: &ArraySeqStPerS<usize>,\n            distances: &ArraySeqStPerS<F64Dist>,\n            weights: &ArraySeqStPerS<ArraySeqStPerS<F64Dist>>,\n        ) -> bool;"
  },
  {
    "id": 2852,
    "function": "f64_approx_eq",
    "file": "Chap56/PathWeightUtilsStPer.rs",
    "lines": "163",
    "spec_strength": "hole",
    "snippet": "    fn f64_approx_eq(a: &F64Dist, b: &F64Dist) -> bool {"
  },
  {
    "id": 2853,
    "function": "new",
    "file": "Chap56/SSSPResultStEphF64.rs",
    "lines": "36-37",
    "spec_strength": "unknown",
    "snippet": "        pub fn new(n: usize, source: usize) -> (result: Self)\n            requires source < n,"
  },
  {
    "id": 2854,
    "function": "get_distance",
    "file": "Chap56/SSSPResultStEphF64.rs",
    "lines": "62",
    "spec_strength": "",
    "snippet": "        pub fn get_distance(&self, v: usize) -> (dist: F64Dist) {"
  },
  {
    "id": 2855,
    "function": "set_distance",
    "file": "Chap56/SSSPResultStEphF64.rs",
    "lines": "69",
    "spec_strength": "",
    "snippet": "        pub fn set_distance(&mut self, v: usize, dist: F64Dist) {"
  },
  {
    "id": 2856,
    "function": "get_predecessor",
    "file": "Chap56/SSSPResultStEphF64.rs",
    "lines": "75",
    "spec_strength": "",
    "snippet": "        pub fn get_predecessor(&self, v: usize) -> (pred: Option<usize>) {"
  },
  {
    "id": 2857,
    "function": "set_predecessor",
    "file": "Chap56/SSSPResultStEphF64.rs",
    "lines": "83",
    "spec_strength": "",
    "snippet": "        pub fn set_predecessor(&mut self, v: usize, pred: usize) {"
  },
  {
    "id": 2858,
    "function": "is_reachable",
    "file": "Chap56/SSSPResultStEphF64.rs",
    "lines": "89",
    "spec_strength": "",
    "snippet": "        pub fn is_reachable(&self, v: usize) -> (b: bool) {"
  },
  {
    "id": 2859,
    "function": "extract_path",
    "file": "Chap56/SSSPResultStEphF64.rs",
    "lines": "97-112",
    "spec_strength": "",
    "snippet": "        pub fn extract_path(&self, v: usize) -> Option<ArraySeqStPerS<usize>> {\n            if !self.is_reachable(v) {\n                return None;\n            }\n            let mut path = Vec::new();\n            let mut current = v;\n            path.push(current);\n            while current != self.source {\n                let pred = *self.predecessors.nth(current);\n                if pred == NO_PREDECESSOR { return None; }\n                path.push(pred);\n                current = pred;\n            }\n            path.reverse();\n            Some(ArraySeqStPerS::from_vec(path))\n        }"
  },
  {
    "id": 2860,
    "function": "new",
    "file": "Chap56/SSSPResultStEphI64.rs",
    "lines": "27-28",
    "spec_strength": "unknown",
    "snippet": "        fn new(n: usize, source: usize) -> (result: Self)\n            requires source < n;"
  },
  {
    "id": 2861,
    "function": "get_distance",
    "file": "Chap56/SSSPResultStEphI64.rs",
    "lines": "30",
    "spec_strength": "",
    "snippet": "        fn get_distance(&self, v: usize) -> (dist: i64);"
  },
  {
    "id": 2862,
    "function": "set_distance",
    "file": "Chap56/SSSPResultStEphI64.rs",
    "lines": "32",
    "spec_strength": "unknown",
    "snippet": "        fn set_distance(&mut self, v: usize, dist: i64);"
  },
  {
    "id": 2863,
    "function": "get_predecessor",
    "file": "Chap56/SSSPResultStEphI64.rs",
    "lines": "34",
    "spec_strength": "",
    "snippet": "        fn get_predecessor(&self, v: usize) -> (pred: Option<usize>);"
  },
  {
    "id": 2864,
    "function": "set_predecessor",
    "file": "Chap56/SSSPResultStEphI64.rs",
    "lines": "36",
    "spec_strength": "unknown",
    "snippet": "        fn set_predecessor(&mut self, v: usize, pred: usize);"
  },
  {
    "id": 2865,
    "function": "is_reachable",
    "file": "Chap56/SSSPResultStEphI64.rs",
    "lines": "38",
    "spec_strength": "",
    "snippet": "        fn is_reachable(&self, v: usize) -> (b: bool);"
  },
  {
    "id": 2866,
    "function": "extract_path",
    "file": "Chap56/SSSPResultStEphI64.rs",
    "lines": "40",
    "spec_strength": "",
    "snippet": "        fn extract_path(&self, v: usize) -> (result: Option<ArraySeqStPerS<usize>>);"
  },
  {
    "id": 2867,
    "function": "new",
    "file": "Chap56/SSSPResultStPerF64.rs",
    "lines": "45-46",
    "spec_strength": "unknown",
    "snippet": "        fn new(n: usize, source: usize) -> (result: Self)\n            requires source < n;"
  },
  {
    "id": 2868,
    "function": "get_distance",
    "file": "Chap56/SSSPResultStPerF64.rs",
    "lines": "48",
    "spec_strength": "",
    "snippet": "        fn get_distance(&self, v: usize) -> (dist: F64Dist);"
  },
  {
    "id": 2869,
    "function": "set_distance",
    "file": "Chap56/SSSPResultStPerF64.rs",
    "lines": "50",
    "spec_strength": "unknown",
    "snippet": "        fn set_distance(self, v: usize, dist: F64Dist) -> (result: Self);"
  },
  {
    "id": 2870,
    "function": "get_predecessor",
    "file": "Chap56/SSSPResultStPerF64.rs",
    "lines": "52",
    "spec_strength": "",
    "snippet": "        fn get_predecessor(&self, v: usize) -> (result: Option<usize>);"
  },
  {
    "id": 2871,
    "function": "set_predecessor",
    "file": "Chap56/SSSPResultStPerF64.rs",
    "lines": "54",
    "spec_strength": "unknown",
    "snippet": "        fn set_predecessor(self, v: usize, pred: usize) -> (result: Self);"
  },
  {
    "id": 2872,
    "function": "is_reachable",
    "file": "Chap56/SSSPResultStPerF64.rs",
    "lines": "56",
    "spec_strength": "",
    "snippet": "        fn is_reachable(&self, v: usize) -> (result: bool);"
  },
  {
    "id": 2873,
    "function": "extract_path",
    "file": "Chap56/SSSPResultStPerF64.rs",
    "lines": "58",
    "spec_strength": "",
    "snippet": "        fn extract_path(&self, v: usize) -> (result: Option<ArraySeqStPerS<usize>>);"
  },
  {
    "id": 2874,
    "function": "new",
    "file": "Chap56/SSSPResultStPerI64.rs",
    "lines": "25-26",
    "spec_strength": "unknown",
    "snippet": "        fn new(n: usize, source: usize) -> (result: Self)\n            requires source < n;"
  },
  {
    "id": 2875,
    "function": "get_distance",
    "file": "Chap56/SSSPResultStPerI64.rs",
    "lines": "28",
    "spec_strength": "",
    "snippet": "        fn get_distance(&self, v: usize) -> (dist: i64);"
  },
  {
    "id": 2876,
    "function": "set_distance",
    "file": "Chap56/SSSPResultStPerI64.rs",
    "lines": "30",
    "spec_strength": "unknown",
    "snippet": "        fn set_distance(self, v: usize, dist: i64) -> (result: Self);"
  },
  {
    "id": 2877,
    "function": "get_predecessor",
    "file": "Chap56/SSSPResultStPerI64.rs",
    "lines": "32",
    "spec_strength": "",
    "snippet": "        fn get_predecessor(&self, v: usize) -> (pred: Option<usize>);"
  },
  {
    "id": 2878,
    "function": "set_predecessor",
    "file": "Chap56/SSSPResultStPerI64.rs",
    "lines": "34",
    "spec_strength": "unknown",
    "snippet": "        fn set_predecessor(self, v: usize, pred: usize) -> (result: Self);"
  },
  {
    "id": 2879,
    "function": "is_reachable",
    "file": "Chap56/SSSPResultStPerI64.rs",
    "lines": "36",
    "spec_strength": "",
    "snippet": "        fn is_reachable(&self, v: usize) -> (b: bool);"
  },
  {
    "id": 2880,
    "function": "extract_path",
    "file": "Chap56/SSSPResultStPerI64.rs",
    "lines": "38",
    "spec_strength": "",
    "snippet": "        fn extract_path(&self, v: usize) -> (result: Option<ArraySeqStPerS<usize>>);"
  },
  {
    "id": 2881,
    "function": "eq",
    "file": "Chap57/DijkstraStEphF64.rs",
    "lines": "42-44",
    "spec_strength": "",
    "snippet": "        fn eq(&self, other: &Self) -> bool {\n            self.dist == other.dist && self.vertex == other.vertex\n        }"
  },
  {
    "id": 2882,
    "function": "cmp",
    "file": "Chap57/DijkstraStEphF64.rs",
    "lines": "49-52",
    "spec_strength": "",
    "snippet": "        fn cmp(&self, other: &Self) -> Ordering {\n            self.dist.val.partial_cmp(&other.dist.val)\n                .unwrap_or(Ordering::Equal)\n        }"
  },
  {
    "id": 2883,
    "function": "partial_cmp",
    "file": "Chap57/DijkstraStEphF64.rs",
    "lines": "56",
    "spec_strength": "",
    "snippet": "        fn partial_cmp(&self, other: &Self) -> Option<Ordering> { Some(self.cmp(other)) }"
  },
  {
    "id": 2884,
    "function": "dijkstra",
    "file": "Chap57/DijkstraStEphI64.rs",
    "lines": "62",
    "spec_strength": "hole",
    "snippet": "        fn dijkstra(graph: &WeightedDirGraphStEphI128<usize>, source: usize) -> SSSPResultStEphI64;"
  },
  {
    "id": 2885,
    "function": "pq_entry_new",
    "file": "Chap57/DijkstraStEphI64.rs",
    "lines": "67-68",
    "spec_strength": "unknown",
    "snippet": "    fn pq_entry_new(dist: i64, vertex: usize) -> (r: PQEntry)\n        ensures r.dist == dist, r.vertex == vertex,"
  },
  {
    "id": 2886,
    "function": "cmp",
    "file": "Chap57/DijkstraStEphI64.rs",
    "lines": "74",
    "spec_strength": "",
    "snippet": "        fn cmp(&self, other: &Self) -> (r: Ordering) {"
  },
  {
    "id": 2887,
    "function": "partial_cmp",
    "file": "Chap57/DijkstraStEphI64.rs",
    "lines": "86",
    "spec_strength": "",
    "snippet": "        fn partial_cmp(&self, other: &Self) -> (r: Option<Ordering>) {"
  },
  {
    "id": 2888,
    "function": "new",
    "file": "Chap57/StackStEph.rs",
    "lines": "55",
    "spec_strength": "unknown",
    "snippet": "        fn new() -> (result: Self);"
  },
  {
    "id": 2889,
    "function": "push",
    "file": "Chap57/StackStEph.rs",
    "lines": "57",
    "spec_strength": "unknown",
    "snippet": "        fn push(&mut self, item: T);"
  },
  {
    "id": 2890,
    "function": "pop",
    "file": "Chap57/StackStEph.rs",
    "lines": "59",
    "spec_strength": "unknown",
    "snippet": "        fn pop(&mut self) -> (result: Option<T>);"
  },
  {
    "id": 2891,
    "function": "peek",
    "file": "Chap57/StackStEph.rs",
    "lines": "61",
    "spec_strength": "unknown",
    "snippet": "        fn peek(&self) -> (result: Option<&T>);"
  },
  {
    "id": 2892,
    "function": "is_empty",
    "file": "Chap57/StackStEph.rs",
    "lines": "63",
    "spec_strength": "unknown",
    "snippet": "        fn is_empty(&self) -> (result: bool);"
  },
  {
    "id": 2893,
    "function": "size",
    "file": "Chap57/StackStEph.rs",
    "lines": "65",
    "spec_strength": "unknown",
    "snippet": "        fn size(&self) -> (result: N);"
  },
  {
    "id": 2894,
    "function": "default",
    "file": "Chap57/StackStEph.rs",
    "lines": "116-117",
    "spec_strength": "unknown",
    "snippet": "        fn default() -> (result: Self)\n            ensures result@ == Seq::<T>::empty(),"
  },
  {
    "id": 2895,
    "function": "bellman_ford",
    "file": "Chap58/BellmanFordStEphI64.rs",
    "lines": "26-27",
    "spec_strength": "",
    "snippet": "        fn bellman_ford(graph: &WeightedDirGraphStEphI128<usize>, source: usize)\n            -> (result: Result<SSSPResultStEphI64, String>);"
  },
  {
    "id": 2896,
    "function": "reconstruct_predecessors",
    "file": "Chap58/BellmanFordStEphI64.rs",
    "lines": "71-92",
    "spec_strength": "",
    "snippet": "    #[cfg(not(verus_keep_ghost))]\n    fn reconstruct_predecessors(\n        graph: &WeightedDirGraphStEphI128<usize>,\n        distances: &HashMap<usize, i64>,\n        result: &mut SSSPResultStEphI64,\n        source: usize,\n    ) {\n        let n = graph.vertices().size();\n        for v in 0..n {\n            if v == source { continue; }\n            let v_dist = *distances.get(&v).unwrap_or(&i64::MAX);\n            if v_dist == i64::MAX { continue; }\n            let in_neighbors = graph.in_neighbors_weighed(&v);\n            for Pair(u, weight) in in_neighbors.iter() {\n                let u_dist = *distances.get(u).unwrap_or(&i64::MAX);\n                if u_dist != i64::MAX {\n                    let path_dist = u_dist.saturating_add(*weight as i64);\n                    if path_dist == v_dist { result.set_predecessor(v, *u); break; }\n                }\n            }\n        }\n    }"
  },
  {
    "id": 2897,
    "function": "johnson_apsp",
    "file": "Chap59/JohnsonMtEphI64.rs",
    "lines": "37",
    "spec_strength": "",
    "snippet": "            fn johnson_apsp(graph: &WeightedDirGraphStEphI128<usize>) -> AllPairsResultStEphI64;"
  },
  {
    "id": 2898,
    "function": "parallel_dijkstra_all",
    "file": "Chap59/JohnsonMtEphI64.rs",
    "lines": "79-138",
    "spec_strength": "",
    "snippet": "    /// Parallel Dijkstra execution using recursive divide-and-conquer with ParaPair!\n    ///\n    /// - APAS: N/A  internal helper, not named in prose.\n    /// - Claude-Opus-4.6: Work O(k * m log n), Span O(m log n) where k = end - start  binary split with ParaPair! gives log k depth, each leaf runs Dijkstra O(m log n)\n    #[cfg(not(verus_keep_ghost))]\n    fn parallel_dijkstra_all(\n        graph: &WeightedDirGraphStEphI128<usize>,\n        potentials: &ArraySeqStEphS<i64>,\n        start: usize,\n        end: usize,\n        n: usize,\n    ) -> (\n        ArraySeqStEphS<ArraySeqStEphS<i64>>,\n        ArraySeqStEphS<ArraySeqStEphS<usize>>,\n    ) {\n        let range_size = end - start;\n\n        if range_size == 0 {\n            return (ArraySeqStEphS::empty(), ArraySeqStEphS::empty());\n        }\n\n        if range_size == 1 {\n            let u = start;\n            let dijkstra_result = dijkstra(graph, u);\n\n            let p_u = *potentials.nth(u);\n            let adjusted_row = ArraySeqStEphS::tabulate(\n                &|v| {\n                    let d_prime = dijkstra_result.get_distance(v);\n                    if d_prime == i64::MAX {\n                        i64::MAX\n                    } else {\n                        let p_v = *potentials.nth(v);\n                        d_prime - p_u + p_v\n                    }\n                },\n                n,\n            );\n\n            let dist_seq = ArraySeqStEphS::singleton(adjusted_row);\n            let pred_seq = ArraySeqStEphS::singleton(dijkstra_result.predecessors.clone());\n            return (dist_seq, pred_seq);\n        }\n\n        let mid = start + range_size / 2;\n        let graph_left = graph.clone();\n        let graph_right = graph.clone();\n        let potentials_left = potentials.clone();\n        let potentials_right = potentials.clone();\n\n        let Pair((left_dist, left_pred), (right_dist, right_pred)) = crate::ParaPair!(\n            move || parallel_dijkstra_all(&graph_left, &potentials_left, start, mid, n),\n            move || parallel_dijkstra_all(&graph_right, &potentials_right, mid, end, n)\n        );\n\n        let combined_dist = ArraySeqStEphS::append(&left_dist, &right_dist);\n        let combined_pred = ArraySeqStEphS::append(&left_pred, &right_pred);\n\n        (combined_dist, combined_pred)\n    }"
  },
  {
    "id": 2899,
    "function": "add_dummy_source",
    "file": "Chap59/JohnsonMtEphI64.rs",
    "lines": "140-164",
    "spec_strength": "",
    "snippet": "    /// Add dummy source vertex s with zero-weight edges to all vertices in G.\n    ///\n    /// - APAS: N/A  Verus-specific scaffolding.\n    /// - Claude-Opus-4.6: Work O(n + m), Span O(n + m)  iterates over vertices and edges\n    #[cfg(not(verus_keep_ghost))]\n    fn add_dummy_source(graph: &WeightedDirGraphStEphI128<usize>, n: usize) -> (WeightedDirGraphStEphI128<usize>, usize) {\n        let mut vertices = SetStEph::empty();\n        for i in 0..n {\n            vertices.insert(i);\n        }\n\n        vertices.insert(n);\n\n        let mut edges = SetStEph::empty();\n\n        for LabEdge(from, to, weight) in graph.labeled_arcs().iter() {\n            edges.insert(WeightedEdge(*from, *to, *weight));\n        }\n\n        for v in 0..n {\n            edges.insert(WeightedEdge(n, v, 0i128));\n        }\n\n        (WeightedDirGraphStEphI128::from_weighed_edges(vertices, edges), n)\n    }"
  },
  {
    "id": 2900,
    "function": "reweight_graph",
    "file": "Chap59/JohnsonMtEphI64.rs",
    "lines": "166-190",
    "spec_strength": "",
    "snippet": "    /// Reweight edges: w'(u,v) = w(u,v) + p(u) - p(v)\n    ///\n    /// - APAS: Work O(m), Span O(m)\n    /// - Claude-Opus-4.6: Work O(n + m), Span O(n + m)  rebuilds vertex set O(n) plus iterates edges O(m)\n    #[cfg(not(verus_keep_ghost))]\n    fn reweight_graph(\n        graph: &WeightedDirGraphStEphI128<usize>,\n        potentials: &ArraySeqStEphS<i64>,\n        n: usize,\n    ) -> WeightedDirGraphStEphI128<usize> {\n        let mut vertices = SetStEph::empty();\n        for i in 0..n {\n            vertices.insert(i);\n        }\n\n        let mut reweighted_edges = SetStEph::empty();\n        for LabEdge(from, to, weight) in graph.labeled_arcs().iter() {\n            let p_from = *potentials.nth(*from) as i128;\n            let p_to = *potentials.nth(*to) as i128;\n            let w_prime: i128 = *weight + p_from - p_to;\n            reweighted_edges.insert(WeightedEdge(*from, *to, w_prime));\n        }\n\n        WeightedDirGraphStEphI128::from_weighed_edges(vertices, reweighted_edges)\n    }"
  },
  {
    "id": 2901,
    "function": "create_negative_cycle_result",
    "file": "Chap59/JohnsonMtEphI64.rs",
    "lines": "192-205",
    "spec_strength": "",
    "snippet": "    /// Create result for negative cycle case.\n    ///\n    /// - APAS: N/A  Verus-specific scaffolding.\n    /// - Claude-Opus-4.6: Work O(n^2), Span O(n^2)  builds nn distance and predecessor matrices\n    #[cfg(not(verus_keep_ghost))]\n    fn create_negative_cycle_result(n: usize) -> AllPairsResultStEphI64 {\n        let distances = ArraySeqStEphS::tabulate(&|_| ArraySeqStEphS::tabulate(&|_| i64::MAX, n), n);\n        let predecessors = ArraySeqStEphS::tabulate(&|_| ArraySeqStEphS::tabulate(&|_| 0, n), n);\n        AllPairsResultStEphI64 {\n            distances,\n            predecessors,\n            n,\n        }\n    }"
  },
  {
    "id": 2902,
    "function": "johnson_apsp",
    "file": "Chap59/JohnsonStEphI64.rs",
    "lines": "34",
    "spec_strength": "",
    "snippet": "            fn johnson_apsp(graph: &WeightedDirGraphStEphI128<usize>) -> AllPairsResultStEphI64;"
  },
  {
    "id": 2903,
    "function": "add_dummy_source",
    "file": "Chap59/JohnsonStEphI64.rs",
    "lines": "100-126",
    "spec_strength": "",
    "snippet": "    /// Add dummy source vertex s with zero-weight edges to all vertices in G.\n    ///\n    /// - APAS: N/A  Verus-specific scaffolding.\n    /// - Claude-Opus-4.6: Work O(n + m), Span O(n + m)  iterates over vertices and edges\n    #[cfg(not(verus_keep_ghost))]\n    fn add_dummy_source(graph: &WeightedDirGraphStEphI128<usize>, n: usize) -> (WeightedDirGraphStEphI128<usize>, usize) {\n        let dummy_idx = n;\n\n        let mut vertices = SetStEph::empty();\n        for i in 0..=n {\n            vertices.insert(i);\n        }\n\n        let mut edges = SetStEph::empty();\n        for LabEdge(from, to, weight) in graph.labeled_arcs().iter() {\n            edges.insert(WeightedEdge(*from, *to, *weight));\n        }\n\n        for i in 0..n {\n            edges.insert(WeightedEdge(dummy_idx, i, 0i128));\n        }\n\n        (\n            WeightedDirGraphStEphI128::from_weighed_edges(vertices, edges),\n            dummy_idx,\n        )\n    }"
  },
  {
    "id": 2904,
    "function": "reweight_graph",
    "file": "Chap59/JohnsonStEphI64.rs",
    "lines": "128-152",
    "spec_strength": "",
    "snippet": "    /// Reweight edges: w'(u,v) = w(u,v) + p(u) - p(v)\n    ///\n    /// - APAS: Work O(m), Span O(m)\n    /// - Claude-Opus-4.6: Work O(n + m), Span O(n + m)  rebuilds vertex set O(n) plus iterates edges O(m)\n    #[cfg(not(verus_keep_ghost))]\n    fn reweight_graph(\n        graph: &WeightedDirGraphStEphI128<usize>,\n        potentials: &ArraySeqStEphS<i64>,\n        n: usize,\n    ) -> WeightedDirGraphStEphI128<usize> {\n        let mut vertices = SetStEph::empty();\n        for i in 0..n {\n            vertices.insert(i);\n        }\n\n        let mut edges = SetStEph::empty();\n        for LabEdge(from, to, weight) in graph.labeled_arcs().iter() {\n            let p_from = *potentials.nth(*from) as i128;\n            let p_to = *potentials.nth(*to) as i128;\n            let new_weight: i128 = *weight + p_from - p_to;\n            edges.insert(WeightedEdge(*from, *to, new_weight));\n        }\n\n        WeightedDirGraphStEphI128::from_weighed_edges(vertices, edges)\n    }"
  },
  {
    "id": 2905,
    "function": "create_negative_cycle_result",
    "file": "Chap59/JohnsonStEphI64.rs",
    "lines": "154-167",
    "spec_strength": "",
    "snippet": "    /// Create result for negative cycle case.\n    ///\n    /// - APAS: N/A  Verus-specific scaffolding.\n    /// - Claude-Opus-4.6: Work O(n^2), Span O(n^2)  builds nn distance and predecessor matrices\n    #[cfg(not(verus_keep_ghost))]\n    fn create_negative_cycle_result(n: usize) -> AllPairsResultStEphI64 {\n        let distances = ArraySeqStEphS::tabulate(&|_| ArraySeqStEphS::tabulate(&|_| i64::MAX, n), n);\n        let predecessors = ArraySeqStEphS::tabulate(&|_| ArraySeqStEphS::tabulate(&|_| 0, n), n);\n        AllPairsResultStEphI64 {\n            distances,\n            predecessors,\n            n,\n        }\n    }"
  },
  {
    "id": 2906,
    "function": "edge_contract_mt",
    "file": "Chap61/EdgeContractionMtEph.rs",
    "lines": "32-35",
    "spec_strength": "",
    "snippet": "            fn edge_contract_mt<V: StT + MtT + Hash + Ord + 'static>(\n                graph: &UnDirGraphMtEph<V>,\n                matching: &SetStEph<Edge<V>>,\n            ) -> UnDirGraphMtEph<V>;"
  },
  {
    "id": 2907,
    "function": "contract_round_mt",
    "file": "Chap61/EdgeContractionMtEph.rs",
    "lines": "39-42",
    "spec_strength": "",
    "snippet": "            fn contract_round_mt<V: StT + MtT + Hash + Ord + 'static>(\n                graph: &UnDirGraphMtEph<V>,\n                seed: u64,\n            ) -> UnDirGraphMtEph<V>;"
  },
  {
    "id": 2908,
    "function": "build_edges_parallel",
    "file": "Chap61/EdgeContractionMtEph.rs",
    "lines": "109-162",
    "spec_strength": "",
    "snippet": "    /// Build new edge set in parallel using divide-and-conquer\n    ///\n    /// - APAS: N/A  Verus-specific scaffolding (parallel edge routing helper)\n    /// - Claude-Opus-4.6: Work (|E|), Span (lg |E|)  genuine divide-and-conquer parallelism\n    #[cfg(not(verus_keep_ghost))]\n    fn build_edges_parallel<V: StT + MtT + Hash + Ord + 'static>(\n        edges: Arc<ArraySeqStEphS<Edge<V>>>,\n        vertex_map: Arc<HashMap<V, V>>,\n        start: usize,\n        end: usize,\n    ) -> SetStEph<Edge<V>> {\n        let size = end - start;\n\n        if size == 0 {\n            return SetLit![];\n        }\n\n        if size == 1 {\n            let edge = edges.nth(start as N);\n            let Edge(u, v) = edge;\n            let block_u = vertex_map.get(u).unwrap().clone();\n            let block_v = vertex_map.get(v).unwrap().clone();\n\n            if block_u != block_v {\n                let new_edge = if block_u < block_v {\n                    Edge(block_u, block_v)\n                } else {\n                    Edge(block_v, block_u)\n                };\n                let mut result: SetStEph<Edge<V>> = SetLit![];\n                let _ = result.insert(new_edge);\n                return result;\n            } else {\n                return SetLit![];\n            }\n        }\n\n        let mid = start + size / 2;\n\n        let edges1 = edges.clone();\n        let map1 = vertex_map.clone();\n        let edges2 = edges;\n        let map2 = vertex_map;\n\n        let pair = ParaPair!(move || build_edges_parallel(edges1, map1, start, mid), move || {\n            build_edges_parallel(edges2, map2, mid, end)\n        });\n\n        let mut result = pair.0;\n        for edge in pair.1.iter() {\n            let _ = result.insert(edge.clone());\n        }\n        result\n    }"
  },
  {
    "id": 2909,
    "function": "edge_contract",
    "file": "Chap61/EdgeContractionStEph.rs",
    "lines": "30-33",
    "spec_strength": "",
    "snippet": "            fn edge_contract<V: StT + Hash + Ord>(\n                graph: &UnDirGraphStEph<V>,\n                matching: &SetStEph<Edge<V>>,\n            ) -> UnDirGraphStEph<V>;"
  },
  {
    "id": 2910,
    "function": "contract_round",
    "file": "Chap61/EdgeContractionStEph.rs",
    "lines": "37",
    "spec_strength": "",
    "snippet": "            fn contract_round<V: StT + Hash + Ord>(graph: &UnDirGraphStEph<V>) -> UnDirGraphStEph<V>;"
  },
  {
    "id": 2911,
    "function": "parallel_matching_mt",
    "file": "Chap61/VertexMatchingMtEph.rs",
    "lines": "30",
    "spec_strength": "",
    "snippet": "            fn parallel_matching_mt<V: StT + MtT + Hash + 'static>(graph: &UnDirGraphMtEph<V>, seed: u64) -> SetStEph<Edge<V>>;"
  },
  {
    "id": 2912,
    "function": "flip_coins_parallel",
    "file": "Chap61/VertexMatchingMtEph.rs",
    "lines": "78-100",
    "spec_strength": "",
    "snippet": "    /// Phase 1: Flip coins for all edges\n    ///\n    /// - APAS: Work (|E|), Span (1)  each coin is independent\n    /// - Claude-Opus-4.6: Work (|E|), Span (|E|)  RNG is sequential, no actual parallelism\n    #[cfg(not(verus_keep_ghost))]\n    fn flip_coins_parallel<V: StT + MtT + 'static>(\n        edges: &ArraySeqStEphS<Edge<V>>,\n        rng: &mut rand::rngs::StdRng,\n    ) -> ArraySeqStEphS<B> {\n        use rand::{Rng, RngExt};\n\n        let n = edges.length();\n        if n == 0 {\n            return ArraySeqStEphS::empty();\n        }\n\n        let mut coins_vec = Vec::with_capacity(n);\n        for _ in 0..n {\n            coins_vec.push(rng.random());\n        }\n\n        ArraySeqStEphS::from_vec(coins_vec)\n    }"
  },
  {
    "id": 2913,
    "function": "select_edges_parallel",
    "file": "Chap61/VertexMatchingMtEph.rs",
    "lines": "102-133",
    "spec_strength": "",
    "snippet": "    /// Phase 2: Select edges in parallel where coin is heads and adjacent edges are tails\n    ///\n    /// - APAS: Work O(|E|), Span O(lg |V|)  each edge checks only incident edges\n    /// - Claude-Opus-4.6: Work (|E|), Span (lg |E| + |E|)  should_select_edge scans all |E| edges\n    #[cfg(not(verus_keep_ghost))]\n    fn select_edges_parallel<V: StT + MtT + Hash + 'static>(\n        graph: &UnDirGraphMtEph<V>,\n        edges: &ArraySeqStEphS<Edge<V>>,\n        coins: &ArraySeqStEphS<B>,\n    ) -> SetStEph<Edge<V>> {\n        use std::sync::Arc;\n        pub type T<V> = UnDirGraphMtEph<V>;\n\n        let n = edges.length();\n        if n == 0 {\n            return SetLit![];\n        }\n\n        let edge_coin_map = edges.iter().zip(coins.iter()).map(|(e, c)| (e.clone(), *c)).collect::<HashMap<Edge<V>, bool>>();\n\n        let graph_arc = Arc::new(graph.clone());\n        let edges_arc = Arc::new(edges.clone());\n        let map_arc = Arc::new(edge_coin_map);\n\n        let selected = select_edges_recursive(graph_arc, edges_arc, map_arc, 0, n);\n\n        let mut result: SetStEph<Edge<V>> = SetLit![];\n        for edge in selected.iter() {\n            let _ = result.insert(edge.clone());\n        }\n        result\n    }"
  },
  {
    "id": 2914,
    "function": "select_edges_recursive",
    "file": "Chap61/VertexMatchingMtEph.rs",
    "lines": "135-178",
    "spec_strength": "",
    "snippet": "    /// - APAS: N/A  Verus-specific scaffolding (parallel recursion helper)\n    /// - Claude-Opus-4.6: Work (k  |E|), Span (lg k + |E|)  each base case calls should_select_edge which is (|E|)\n    #[cfg(not(verus_keep_ghost))]\n    fn select_edges_recursive<V: StT + MtT + Hash + 'static>(\n        graph: Arc<UnDirGraphMtEph<V>>,\n        edges: Arc<ArraySeqStEphS<Edge<V>>>,\n        edge_coins: Arc<HashMap<Edge<V>, bool>>,\n        start: usize,\n        end: usize,\n    ) -> ArraySeqStEphS<Edge<V>> {\n        let size = end - start;\n\n        if size == 0 {\n            return ArraySeqStEphS::empty();\n        }\n\n        if size == 1 {\n            let edge = edges.nth(start as N);\n            if should_select_edge(&graph, edge, &edge_coins) {\n                return ArraySeqStEphS::from_vec(std::vec![edge.clone()]);\n            } else {\n                return ArraySeqStEphS::empty();\n            }\n        }\n\n        let mid = start + size / 2;\n\n        let graph1 = graph.clone();\n        let edges1 = edges.clone();\n        let coins1 = edge_coins.clone();\n        let graph2 = graph;\n        let edges2 = edges;\n        let coins2 = edge_coins;\n\n        let pair = ParaPair!(\n            move || select_edges_recursive(graph1, edges1, coins1, start, mid),\n            move || select_edges_recursive(graph2, edges2, coins2, mid, end)\n        );\n\n        let mut left_vec = pair.0.iter().cloned().collect::<Vec<Edge<V>>>();\n        let right_vec = pair.1.iter().cloned().collect::<Vec<Edge<V>>>();\n        left_vec.extend(right_vec);\n        ArraySeqStEphS::from_vec(left_vec)\n    }"
  },
  {
    "id": 2915,
    "function": "should_select_edge",
    "file": "Chap61/VertexMatchingMtEph.rs",
    "lines": "180-211",
    "spec_strength": "",
    "snippet": "    /// Check if an edge should be selected\n    ///\n    /// Edge is selected if its coin is heads and all adjacent edges have tails\n    ///\n    /// - APAS: Work O(degree(u) + degree(v)), Span O(degree(u) + degree(v))  checks only incident edges\n    /// - Claude-Opus-4.6: Work (|E|), Span (|E|)  iterates all edges, not just incident ones\n    #[cfg(not(verus_keep_ghost))]\n    fn should_select_edge<V: StT + MtT + Hash + 'static>(\n        graph: &UnDirGraphMtEph<V>,\n        edge: &Edge<V>,\n        edge_coins: &HashMap<Edge<V>, bool>,\n    ) -> bool {\n        let Edge(u, v) = edge;\n\n        if !edge_coins.get(edge).copied().unwrap_or(false) {\n            return false;\n        }\n\n        for adj_edge in graph.edges().iter() {\n            if adj_edge == edge {\n                continue;\n            }\n\n            if (graph.incident(adj_edge, u) || graph.incident(adj_edge, v))\n                && edge_coins.get(adj_edge).copied().unwrap_or(false)\n            {\n                return false;\n            }\n        }\n\n        true\n    }"
  },
  {
    "id": 2916,
    "function": "greedy_matching",
    "file": "Chap61/VertexMatchingStEph.rs",
    "lines": "26",
    "spec_strength": "",
    "snippet": "            fn greedy_matching<V: StT + Hash>(graph: &UnDirGraphStEph<V>) -> SetStEph<Edge<V>>;"
  },
  {
    "id": 2917,
    "function": "parallel_matching_st",
    "file": "Chap61/VertexMatchingStEph.rs",
    "lines": "30",
    "spec_strength": "",
    "snippet": "            fn parallel_matching_st<V: StT + Hash>(graph: &UnDirGraphStEph<V>, seed: u64) -> SetStEph<Edge<V>>;"
  },
  {
    "id": 2918,
    "function": "star_contract_mt",
    "file": "Chap62/StarContractionMtEph.rs",
    "lines": "31-35",
    "spec_strength": "",
    "snippet": "            fn star_contract_mt<V, R, F, G>(graph: &UnDirGraphMtEph<V>, seed: u64, base: &F, expand: &G) -> R\n            where\n                V: StT + MtT + Hash + Ord + 'static,\n                F: Fn(&SetStEph<V>) -> R,\n                G: Fn(&SetStEph<V>, &SetStEph<Edge<V>>, &SetStEph<V>, &HashMap<V, V>, R) -> R;"
  },
  {
    "id": 2919,
    "function": "contract_to_vertices_mt",
    "file": "Chap62/StarContractionMtEph.rs",
    "lines": "39",
    "spec_strength": "",
    "snippet": "            fn contract_to_vertices_mt<V: StT + MtT + Hash + Ord + 'static>(graph: &UnDirGraphMtEph<V>, seed: u64) -> SetStEph<V>;"
  },
  {
    "id": 2920,
    "function": "build_quotient_graph_parallel",
    "file": "Chap62/StarContractionMtEph.rs",
    "lines": "83-104",
    "spec_strength": "",
    "snippet": "    /// Build quotient graph from partition (parallel version)\n    ///\n    /// Routes edges through partition map using divide-and-conquer parallelism.\n    ///\n    /// - APAS: (no cost stated)  helper not in prose.\n    /// - Claude-Opus-4.6: Work O(m), Span O(lg m)  delegates to route_edges_parallel which uses ParaPair fork-join.\n    #[cfg(not(verus_keep_ghost))]\n    fn build_quotient_graph_parallel<V: StT + MtT + Hash + Ord + 'static>(\n        graph: &UnDirGraphMtEph<V>,\n        centers: &SetStEph<V>,\n        partition_map: &HashMap<V, V>,\n    ) -> UnDirGraphMtEph<V> {\n        let edges_vec = graph.edges().iter().cloned().collect::<Vec<Edge<V>>>();\n        let edges_seq = ArraySeqStEphS::from_vec(edges_vec);\n        let n_edges = edges_seq.length();\n\n        let part_map_arc = Arc::new(partition_map.clone());\n\n        let quotient_edges = route_edges_parallel(&edges_seq, part_map_arc, 0, n_edges);\n\n        <UnDirGraphMtEph<V> as UnDirGraphMtEphTrait<V>>::from_sets(centers.clone(), quotient_edges)\n    }"
  },
  {
    "id": 2921,
    "function": "route_edges_parallel",
    "file": "Chap62/StarContractionMtEph.rs",
    "lines": "106-156",
    "spec_strength": "",
    "snippet": "    /// Parallel edge routing using divide-and-conquer\n    ///\n    /// - APAS: (no cost stated)  helper not in prose.\n    /// - Claude-Opus-4.6: Work O(k), Span O(lg k)  binary fork-join via ParaPair; k = end - start.\n    #[cfg(not(verus_keep_ghost))]\n    fn route_edges_parallel<V: StT + MtT + Hash + Ord + 'static>(\n        edges: &ArraySeqStEphS<Edge<V>>,\n        partition_map: Arc<HashMap<V, V>>,\n        start: usize,\n        end: usize,\n    ) -> SetStEph<Edge<V>> {\n        let size = end - start;\n\n        if size == 0 {\n            return SetLit![];\n        }\n\n        if size == 1 {\n            let edge = edges.nth(start as N);\n            let Edge(u, v) = edge;\n            let u_center = partition_map.get(u).unwrap_or(u);\n            let v_center = partition_map.get(v).unwrap_or(v);\n\n            if u_center != v_center {\n                let new_edge = if u_center < v_center {\n                    Edge(u_center.clone(), v_center.clone())\n                } else {\n                    Edge(v_center.clone(), u_center.clone())\n                };\n                return SetLit![new_edge];\n            }\n            return SetLit![];\n        }\n\n        let mid = start + size / 2;\n\n        let edges1 = edges.clone();\n        let map1 = partition_map.clone();\n        let edges2 = edges.clone();\n        let map2 = partition_map;\n\n        let pair = ParaPair!(move || route_edges_parallel(&edges1, map1, start, mid), move || {\n            route_edges_parallel(&edges2, map2, mid, end)\n        });\n\n        let mut result = pair.0;\n        for edge in pair.1.iter() {\n            let _ = result.insert(edge.clone());\n        }\n        result\n    }"
  },
  {
    "id": 2922,
    "function": "star_contract",
    "file": "Chap62/StarContractionStEph.rs",
    "lines": "26-30",
    "spec_strength": "",
    "snippet": "            fn star_contract<V, R, F, G>(graph: &UnDirGraphStEph<V>, base: &F, expand: &G) -> R\n            where\n                V: StT + Hash + Ord,\n                F: Fn(&SetStEph<V>) -> R,\n                G: Fn(&SetStEph<V>, &SetStEph<Edge<V>>, &SetStEph<V>, &HashMap<V, V>, R) -> R;"
  },
  {
    "id": 2923,
    "function": "contract_to_vertices",
    "file": "Chap62/StarContractionStEph.rs",
    "lines": "34",
    "spec_strength": "",
    "snippet": "            fn contract_to_vertices<V: StT + Hash + Ord>(graph: &UnDirGraphStEph<V>) -> SetStEph<V>;"
  },
  {
    "id": 2924,
    "function": "build_quotient_graph",
    "file": "Chap62/StarContractionStEph.rs",
    "lines": "77-108",
    "spec_strength": "",
    "snippet": "    /// Build quotient graph from partition\n    ///\n    /// Routes edges through partition map, removing self-loops.\n    ///\n    /// - APAS: (no cost stated)  helper not in prose.\n    /// - Claude-Opus-4.6: Work O(m), Span O(m)  sequential loop over all edges.\n    #[cfg(not(verus_keep_ghost))]\n    fn build_quotient_graph<V: StT + Hash + Ord>(\n        graph: &UnDirGraphStEph<V>,\n        centers: &SetStEph<V>,\n        partition_map: &HashMap<V, V>,\n    ) -> UnDirGraphStEph<V> {\n        let mut quotient_edges: SetStEph<Edge<V>> = SetLit![];\n\n        for edge in graph.edges().iter() {\n            let Edge(u, v) = edge;\n\n            let u_center = partition_map.get(u).unwrap_or(u);\n            let v_center = partition_map.get(v).unwrap_or(v);\n\n            if u_center != v_center {\n                let new_edge = if u_center < v_center {\n                    Edge(u_center.clone(), v_center.clone())\n                } else {\n                    Edge(v_center.clone(), u_center.clone())\n                };\n                let _ = quotient_edges.insert(new_edge);\n            }\n        }\n\n        <UnDirGraphStEph<V> as UnDirGraphStEphTrait<V>>::from_sets(centers.clone(), quotient_edges)\n    }"
  },
  {
    "id": 2925,
    "function": "parallel_star_partition",
    "file": "Chap62/StarPartitionMtEph.rs",
    "lines": "26-29",
    "spec_strength": "",
    "snippet": "            fn parallel_star_partition<V: StT + MtT + Hash + Ord + 'static>(\n                graph: &UnDirGraphMtEph<V>,\n                seed: u64,\n            ) -> (SetStEph<V>, HashMap<V, V>);"
  },
  {
    "id": 2926,
    "function": "sequential_star_partition",
    "file": "Chap62/StarPartitionStEph.rs",
    "lines": "25",
    "spec_strength": "",
    "snippet": "            fn sequential_star_partition<V: StT + Hash + Ord>(graph: &UnDirGraphStEph<V>) -> (SetStEph<V>, HashMap<V, V>);"
  },
  {
    "id": 2927,
    "function": "count_components_mt",
    "file": "Chap63/ConnectivityMtEph.rs",
    "lines": "36",
    "spec_strength": "",
    "snippet": "            fn count_components_mt<V: StT + MtT + Hash + Ord + 'static>(graph: &UnDirGraphMtEph<V>, seed: u64) -> N;"
  },
  {
    "id": 2928,
    "function": "connected_components_mt",
    "file": "Chap63/ConnectivityMtEph.rs",
    "lines": "40-43",
    "spec_strength": "",
    "snippet": "            fn connected_components_mt<V: StT + MtT + Hash + Ord + 'static>(\n                graph: &UnDirGraphMtEph<V>,\n                seed: u64,\n            ) -> (SetStEph<V>, HashMap<V, V>);"
  },
  {
    "id": 2929,
    "function": "count_components_hof",
    "file": "Chap63/ConnectivityMtEph.rs",
    "lines": "47",
    "spec_strength": "",
    "snippet": "            fn count_components_hof<V: StT + MtT + Hash + Ord + 'static>(graph: &UnDirGraphMtEph<V>, seed: u64) -> N;"
  },
  {
    "id": 2930,
    "function": "connected_components_hof",
    "file": "Chap63/ConnectivityMtEph.rs",
    "lines": "51-54",
    "spec_strength": "",
    "snippet": "            fn connected_components_hof<V: StT + MtT + Hash + Ord + 'static>(\n                graph: &UnDirGraphMtEph<V>,\n                seed: u64,\n            ) -> (SetStEph<V>, HashMap<V, V>);"
  },
  {
    "id": 2931,
    "function": "build_quotient_edges_parallel",
    "file": "Chap63/ConnectivityMtEph.rs",
    "lines": "127-143",
    "spec_strength": "",
    "snippet": "    /// Build quotient graph edges in parallel.\n    ///\n    /// - APAS: N/A  helper function implicit in Algorithm 63.2/63.3 Line 7.\n    /// - Claude-Opus-4.6: Work O(m), Span O(m)  delegates to route_edges_parallel whose merge is sequential\n    #[cfg(not(verus_keep_ghost))]\n    fn build_quotient_edges_parallel<V: StT + MtT + Hash + Ord + 'static>(\n        graph: &UnDirGraphMtEph<V>,\n        partition_map: &HashMap<V, V>,\n    ) -> SetStEph<Edge<V>> {\n        let edges_vec = graph.edges().iter().cloned().collect::<Vec<Edge<V>>>();\n        let edges_seq = ArraySeqStEphS::from_vec(edges_vec);\n        let n_edges = edges_seq.length();\n\n        let part_map_arc = Arc::new(partition_map.clone());\n\n        route_edges_parallel(&edges_seq, part_map_arc, 0, n_edges)\n    }"
  },
  {
    "id": 2932,
    "function": "route_edges_parallel",
    "file": "Chap63/ConnectivityMtEph.rs",
    "lines": "145-195",
    "spec_strength": "",
    "snippet": "    /// Parallel edge routing using divide-and-conquer.\n    ///\n    /// - APAS: N/A  helper function, not in prose.\n    /// - Claude-Opus-4.6: Work O(k), Span O(k)  sequential set union after ParaPair! makes span O(k) not O(lg k)\n    #[cfg(not(verus_keep_ghost))]\n    fn route_edges_parallel<V: StT + MtT + Hash + Ord + 'static>(\n        edges: &ArraySeqStEphS<Edge<V>>,\n        partition_map: Arc<HashMap<V, V>>,\n        start: usize,\n        end: usize,\n    ) -> SetStEph<Edge<V>> {\n        let size = end - start;\n\n        if size == 0 {\n            return SetLit![];\n        }\n\n        if size == 1 {\n            let edge = edges.nth(start as N);\n            let Edge(u, v) = edge;\n            let u_center = partition_map.get(u).unwrap_or(u);\n            let v_center = partition_map.get(v).unwrap_or(v);\n\n            if u_center != v_center {\n                let new_edge = if u_center < v_center {\n                    Edge(u_center.clone(), v_center.clone())\n                } else {\n                    Edge(v_center.clone(), u_center.clone())\n                };\n                return SetLit![new_edge];\n            }\n            return SetLit![];\n        }\n\n        let mid = start + size / 2;\n\n        let edges1 = edges.clone();\n        let map1 = partition_map.clone();\n        let edges2 = edges.clone();\n        let map2 = partition_map;\n\n        let pair = ParaPair!(move || route_edges_parallel(&edges1, map1, start, mid), move || {\n            route_edges_parallel(&edges2, map2, mid, end)\n        });\n\n        let mut result = pair.0;\n        for edge in pair.1.iter() {\n            let _ = result.insert(edge.clone());\n        }\n        result\n    }"
  },
  {
    "id": 2933,
    "function": "compose_maps_parallel",
    "file": "Chap63/ConnectivityMtEph.rs",
    "lines": "197-212",
    "spec_strength": "",
    "snippet": "    /// Compose maps (P  C): for each (u  v) in P, output (u  C[v]).\n    ///\n    /// - APAS: N/A  helper function, Line 10 of Algorithm 63.3.\n    /// - Claude-Opus-4.6: Work O(|P|), Span O(|P|)  currently sequential despite \"parallel\" name\n    #[cfg(not(verus_keep_ghost))]\n    fn compose_maps_parallel<V: StT + MtT + Hash + Ord + 'static>(\n        partition_map: &HashMap<V, V>,\n        component_map: &HashMap<V, V>,\n    ) -> HashMap<V, V> {\n        let mut result = HashMap::new();\n        for (u, v) in partition_map.iter() {\n            let component = component_map.get(v).unwrap_or(v);\n            let _ = result.insert(u.clone(), component.clone());\n        }\n        result\n    }"
  },
  {
    "id": 2934,
    "function": "count_components",
    "file": "Chap63/ConnectivityStEph.rs",
    "lines": "31",
    "spec_strength": "",
    "snippet": "            fn count_components<V: StT + Hash + Ord>(graph: &UnDirGraphStEph<V>) -> N;"
  },
  {
    "id": 2935,
    "function": "connected_components",
    "file": "Chap63/ConnectivityStEph.rs",
    "lines": "35",
    "spec_strength": "",
    "snippet": "            fn connected_components<V: StT + Hash + Ord>(graph: &UnDirGraphStEph<V>) -> (SetStEph<V>, HashMap<V, V>);"
  },
  {
    "id": 2936,
    "function": "count_components_hof",
    "file": "Chap63/ConnectivityStEph.rs",
    "lines": "39",
    "spec_strength": "",
    "snippet": "            fn count_components_hof<V: StT + Hash + Ord>(graph: &UnDirGraphStEph<V>) -> N;"
  },
  {
    "id": 2937,
    "function": "connected_components_hof",
    "file": "Chap63/ConnectivityStEph.rs",
    "lines": "43",
    "spec_strength": "",
    "snippet": "            fn connected_components_hof<V: StT + Hash + Ord>(graph: &UnDirGraphStEph<V>) -> (SetStEph<V>, HashMap<V, V>);"
  },
  {
    "id": 2938,
    "function": "build_quotient_edges",
    "file": "Chap63/ConnectivityStEph.rs",
    "lines": "118-146",
    "spec_strength": "",
    "snippet": "    /// Build quotient graph edges by routing through partition map.\n    /// Filters out self-edges (where both endpoints map to same super-vertex).\n    ///\n    /// - APAS: N/A  helper function implicit in Algorithm 63.2/63.3 Line 7.\n    /// - Claude-Opus-4.6: Work O(m), Span O(m)  single pass over edges\n    #[cfg(not(verus_keep_ghost))]\n    fn build_quotient_edges<V: StT + Hash + Ord>(\n        graph: &UnDirGraphStEph<V>,\n        partition_map: &HashMap<V, V>,\n    ) -> SetStEph<Edge<V>> {\n        let mut quotient_edges: SetStEph<Edge<V>> = SetLit![];\n\n        for edge in graph.edges().iter() {\n            let Edge(u, v) = edge;\n            let u_center = partition_map.get(u).unwrap_or(u);\n            let v_center = partition_map.get(v).unwrap_or(v);\n\n            if u_center != v_center {\n                let new_edge = if u_center < v_center {\n                    Edge(u_center.clone(), v_center.clone())\n                } else {\n                    Edge(v_center.clone(), u_center.clone())\n                };\n                let _ = quotient_edges.insert(new_edge);\n            }\n        }\n\n        quotient_edges\n    }"
  },
  {
    "id": 2939,
    "function": "new_spanning_edges_lock",
    "file": "Chap64/SpanTreeMtEph.rs",
    "lines": "36-38",
    "spec_strength": "hole",
    "snippet": "        fn new_spanning_edges_lock<V: StT + MtT + Hash + Ord>(\n            val: SetStEph<Edge<V>>,\n        ) -> (lock: RwLock<SetStEph<Edge<V>>, SpanTreeMtEphSpanningEdgesWf>) {"
  },
  {
    "id": 2940,
    "function": "new_valid_lock",
    "file": "Chap64/SpanTreeMtEph.rs",
    "lines": "47",
    "spec_strength": "hole",
    "snippet": "        fn new_valid_lock(val: bool) -> (lock: RwLock<bool, SpanTreeMtEphValidWf>) {"
  },
  {
    "id": 2941,
    "function": "spanning_tree_star_contraction_mt",
    "file": "Chap64/SpanTreeMtEph.rs",
    "lines": "54-56",
    "spec_strength": "",
    "snippet": "            fn spanning_tree_star_contraction_mt<V: StT + MtT + Hash + Ord + 'static>(\n                graph: &UnDirGraphMtEph<V>,\n            ) -> SetStEph<Edge<V>>;"
  },
  {
    "id": 2942,
    "function": "verify_spanning_tree",
    "file": "Chap64/SpanTreeMtEph.rs",
    "lines": "60",
    "spec_strength": "",
    "snippet": "            fn verify_spanning_tree<V: StT + MtT + Hash + Ord>(graph: &UnDirGraphMtEph<V>, tree: &SetStEph<Edge<V>>) -> B;"
  },
  {
    "id": 2943,
    "function": "spanning_tree_star_contraction",
    "file": "Chap64/SpanTreeStEph.rs",
    "lines": "27",
    "spec_strength": "",
    "snippet": "            fn spanning_tree_star_contraction<V: StT + Hash + Ord>(graph: &UnDirGraphStEph<V>) -> SetStEph<Edge<V>>;"
  },
  {
    "id": 2944,
    "function": "verify_spanning_tree",
    "file": "Chap64/SpanTreeStEph.rs",
    "lines": "31",
    "spec_strength": "",
    "snippet": "            fn verify_spanning_tree<V: StT + Hash + Ord>(graph: &UnDirGraphStEph<V>, tree: &SetStEph<Edge<V>>) -> B;"
  },
  {
    "id": 2945,
    "function": "euler_tour",
    "file": "Chap64/TSPApproxStEph.rs",
    "lines": "40-42",
    "spec_strength": "",
    "snippet": "        /// Compute Euler tour of a tree\n        /// APAS: Work O(|V|), Span O(|V|)\n        fn euler_tour<V: StT + Hash + Ord>(tree: &LabUnDirGraphStEph<V, F64Ord>, start: V) -> Vec<V>;"
  },
  {
    "id": 2946,
    "function": "shortcut_tour",
    "file": "Chap64/TSPApproxStEph.rs",
    "lines": "44-46",
    "spec_strength": "",
    "snippet": "        /// Shortcut Euler tour to avoid revisiting vertices\n        /// APAS: Work O(|V|), Span O(|V|)\n        fn shortcut_tour<V: StT + Hash + Ord>(euler_tour: &[V]) -> Vec<V>;"
  },
  {
    "id": 2947,
    "function": "tour_weight",
    "file": "Chap64/TSPApproxStEph.rs",
    "lines": "48-53",
    "spec_strength": "",
    "snippet": "        /// Compute total weight of a tour\n        /// APAS: Work O(|V|), Span O(|V|)\n        fn tour_weight<V: StT + Hash + Ord>(\n            tour: &[V],\n            distances: &HashMap<(V, V), F64Ord>,\n        ) -> F64Ord;"
  },
  {
    "id": 2948,
    "function": "approx_metric_tsp",
    "file": "Chap64/TSPApproxStEph.rs",
    "lines": "55-60",
    "spec_strength": "",
    "snippet": "        /// 2-approximation algorithm for metric TSP\n        /// APAS: Work O(|V| log |V|), Span O(|V| log |V|)\n        fn approx_metric_tsp<V: StT + Hash + Ord>(\n            distances: &HashMap<(V, V), F64Ord>,\n            vertices: &SetStEph<V>,\n        ) -> Vec<V>;"
  },
  {
    "id": 2949,
    "function": "euler_tour_dfs",
    "file": "Chap64/TSPApproxStEph.rs",
    "lines": "92-143",
    "spec_strength": "",
    "snippet": "    /// - APAS: N/A  internal helper for euler_tour.\n    /// - Claude-Opus-4.6: Work O(n * m_tree), Span O(n * m_tree)  for each vertex,\n    ///   scans neighbors (O(m)) and tree_edges (O(m_tree)) to find matching edges.\n    #[cfg(not(verus_keep_ghost))]\n    fn euler_tour_dfs<V: StT + Hash + Ord>(\n        graph: &LabUnDirGraphStEph<V, F64Ord>,\n        current: &V,\n        parent: Option<&V>,\n        tree_edges: &SetStEph<LabEdge<V, F64Ord>>,\n        tour: &mut Vec<V>,\n        visited_edges: &mut HashSetWithViewPlus<(V, V)>,\n    ) {\n        tour.push(current.clone());\n\n        // Visit all neighbors connected by tree edges\n        let neighbors = get_neighbors(graph, current);\n        for neighbor in neighbors.iter() {\n            // Skip parent to avoid immediate backtrack\n            if let Some(p) = parent {\n                if neighbor == p {\n                    continue;\n                }\n            }\n\n            // Check if edge is in tree and not yet traversed\n            let edge_key = if current < neighbor {\n                (current.clone(), neighbor.clone())\n            } else {\n                (neighbor.clone(), current.clone())\n            };\n\n            if visited_edges.contains(&edge_key) {\n                continue;\n            }\n\n            // Check if edge exists in tree_edges\n            let mut edge_found = false;\n            for edge in tree_edges.iter() {\n                let LabEdge(u, v, _) = edge;\n                if (u == current && v == neighbor) || (u == neighbor && v == current) {\n                    edge_found = true;\n                    break;\n                }\n            }\n\n            if edge_found {\n                visited_edges.insert(edge_key);\n                euler_tour_dfs(graph, neighbor, Some(current), tree_edges, tour, visited_edges);\n                tour.push(current.clone());\n            }\n        }\n    }"
  },
  {
    "id": 2950,
    "function": "get_neighbors",
    "file": "Chap64/TSPApproxStEph.rs",
    "lines": "208-222",
    "spec_strength": "",
    "snippet": "    /// - APAS: N/A  internal helper, no prose counterpart.\n    /// - Claude-Opus-4.6: Work O(m), Span O(m)  linear scan over all edges.\n    #[cfg(not(verus_keep_ghost))]\n    fn get_neighbors<V: StT + Hash + Ord>(graph: &LabUnDirGraphStEph<V, F64Ord>, v: &V) -> SetStEph<V> {\n        let mut neighbors = SetLit![];\n        for edge in graph.labeled_edges().iter() {\n            let LabEdge(a, b, _) = edge;\n            if a == v {\n                let _ = neighbors.insert(b.clone());\n            } else if b == v {\n                let _ = neighbors.insert(a.clone());\n            }\n        }\n        neighbors\n    }"
  },
  {
    "id": 2951,
    "function": "get_edge_weight",
    "file": "Chap64/TSPApproxStEph.rs",
    "lines": "224-239",
    "spec_strength": "",
    "snippet": "    /// - APAS: N/A  internal helper, no prose counterpart.\n    /// - Claude-Opus-4.6: Work O(m), Span O(m)  linear scan over all edges.\n    #[cfg(not(verus_keep_ghost))]\n    fn get_edge_weight<V: StT + Hash + Ord>(\n        graph: &LabUnDirGraphStEph<V, F64Ord>,\n        u: &V,\n        v: &V,\n    ) -> Option<F64Ord> {\n        for edge in graph.labeled_edges().iter() {\n            let LabEdge(a, b, w) = edge;\n            if (a == u && b == v) || (a == v && b == u) {\n                return Some(*w);\n            }\n        }\n        None\n    }"
  },
  {
    "id": 2952,
    "function": "kruskal_mst",
    "file": "Chap65/KruskalStEph.rs",
    "lines": "26-28",
    "spec_strength": "",
    "snippet": "            fn kruskal_mst<V: StT + Hash + Ord>(\n                graph: &LabUnDirGraphStEph<V, F64Ord>,\n            ) -> SetStEph<LabEdge<V, F64Ord>>;"
  },
  {
    "id": 2953,
    "function": "mst_weight",
    "file": "Chap65/KruskalStEph.rs",
    "lines": "32",
    "spec_strength": "",
    "snippet": "            fn mst_weight<V: StT + Hash>(mst: &SetStEph<LabEdge<V, F64Ord>>) -> F64Ord;"
  },
  {
    "id": 2954,
    "function": "verify_mst_size",
    "file": "Chap65/KruskalStEph.rs",
    "lines": "36-39",
    "spec_strength": "",
    "snippet": "            fn verify_mst_size<V: StT + Hash + Ord>(\n                graph: &LabUnDirGraphStEph<V, F64Ord>,\n                mst: &SetStEph<LabEdge<V, F64Ord>>,\n            ) -> B;"
  },
  {
    "id": 2955,
    "function": "prim_mst",
    "file": "Chap65/PrimStEph.rs",
    "lines": "43-46",
    "spec_strength": "",
    "snippet": "            fn prim_mst<V: StT + Hash + Ord>(\n                graph: &LabUnDirGraphStEph<V, F64Ord>,\n                start: V,\n            ) -> SetStEph<LabEdge<V, F64Ord>>;"
  },
  {
    "id": 2956,
    "function": "mst_weight",
    "file": "Chap65/PrimStEph.rs",
    "lines": "50",
    "spec_strength": "",
    "snippet": "            fn mst_weight<V: StT + Hash>(mst: &SetStEph<LabEdge<V, F64Ord>>) -> F64Ord;"
  },
  {
    "id": 2957,
    "function": "pq_entry_new",
    "file": "Chap65/PrimStEph.rs",
    "lines": "59-69",
    "spec_strength": "",
    "snippet": "    /// Module-level function to create a new PQEntry.\n    /// - APAS: N/A  Verus-specific scaffolding.\n    /// - Claude-Opus-4.6: Work (1), Span (1)\n    #[cfg(not(verus_keep_ghost))]\n    fn pq_entry_new<V: StT + Hash + Ord>(priority: F64Ord, vertex: V, parent: Option<V>) -> PQEntry<V> {\n        PQEntry {\n            priority,\n            vertex,\n            parent,\n        }\n    }"
  },
  {
    "id": 2958,
    "function": "cmp",
    "file": "Chap65/PrimStEph.rs",
    "lines": "73-75",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A  Verus-specific scaffolding.\n        /// - Claude-Opus-4.6: Work (1), Span (1)\n        fn cmp(&self, other: &Self) -> Ordering { self.priority.cmp(&other.priority) }"
  },
  {
    "id": 2959,
    "function": "partial_cmp",
    "file": "Chap65/PrimStEph.rs",
    "lines": "80-82",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A  Verus-specific scaffolding.\n        /// - Claude-Opus-4.6: Work (1), Span (1)\n        fn partial_cmp(&self, other: &Self) -> Option<Ordering> { Some(self.cmp(other)) }"
  },
  {
    "id": 2960,
    "function": "new",
    "file": "Chap65/UnionFindStEph.rs",
    "lines": "22",
    "spec_strength": "",
    "snippet": "            fn new() -> Self;"
  },
  {
    "id": 2961,
    "function": "insert",
    "file": "Chap65/UnionFindStEph.rs",
    "lines": "26",
    "spec_strength": "",
    "snippet": "            fn insert(&mut self, v: V);"
  },
  {
    "id": 2962,
    "function": "find",
    "file": "Chap65/UnionFindStEph.rs",
    "lines": "30",
    "spec_strength": "",
    "snippet": "            fn find(&mut self, v: &V) -> V;"
  },
  {
    "id": 2963,
    "function": "union",
    "file": "Chap65/UnionFindStEph.rs",
    "lines": "34",
    "spec_strength": "",
    "snippet": "            fn union(&mut self, u: &V, v: &V);"
  },
  {
    "id": 2964,
    "function": "equals",
    "file": "Chap65/UnionFindStEph.rs",
    "lines": "38",
    "spec_strength": "",
    "snippet": "            fn equals(&mut self, u: &V, v: &V) -> B;"
  },
  {
    "id": 2965,
    "function": "num_sets",
    "file": "Chap65/UnionFindStEph.rs",
    "lines": "42",
    "spec_strength": "",
    "snippet": "            fn num_sets(&mut self) -> usize;"
  },
  {
    "id": 2966,
    "function": "default",
    "file": "Chap65/UnionFindStEph.rs",
    "lines": "128-130",
    "spec_strength": "",
    "snippet": "        /// - APAS: N/A  Rust trait boilerplate.\n        /// - Claude-Opus-4.6: Work (1), Span (1)  delegates to new()\n        fn default() -> Self { Self::new() }"
  },
  {
    "id": 2967,
    "function": "vertex_bridges_mt",
    "file": "Chap66/BoruvkaMtEph.rs",
    "lines": "36-40",
    "spec_strength": "",
    "snippet": "            fn vertex_bridges_mt<V: StTInMtT + Hash + Ord + 'static>(\n                edges: Arc<Vec<LabeledEdge<V>>>,\n                start: usize,\n                end: usize,\n            ) -> HashMap<V, (V, F64Ord, usize)>;"
  },
  {
    "id": 2968,
    "function": "bridge_star_partition_mt",
    "file": "Chap66/BoruvkaMtEph.rs",
    "lines": "44-48",
    "spec_strength": "",
    "snippet": "            fn bridge_star_partition_mt<V: StTInMtT + Hash + Ord + 'static>(\n                vertices_vec: Vec<V>,\n                bridges: HashMap<V, (V, F64Ord, usize)>,\n                rng: &mut StdRng,\n            ) -> (SetStEph<V>, HashMap<V, (V, F64Ord, usize)>);"
  },
  {
    "id": 2969,
    "function": "boruvka_mst_mt",
    "file": "Chap66/BoruvkaMtEph.rs",
    "lines": "52-57",
    "spec_strength": "",
    "snippet": "            fn boruvka_mst_mt<V: StTInMtT + Hash + Ord + 'static>(\n                vertices_vec: Vec<V>,\n                edges_vec: Vec<LabeledEdge<V>>,\n                mst_labels: SetStEph<usize>,\n                rng: &mut StdRng,\n            ) -> SetStEph<usize>;"
  },
  {
    "id": 2970,
    "function": "boruvka_mst_mt_with_seed",
    "file": "Chap66/BoruvkaMtEph.rs",
    "lines": "61-65",
    "spec_strength": "",
    "snippet": "            fn boruvka_mst_mt_with_seed<V: StTInMtT + Hash + Ord + 'static>(\n                vertices: &SetStEph<V>,\n                edges: &SetStEph<LabeledEdge<V>>,\n                seed: u64,\n            ) -> SetStEph<usize>;"
  },
  {
    "id": 2971,
    "function": "mst_weight",
    "file": "Chap66/BoruvkaMtEph.rs",
    "lines": "69-72",
    "spec_strength": "",
    "snippet": "            fn mst_weight<V: StT + Hash>(\n                edges: &SetStEph<LabeledEdge<V>>,\n                mst_labels: &SetStEph<usize>,\n            ) -> F64Ord;"
  },
  {
    "id": 2972,
    "function": "filter_tail_to_head_mt",
    "file": "Chap66/BoruvkaMtEph.rs",
    "lines": "181-232",
    "spec_strength": "",
    "snippet": "    /// Parallel filter: find edges from TailHead.\n    ///\n    /// - APAS: N/A  internal helper, not in prose.\n    /// - Claude-Opus-4.6: Work O(n), Span O(log n)  parallel divide-and-conquer via ParaPair!.\n    #[cfg(not(verus_keep_ghost))]\n    fn filter_tail_to_head_mt<V: StTInMtT + Hash + Ord + 'static>(\n        vertices: Arc<Vec<V>>,\n        bridges: Arc<HashMap<V, (V, F64Ord, usize)>>,\n        coin_flips: Arc<HashMap<V, bool>>,\n        start: usize,\n        end: usize,\n    ) -> HashMap<V, (V, F64Ord, usize)> {\n        let size = end - start;\n        if size == 0 {\n            return HashMap::new();\n        }\n\n        if size == 1 {\n            // Base case: check single vertex\n            let u = &vertices[start];\n            if let Some((v, w, label)) = bridges.get(u) {\n                let u_heads = coin_flips.get(u).copied().unwrap_or(false);\n                let v_heads = coin_flips.get(v).copied().unwrap_or(false);\n\n                if !u_heads && v_heads {\n                    let mut result = HashMap::new();\n                    let _ = result.insert(u.clone(), (v.clone(), *w, *label));\n                    return result;\n                }\n            }\n            return HashMap::new();\n        }\n\n        // Divide and conquer\n        let mid = start + size / 2;\n        let verts1 = vertices.clone();\n        let bridges1 = bridges.clone();\n        let flips1 = coin_flips.clone();\n        let verts2 = vertices;\n        let bridges2 = bridges;\n        let flips2 = coin_flips;\n\n        let pair = ParaPair!(\n            move || filter_tail_to_head_mt(verts1, bridges1, flips1, start, mid),\n            move || filter_tail_to_head_mt(verts2, bridges2, flips2, mid, end)\n        );\n\n        // Merge\n        let mut merged = pair.0;\n        merged.extend(pair.1);\n        merged\n    }"
  },
  {
    "id": 2973,
    "function": "reroute_edges_mt",
    "file": "Chap66/BoruvkaMtEph.rs",
    "lines": "285-328",
    "spec_strength": "",
    "snippet": "    /// Parallel edge re-routing: map edges to new endpoints and remove self-edges.\n    ///\n    /// - APAS: N/A  internal helper, not in prose.\n    /// - Claude-Opus-4.6: Work O(m), Span O(log m)  parallel divide-and-conquer via ParaPair!.\n    #[cfg(not(verus_keep_ghost))]\n    fn reroute_edges_mt<V: StTInMtT + Hash + Ord + 'static>(\n        edges: Arc<Vec<LabeledEdge<V>>>,\n        partition: Arc<HashMap<V, V>>,\n        start: usize,\n        end: usize,\n    ) -> Vec<LabeledEdge<V>> {\n        let size = end - start;\n        if size == 0 {\n            return Vec::new();\n        }\n\n        if size == 1 {\n            let LabeledEdge(u, v, w, label) = &edges[start];\n            let new_u = partition.get(u).cloned().unwrap_or_else(|| u.clone());\n            let new_v = partition.get(v).cloned().unwrap_or_else(|| v.clone());\n\n            if new_u != new_v {\n                return vec![LabeledEdge(new_u, new_v, *w, *label)];\n            }\n            return Vec::new();\n        }\n\n        // Divide and conquer\n        let mid = start + size / 2;\n        let edges1 = edges.clone();\n        let part1 = partition.clone();\n        let edges2 = edges;\n        let part2 = partition;\n\n        let pair = ParaPair!(move || reroute_edges_mt(edges1, part1, start, mid), move || {\n            reroute_edges_mt(edges2, part2, mid, end)\n        });\n\n        // Merge\n        let mut left_result = pair.0;\n        let mut right_result = pair.1;\n        left_result.append(&mut right_result);\n        left_result\n    }"
  },
  {
    "id": 2974,
    "function": "vertex_bridges",
    "file": "Chap66/BoruvkaStEph.rs",
    "lines": "35-37",
    "spec_strength": "",
    "snippet": "            fn vertex_bridges<V: StT + Hash + Ord>(\n                edges: &SetStEph<LabeledEdge<V>>,\n            ) -> HashMap<V, (V, F64Ord, usize)>;"
  },
  {
    "id": 2975,
    "function": "bridge_star_partition",
    "file": "Chap66/BoruvkaStEph.rs",
    "lines": "41-45",
    "spec_strength": "",
    "snippet": "            fn bridge_star_partition<V: StT + Hash + Ord>(\n                vertices: &SetStEph<V>,\n                bridges: &HashMap<V, (V, F64Ord, usize)>,\n                rng: &mut StdRng,\n            ) -> (SetStEph<V>, HashMap<V, (V, F64Ord, usize)>);"
  },
  {
    "id": 2976,
    "function": "boruvka_mst",
    "file": "Chap66/BoruvkaStEph.rs",
    "lines": "49-54",
    "spec_strength": "",
    "snippet": "            fn boruvka_mst<V: StT + Hash + Ord>(\n                vertices: &SetStEph<V>,\n                edges: &SetStEph<LabeledEdge<V>>,\n                mst_labels: SetStEph<usize>,\n                rng: &mut StdRng,\n            ) -> SetStEph<usize>;"
  },
  {
    "id": 2977,
    "function": "boruvka_mst_with_seed",
    "file": "Chap66/BoruvkaStEph.rs",
    "lines": "58-62",
    "spec_strength": "",
    "snippet": "            fn boruvka_mst_with_seed<V: StT + Hash + Ord>(\n                vertices: &SetStEph<V>,\n                edges: &SetStEph<LabeledEdge<V>>,\n                seed: u64,\n            ) -> SetStEph<usize>;"
  },
  {
    "id": 2978,
    "function": "mst_weight",
    "file": "Chap66/BoruvkaStEph.rs",
    "lines": "66-69",
    "spec_strength": "",
    "snippet": "            fn mst_weight<V: StT + Hash>(\n                edges: &SetStEph<LabeledEdge<V>>,\n                mst_labels: &SetStEph<usize>,\n            ) -> F64Ord;"
  }
]