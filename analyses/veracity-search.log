Logging to: /home/milnes/projects/APAS-VERUS/analyses/veracity-search.log
Verus Search
============

Pattern: proof fn _ types Set requires .*finite
Searching: /home/milnes/projects/verus/source/vstd
Files: 89, Functions: 2148, Matches: 35

[31m/home/milnes/projects/verus/source/vstd/set_lib.rs:244: [0m
/// A finite set with length 0 is equivalent to the empty set.
[38;5;22m    pub proof fn lemma_len0_is_empty(self)[0m
[38;5;22m        requires[0m
[38;5;22m            self.finite(),[0m
[38;5;22m            self.len() == 0,[0m
[38;5;22m        ensures[0m
[38;5;22m            self == Set::<A>::empty(),[0m

[31m/home/milnes/projects/verus/source/vstd/set_lib.rs:271: [0m
/// A set has exactly one element, if and only if, it has at least one element and any two elements are equal.
[38;5;22m    pub proof fn lemma_is_singleton(s: Set<A>)[0m
[38;5;22m        requires[0m
[38;5;22m            s.finite(),[0m
[38;5;22m        ensures[0m
[38;5;22m            s.is_singleton() == (s.len() == 1),[0m

[31m/home/milnes/projects/verus/source/vstd/set_lib.rs:410: [0m
/// Set difference with an additional element inserted decreases the size of
/// the result. This can be useful for proving termination when traversing
/// a set while tracking the elements that have already been handled.
[38;5;22m    pub broadcast proof fn lemma_set_insert_diff_decreases(self, s: Set<A>, elt: A)[0m
[38;5;22m        requires[0m
[38;5;22m            self.contains(elt),[0m
[38;5;22m            !s.contains(elt),[0m
[38;5;22m            self.finite(),[0m
[38;5;22m        ensures[0m
[38;5;22m            #[trigger] self.difference(s.insert(elt)).len() < self.difference(s).len(),[0m

[31m/home/milnes/projects/verus/source/vstd/set_lib.rs:422: [0m
/// If there is an element not present in a subset, its length is stricly smaller.
[38;5;22m    pub proof fn lemma_subset_not_in_lt(self: Set<A>, s2: Set<A>, elt: A)[0m
[38;5;22m        requires[0m
[38;5;22m            self.subset_of(s2),[0m
[38;5;22m            s2.finite(),[0m
[38;5;22m            !self.contains(elt),[0m
[38;5;22m            s2.contains(elt),[0m
[38;5;22m        ensures[0m
[38;5;22m            self.len() < s2.len(),[0m

[31m/home/milnes/projects/verus/source/vstd/set_lib.rs:659: [0m
/// Conversion to a sequence and back to a set is the identity function.
[38;5;22m    pub broadcast proof fn lemma_to_seq_to_set_id(self)[0m
[38;5;22m        requires[0m
[38;5;22m            self.finite(),[0m
[38;5;22m        ensures[0m
[38;5;22m            #[trigger] self.to_seq().to_set() =~= self,[0m
[38;5;22m        decreases self.len(),[0m

[31m/home/milnes/projects/verus/source/vstd/set_lib.rs:770: [0m
[38;5;22mpub proof fn lemma_set_union_finite_implies_sets_finite<A>(s1: Set<A>, s2: Set<A>)[0m
[38;5;22m    requires[0m
[38;5;22m        s1.union(s2).finite(),[0m
[38;5;22m    ensures[0m
[38;5;22m        s1.finite(),[0m
[38;5;22m        s2.finite(),[0m
[38;5;22m    decreases s1.union(s2).len(),[0m

[31m/home/milnes/projects/verus/source/vstd/set_lib.rs:800: [0m
/// The size of a union of two sets is less than or equal to the size of
/// both individual sets combined.
[38;5;22mpub proof fn lemma_len_union<A>(s1: Set<A>, s2: Set<A>)[0m
[38;5;22m    requires[0m
[38;5;22m        s1.finite(),[0m
[38;5;22m        s2.finite(),[0m
[38;5;22m    ensures[0m
[38;5;22m        s1.union(s2).len() <= s1.len() + s2.len(),[0m
[38;5;22m    decreases s1.len(),[0m

[31m/home/milnes/projects/verus/source/vstd/set_lib.rs:823: [0m
/// The size of a union of two sets is greater than or equal to the size of
/// both individual sets.
[38;5;22mpub proof fn lemma_len_union_ind<A>(s1: Set<A>, s2: Set<A>)[0m
[38;5;22m    requires[0m
[38;5;22m        s1.finite(),[0m
[38;5;22m        s2.finite(),[0m
[38;5;22m    ensures[0m
[38;5;22m        s1.union(s2).len() >= s1.len(),[0m
[38;5;22m        s1.union(s2).len() >= s2.len(),[0m
[38;5;22m    decreases s2.len(),[0m

[31m/home/milnes/projects/verus/source/vstd/set_lib.rs:848: [0m
/// The size of the intersection of finite set `s1` and set `s2` is less than or equal to the size of `s1`.
[38;5;22mpub proof fn lemma_len_intersect<A>(s1: Set<A>, s2: Set<A>)[0m
[38;5;22m    requires[0m
[38;5;22m        s1.finite(),[0m
[38;5;22m    ensures[0m
[38;5;22m        s1.intersect(s2).len() <= s1.len(),[0m
[38;5;22m    decreases s1.len(),[0m

[31m/home/milnes/projects/verus/source/vstd/set_lib.rs:866: [0m
/// If `s1` is a subset of finite set `s2`, then the size of `s1` is less than or equal to
/// the size of `s2` and `s1` must be finite.
[38;5;22mpub proof fn lemma_len_subset<A>(s1: Set<A>, s2: Set<A>)[0m
[38;5;22m    requires[0m
[38;5;22m        s2.finite(),[0m
[38;5;22m        s1.subset_of(s2),[0m
[38;5;22m    ensures[0m
[38;5;22m        s1.len() <= s2.len(),[0m
[38;5;22m        s1.finite(),[0m

[31m/home/milnes/projects/verus/source/vstd/set_lib.rs:879: [0m
/// A subset of a finite set `s` is finite.
[38;5;22mpub broadcast proof fn lemma_set_subset_finite<A>(s: Set<A>, sub: Set<A>)[0m
[38;5;22m    requires[0m
[38;5;22m        s.finite(),[0m
[38;5;22m        sub.subset_of(s),[0m
[38;5;22m    ensures[0m
[38;5;22m        #![trigger sub.subset_of(s)][0m
[38;5;22m        sub.finite(),[0m

[31m/home/milnes/projects/verus/source/vstd/set_lib.rs:892: [0m
/// The size of the difference of finite set `s1` and set `s2` is less than or equal to the size of `s1`.
[38;5;22mpub proof fn lemma_len_difference<A>(s1: Set<A>, s2: Set<A>)[0m
[38;5;22m    requires[0m
[38;5;22m        s1.finite(),[0m
[38;5;22m    ensures[0m
[38;5;22m        s1.difference(s2).len() <= s1.len(),[0m
[38;5;22m    decreases s1.len(),[0m

[31m/home/milnes/projects/verus/source/vstd/set_lib.rs:932: [0m
/// If x is a subset of y and the size of x is equal to the size of y, x is equal to y.
[38;5;22mpub proof fn lemma_subset_equality<A>(x: Set<A>, y: Set<A>)[0m
[38;5;22m    requires[0m
[38;5;22m        x.subset_of(y),[0m
[38;5;22m        x.finite(),[0m
[38;5;22m        y.finite(),[0m
[38;5;22m        x.len() == y.len(),[0m
[38;5;22m    ensures[0m
[38;5;22m        x =~= y,[0m
[38;5;22m    decreases x.len(),[0m

[31m/home/milnes/projects/verus/source/vstd/set_lib.rs:953: [0m
/// If an injective function is applied to each element of a set to construct
/// another set, the two sets have the same size.
[38;5;22mpub proof fn lemma_map_size<A, B>(x: Set<A>, y: Set<B>, f: spec_fn(A) -> B)[0m
[38;5;22m    requires[0m
[38;5;22m        x.finite(),[0m
[38;5;22m        injective_on(f, x),[0m
[38;5;22m        x.map(f) == y,[0m
[38;5;22m    ensures[0m
[38;5;22m        y.finite(),[0m
[38;5;22m        x.len() == y.len(),[0m
[38;5;22m    decreases x.len(),[0m

[31m/home/milnes/projects/verus/source/vstd/set_lib.rs:979: [0m
/// If any function is applied to each element of a set to construct
/// another set, the constructed set's length is at most the original's
[38;5;22mpub proof fn lemma_map_size_bound<A, B>(x: Set<A>, y: Set<B>, f: spec_fn(A) -> B)[0m
[38;5;22m    requires[0m
[38;5;22m        x.finite(),[0m
[38;5;22m        x.map(f) == y,[0m
[38;5;22m    ensures[0m
[38;5;22m        y.finite(),[0m
[38;5;22m        y.len() <= x.len(),[0m
[38;5;22m    decreases x.len(),[0m

[31m/home/milnes/projects/verus/source/vstd/set_lib.rs:1077: [0m
/// Set `s` has length 0 if and only if it is equal to the empty set. If `s` has length greater than 0,
/// Then there must exist an element `x` such that `s` contains `x`.
[38;5;22mpub broadcast proof fn lemma_set_empty_equivalency_len<A>(s: Set<A>)[0m
[38;5;22m    requires[0m
[38;5;22m        s.finite(),[0m
[38;5;22m    ensures[0m
[38;5;22m        #![trigger s.len()][0m
[38;5;22m        (s.len() == 0 <==> s == Set::<A>::empty()) && (s.len() != 0 ==> exists|x: A| s.contains(x)),[0m

[31m/home/milnes/projects/verus/source/vstd/set_lib.rs:1104: [0m
/// If sets `a` and `b` are disjoint, meaning they share no elements in common, then the length
/// of the union `a + b` is equal to the sum of the lengths of `a` and `b`.
[38;5;22mpub broadcast proof fn lemma_set_disjoint_lens<A>(a: Set<A>, b: Set<A>)[0m
[38;5;22m    requires[0m
[38;5;22m        a.finite(),[0m
[38;5;22m        b.finite(),[0m
[38;5;22m    ensures[0m
[38;5;22m        a.disjoint(b) ==> #[trigger] (a + b).len() == a.len() + b.len(),[0m
[38;5;22m    decreases a.len(),[0m

[31m/home/milnes/projects/verus/source/vstd/set_lib.rs:1151: [0m
/// The length of the union between two sets added to the length of the intersection between the
/// two sets is equal to the sum of the lengths of the two sets.
[38;5;22mpub broadcast proof fn lemma_set_intersect_union_lens<A>(a: Set<A>, b: Set<A>)[0m
[38;5;22m    requires[0m
[38;5;22m        a.finite(),[0m
[38;5;22m        b.finite(),[0m
[38;5;22m    ensures[0m
[38;5;22m        #[trigger] (a + b).len() + #[trigger] a.intersect(b).len() == a.len() + b.len(),[0m
[38;5;22m    decreases a.len(),[0m

[31m/home/milnes/projects/verus/source/vstd/set_lib.rs:1183: [0m
///
/// The length of the set difference `A \ B` is equal to the length of `A` minus the length of the
/// intersection `A âˆ© B`.
[38;5;22mpub broadcast proof fn lemma_set_difference_len<A>(a: Set<A>, b: Set<A>)[0m
[38;5;22m    requires[0m
[38;5;22m        a.finite(),[0m
[38;5;22m        b.finite(),[0m
[38;5;22m    ensures[0m
[38;5;22m        (#[trigger] a.difference(b).len() + b.difference(a).len() + a.intersect(b).len() == (a[0m
[38;5;22m            + b).len()) && (a.difference(b).len() == a.len() - a.intersect(b).len()),[0m
[38;5;22m    decreases a.len(),[0m

[31m/home/milnes/projects/verus/source/vstd/set.rs:539: [0m
[38;5;22m    pub proof fn lemma_finite_set_induct<A>(s: Set<A>, pred: spec_fn(Set<A>) -> bool)[0m
[38;5;22m        requires[0m
[38;5;22m            s.finite(),[0m
[38;5;22m            pred(Set::empty()),[0m
[38;5;22m            forall|s, a| pred(s) && s.finite() && !s.contains(a) ==> #[trigger] pred(s.insert(a)),[0m
[38;5;22m        ensures[0m
[38;5;22m            pred(s),[0m

[31m/home/milnes/projects/verus/source/vstd/set.rs:552: [0m
[38;5;22m    proof fn lemma_finite_set_induct_aux<A>([0m
[38;5;22m        s: Set<A>,[0m
[38;5;22m        f: spec_fn(A) -> nat,[0m
[38;5;22m        ub: nat,[0m
[38;5;22m        pred: spec_fn(Set<A>) -> bool,[0m
[38;5;22m    )[0m
[38;5;22m        requires[0m
[38;5;22m            surj_on(f, s),[0m
[38;5;22m            s.finite(),[0m
[38;5;22m            forall|a| s.contains(a) ==> f(a) < ub,[0m
[38;5;22m            pred(Set::empty()),[0m
[38;5;22m            forall|s, a| pred(s) && s.finite() && !s.contains(a) ==> #[trigger] pred(s.insert(a)),[0m
[38;5;22m        ensures[0m
[38;5;22m            pred(s),[0m
[38;5;22m        decreases ub,[0m

[31m/home/milnes/projects/verus/source/vstd/set.rs:584: [0m
[38;5;22m    proof fn lemma_fold_graph_exists<A, B>(z: B, f: spec_fn(B, A) -> B, s: Set<A>)[0m
[38;5;22m        requires[0m
[38;5;22m            s.finite(),[0m
[38;5;22m            is_fun_commutative(f),[0m
[38;5;22m        ensures[0m
[38;5;22m            exists|y, d| fold_graph(z, f, s, y, d),[0m

[31m/home/milnes/projects/verus/source/vstd/set.rs:606: [0m
[38;5;22m    pub broadcast proof fn lemma_fold_insert<A, B>(s: Set<A>, z: B, f: spec_fn(B, A) -> B, a: A)[0m
[38;5;22m        requires[0m
[38;5;22m            s.finite(),[0m
[38;5;22m            !s.contains(a),[0m
[38;5;22m            is_fun_commutative(f),[0m
[38;5;22m        ensures[0m
[38;5;22m            #[trigger] s.insert(a).fold(z, f) == f(s.fold(z, f), a),[0m

[31m/home/milnes/projects/verus/source/vstd/set.rs:790: [0m
/// The result of inserting an element `a` into a finite set `s` is also finite.
[38;5;22mpub broadcast proof fn axiom_set_insert_finite<A>(s: Set<A>, a: A)[0m
[38;5;22m    requires[0m
[38;5;22m        s.finite(),[0m
[38;5;22m    ensures[0m
[38;5;22m        #[trigger] s.insert(a).finite(),[0m

[31m/home/milnes/projects/verus/source/vstd/set.rs:827: [0m
/// The result of removing an element `a` from a finite set `s` is also finite.
[38;5;22mpub broadcast proof fn axiom_set_remove_finite<A>(s: Set<A>, a: A)[0m
[38;5;22m    requires[0m
[38;5;22m        s.finite(),[0m
[38;5;22m    ensures[0m
[38;5;22m        #[trigger] s.remove(a).finite(),[0m

[31m/home/milnes/projects/verus/source/vstd/set.rs:855: [0m
/// The union of two finite sets is finite.
[38;5;22mpub broadcast proof fn axiom_set_union_finite<A>(s1: Set<A>, s2: Set<A>)[0m
[38;5;22m    requires[0m
[38;5;22m        s1.finite(),[0m
[38;5;22m        s2.finite(),[0m
[38;5;22m    ensures[0m
[38;5;22m        #[trigger] s1.union(s2).finite(),[0m

[31m/home/milnes/projects/verus/source/vstd/set.rs:880: [0m
/// The intersection of two finite sets is finite.
[38;5;22mpub broadcast proof fn axiom_set_intersect_finite<A>(s1: Set<A>, s2: Set<A>)[0m
[38;5;22m    requires[0m
[38;5;22m        s1.finite() || s2.finite(),[0m
[38;5;22m    ensures[0m
[38;5;22m        #[trigger] s1.intersect(s2).finite(),[0m

[31m/home/milnes/projects/verus/source/vstd/set.rs:892: [0m
/// The set difference between two finite sets is finite.
[38;5;22mpub broadcast proof fn axiom_set_difference_finite<A>(s1: Set<A>, s2: Set<A>)[0m
[38;5;22m    requires[0m
[38;5;22m        s1.finite(),[0m
[38;5;22m    ensures[0m
[38;5;22m        #[trigger] s1.difference(s2).finite(),[0m

[31m/home/milnes/projects/verus/source/vstd/set.rs:904: [0m
/// An infinite set `s` contains the element `s.choose()`.
[38;5;22mpub broadcast proof fn axiom_set_choose_infinite<A>(s: Set<A>)[0m
[38;5;22m    requires[0m
[38;5;22m        !s.finite(),[0m
[38;5;22m    ensures[0m
[38;5;22m        #[trigger] s.contains(s.choose()),[0m

[31m/home/milnes/projects/verus/source/vstd/set.rs:928: [0m
/// The result of inserting an element `a` into a finite set `s` has length
/// `s.len() + 1` if `a` is not already in `s` and length `s.len()` otherwise.
[38;5;22mpub broadcast proof fn axiom_set_insert_len<A>(s: Set<A>, a: A)[0m
[38;5;22m    requires[0m
[38;5;22m        s.finite(),[0m
[38;5;22m    ensures[0m
[38;5;22m        #[trigger] s.insert(a).len() == s.len() + (if s.contains(a)[0m

[31m/home/milnes/projects/verus/source/vstd/set.rs:947: [0m
/// The result of removing an element `a` from a finite set `s` has length
/// `s.len() - 1` if `a` is in `s` and length `s.len()` otherwise.
[38;5;22mpub broadcast proof fn axiom_set_remove_len<A>(s: Set<A>, a: A)[0m
[38;5;22m    requires[0m
[38;5;22m        s.finite(),[0m
[38;5;22m    ensures[0m
[38;5;22m        s.len() == #[trigger] s.remove(a).len() + (if s.contains(a)[0m

[31m/home/milnes/projects/verus/source/vstd/set.rs:967: [0m
/// If a finite set `s` contains any element, it has length greater than 0.
[38;5;22mpub broadcast proof fn axiom_set_contains_len<A>(s: Set<A>, a: A)[0m
[38;5;22m    requires[0m
[38;5;22m        s.finite(),[0m
[38;5;22m        #[trigger] s.contains(a),[0m
[38;5;22m    ensures[0m
[38;5;22m        #[trigger] s.len() != 0,[0m

[31m/home/milnes/projects/verus/source/vstd/set.rs:982: [0m
/// A finite set `s` contains the element `s.choose()` if it has length greater than 0.
[38;5;22mpub broadcast proof fn axiom_set_choose_len<A>(s: Set<A>)[0m
[38;5;22m    requires[0m
[38;5;22m        s.finite(),[0m
[38;5;22m        #[trigger] s.len() != 0,[0m
[38;5;22m    ensures[0m
[38;5;22m        #[trigger] s.contains(s.choose()),[0m

[31m/home/milnes/projects/verus/source/vstd/tokens.rs:501: [0m
[38;5;22mproof fn fresh_is_fresh(s: Set<int>)[0m
[38;5;22m    requires s.finite(),[0m
[38;5;22m    ensures !s.contains(fresh(s))[0m

[31m/home/milnes/projects/verus/source/vstd/map_lib.rs:224: [0m
/// Removing a set of n keys from a map that previously contained all n keys
/// results in a domain of size n less than the original domain.
[38;5;22m    pub proof fn lemma_remove_keys_len(self, keys: Set<K>)[0m
[38;5;22m        requires[0m
[38;5;22m            forall|k: K| #[trigger] keys.contains(k) ==> self.contains_key(k),[0m
[38;5;22m            keys.finite(),[0m
[38;5;22m            self.dom().finite(),[0m
[38;5;22m        ensures[0m
[38;5;22m            self.remove_keys(keys).dom().len() == self.dom().len() - keys.len(),[0m
[38;5;22m        decreases keys.len(),[0m

