Logging to: /home/milnes/projects/APAS-VERUS/analyses/veracity-search.log
Verus Search
============

Pattern: fn set
Searching: /home/milnes/projects/verus/source/vstd
Files: 96, Functions: 2371, Matches: 108

[31m/home/milnes/projects/verus/source/vstd/hash_set.rs:162: [0m
[38;5;22mpub broadcast axiom fn axiom_hash_set_with_view_spec_len<Key>(m: &HashSetWithView<Key>) where[0m
[38;5;22m    Key: View + Eq + Hash,[0m
[38;5;22m    ensures[0m
[38;5;22m        #[trigger] m.spec_len() == m@.len(),[0m
[38;5;22m;[0m

[31m/home/milnes/projects/verus/source/vstd/hash_set.rs:305: [0m
[38;5;22mpub broadcast axiom fn axiom_string_hash_set_spec_len(m: &StringHashSet)[0m
[38;5;22m    ensures[0m
[38;5;22m        #[trigger] m.spec_len() == m@.len(),[0m
[38;5;22m;[0m

[31m/home/milnes/projects/verus/source/vstd/multiset.rs:65: [0m
[38;5;22m    pub open spec fn from_set(m: Set<V>) -> Self[0m

[31m/home/milnes/projects/verus/source/vstd/std_specs/core.rs:174: [0m
[38;5;22m    spec fn spec_index_set_requires(&self, index: Idx) -> bool;[0m

[31m/home/milnes/projects/verus/source/vstd/std_specs/core.rs:176: [0m
[38;5;22m    spec fn spec_index_set_ensures([0m
[38;5;22m        &self,[0m
[38;5;22m        new_container: &Self,[0m
[38;5;22m        index: Idx,[0m
[38;5;22m        val: Self::Output,[0m
[38;5;22m    ) -> bool where Self::Output: Sized;[0m

[31m/home/milnes/projects/verus/source/vstd/std_specs/core.rs:190: [0m
#[verifier(external_body)]
[38;5;22mpub fn index_set<T, Idx, E>(container: &mut T, index: Idx, val: E) where[0m
[38;5;22m    T: ?Sized + core::ops::IndexMut<Idx> + core::ops::Index<Idx, Output = E> + IndexSetTrustedSpec<[0m
[38;5;22m        Idx,[0m
[38;5;22m    >,[0m
[38;5;22m    requires[0m
[38;5;22m        old(container).spec_index_set_requires(index),[0m
[38;5;22m    ensures[0m
[38;5;22m        old(container).spec_index_set_ensures(container, index, val),[0m
[38;5;22m    no_unwind[0m

[31m/home/milnes/projects/verus/source/vstd/std_specs/hash.rs:1214: [0m
[38;5;22mpub uninterp spec fn spec_hash_set_len<Key, S>(m: &HashSet<Key, S>) -> usize;[0m

[31m/home/milnes/projects/verus/source/vstd/std_specs/hash.rs:1216: [0m
[38;5;22mpub broadcast proof fn axiom_spec_hash_set_len<Key, S>(m: &HashSet<Key, S>)[0m
[38;5;22m    ensures[0m
[38;5;22m        obeys_key_model::<Key>() && builds_valid_hashers::<S>() ==> #[trigger] spec_hash_set_len(m)[0m
[38;5;22m            == m@.len(),[0m

[31m/home/milnes/projects/verus/source/vstd/std_specs/hash.rs:1289: [0m
[38;5;22mpub uninterp spec fn set_contains_borrowed_key<Key, Q: ?Sized>(m: Set<Key>, k: &Q) -> bool;[0m

[31m/home/milnes/projects/verus/source/vstd/std_specs/hash.rs:1291: [0m
[38;5;22mpub broadcast proof fn axiom_set_contains_deref_key<Q>(m: Set<Q>, k: &Q)[0m
[38;5;22m    ensures[0m
[38;5;22m        #[trigger] set_contains_borrowed_key::<Q, Q>(m, k) <==> m.contains(*k),[0m

[31m/home/milnes/projects/verus/source/vstd/std_specs/hash.rs:1298: [0m
[38;5;22mpub broadcast proof fn axiom_set_contains_box<Q>(m: Set<Box<Q>>, k: &Q)[0m
[38;5;22m    ensures[0m
[38;5;22m        #[trigger] set_contains_borrowed_key::<Box<Q>, Q>(m, k) <==> m.contains(Box::new(*k)),[0m

[31m/home/milnes/projects/verus/source/vstd/std_specs/hash.rs:1333: [0m
[38;5;22mpub broadcast proof fn axiom_set_deref_key_to_value<Q>(m: Set<Q>, k: &Q, v: &Q)[0m
[38;5;22m    ensures[0m
[38;5;22m        #[trigger] sets_borrowed_key_to_key::<Q, Q>(m, k, v) <==> m.contains(*k) && k == v,[0m

[31m/home/milnes/projects/verus/source/vstd/std_specs/hash.rs:1340: [0m
[38;5;22mpub broadcast proof fn axiom_set_box_key_to_value<Q>(m: Set<Box<Q>>, q: &Q, v: &Box<Q>)[0m
[38;5;22m    ensures[0m
[38;5;22m        #[trigger] sets_borrowed_key_to_key::<Box<Q>, Q>(m, q, v) <==> (m.contains(*v) && Box::new([0m
[38;5;22m            *q,[0m
[38;5;22m        ) == v),[0m

[31m/home/milnes/projects/verus/source/vstd/std_specs/hash.rs:1382: [0m
[38;5;22mpub broadcast proof fn axiom_set_deref_key_removed<Q>(old_m: Set<Q>, new_m: Set<Q>, k: &Q)[0m
[38;5;22m    ensures[0m
[38;5;22m        #[trigger] sets_differ_by_borrowed_key::<Q, Q>(old_m, new_m, k) <==> new_m == old_m.remove([0m
[38;5;22m            *k,[0m
[38;5;22m        ),[0m

[31m/home/milnes/projects/verus/source/vstd/std_specs/hash.rs:1391: [0m
[38;5;22mpub broadcast proof fn axiom_set_box_key_removed<Q>(old_m: Set<Box<Q>>, new_m: Set<Box<Q>>, q: &Q)[0m
[38;5;22m    ensures[0m
[38;5;22m        #[trigger] sets_differ_by_borrowed_key::<Box<Q>, Q>(old_m, new_m, q) <==> new_m[0m
[38;5;22m            == old_m.remove(Box::new(*q)),[0m

[31m/home/milnes/projects/verus/source/vstd/std_specs/slice.rs:14: [0m
[38;5;22m    open spec fn spec_index_set_requires(&self, index: usize) -> bool[0m

[31m/home/milnes/projects/verus/source/vstd/std_specs/slice.rs:18: [0m
[38;5;22m    open spec fn spec_index_set_ensures(&self, new_container: &Self, index: usize, val: T) -> bool[0m

[31m/home/milnes/projects/verus/source/vstd/std_specs/slice.rs:26: [0m
[38;5;22m    open spec fn spec_index_set_requires(&self, index: usize) -> bool[0m

[31m/home/milnes/projects/verus/source/vstd/std_specs/slice.rs:30: [0m
[38;5;22m    open spec fn spec_index_set_ensures(&self, new_container: &Self, index: usize, val: T) -> bool[0m

[31m/home/milnes/projects/verus/source/vstd/std_specs/vec.rs:325: [0m
[38;5;22m    open spec fn spec_index_set_requires(&self, index: usize) -> bool[0m

[31m/home/milnes/projects/verus/source/vstd/std_specs/vec.rs:329: [0m
[38;5;22m    open spec fn spec_index_set_ensures(&self, new_container: &Self, index: usize, val: T) -> bool[0m

[31m/home/milnes/projects/verus/source/vstd/std_specs/btree.rs:971: [0m
[38;5;22mpub uninterp spec fn spec_btree_set_len<Key, A: Allocator + Clone>(m: &BTreeSet<Key, A>) -> usize;[0m

[31m/home/milnes/projects/verus/source/vstd/std_specs/btree.rs:973: [0m
[38;5;22mpub broadcast axiom fn axiom_spec_btree_set_len<Key, A: Allocator + Clone>(m: &BTreeSet<Key, A>)[0m
[38;5;22m    ensures[0m
[38;5;22m        key_obeys_cmp_spec::<Key>() ==> #[trigger] spec_btree_set_len(m) == m@.len(),[0m
[38;5;22m;[0m

[31m/home/milnes/projects/verus/source/vstd/std_specs/btree.rs:1037: [0m
[38;5;22mpub uninterp spec fn set_contains_borrowed_key<Key, Q: ?Sized>(m: Set<Key>, k: &Q) -> bool;[0m

[31m/home/milnes/projects/verus/source/vstd/std_specs/btree.rs:1039: [0m
[38;5;22mpub broadcast axiom fn axiom_set_contains_deref_key<Q>(m: Set<Q>, k: &Q)[0m
[38;5;22m    ensures[0m
[38;5;22m        #[trigger] set_contains_borrowed_key::<Q, Q>(m, k) <==> m.contains(*k),[0m
[38;5;22m;[0m

[31m/home/milnes/projects/verus/source/vstd/std_specs/btree.rs:1044: [0m
[38;5;22mpub broadcast axiom fn axiom_set_contains_box<Q>(m: Set<Box<Q>>, k: &Q)[0m
[38;5;22m    ensures[0m
[38;5;22m        #[trigger] set_contains_borrowed_key::<Box<Q>, Q>(m, k) <==> m.contains(Box::new(*k)),[0m
[38;5;22m;[0m

[31m/home/milnes/projects/verus/source/vstd/std_specs/btree.rs:1075: [0m
[38;5;22mpub broadcast axiom fn axiom_set_deref_key_to_value<Q>(m: Set<Q>, k: &Q, v: &Q)[0m
[38;5;22m    ensures[0m
[38;5;22m        #[trigger] sets_borrowed_key_to_key::<Q, Q>(m, k, v) <==> m.contains(*k) && k == v,[0m
[38;5;22m;[0m

[31m/home/milnes/projects/verus/source/vstd/std_specs/btree.rs:1080: [0m
[38;5;22mpub broadcast axiom fn axiom_set_box_key_to_value<Q>(m: Set<Box<Q>>, q: &Q, v: &Box<Q>)[0m
[38;5;22m    ensures[0m
[38;5;22m        #[trigger] sets_borrowed_key_to_key::<Box<Q>, Q>(m, q, v) <==> (m.contains(*v) && Box::new([0m
[38;5;22m            *q,[0m
[38;5;22m        ) == v),[0m
[38;5;22m;[0m

[31m/home/milnes/projects/verus/source/vstd/std_specs/btree.rs:1120: [0m
[38;5;22mpub broadcast axiom fn axiom_set_deref_key_removed<Q>(old_m: Set<Q>, new_m: Set<Q>, k: &Q)[0m
[38;5;22m    ensures[0m
[38;5;22m        #[trigger] sets_differ_by_borrowed_key::<Q, Q>(old_m, new_m, k) <==> new_m == old_m.remove([0m
[38;5;22m            *k,[0m
[38;5;22m        ),[0m
[38;5;22m;[0m

[31m/home/milnes/projects/verus/source/vstd/std_specs/btree.rs:1127: [0m
[38;5;22mpub broadcast axiom fn axiom_set_box_key_removed<Q>(old_m: Set<Box<Q>>, new_m: Set<Box<Q>>, q: &Q)[0m
[38;5;22m    ensures[0m
[38;5;22m        #[trigger] sets_differ_by_borrowed_key::<Box<Q>, Q>(old_m, new_m, q) <==> new_m[0m
[38;5;22m            == old_m.remove(Box::new(*q)),[0m
[38;5;22m;[0m

[31m/home/milnes/projects/verus/source/vstd/std_specs/btree.rs:1164: [0m
[38;5;22mpub broadcast axiom fn axiom_btree_set_decreases<Key, A: Allocator + Clone>(m: BTreeSet<Key, A>)[0m
[38;5;22m    ensures[0m
[38;5;22m        #[trigger] (decreases_to!(m => m@)),[0m
[38;5;22m;[0m

[31m/home/milnes/projects/verus/source/vstd/tokens/set.rs:200: [0m
///     subset
/// }
/// ```
[38;5;22m    pub proof fn insert_set(tracked &mut self, s: Set<T>) -> (tracked result: GhostSubset<T>)[0m
[38;5;22m        requires[0m
[38;5;22m            old(self)@.disjoint(s),[0m
[38;5;22m        ensures[0m
[38;5;22m            self.id() == old(self).id(),[0m
[38;5;22m            self@ == old(self)@.union(s),[0m
[38;5;22m            result.id() == self.id(),[0m
[38;5;22m            result@ == s,[0m

[31m/home/milnes/projects/verus/source/vstd/set_lib.rs:410: [0m
/// Set difference with an additional element inserted decreases the size of
/// the result. This can be useful for proving termination when traversing
/// a set while tracking the elements that have already been handled.
[38;5;22m    pub broadcast proof fn lemma_set_insert_diff_decreases(self, s: Set<A>, elt: A)[0m
[38;5;22m        requires[0m
[38;5;22m            self.contains(elt),[0m
[38;5;22m            !s.contains(elt),[0m
[38;5;22m            self.finite(),[0m
[38;5;22m        ensures[0m
[38;5;22m            #[trigger] self.difference(s.insert(elt)).len() < self.difference(s).len(),[0m

[31m/home/milnes/projects/verus/source/vstd/set_lib.rs:438: [0m
/// Inserting an element and mapping a function over a set commute
[38;5;22m    pub broadcast proof fn lemma_set_map_insert_commute<B>(self, elt: A, f: spec_fn(A) -> B)[0m
[38;5;22m        ensures[0m
[38;5;22m            #[trigger] self.insert(elt).map(f) =~= self.map(f).insert(f(elt)),[0m

[31m/home/milnes/projects/verus/source/vstd/set_lib.rs:626: [0m
[38;5;22m    pub broadcast proof fn lemma_set_all_subset(self, s2: Set<A>, p: spec_fn(A) -> bool)[0m
[38;5;22m        requires[0m
[38;5;22m            #[trigger] self.subset_of(s2),[0m
[38;5;22m            s2.all(p),[0m
[38;5;22m        ensures[0m
[38;5;22m            #[trigger] self.all(p),[0m

[31m/home/milnes/projects/verus/source/vstd/set_lib.rs:659: [0m
/// Conversion to a sequence and back to a set is the identity function.
[38;5;22m    pub broadcast proof fn lemma_to_seq_to_set_id(self)[0m
[38;5;22m        requires[0m
[38;5;22m            self.finite(),[0m
[38;5;22m        ensures[0m
[38;5;22m            #[trigger] self.to_seq().to_set() =~= self,[0m
[38;5;22m        decreases self.len(),[0m

[31m/home/milnes/projects/verus/source/vstd/set_lib.rs:732: [0m
/// The result of inserting an element `a` into a set `s` is finite iff `s` is finite.
[38;5;22mpub broadcast proof fn lemma_set_insert_finite_iff<A>(s: Set<A>, a: A)[0m
[38;5;22m    ensures[0m
[38;5;22m        #[trigger] s.insert(a).finite() <==> s.finite(),[0m

[31m/home/milnes/projects/verus/source/vstd/set_lib.rs:747: [0m
/// The result of removing an element `a` into a set `s` is finite iff `s` is finite.
[38;5;22mpub broadcast proof fn lemma_set_remove_finite_iff<A>(s: Set<A>, a: A)[0m
[38;5;22m    ensures[0m
[38;5;22m        #[trigger] s.remove(a).finite() <==> s.finite(),[0m

[31m/home/milnes/projects/verus/source/vstd/set_lib.rs:761: [0m
/// The union of two sets is finite iff both sets are finite.
[38;5;22mpub broadcast proof fn lemma_set_union_finite_iff<A>(s1: Set<A>, s2: Set<A>)[0m
[38;5;22m    ensures[0m
[38;5;22m        #[trigger] s1.union(s2).finite() <==> s1.finite() && s2.finite(),[0m

[31m/home/milnes/projects/verus/source/vstd/set_lib.rs:770: [0m
[38;5;22mpub proof fn lemma_set_union_finite_implies_sets_finite<A>(s1: Set<A>, s2: Set<A>)[0m
[38;5;22m    requires[0m
[38;5;22m        s1.union(s2).finite(),[0m
[38;5;22m    ensures[0m
[38;5;22m        s1.finite(),[0m
[38;5;22m        s2.finite(),[0m
[38;5;22m    decreases s1.union(s2).len(),[0m

[31m/home/milnes/projects/verus/source/vstd/set_lib.rs:879: [0m
/// A subset of a finite set `s` is finite.
[38;5;22mpub broadcast proof fn lemma_set_subset_finite<A>(s: Set<A>, sub: Set<A>)[0m
[38;5;22m    requires[0m
[38;5;22m        s.finite(),[0m
[38;5;22m        sub.subset_of(s),[0m
[38;5;22m    ensures[0m
[38;5;22m        #![trigger sub.subset_of(s)][0m
[38;5;22m        sub.finite(),[0m

[31m/home/milnes/projects/verus/source/vstd/set_lib.rs:909: [0m
/// Creates a finite set of integers in the range [lo, hi).
[38;5;22mpub open spec fn set_int_range(lo: int, hi: int) -> Set<int>[0m

[31m/home/milnes/projects/verus/source/vstd/set_lib.rs:1016: [0m
/// Taking the union of sets `a` and `b` and then taking the union of the result with `b`
/// is the same as taking the union of `a` and `b` once.
[38;5;22mpub broadcast proof fn lemma_set_union_again1<A>(a: Set<A>, b: Set<A>)[0m
[38;5;22m    ensures[0m
[38;5;22m        #[trigger] a.union(b).union(b) =~= a.union(b),[0m

[31m/home/milnes/projects/verus/source/vstd/set_lib.rs:1025: [0m
/// Taking the union of sets `a` and `b` and then taking the union of the result with `a`
/// is the same as taking the union of `a` and `b` once.
[38;5;22mpub broadcast proof fn lemma_set_union_again2<A>(a: Set<A>, b: Set<A>)[0m
[38;5;22m    ensures[0m
[38;5;22m        #[trigger] a.union(b).union(a) =~= a.union(b),[0m

[31m/home/milnes/projects/verus/source/vstd/set_lib.rs:1034: [0m
/// Taking the intersection of sets `a` and `b` and then taking the intersection of the result with `b`
/// is the same as taking the intersection of `a` and `b` once.
[38;5;22mpub broadcast proof fn lemma_set_intersect_again1<A>(a: Set<A>, b: Set<A>)[0m
[38;5;22m    ensures[0m
[38;5;22m        #![trigger (a.intersect(b)).intersect(b)][0m
[38;5;22m        (a.intersect(b)).intersect(b) =~= a.intersect(b),[0m

[31m/home/milnes/projects/verus/source/vstd/set_lib.rs:1044: [0m
/// Taking the intersection of sets `a` and `b` and then taking the intersection of the result with `a`
/// is the same as taking the intersection of `a` and `b` once.
[38;5;22mpub broadcast proof fn lemma_set_intersect_again2<A>(a: Set<A>, b: Set<A>)[0m
[38;5;22m    ensures[0m
[38;5;22m        #![trigger (a.intersect(b)).intersect(a)][0m
[38;5;22m        (a.intersect(b)).intersect(a) =~= a.intersect(b),[0m

[31m/home/milnes/projects/verus/source/vstd/set_lib.rs:1053: [0m
/// If set `s2` contains element `a`, then the set difference of `s1` and `s2` does not contain `a`.
[38;5;22mpub broadcast proof fn lemma_set_difference2<A>(s1: Set<A>, s2: Set<A>, a: A)[0m
[38;5;22m    ensures[0m
[38;5;22m        #![trigger s1.difference(s2).contains(a)][0m
[38;5;22m        s2.contains(a) ==> !s1.difference(s2).contains(a),[0m

[31m/home/milnes/projects/verus/source/vstd/set_lib.rs:1063: [0m
/// If sets `a` and `b` are disjoint, meaning they have no elements in common, then the set difference
/// of `a + b` and `b` is equal to `a` and the set difference of `a + b` and `a` is equal to `b`.
[38;5;22mpub broadcast proof fn lemma_set_disjoint<A>(a: Set<A>, b: Set<A>)[0m
[38;5;22m    ensures[0m
[38;5;22m        #![trigger (a + b).difference(a)]  //TODO: this might be too free[0m
[38;5;22m        a.disjoint(b) ==> ((a + b).difference(a) =~= b && (a + b).difference(b) =~= a),[0m

[31m/home/milnes/projects/verus/source/vstd/set_lib.rs:1077: [0m
/// Set `s` has length 0 if and only if it is equal to the empty set. If `s` has length greater than 0,
/// Then there must exist an element `x` such that `s` contains `x`.
[38;5;22mpub broadcast proof fn lemma_set_empty_equivalency_len<A>(s: Set<A>)[0m
[38;5;22m    requires[0m
[38;5;22m        s.finite(),[0m
[38;5;22m    ensures[0m
[38;5;22m        #![trigger s.len()][0m
[38;5;22m        (s.len() == 0 <==> s == Set::<A>::empty()) && (s.len() != 0 ==> exists|x: A| s.contains(x)),[0m

[31m/home/milnes/projects/verus/source/vstd/set_lib.rs:1104: [0m
/// If sets `a` and `b` are disjoint, meaning they share no elements in common, then the length
/// of the union `a + b` is equal to the sum of the lengths of `a` and `b`.
[38;5;22mpub broadcast proof fn lemma_set_disjoint_lens<A>(a: Set<A>, b: Set<A>)[0m
[38;5;22m    requires[0m
[38;5;22m        a.finite(),[0m
[38;5;22m        b.finite(),[0m
[38;5;22m    ensures[0m
[38;5;22m        a.disjoint(b) ==> #[trigger] (a + b).len() == a.len() + b.len(),[0m
[38;5;22m    decreases a.len(),[0m

[31m/home/milnes/projects/verus/source/vstd/set_lib.rs:1151: [0m
/// The length of the union between two sets added to the length of the intersection between the
/// two sets is equal to the sum of the lengths of the two sets.
[38;5;22mpub broadcast proof fn lemma_set_intersect_union_lens<A>(a: Set<A>, b: Set<A>)[0m
[38;5;22m    requires[0m
[38;5;22m        a.finite(),[0m
[38;5;22m        b.finite(),[0m
[38;5;22m    ensures[0m
[38;5;22m        #[trigger] (a + b).len() + #[trigger] a.intersect(b).len() == a.len() + b.len(),[0m
[38;5;22m    decreases a.len(),[0m

[31m/home/milnes/projects/verus/source/vstd/set_lib.rs:1183: [0m
///
/// The length of the set difference `A \ B` is equal to the length of `A` minus the length of the
/// intersection `A âˆ© B`.
[38;5;22mpub broadcast proof fn lemma_set_difference_len<A>(a: Set<A>, b: Set<A>)[0m
[38;5;22m    requires[0m
[38;5;22m        a.finite(),[0m
[38;5;22m        b.finite(),[0m
[38;5;22m    ensures[0m
[38;5;22m        (#[trigger] a.difference(b).len() + b.difference(a).len() + a.intersect(b).len() == (a[0m
[38;5;22m            + b).len()) && (a.difference(b).len() == a.len() - a.intersect(b).len()),[0m
[38;5;22m    decreases a.len(),[0m

[31m/home/milnes/projects/verus/source/vstd/set_lib.rs:1247: [0m
#[doc(hidden)]
#[verifier::inline]
[38;5;22mpub open spec fn check_argument_is_set<A>(s: Set<A>) -> Set<A>[0m

[31m/home/milnes/projects/verus/source/vstd/seq_lib.rs:526: [0m
/// Converts a sequence into a set
[38;5;22m    pub open spec fn to_set(self) -> Set<A>[0m

[31m/home/milnes/projects/verus/source/vstd/seq_lib.rs:1035: [0m
/// A sequence of unique items, when converted to a set, produces a set with matching length
[38;5;22m    pub proof fn unique_seq_to_set(self)[0m
[38;5;22m        requires[0m
[38;5;22m            self.no_duplicates(),[0m
[38;5;22m        ensures[0m
[38;5;22m            self.len() == self.to_set().len(),[0m
[38;5;22m        decreases self.len(),[0m

[31m/home/milnes/projects/verus/source/vstd/seq_lib.rs:1059: [0m
/// The cardinality of a set of elements is always less than or
/// equal to that of the full sequence of elements.
[38;5;22m    pub proof fn lemma_cardinality_of_set(self)[0m
[38;5;22m        ensures[0m
[38;5;22m            self.to_set().len() <= self.len(),[0m
[38;5;22m        decreases self.len(),[0m

[31m/home/milnes/projects/verus/source/vstd/seq_lib.rs:1077: [0m
/// A sequence is of length 0 if and only if its conversion to
/// a set results in the empty set.
[38;5;22m    pub proof fn lemma_cardinality_of_empty_set_is_0(self)[0m
[38;5;22m        ensures[0m
[38;5;22m            self.to_set().len() == 0 <==> self.len() == 0,[0m

[31m/home/milnes/projects/verus/source/vstd/seq_lib.rs:1094: [0m
/// A sequence with cardinality equal to its set has no duplicates.
/// Inverse property of that shown in lemma unique_seq_to_set
[38;5;22m    pub proof fn lemma_no_dup_set_cardinality(self)[0m
[38;5;22m        requires[0m
[38;5;22m            self.to_set().len() == self.len(),[0m
[38;5;22m        ensures[0m
[38;5;22m            self.no_duplicates(),[0m
[38;5;22m        decreases self.len(),[0m

[31m/home/milnes/projects/verus/source/vstd/seq_lib.rs:1123: [0m
/// Mapping a function over a sequence and converting to a set is the same
/// as mapping it over the sequence converted to a set.
[38;5;22m    pub broadcast proof fn lemma_to_set_map_commutes<B>(self, f: spec_fn(A) -> B)[0m
[38;5;22m        ensures[0m
[38;5;22m            #[trigger] self.to_set().map(f) =~= self.map_values(f).to_set(),[0m

[31m/home/milnes/projects/verus/source/vstd/seq_lib.rs:1147: [0m
/// Appending an element to a sequence and converting to set, is equal
/// to converting to set and inserting it.
[38;5;22m    pub broadcast proof fn lemma_to_set_insert_commutes(sq: Seq<A>, elt: A)[0m
[38;5;22m        requires[0m
[38;5;22m        ensures[0m
[38;5;22m            #[trigger] (sq + seq![elt]).to_set() =~= sq.to_set().insert(elt),[0m

[31m/home/milnes/projects/verus/source/vstd/seq_lib.rs:1922: [0m
///     assert(s.push(3).to_set() =~= s.to_set().insert(3));
/// }
/// ```
[38;5;22m    pub broadcast proof fn lemma_push_to_set_commute(self, elem: A)[0m
[38;5;22m        ensures[0m
[38;5;22m            #[trigger] self.push(elem).to_set() =~= self.to_set().insert(elem),[0m

[31m/home/milnes/projects/verus/source/vstd/seq_lib.rs:2986: [0m
/// Recursive definition of seq to set conversion
[38;5;22mspec fn seq_to_set_rec<A>(seq: Seq<A>) -> Set<A>[0m
[38;5;22m    decreases seq.len(),[0m

[31m/home/milnes/projects/verus/source/vstd/seq_lib.rs:2997: [0m
[38;5;22mproof fn seq_to_set_rec_is_finite<A>(seq: Seq<A>)[0m
[38;5;22m    ensures[0m
[38;5;22m        seq_to_set_rec(seq).finite(),[0m
[38;5;22m    decreases seq.len(),[0m

[31m/home/milnes/projects/verus/source/vstd/seq_lib.rs:3013: [0m
[38;5;22mproof fn seq_to_set_rec_contains<A>(seq: Seq<A>)[0m
[38;5;22m    ensures[0m
[38;5;22m        forall|a| #[trigger] seq.contains(a) <==> seq_to_set_rec(seq).contains(a),[0m
[38;5;22m    decreases seq.len(),[0m

[31m/home/milnes/projects/verus/source/vstd/seq_lib.rs:3040: [0m
[38;5;22mproof fn seq_to_set_equal_rec<A>(seq: Seq<A>)[0m
[38;5;22m    ensures[0m
[38;5;22m        seq.to_set() == seq_to_set_rec(seq),[0m

[31m/home/milnes/projects/verus/source/vstd/seq_lib.rs:3054: [0m
/// The set obtained from a sequence is finite
[38;5;22mpub broadcast proof fn seq_to_set_is_finite<A>(seq: Seq<A>)[0m
[38;5;22m    ensures[0m
[38;5;22m        #[trigger] seq.to_set().finite(),[0m

[31m/home/milnes/projects/verus/source/vstd/seq_lib.rs:3066: [0m
[38;5;22mpub proof fn seq_to_set_distributes_over_add<T>(s1: Seq<T>, s2: Seq<T>)[0m
[38;5;22m    ensures[0m
[38;5;22m        s1.to_set() + s2.to_set() =~= (s1 + s2).to_set(),[0m

[31m/home/milnes/projects/verus/source/vstd/set.rs:539: [0m
[38;5;22m    pub proof fn lemma_finite_set_induct<A>(s: Set<A>, pred: spec_fn(Set<A>) -> bool)[0m
[38;5;22m        requires[0m
[38;5;22m            s.finite(),[0m
[38;5;22m            pred(Set::empty()),[0m
[38;5;22m            forall|s, a| pred(s) && s.finite() && !s.contains(a) ==> #[trigger] pred(s.insert(a)),[0m
[38;5;22m        ensures[0m
[38;5;22m            pred(s),[0m

[31m/home/milnes/projects/verus/source/vstd/set.rs:552: [0m
[38;5;22m    proof fn lemma_finite_set_induct_aux<A>([0m
[38;5;22m        s: Set<A>,[0m
[38;5;22m        f: spec_fn(A) -> nat,[0m
[38;5;22m        ub: nat,[0m
[38;5;22m        pred: spec_fn(Set<A>) -> bool,[0m
[38;5;22m    )[0m
[38;5;22m        requires[0m
[38;5;22m            surj_on(f, s),[0m
[38;5;22m            s.finite(),[0m
[38;5;22m            forall|a| s.contains(a) ==> f(a) < ub,[0m
[38;5;22m            pred(Set::empty()),[0m
[38;5;22m            forall|s, a| pred(s) && s.finite() && !s.contains(a) ==> #[trigger] pred(s.insert(a)),[0m
[38;5;22m        ensures[0m
[38;5;22m            pred(s),[0m
[38;5;22m        decreases ub,[0m

[31m/home/milnes/projects/verus/source/vstd/set.rs:633: [0m
/// The empty set contains no elements
[38;5;22mpub broadcast proof fn axiom_set_empty<A>(a: A)[0m
[38;5;22m    ensures[0m
[38;5;22m        !(#[trigger] Set::empty().contains(a)),[0m

[31m/home/milnes/projects/verus/source/vstd/set.rs:640: [0m
/// A call to `Set::new` with the predicate `f` contains `a` if and only if `f(a)` is true.
[38;5;22mpub broadcast proof fn axiom_set_new<A>(f: spec_fn(A) -> bool, a: A)[0m
[38;5;22m    ensures[0m
[38;5;22m        #[trigger] Set::new(f).contains(a) == f(a),[0m

[31m/home/milnes/projects/verus/source/vstd/set.rs:647: [0m
/// The result of inserting element `a` into set `s` must contains `a`.
[38;5;22mpub broadcast proof fn axiom_set_insert_same<A>(s: Set<A>, a: A)[0m
[38;5;22m    ensures[0m
[38;5;22m        #[trigger] s.insert(a).contains(a),[0m

[31m/home/milnes/projects/verus/source/vstd/set.rs:655: [0m
/// If `a1` does not equal `a2`, then the result of inserting element `a2` into set `s`
/// must contain `a1` if and only if the set contained `a1` before the insertion of `a2`.
[38;5;22mpub broadcast proof fn axiom_set_insert_different<A>(s: Set<A>, a1: A, a2: A)[0m
[38;5;22m    requires[0m
[38;5;22m        a1 != a2,[0m
[38;5;22m    ensures[0m
[38;5;22m        #[trigger] s.insert(a2).contains(a1) == s.contains(a1),[0m

[31m/home/milnes/projects/verus/source/vstd/set.rs:664: [0m
/// The result of removing element `a` from set `s` must not contain `a`.
[38;5;22mpub broadcast proof fn axiom_set_remove_same<A>(s: Set<A>, a: A)[0m
[38;5;22m    ensures[0m
[38;5;22m        !(#[trigger] s.remove(a).contains(a)),[0m

[31m/home/milnes/projects/verus/source/vstd/set.rs:672: [0m
/// Removing an element `a` from a set `s` and then inserting `a` back into the set`
/// is equivalent to the original set `s`.
[38;5;22mpub broadcast proof fn axiom_set_remove_insert<A>(s: Set<A>, a: A)[0m
[38;5;22m    requires[0m
[38;5;22m        s.contains(a),[0m
[38;5;22m    ensures[0m
[38;5;22m        (#[trigger] s.remove(a)).insert(a) == s,[0m

[31m/home/milnes/projects/verus/source/vstd/set.rs:702: [0m
/// If `a1` does not equal `a2`, then the result of removing element `a2` from set `s`
/// must contain `a1` if and only if the set contained `a1` before the removal of `a2`.
[38;5;22mpub broadcast proof fn axiom_set_remove_different<A>(s: Set<A>, a1: A, a2: A)[0m
[38;5;22m    requires[0m
[38;5;22m        a1 != a2,[0m
[38;5;22m    ensures[0m
[38;5;22m        #[trigger] s.remove(a2).contains(a1) == s.contains(a1),[0m

[31m/home/milnes/projects/verus/source/vstd/set.rs:712: [0m
/// The union of sets `s1` and `s2` contains element `a` if and only if
/// `s1` contains `a` and/or `s2` contains `a`.
[38;5;22mpub broadcast proof fn axiom_set_union<A>(s1: Set<A>, s2: Set<A>, a: A)[0m
[38;5;22m    ensures[0m
[38;5;22m        #[trigger] s1.union(s2).contains(a) == (s1.contains(a) || s2.contains(a)),[0m

[31m/home/milnes/projects/verus/source/vstd/set.rs:720: [0m
/// The intersection of sets `s1` and `s2` contains element `a` if and only if
/// both `s1` and `s2` contain `a`.
[38;5;22mpub broadcast proof fn axiom_set_intersect<A>(s1: Set<A>, s2: Set<A>, a: A)[0m
[38;5;22m    ensures[0m
[38;5;22m        #[trigger] s1.intersect(s2).contains(a) == (s1.contains(a) && s2.contains(a)),[0m

[31m/home/milnes/projects/verus/source/vstd/set.rs:728: [0m
/// The set difference between `s1` and `s2` contains element `a` if and only if
/// `s1` contains `a` and `s2` does not contain `a`.
[38;5;22mpub broadcast proof fn axiom_set_difference<A>(s1: Set<A>, s2: Set<A>, a: A)[0m
[38;5;22m    ensures[0m
[38;5;22m        #[trigger] s1.difference(s2).contains(a) == (s1.contains(a) && !s2.contains(a)),[0m

[31m/home/milnes/projects/verus/source/vstd/set.rs:735: [0m
/// The complement of set `s` contains element `a` if and only if `s` does not contain `a`.
[38;5;22mpub broadcast proof fn axiom_set_complement<A>(s: Set<A>, a: A)[0m
[38;5;22m    ensures[0m
[38;5;22m        #[trigger] s.complement().contains(a) == !s.contains(a),[0m

[31m/home/milnes/projects/verus/source/vstd/set.rs:742: [0m
/// Sets `s1` and `s2` are equal if and only if they contain all of the same elements.
[38;5;22mpub broadcast proof fn axiom_set_ext_equal<A>(s1: Set<A>, s2: Set<A>)[0m
[38;5;22m    ensures[0m
[38;5;22m        #[trigger] (s1 =~= s2) <==> (forall|a: A| s1.contains(a) == s2.contains(a)),[0m

[31m/home/milnes/projects/verus/source/vstd/set.rs:760: [0m
[38;5;22mpub broadcast proof fn axiom_set_ext_equal_deep<A>(s1: Set<A>, s2: Set<A>)[0m
[38;5;22m    ensures[0m
[38;5;22m        #[trigger] (s1 =~~= s2) <==> s1 =~= s2,[0m

[31m/home/milnes/projects/verus/source/vstd/set.rs:780: [0m
/// The empty set is finite.
[38;5;22mpub broadcast proof fn axiom_set_empty_finite<A>()[0m
[38;5;22m    ensures[0m
[38;5;22m        #[trigger] Set::<A>::empty().finite(),[0m

[31m/home/milnes/projects/verus/source/vstd/set.rs:790: [0m
/// The result of inserting an element `a` into a finite set `s` is also finite.
[38;5;22mpub broadcast proof fn axiom_set_insert_finite<A>(s: Set<A>, a: A)[0m
[38;5;22m    requires[0m
[38;5;22m        s.finite(),[0m
[38;5;22m    ensures[0m
[38;5;22m        #[trigger] s.insert(a).finite(),[0m

[31m/home/milnes/projects/verus/source/vstd/set.rs:827: [0m
/// The result of removing an element `a` from a finite set `s` is also finite.
[38;5;22mpub broadcast proof fn axiom_set_remove_finite<A>(s: Set<A>, a: A)[0m
[38;5;22m    requires[0m
[38;5;22m        s.finite(),[0m
[38;5;22m    ensures[0m
[38;5;22m        #[trigger] s.remove(a).finite(),[0m

[31m/home/milnes/projects/verus/source/vstd/set.rs:855: [0m
/// The union of two finite sets is finite.
[38;5;22mpub broadcast proof fn axiom_set_union_finite<A>(s1: Set<A>, s2: Set<A>)[0m
[38;5;22m    requires[0m
[38;5;22m        s1.finite(),[0m
[38;5;22m        s2.finite(),[0m
[38;5;22m    ensures[0m
[38;5;22m        #[trigger] s1.union(s2).finite(),[0m

[31m/home/milnes/projects/verus/source/vstd/set.rs:880: [0m
/// The intersection of two finite sets is finite.
[38;5;22mpub broadcast proof fn axiom_set_intersect_finite<A>(s1: Set<A>, s2: Set<A>)[0m
[38;5;22m    requires[0m
[38;5;22m        s1.finite() || s2.finite(),[0m
[38;5;22m    ensures[0m
[38;5;22m        #[trigger] s1.intersect(s2).finite(),[0m

[31m/home/milnes/projects/verus/source/vstd/set.rs:892: [0m
/// The set difference between two finite sets is finite.
[38;5;22mpub broadcast proof fn axiom_set_difference_finite<A>(s1: Set<A>, s2: Set<A>)[0m
[38;5;22m    requires[0m
[38;5;22m        s1.finite(),[0m
[38;5;22m    ensures[0m
[38;5;22m        #[trigger] s1.difference(s2).finite(),[0m

[31m/home/milnes/projects/verus/source/vstd/set.rs:904: [0m
/// An infinite set `s` contains the element `s.choose()`.
[38;5;22mpub broadcast proof fn axiom_set_choose_infinite<A>(s: Set<A>)[0m
[38;5;22m    requires[0m
[38;5;22m        !s.finite(),[0m
[38;5;22m    ensures[0m
[38;5;22m        #[trigger] s.contains(s.choose()),[0m

[31m/home/milnes/projects/verus/source/vstd/set.rs:919: [0m
/// The empty set has length 0.
[38;5;22mpub broadcast proof fn axiom_set_empty_len<A>()[0m
[38;5;22m    ensures[0m
[38;5;22m        #[trigger] Set::<A>::empty().len() == 0,[0m

[31m/home/milnes/projects/verus/source/vstd/set.rs:928: [0m
/// The result of inserting an element `a` into a finite set `s` has length
/// `s.len() + 1` if `a` is not already in `s` and length `s.len()` otherwise.
[38;5;22mpub broadcast proof fn axiom_set_insert_len<A>(s: Set<A>, a: A)[0m
[38;5;22m    requires[0m
[38;5;22m        s.finite(),[0m
[38;5;22m    ensures[0m
[38;5;22m        #[trigger] s.insert(a).len() == s.len() + (if s.contains(a)[0m

[31m/home/milnes/projects/verus/source/vstd/set.rs:947: [0m
/// The result of removing an element `a` from a finite set `s` has length
/// `s.len() - 1` if `a` is in `s` and length `s.len()` otherwise.
[38;5;22mpub broadcast proof fn axiom_set_remove_len<A>(s: Set<A>, a: A)[0m
[38;5;22m    requires[0m
[38;5;22m        s.finite(),[0m
[38;5;22m    ensures[0m
[38;5;22m        s.len() == #[trigger] s.remove(a).len() + (if s.contains(a)[0m

[31m/home/milnes/projects/verus/source/vstd/set.rs:967: [0m
/// If a finite set `s` contains any element, it has length greater than 0.
[38;5;22mpub broadcast proof fn axiom_set_contains_len<A>(s: Set<A>, a: A)[0m
[38;5;22m    requires[0m
[38;5;22m        s.finite(),[0m
[38;5;22m        #[trigger] s.contains(a),[0m
[38;5;22m    ensures[0m
[38;5;22m        #[trigger] s.len() != 0,[0m

[31m/home/milnes/projects/verus/source/vstd/set.rs:982: [0m
/// A finite set `s` contains the element `s.choose()` if it has length greater than 0.
[38;5;22mpub broadcast proof fn axiom_set_choose_len<A>(s: Set<A>)[0m
[38;5;22m    requires[0m
[38;5;22m        s.finite(),[0m
[38;5;22m        #[trigger] s.len() != 0,[0m
[38;5;22m    ensures[0m
[38;5;22m        #[trigger] s.contains(s.choose()),[0m

[31m/home/milnes/projects/verus/source/vstd/tokens.rs:386: [0m
[38;5;22m    pub closed spec fn set(self) -> Set<Element>[0m

[31m/home/milnes/projects/verus/source/vstd/pcm.rs:108: [0m
[38;5;22mpub open spec fn set_op<P: PCM>(s: Set<P>, t: P) -> Set<P>[0m

[31m/home/milnes/projects/verus/source/vstd/array.rs:39: [0m
[38;5;22m    fn set(&mut self, idx: usize, t: T);[0m

[31m/home/milnes/projects/verus/source/vstd/array.rs:61: [0m
#[verifier::external_body]
[38;5;22m    fn set(&mut self, idx: usize, t: T)[0m
[38;5;22m        requires[0m
[38;5;22m            0 <= idx < N,[0m
[38;5;22m        ensures[0m
[38;5;22m            self@ == old(self)@.update(idx as int, t),[0m

[31m/home/milnes/projects/verus/source/vstd/cell/invcell.rs:116: [0m
[38;5;22m    pub fn set(&self, val: T)[0m
[38;5;22m        requires[0m
[38;5;22m            self.inv(val),[0m

[31m/home/milnes/projects/verus/source/vstd/state_machine_internal.rs:64: [0m
[38;5;22mpub fn assert_add_set(b: bool)[0m

[31m/home/milnes/projects/verus/source/vstd/state_machine_internal.rs:186: [0m
[38;5;22mpub fn assert_general_add_set(b: bool)[0m

[31m/home/milnes/projects/verus/source/vstd/slice.rs:43: [0m
[38;5;22m    fn set(&mut self, idx: usize, t: T);[0m

[31m/home/milnes/projects/verus/source/vstd/slice.rs:48: [0m
#[verifier::external_body]
[38;5;22m    fn set(&mut self, idx: usize, t: T)[0m
[38;5;22m        requires[0m
[38;5;22m            0 <= idx < old(self)@.len(),[0m
[38;5;22m        ensures[0m
[38;5;22m            self@ == old(self)@.update(idx as int, t),[0m

[31m/home/milnes/projects/verus/source/vstd/pervasive.rs:381: [0m
[38;5;22m    fn set(&mut self, i: usize, value: T);[0m

[31m/home/milnes/projects/verus/source/vstd/pervasive.rs:383: [0m
[38;5;22m    fn set_and_swap(&mut self, i: usize, value: &mut T);[0m

[31m/home/milnes/projects/verus/source/vstd/pervasive.rs:390: [0m
/// Replacement for `self[i] = value;` (which Verus does not support for technical reasons)
#[verifier::external_body]
[38;5;22m    fn set(&mut self, i: usize, value: T)[0m
[38;5;22m        requires[0m
[38;5;22m            i < old(self).len(),[0m
[38;5;22m        ensures[0m
[38;5;22m            self@ == old(self)@.update(i as int, value),[0m

[31m/home/milnes/projects/verus/source/vstd/pervasive.rs:401: [0m
/// Replacement for `swap(&mut self[i], &mut value)` (which Verus does not support for technical reasons)
#[verifier::external_body]
[38;5;22m    fn set_and_swap(&mut self, i: usize, value: &mut T)[0m
[38;5;22m        requires[0m
[38;5;22m            i < old(self).len(),[0m
[38;5;22m        ensures[0m
[38;5;22m            self@ == old(self)@.update(i as int, *old(value)),[0m
[38;5;22m            *value == old(self)@.index(i as int),[0m

[31m/home/milnes/projects/verus/source/vstd/storage_protocol.rs:125: [0m
[38;5;22mpub open spec fn set_op<K, V, P: Protocol<K, V>>(s: Set<(P, Map<K, V>)>, t: P) -> Set<[0m
[38;5;22m    (P, Map<K, V>),[0m
[38;5;22m>[0m

