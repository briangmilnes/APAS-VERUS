<style>
body { max-width: 100% !important; width: 100% !important; margin: 0 !important; padding: 1em !important; }
.markdown-body { max-width: 100% !important; width: 100% !important; }
.container, .container-lg, .container-xl, main, article { max-width: 100% !important; width: 100% !important; }
table { width: 100% !important; table-layout: fixed; }
</style>

# Chapter 26 — Divide and Conquer: Review Against Prose

**Reviewer:** Claude-Opus-4.6  
**Date:** 2026-02-13 (updated 2026-02-13)  
**Source:** `prompts/Chap26.txt` vs `src/Chap26/`

---

## Phase 1: Function Inventory & Spec Strengths

Generated by `veracity-review-module-fn-impls -d src/Chap26` and classified per the spec-strengths protocol.

| # | Module | Function | SpecStr | Hole? | Notes |
|---|--------|----------|---------|-------|-------|
| 1 | DivConReduceMtPer | `max_element_parallel` | strong | — | Full max-element contract |
| 2 | DivConReduceMtPer | `sum_parallel` | strong | `external_body` | Result == spec_iterate |
| 3 | DivConReduceMtPer | `product_parallel` | strong | `external_body` | Result == spec_iterate |
| 4 | DivConReduceMtPer | `any_parallel` | strong | — | Result == spec_iterate |
| 5 | DivConReduceMtPer | `all_parallel` | strong | — | Result == spec_iterate |
| 6 | DivConReduceStPer | `max_element` | strong | — | Full max-element contract |
| 7 | DivConReduceStPer | `sum` | strong | `external_body` | Result == spec_iterate |
| 8 | DivConReduceStPer | `product` | strong | `external_body` | Result == spec_iterate |
| 9 | DivConReduceStPer | `any` | strong | — | Result == spec_iterate |
| 10 | DivConReduceStPer | `all` | strong | — | Result == spec_iterate |
| 11 | ETSPStEph | `etsp` | **weak** | `external_body` | Only ensures `tour.len() == points.len()` |
| 12 | ETSPStEph | `distance` | none | — | Outside verus!, no spec |
| 13 | ETSPStEph | `etsp_inner` | none | — | Outside verus!, no spec |
| 14 | ETSPMtEph | `etsp_parallel` | **weak** | `external_body` | Same spec as St: `tour.len() == points.len()` |
| 15 | ETSPMtEph | `etsp_parallel_inner` | none | — | Outside verus!, no spec (f64 + ParaPair!) |
| 16 | MergeSortMtPer | `merge_parallel` | strong | `external_body` | spec_merge_post (sorted + permutation) |
| 17 | MergeSortMtPer | `merge_sort_parallel` | strong | `external_body` | spec_sort_post (sorted + permutation) |
| 18 | MergeSortStPer | `merge` | strong | — | spec_merge_post — fully verified |
| 19 | MergeSortStPer | `merge_sort` | strong | — | spec_sort_post — fully verified |
| 20 | MergeSortStPer | `lemma_push_sorted` | strong | — | Proof fn — fully verified |
| 21 | ScanDCMtPer | `prefix_sums_dc_parallel` | strong | `external_body` | spec_scan_post |
| 22 | ScanDCMtPer | `prefix_sums_dc_inner` | none | — | Outside verus!, no spec |
| 23 | ScanDCStPer | `scan_dc` | strong | — | spec_scan_post — fully verified |
| 24 | ScanDCStPer | `prefix_sums_dc` | strong | `external_body` | Delegates to scan_dc but closure unverified |
| 25 | ScanDCStPer | `lemma_fold_left_monoid` | strong | — | Proof fn — fully verified |

**Summary:** 19 strong, 2 weak, 4 none (25 total). 10 `external_body` holes.

---

## Phase 2: Prose Inventory

Extracted from `prompts/Chap26.txt`.

### Definitions

| # | Item | Description |
|---|------|-------------|
| 1 | Definition 26.1 | Divide-and-Conquer Algorithm — base case + inductive step (divide/recur/combine) |
| 2 | Definition 26.3 | The Comparison-Sorting Problem — sort by total ordering |
| 3 | Definition 26.6 | The Planar Euclidean Traveling Salesperson Problem — minimum tour in 2-d |

### Algorithms

| # | Item | Description | Work | Span |
|---|------|-------------|------|------|
| 1 | Example 26.2 | Maximal Element via D&C | Θ(n) | Θ(lg n) |
| 2 | Algorithm 26.2 | Reduce with D&C (`reduceDC`) | Θ(n) | Θ(lg n) |
| 3 | Algorithm 26.4 | Merge Sort | Θ(n lg n) | Θ(lg² n) |
| 4 | Algorithm 26.5 | Scan with D&C (`scanDC`) | Θ(n lg n) | Θ(lg n) |
| 5 | Algorithm 26.7 | D&C eTSP heuristic | Θ(n²) | Θ(lg² n) |
| 6 | Section 5 | D&C with Reduce pattern | — | — |

### Cost Specs Stated in Prose

| # | Algorithm | Work | Span | Notes |
|---|-----------|------|------|-------|
| 1 | D&C Maximal Element | Θ(n) | Θ(lg n) | Constant-time comparison |
| 2 | D&C Reduce (general) | Θ(n) | Θ(lg n) | Constant-time binary op |
| 3 | Merge (assumed) | Θ(n) | Θ(lg n) | Stated as assumption for merge sort analysis |
| 4 | Merge Sort | Θ(n lg n) | Θ(lg² n) | Uses assumed merge bounds |
| 5 | Scan DC | Θ(n lg n) | Θ(lg n) | Noted: contraction can do better |
| 6 | eTSP heuristic | Θ(n²) | Θ(lg² n) | Only W recurrence solved explicitly |

### Theorems / Properties

| # | Property | Description |
|---|----------|-------------|
| 1 | Merge sort correctness | By induction: base case trivial; merge of sorted halves produces sorted permutation |
| 2 | eTSP heuristic quality | NP-hard; heuristic known to work well in practice; no proven approximation ratio |
| 3 | D&C-to-reduce equivalence | Algorithms with simple split + combine can be expressed as `reduce myCombine emptyVal (map base a)` |

### Exercises / Problems

None explicitly numbered in the Chapter 26 prose.

---

## Phase 3a: Cost Disagreements

Cost annotations were written to source files. Below are the **disagreements** found:

| # | Function | Module | APAS Span | Actual Span | Reason |
|---|----------|--------|-----------|-------------|--------|
| 1 | ~~`max_element_parallel`~~ | ~~DivConReduceMtPer~~ | ~~Θ(lg n)~~ | ~~Θ(n)~~ | ~~Sequential while loop~~ **FIXED**: now parallel reduce |
| 2 | `merge_parallel` | MergeSortMtPer | Θ(lg n) | **Θ(lg² n)** | Binary-search recursive merge: O(lg n) per level × O(lg n) levels |
| 3 | `merge_sort_parallel` | MergeSortMtPer | Θ(lg² n) | **Θ(lg³ n)** | Consequence of merge_parallel having Θ(lg² n) span instead of Θ(lg n) |
| 4 | `prefix_sums_dc_parallel` | ScanDCMtPer | Θ(lg n) | **Uncertain** | Depends on whether `tabulate`/`append` are O(1) span; could be Θ(n) if sequential |
| 5 | `etsp_parallel` | ETSPMtEph | Θ(lg² n) | **Θ(n²)** | Recursive calls are parallel via ParaPair!, but O(n²) swap search is sequential |
| 6 | All St functions | All St modules | Θ(lg n) or Θ(lg² n) | **Span = Work** | Sequential implementations; span equals work by definition |

---

## Phase 3b: Implementation Fidelity

| # | Module | Prose Algorithm | Faithful? | Deviations |
|---|--------|----------------|-----------|------------|
| 1 | DivConReduceStPer | Algorithm 26.2 / Section 5 | Yes | `max_element` uses direct while loop instead of reduce — functionally equivalent, same cost |
| 2 | DivConReduceMtPer | Algorithm 26.2 (parallel) | Yes | All 5 functions delegate to `ArraySeqMtPerS::reduce`. ~~`max_element_parallel` was sequential~~ **FIXED**: now parallel reduce with proof lemmas. |
| 3 | MergeSortStPer | Algorithm 26.4 | Yes | Sequential two-pointer merge + recursive sort. No larger base case (prose mentions 10-20 keys as practical optimization) |
| 4 | MergeSortMtPer | Algorithm 26.4 (parallel) | Yes | Parallel merge uses binary-search split (correct D&C approach). Uses `ParaPair!` macro for fork-join |
| 5 | ScanDCStPer | Algorithm 26.5 | Yes | Sequential implementation of the recursive scan with left/right adjustment. Faithful to pseudocode |
| 6 | ScanDCMtPer | Algorithm 26.5 (parallel) | Yes | Uses `thread::scope` for parallel recursion. Combine uses `tabulate` (parallel map) + `append` |
| 7 | ETSPStEph | Algorithm 26.7 | **Mostly** | Adds n=3 base case (greedy nearest neighbor) not in prose. Uses sort-based median split (prose says "find median along longest dimension"). Sequential only. |
| 8 | ETSPMtEph | Algorithm 26.7 (parallel) | **Partial** | Recursive calls parallelized via `ParaPair!` (help-first scheduler). Swap search (`minVal`) is sequential O(n²) — APAS achieves Θ(lg n) span with parallel reduce over edge pairs. |

---

## Phase 3c: Spec Fidelity

| # | Function | Prose Claims | Spec Captures? | Gaps |
|---|----------|-------------|---------------|------|
| 1 | `max_element` / `_parallel` | Returns maximal element | **Yes** — `forall` (all ≤ result) + `exists` (result in input) | — |
| 2 | `sum` / `_parallel` | Reduces with (+) | **Yes** — `result == spec_iterate(input, +, 0)` | — |
| 3 | `product` / `_parallel` | Reduces with (×) | **Yes** — `result == spec_iterate(input, ×, 1)` | — |
| 4 | `any` / `_parallel` | Reduces with (∨) | **Yes** — `result == spec_iterate(input, ∨, false)` | — |
| 5 | `all` / `_parallel` | Reduces with (∧) | **Yes** — `result == spec_iterate(input, ∧, true)` | — |
| 6 | `merge` / `_parallel` | Sorted merge of two sorted inputs | **Yes** — `spec_merge_post`: sorted output, correct length, multiset permutation | — |
| 7 | `merge_sort` / `_parallel` | Sort = sorted permutation of input | **Yes** — `spec_sort_post`: sorted output, correct length, multiset permutation | — |
| 8 | `scan_dc` | Exclusive prefix scan | **Yes** — `spec_scan_post`: prefixes[i] = fold(a[0..i], f, id), total = fold(a, f, id) | — |
| 9 | `prefix_sums_dc` / `_parallel` | Prefix sums = scan with (+, 0) | **Yes** — same as scan_dc with specific operation | — |
| 10 | `etsp` / `etsp_parallel` | Tour visits all points, forms cycle | **No** — only ensures `tour.len() == points.len()` | Missing: edges form valid cycle, all points visited exactly once, edges connect actual input points |

**Summary:** 9/10 function families have strong spec fidelity. `etsp`/`etsp_parallel` have a **weak** spec that only captures the length property, not structural validity or correctness. This is a permanent limitation: f64 arithmetic is outside Verus's verification domain (see Verus float status note below).

---

## Phase 4: Parallelism Review

### 4a: Mt Function Classification

| # | Function | Module | Classification | Mechanism |
|---|----------|--------|---------------|-----------|
| 1 | `max_element_parallel` | DivConReduceMtPer | **Delegating** (to parallel `reduce`) | `ArraySeqMtPerS::reduce` — FIXED from sequential |
| 2 | `sum_parallel` | DivConReduceMtPer | **Delegating** (to parallel `reduce`) | `ArraySeqMtPerS::reduce` |
| 3 | `product_parallel` | DivConReduceMtPer | **Delegating** (to parallel `reduce`) | `ArraySeqMtPerS::reduce` |
| 4 | `any_parallel` | DivConReduceMtPer | **Delegating** (to parallel `reduce`) | `ArraySeqMtPerS::reduce` |
| 5 | `all_parallel` | DivConReduceMtPer | **Delegating** (to parallel `reduce`) | `ArraySeqMtPerS::reduce` |
| 6 | `merge_parallel` | MergeSortMtPer | **Parallel** | `thread::scope` + `s.spawn`, recursive |
| 7 | `merge_sort_parallel` | MergeSortMtPer | **Parallel** | `ParaPair!` macro, fork-join |
| 8 | `prefix_sums_dc_parallel` | ScanDCMtPer | **Delegating** (to parallel inner) | Calls `prefix_sums_dc_inner` |
| 9 | `prefix_sums_dc_inner` | ScanDCMtPer | **Parallel** | `thread::scope` + `s.spawn`, recursive |
| 10 | `etsp_parallel` | ETSPMtEph | **Partial** | `ParaPair!` for recursive calls; swap search sequential |
| 11 | `etsp_parallel_inner` | ETSPMtEph | **Partial** | Same — recursive fork-join parallel, O(n²) combine sequential |

### 4b: Span Audit

| # | Function | APAS Span | Actual Span | Match? | Notes |
|---|----------|-----------|-------------|--------|-------|
| 1 | `max_element_parallel` | Θ(lg n) | Θ(lg n) | Yes | Via parallel reduce — FIXED |
| 2 | `sum_parallel` | Θ(lg n) | Θ(lg n) | Yes | Via parallel reduce |
| 3 | `product_parallel` | Θ(lg n) | Θ(lg n) | Yes | Via parallel reduce |
| 4 | `any_parallel` | Θ(lg n) | Θ(lg n) | Yes | Via parallel reduce |
| 5 | `all_parallel` | Θ(lg n) | Θ(lg n) | Yes | Via parallel reduce |
| 6 | `merge_parallel` | Θ(lg n) | Θ(lg² n) | **NO** | Binary-search parallel merge has extra log factor |
| 7 | `merge_sort_parallel` | Θ(lg² n) | Θ(lg³ n) | **NO** | Inherits merge_parallel's extra log factor |
| 8 | `prefix_sums_dc_parallel` | Θ(lg n) | Θ(lg n) or Θ(n) | **Uncertain** | Depends on tabulate/append span |
| 9 | `etsp_parallel` | Θ(lg² n) | Θ(n²) | **NO** | Recursive calls parallel, but O(n²) swap search is sequential |

### 4c: Parallelism Gap Table

| # | Function | APAS Span | Actual | Parallel? | Notes |
|---|----------|-----------|--------|-----------|-------|
| 1 | `max_element_parallel` | Θ(lg n) | Θ(lg n) | Yes | FIXED — now delegates to parallel reduce |
| 2 | `sum_parallel` | Θ(lg n) | Θ(lg n) | Yes | — |
| 3 | `product_parallel` | Θ(lg n) | Θ(lg n) | Yes | — |
| 4 | `any_parallel` | Θ(lg n) | Θ(lg n) | Yes | — |
| 5 | `all_parallel` | Θ(lg n) | Θ(lg n) | Yes | — |
| 6 | `merge_parallel` | Θ(lg n) | Θ(lg² n) | Yes | Correct parallel structure; extra log from binary search depth |
| 7 | `merge_sort_parallel` | Θ(lg² n) | Θ(lg³ n) | Yes | Cascading from merge_parallel |
| 8 | `prefix_sums_dc_parallel` | Θ(lg n) | Uncertain | Yes | Thread parallelism correct; combine step cost unclear |
| 9 | `etsp_parallel` | Θ(lg² n) | Θ(n²) | Partial | Recursive fork-join parallel; O(n²) swap search sequential |

---

## Phase 5: Runtime Test Review

### 5a: Coverage Check

| # | Module | Test File | Exec Fns | Tests | Coverage |
|---|--------|-----------|----------|-------|----------|
| 1 | DivConReduceStPer | TestDivConReduceStPer.rs | 5 | 8 | All 5 functions tested |
| 2 | DivConReduceMtPer | TestDivConReduceMtPer.rs | 5 | 8 | All 5 functions tested |
| 3 | MergeSortStPer | TestMergeSortStPer.rs | 2 | 7 | Both merge and merge_sort tested |
| 4 | MergeSortMtPer | TestMergeSortMtPer.rs | 2 | 5 | Both functions tested |
| 5 | ScanDCStPer | TestScanDCStPer.rs | 2 | 6 | prefix_sums_dc tested (scan_dc tested indirectly) |
| 6 | ScanDCMtPer | TestScanDCMtPer.rs | 1 | 5 | prefix_sums_dc_parallel tested |
| 7 | ETSPStEph | TestETSPStEph.rs | 1 | 7 | etsp tested extensively |
| 8 | ETSPMtEph | TestETSPMtEph.rs | 1 | 7 | etsp_parallel tested (mirrors St tests) |

### 5b: Test Quality

| # | Module | Happy Path | Edge Cases | Spec Properties | Equality | Quality |
|---|--------|-----------|-----------|----------------|----------|---------|
| 1 | DivConReduceStPer | Yes | Empty only | Sum/product values verified | N/A | Good |
| 2 | DivConReduceMtPer | Yes | Empty only | Same as St | N/A | Good |
| 3 | MergeSortStPer | Yes | Empty, single, dupl. | Sorted + values checked | N/A | **Excellent** |
| 4 | MergeSortMtPer | Yes | Empty, single | Sorted + values checked | N/A | Good |
| 5 | ScanDCStPer | Yes | Empty, single | Prefix values verified against APAS example | N/A | **Excellent** |
| 6 | ScanDCMtPer | Yes | Empty, single | Same as St | N/A | Good |
| 7 | ETSPStEph | Yes | 2-pt, 3-pt, collinear | Tour length quality check | N/A | **Excellent** |
| 8 | ETSPMtEph | Yes | 2-pt, 3-pt, collinear | Tour length quality check | N/A | **Excellent** |

### 5c: Missing Tests

| # | Priority | Function | Missing Test | Reason |
|---|----------|----------|-------------|--------|
| 1 | Medium | `max_element` / `_parallel` | Singleton input | Edge case |
| 2 | Medium | `sum` / `_parallel` | Empty input (should return 0) | Edge case |
| 3 | Medium | `product` / `_parallel` | Empty input (should return 1) | Edge case |
| 4 | Low | `merge_sort_parallel` | Duplicates test | St has it, Mt doesn't |
| 5 | Low | `scan_dc` | Direct test with custom function (not just prefix sums) | scan_dc is generic |
| 6 | Low | `prefix_sums_dc_parallel` | `tabulate`-generated input test | St has it, Mt doesn't |

---

## Phase 6: Gap Analysis

### Prose Items with No Implementation

| # | Prose Item | Status | Notes |
|---|-----------|--------|-------|
| 1 | Quick Sort (Remark after Algorithm 26.4) | Not implemented | Mentioned as a remark, not a required algorithm. Chapter-appropriate omission. |
| 2 | "Strengthening" concept (end of Section 4) | Not implemented | Conceptual discussion, not an algorithm. |
| 3 | ~~eTSP parallel variant~~ | ~~Not implemented~~ | **IMPLEMENTED (2026-02-13):** `ETSPMtEph` module added with `ParaPair!` for recursive fork-join. Swap search still sequential O(n²). |

### Code with No Prose Counterpart

| # | Item | Type | Module | Purpose |
|---|------|------|--------|---------|
| 1 | `spec_sum_fn`, `spec_product_fn`, `spec_or_fn`, `spec_and_fn`, `spec_max_fn` | spec fn | DivConReduceStPer | Verus spec scaffolding for reduce ops |
| 2 | `spec_sorted`, `spec_is_permutation`, `spec_merge_post`, `spec_sort_post` | spec fn | MergeSortStPer | Correctness predicates |
| 3 | `spec_scan_at`, `spec_scan_post` | spec fn | ScanDCStPer | Scan correctness predicates |
| 4 | `spec_is_valid_tour` | spec fn | ETSPStEph | Trivial tour validity (n_edges == n_points) |
| 5 | `lemma_push_sorted` | proof fn | MergeSortStPer | Helper for merge proof |
| 6 | `lemma_fold_left_monoid` | proof fn | ScanDCStPer | Helper for scan proof |
| 7 | `etsp_inner` | fn | ETSPStEph | Recursive helper, outside verus! |
| 8 | `prefix_sums_dc_inner` | fn | ScanDCMtPer | Parallel recursive helper, outside verus! |
| 9 | `Point`, `Edge` types | struct | ETSPStEph | Data definitions implied by prose |
| 10 | `distance` | fn | ETSPStEph | Euclidean distance, implied by ‖u − v‖ in prose |
| 11 | `etsp_parallel_inner` | fn | ETSPMtEph | Parallel recursive helper, outside verus! (f64 + ParaPair!) |

---

## Proof Holes Summary

10 `external_body` holes across 7 modules:

| # | Module | Function | Reason for Hole | Category |
|---|--------|----------|----------------|----------|
| 1 | DivConReduceStPer | `sum` | usize overflow: spec wraps via `as N`, exec checks overflow | usize overflow |
| 2 | DivConReduceStPer | `product` | Same usize overflow issue | usize overflow |
| 3 | DivConReduceMtPer | `sum_parallel` | Same usize overflow + parallel delegation | usize overflow |
| 4 | DivConReduceMtPer | `product_parallel` | Same usize overflow + parallel delegation | usize overflow |
| 5 | ScanDCStPer | `prefix_sums_dc` | Closure `\|x, y\| x + y` cannot satisfy biconditional ensures for usize | usize overflow |
| 6 | ETSPStEph | `etsp` | Delegates to `etsp_inner` (outside verus!, uses f64) | **f64 (permanent)** |
| 7 | ETSPMtEph | `etsp_parallel` | Delegates to `etsp_parallel_inner` (f64 + ParaPair!) | **f64 + threading (permanent)** |
| 8 | MergeSortMtPer | `merge_parallel` | Parallel merge with thread::scope — Verus cannot verify threading | **threading (permanent)** |
| 9 | MergeSortMtPer | `merge_sort_parallel` | Parallel sort with ParaPair! — Verus cannot verify threading | **threading (permanent)** |
| 10 | ScanDCMtPer | `prefix_sums_dc_parallel` | Delegates to parallel inner function — Verus cannot verify threading | **threading (permanent)** |

Note: `etsp_parallel` (row 7) has two independent reasons for `external_body`: f64 arithmetic and threading via `ParaPair!`.

**Categorized:**
- **usize overflow** (5 holes): sum, product (St + Mt), prefix_sums_dc — fixable with `wrapping_add`/`wrapping_mul` or future `u64` migration (see "Exile on N Street" rule)
- **Threading** (3 holes): merge_parallel, merge_sort_parallel, prefix_sums_dc_parallel — permanent, Verus cannot verify `thread::scope`/`ParaPair!`
- **f64 arithmetic** (1 hole): etsp — permanent, Verus provides no float axioms (vstd `float.rs` has only bit-level classification; all arithmetic ensures are uninterpreted)
- **f64 + threading** (1 hole): etsp_parallel — dual reason, both permanent

---

## Key Findings

### Critical Issues

1. **`max_element_parallel` was not parallel.** ~~It used a sequential while loop in the Mt module.~~ **FIXED (2026-02-13):** Now delegates to `ArraySeqMtPerS::reduce` with `spec_max_fn` and two proof lemmas (`lemma_max_fold_left_bound`, `lemma_max_fold_left_achievable`) to bridge from `spec_iterate` to the `forall`/`exists` postcondition. Fully verified.

2. **`merge_parallel` has Θ(lg² n) span, not APAS's assumed Θ(lg n).** The binary-search-split parallel merge adds a logarithmic factor at each recursion level. This cascades to `merge_sort_parallel` achieving Θ(lg³ n) instead of Θ(lg² n). An O(lg n)-span merge would require a rank-based parallel merge algorithm.

### Moderate Issues

3. **`etsp`/`etsp_parallel` spec is weak** — only ensures length preservation. No structural validity (cycle, edge connectivity) is expressed. Permanent: f64 arithmetic is outside Verus's verification domain. Verus's `vstd::float` provides only bit-level classification (NaN, infinite, finite, sign); all arithmetic ensures are uninterpreted functions requiring user-supplied axioms.

4. **`etsp_parallel` swap search is sequential O(n²).** ~~No `ETSPMtEph` module exists.~~ **IMPLEMENTED (2026-02-13):** `ETSPMtEph` added with `ParaPair!` for recursive fork-join. However, the `minVal` swap search (nested loop over all edge pairs) remains sequential, giving actual Span Θ(n²) vs APAS's Θ(lg² n). Achieving Θ(lg² n) would require parallelizing the swap search as a 2D parallel reduce.

5. **`prefix_sums_dc_parallel` span is uncertain** — depends on whether `ArraySeqMtPerS::tabulate` and `append` achieve O(1) span.

### Strengths

6. **MergeSortStPer and ScanDCStPer are fully verified** — no proof holes, strong specs, complete proofs including helper lemmas.

7. **19 of 20 assessed functions have strong specs** — the codebase has excellent specification coverage.

8. **Test coverage is comprehensive** — all 8 modules have corresponding test files with meaningful assertions.

9. **Proof structure is clean** — helper lemmas (`lemma_push_sorted`, `lemma_fold_left_monoid`) are isolated, well-specified, and fully verified.
