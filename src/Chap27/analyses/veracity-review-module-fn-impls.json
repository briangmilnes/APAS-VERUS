[
  {
    "id": 1,
    "function": "lemma_fold_left_monoid",
    "file": "Chap27/ReduceContractMtEph.rs",
    "lines": "49-52",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_fold_left_monoid<T>(s: Seq<T>, x: T, f: spec_fn(T, T) -> T, id: T)\n        requires spec_monoid(f, id),\n        ensures s.fold_left(x, f) == f(x, s.fold_left(id, f)),\n        decreases s.len(),"
  },
  {
    "id": 2,
    "function": "lemma_fold_left_pair",
    "file": "Chap27/ReduceContractMtEph.rs",
    "lines": "62-64",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_fold_left_pair<T>(a: T, b: T, f: spec_fn(T, T) -> T, id: T)\n        requires spec_monoid(f, id),\n        ensures seq![a, b].fold_left(id, f) == f(a, b),"
  },
  {
    "id": 3,
    "function": "lemma_fold_left_singleton",
    "file": "Chap27/ReduceContractMtEph.rs",
    "lines": "73-75",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_fold_left_singleton<T>(a: T, f: spec_fn(T, T) -> T, id: T)\n        requires spec_monoid(f, id),\n        ensures seq![a].fold_left(id, f) == a,"
  },
  {
    "id": 4,
    "function": "lemma_contraction_even",
    "file": "Chap27/ReduceContractMtEph.rs",
    "lines": "83-93",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_contraction_even<T>(s: Seq<T>, f: spec_fn(T, T) -> T, id: T)\n        requires\n            spec_monoid(f, id),\n            s.len() >= 2,\n            s.len() % 2 == 0,\n        ensures\n            s.fold_left(id, f) == Seq::new(\n                (s.len() / 2) as nat,\n                |i: int| f(s[2 * i], s[2 * i + 1]),\n            ).fold_left(id, f),\n        decreases s.len(),"
  },
  {
    "id": 5,
    "function": "reduce_contract_parallel",
    "file": "Chap27/ReduceContractMtEph.rs",
    "lines": "152-165",
    "spec_strength": "unknown",
    "snippet": "        fn reduce_contract_parallel<F: Fn(&T, &T) -> T + Send + Sync + 'static>(\n            a: &ArraySeqMtEphS<T>,\n            f: Arc<F>,\n            Ghost(spec_f): Ghost<spec_fn(T, T) -> T>,\n            id: T,\n        ) -> (reduced: T)\n            requires\n                a.spec_len() <= usize::MAX,\n                obeys_feq_clone::<T>(),\n                spec_monoid(spec_f, id),\n                forall|x: &T, y: &T| #[trigger] f.requires((x, y)),\n                forall|x: T, y: T, ret: T| f.ensures((&x, &y), ret) ==> ret == spec_f(x, y),\n            ensures\n                reduced == Seq::new(a.spec_len(), |i: int| a.spec_index(i)).fold_left(id, spec_f);"
  },
  {
    "id": 6,
    "function": "contract_parallel",
    "file": "Chap27/ReduceContractMtEph.rs",
    "lines": "175-190",
    "spec_strength": "unknown",
    "snippet": "    pub fn contract_parallel<T: StTInMtT + Clone + 'static, F: Fn(&T, &T) -> T + Send + Sync + 'static>(\n        a: &ArraySeqMtEphS<T>,\n        f: &Arc<F>,\n        Ghost(spec_f): Ghost<spec_fn(T, T) -> T>,\n        half: usize,\n    ) -> (b: ArraySeqMtEphS<T>)\n        requires\n            half == a.spec_len() / 2,\n            a.spec_len() >= 2,\n            half <= usize::MAX,\n            obeys_feq_clone::<T>(),\n            forall|x: &T, y: &T| #[trigger] f.requires((x, y)),\n            forall|x: T, y: T, ret: T| f.ensures((&x, &y), ret) ==> ret == spec_f(x, y),\n        ensures\n            b.spec_len() == half as nat,\n            forall|j: int| #![trigger b.spec_index(j)] 0 <= j < half as int ==> {"
  },
  {
    "id": 7,
    "function": "lemma_fold_left_monoid",
    "file": "Chap27/ReduceContractStEph.rs",
    "lines": "44-47",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_fold_left_monoid<T>(s: Seq<T>, x: T, f: spec_fn(T, T) -> T, id: T)\n        requires spec_monoid(f, id),\n        ensures s.fold_left(x, f) == f(x, s.fold_left(id, f)),\n        decreases s.len(),"
  },
  {
    "id": 8,
    "function": "lemma_fold_left_pair",
    "file": "Chap27/ReduceContractStEph.rs",
    "lines": "60-62",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_fold_left_pair<T>(a: T, b: T, f: spec_fn(T, T) -> T, id: T)\n        requires spec_monoid(f, id),\n        ensures seq![a, b].fold_left(id, f) == f(a, b),"
  },
  {
    "id": 9,
    "function": "lemma_fold_left_singleton",
    "file": "Chap27/ReduceContractStEph.rs",
    "lines": "76-78",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_fold_left_singleton<T>(a: T, f: spec_fn(T, T) -> T, id: T)\n        requires spec_monoid(f, id),\n        ensures seq![a].fold_left(id, f) == a,"
  },
  {
    "id": 10,
    "function": "lemma_contraction_even",
    "file": "Chap27/ReduceContractStEph.rs",
    "lines": "88-98",
    "spec_strength": "unknown",
    "snippet": "    pub proof fn lemma_contraction_even<T>(s: Seq<T>, f: spec_fn(T, T) -> T, id: T)\n        requires\n            spec_monoid(f, id),\n            s.len() >= 2,\n            s.len() % 2 == 0,\n        ensures\n            s.fold_left(id, f) == Seq::new(\n                (s.len() / 2) as nat,\n                |i: int| f(s[2 * i], s[2 * i + 1]),\n            ).fold_left(id, f),\n        decreases s.len(),"
  },
  {
    "id": 11,
    "function": "reduce_contract",
    "file": "Chap27/ReduceContractStEph.rs",
    "lines": "168-180",
    "spec_strength": "unknown",
    "snippet": "        fn reduce_contract<F: Fn(&T, &T) -> T>(\n            a: &ArraySeqStEphS<T>,\n            f: &F,\n            Ghost(spec_f): Ghost<spec_fn(T, T) -> T>,\n            id: T,\n        ) -> (reduced: T)\n            requires\n                a.spec_len() <= usize::MAX,\n                spec_monoid(spec_f, id),\n                forall|x: &T, y: &T| #[trigger] f.requires((x, y)),\n                forall|x: T, y: T, ret: T| f.ensures((&x, &y), ret) ==> ret == spec_f(x, y),\n            ensures\n                reduced == Seq::new(a.spec_len(), |i: int| a.spec_index(i)).fold_left(id, spec_f);"
  },
  {
    "id": 12,
    "function": "lemma_fold_left_monoid",
    "file": "Chap27/ScanContractMtEph.rs",
    "lines": "48-51",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_fold_left_monoid<T>(s: Seq<T>, x: T, f: spec_fn(T, T) -> T, id: T)\n        requires spec_monoid(f, id),\n        ensures s.fold_left(x, f) == f(x, s.fold_left(id, f)),\n        decreases s.len(),"
  },
  {
    "id": 13,
    "function": "lemma_fold_left_pair",
    "file": "Chap27/ScanContractMtEph.rs",
    "lines": "62-64",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_fold_left_pair<T>(a: T, b: T, f: spec_fn(T, T) -> T, id: T)\n        requires spec_monoid(f, id),\n        ensures seq![a, b].fold_left(id, f) == f(a, b),"
  },
  {
    "id": 14,
    "function": "lemma_fold_left_singleton",
    "file": "Chap27/ScanContractMtEph.rs",
    "lines": "73-75",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_fold_left_singleton<T>(a: T, f: spec_fn(T, T) -> T, id: T)\n        requires spec_monoid(f, id),\n        ensures seq![a].fold_left(id, f) == a,"
  },
  {
    "id": 15,
    "function": "lemma_contraction_even",
    "file": "Chap27/ScanContractMtEph.rs",
    "lines": "83-93",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_contraction_even<T>(s: Seq<T>, f: spec_fn(T, T) -> T, id: T)\n        requires\n            spec_monoid(f, id),\n            s.len() >= 2,\n            s.len() % 2 == 0,\n        ensures\n            s.fold_left(id, f) == Seq::new(\n                (s.len() / 2) as nat,\n                |i: int| f(s[2 * i], s[2 * i + 1]),\n            ).fold_left(id, f),\n        decreases s.len(),"
  },
  {
    "id": 16,
    "function": "lemma_prefix_contraction",
    "file": "Chap27/ScanContractMtEph.rs",
    "lines": "149-157",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_prefix_contraction<T>(s: Seq<T>, b: Seq<T>, f: spec_fn(T, T) -> T, id: T, k: int)\n        requires\n            spec_monoid(f, id),\n            k >= 1,\n            2 * k <= s.len(),\n            b.len() >= k,\n            forall|i: int| #![trigger b[i]] 0 <= i < b.len() ==> b[i] == f(s[2 * i], s[2 * i + 1]),\n        ensures\n            s.take(2 * k).fold_left(id, f) == b.take(k).fold_left(id, f),"
  },
  {
    "id": 17,
    "function": "lemma_expand_even",
    "file": "Chap27/ScanContractMtEph.rs",
    "lines": "169-177",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_expand_even<T>(s: Seq<T>, b_seq: Seq<T>, f: spec_fn(T, T) -> T, id: T, j: int)\n        requires\n            spec_monoid(f, id),\n            j >= 0,\n            2 * j <= s.len(),\n            b_seq.len() >= j,\n            forall|i: int| #![trigger b_seq[i]] 0 <= i < b_seq.len() ==> b_seq[i] == f(s[2 * i], s[2 * i + 1]),\n        ensures\n            b_seq.take(j).fold_left(id, f) == s.take(2 * j).fold_left(id, f),"
  },
  {
    "id": 18,
    "function": "lemma_expand_odd",
    "file": "Chap27/ScanContractMtEph.rs",
    "lines": "189-195",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_expand_odd<T>(s: Seq<T>, f: spec_fn(T, T) -> T, id: T, j: int)\n        requires\n            spec_monoid(f, id),\n            j >= 0,\n            2 * j + 1 <= s.len(),\n        ensures\n            f(s.take(2 * j).fold_left(id, f), s[2 * j]) == s.take(2 * j + 1).fold_left(id, f),"
  },
  {
    "id": 19,
    "function": "lemma_expand_odd_tail",
    "file": "Chap27/ScanContractMtEph.rs",
    "lines": "205-216",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_expand_odd_tail<T>(\n        s: Seq<T>, b_seq: Seq<T>, f: spec_fn(T, T) -> T, id: T, half: int,\n    )\n        requires\n            spec_monoid(f, id),\n            half >= 1,\n            s.len() == 2 * half + 1,\n            b_seq.len() == half,\n            forall|i: int| #![trigger b_seq[i]] 0 <= i < b_seq.len() ==> b_seq[i] == f(s[2 * i], s[2 * i + 1]),\n        ensures\n            f(b_seq.take(half - 1).fold_left(id, f), b_seq[half - 1])\n                == s.take(2 * half).fold_left(id, f),"
  },
  {
    "id": 20,
    "function": "scan_contract_parallel",
    "file": "Chap27/ScanContractMtEph.rs",
    "lines": "234-250",
    "spec_strength": "unknown",
    "snippet": "        fn scan_contract_parallel<F: Fn(&T, &T) -> T + Send + Sync + 'static>(\n            a: &ArraySeqMtEphS<T>,\n            f: Arc<F>,\n            Ghost(spec_f): Ghost<spec_fn(T, T) -> T>,\n            id: T,\n        ) -> (scanned: ArraySeqMtEphS<T>)\n            requires\n                a.spec_len() <= usize::MAX,\n                obeys_feq_clone::<T>(),\n                spec_monoid(spec_f, id),\n                forall|x: &T, y: &T| #[trigger] f.requires((x, y)),\n                forall|x: T, y: T, ret: T| f.ensures((&x, &y), ret) ==> ret == spec_f(x, y),\n            ensures\n                scanned.spec_len() == a.spec_len(),\n                forall|i: int| #![trigger scanned.spec_index(i)]\n                    0 <= i < a.spec_len() ==>\n                        scanned.spec_index(i) == Seq::new(a.spec_len(), |j: int| a.spec_index(j)).take(i).fold_left(id, spec_f);"
  },
  {
    "id": 21,
    "function": "expand_scan_parallel",
    "file": "Chap27/ScanContractMtEph.rs",
    "lines": "253-273",
    "spec_strength": "unknown",
    "snippet": "        fn expand_scan_parallel<F: Fn(&T, &T) -> T + Send + Sync + 'static>(\n            a: &ArraySeqMtEphS<T>,\n            b: &ArraySeqMtEphS<T>,\n            c: &ArraySeqMtEphS<T>,\n            f: &Arc<F>,\n            Ghost(spec_f): Ghost<spec_fn(T, T) -> T>,\n            id: &T,\n            n: usize,\n            half: usize,\n        ) -> (result: Vec<T>)\n            requires\n                n == a.spec_len(),\n                n >= 2,\n                half == n / 2,\n                half <= n,\n                b.spec_len() == half as nat,\n                c.spec_len() == half as nat,\n                spec_monoid(spec_f, *id),\n                forall|x: &T, y: &T| #[trigger] f.requires((x, y)),\n                forall|x: T, y: T, ret: T| f.ensures((&x, &y), ret) ==> ret == spec_f(x, y),\n                forall|k: int| #![trigger b.spec_index(k)] 0 <= k < half as int ==> {"
  },
  {
    "id": 22,
    "function": "lemma_fold_left_monoid",
    "file": "Chap27/ScanContractStEph.rs",
    "lines": "42-45",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_fold_left_monoid<T>(s: Seq<T>, x: T, f: spec_fn(T, T) -> T, id: T)\n        requires spec_monoid(f, id),\n        ensures s.fold_left(x, f) == f(x, s.fold_left(id, f)),\n        decreases s.len(),"
  },
  {
    "id": 23,
    "function": "lemma_fold_left_pair",
    "file": "Chap27/ScanContractStEph.rs",
    "lines": "56-58",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_fold_left_pair<T>(a: T, b: T, f: spec_fn(T, T) -> T, id: T)\n        requires spec_monoid(f, id),\n        ensures seq![a, b].fold_left(id, f) == f(a, b),"
  },
  {
    "id": 24,
    "function": "lemma_fold_left_singleton",
    "file": "Chap27/ScanContractStEph.rs",
    "lines": "67-69",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_fold_left_singleton<T>(a: T, f: spec_fn(T, T) -> T, id: T)\n        requires spec_monoid(f, id),\n        ensures seq![a].fold_left(id, f) == a,"
  },
  {
    "id": 25,
    "function": "lemma_contraction_even",
    "file": "Chap27/ScanContractStEph.rs",
    "lines": "77-87",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_contraction_even<T>(s: Seq<T>, f: spec_fn(T, T) -> T, id: T)\n        requires\n            spec_monoid(f, id),\n            s.len() >= 2,\n            s.len() % 2 == 0,\n        ensures\n            s.fold_left(id, f) == Seq::new(\n                (s.len() / 2) as nat,\n                |i: int| f(s[2 * i], s[2 * i + 1]),\n            ).fold_left(id, f),\n        decreases s.len(),"
  },
  {
    "id": 26,
    "function": "lemma_prefix_contraction",
    "file": "Chap27/ScanContractStEph.rs",
    "lines": "143-151",
    "spec_strength": "unknown",
    "snippet": "    pub proof fn lemma_prefix_contraction<T>(s: Seq<T>, b: Seq<T>, f: spec_fn(T, T) -> T, id: T, k: int)\n        requires\n            spec_monoid(f, id),\n            k >= 1,\n            2 * k <= s.len(),\n            b.len() >= k,\n            forall|i: int| #![trigger b[i]] 0 <= i < b.len() ==> b[i] == f(s[2 * i], s[2 * i + 1]),\n        ensures\n            s.take(2 * k).fold_left(id, f) == b.take(k).fold_left(id, f),"
  },
  {
    "id": 27,
    "function": "lemma_expand_even",
    "file": "Chap27/ScanContractStEph.rs",
    "lines": "163-171",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_expand_even<T>(s: Seq<T>, b_seq: Seq<T>, f: spec_fn(T, T) -> T, id: T, j: int)\n        requires\n            spec_monoid(f, id),\n            j >= 0,\n            2 * j <= s.len(),\n            b_seq.len() >= j,\n            forall|i: int| #![trigger b_seq[i]] 0 <= i < b_seq.len() ==> b_seq[i] == f(s[2 * i], s[2 * i + 1]),\n        ensures\n            b_seq.take(j).fold_left(id, f) == s.take(2 * j).fold_left(id, f),"
  },
  {
    "id": 28,
    "function": "lemma_expand_odd",
    "file": "Chap27/ScanContractStEph.rs",
    "lines": "183-189",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_expand_odd<T>(s: Seq<T>, f: spec_fn(T, T) -> T, id: T, j: int)\n        requires\n            spec_monoid(f, id),\n            j >= 0,\n            2 * j + 1 <= s.len(),\n        ensures\n            f(s.take(2 * j).fold_left(id, f), s[2 * j]) == s.take(2 * j + 1).fold_left(id, f),"
  },
  {
    "id": 29,
    "function": "lemma_expand_odd_tail",
    "file": "Chap27/ScanContractStEph.rs",
    "lines": "199-210",
    "spec_strength": "unknown",
    "snippet": "    proof fn lemma_expand_odd_tail<T>(\n        s: Seq<T>, b_seq: Seq<T>, f: spec_fn(T, T) -> T, id: T, half: int,\n    )\n        requires\n            spec_monoid(f, id),\n            half >= 1,\n            s.len() == 2 * half + 1,\n            b_seq.len() == half,\n            forall|i: int| #![trigger b_seq[i]] 0 <= i < b_seq.len() ==> b_seq[i] == f(s[2 * i], s[2 * i + 1]),\n        ensures\n            f(b_seq.take(half - 1).fold_left(id, f), b_seq[half - 1])\n                == s.take(2 * half).fold_left(id, f),"
  },
  {
    "id": 30,
    "function": "scan_contract",
    "file": "Chap27/ScanContractStEph.rs",
    "lines": "228-243",
    "spec_strength": "unknown",
    "snippet": "        fn scan_contract<F: Fn(&T, &T) -> T>(\n            a: &ArraySeqStEphS<T>,\n            f: &F,\n            Ghost(spec_f): Ghost<spec_fn(T, T) -> T>,\n            id: T,\n        ) -> (scanned: ArraySeqStEphS<T>)\n            requires\n                a.spec_len() <= usize::MAX,\n                spec_monoid(spec_f, id),\n                forall|x: &T, y: &T| #[trigger] f.requires((x, y)),\n                forall|x: T, y: T, ret: T| f.ensures((&x, &y), ret) ==> ret == spec_f(x, y),\n            ensures\n                scanned.spec_len() == a.spec_len(),\n                forall|i: int| #![trigger scanned.spec_index(i)]\n                    0 <= i < a.spec_len() ==>\n                        scanned.spec_index(i) == Seq::new(a.spec_len(), |j: int| a.spec_index(j)).take(i).fold_left(id, spec_f);"
  },
  {
    "id": 31,
    "function": "expand_scan",
    "file": "Chap27/ScanContractStEph.rs",
    "lines": "246-266",
    "spec_strength": "unknown",
    "snippet": "        fn expand_scan<F: Fn(&T, &T) -> T>(\n            a: &ArraySeqStEphS<T>,\n            b: &ArraySeqStEphS<T>,\n            c: &ArraySeqStEphS<T>,\n            f: &F,\n            Ghost(spec_f): Ghost<spec_fn(T, T) -> T>,\n            id: &T,\n            n: usize,\n            half: usize,\n        ) -> (result: Vec<T>)\n            requires\n                n == a.spec_len(),\n                n >= 2,\n                half == n / 2,\n                half <= n,\n                b.spec_len() == half as nat,\n                c.spec_len() == half as nat,\n                spec_monoid(spec_f, *id),\n                forall|x: &T, y: &T| #[trigger] f.requires((x, y)),\n                forall|x: T, y: T, ret: T| f.ensures((&x, &y), ret) ==> ret == spec_f(x, y),\n                forall|k: int| #![trigger b.spec_index(k)] 0 <= k < half as int ==> {"
  }
]