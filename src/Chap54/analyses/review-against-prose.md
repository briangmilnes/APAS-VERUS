<style>
body { max-width: 100% !important; width: 100% !important; margin: 0 !important; padding: 1em !important; }
.markdown-body { max-width: 100% !important; width: 100% !important; }
.container, .container-lg, .container-xl, main, article { max-width: 100% !important; width: 100% !important; }
table { width: 100% !important; table-layout: fixed; }
</style>

# Chapter 54 â€” Breadth-First Search: Review Against Prose

**Date:** 2026-02-13
**Reviewer:** Claude-Opus-4.6

## Phase 1: Inventory (Tool-Generated)

Generated by `veracity-review-module-fn-impls -d src/Chap54`.

| # | Dir | Module | Tr | IT | IBI | ML | V! | -V! | Unk | Hole | NoSpec |
|---|-----|--------|:--:|:--:|:---:|:--:|:--:|:---:|:---:|:----:|:------:|
| 1 | Chap54 | BFSMtEph | 1 | 0 | 0 | 1 | 0 | 1 | 0 | 0 | 1 |
| 2 | Chap54 | BFSMtPer | 1 | 0 | 0 | 2 | 0 | 2 | 0 | 0 | 2 |
| 3 | Chap54 | BFSStEph | 1 | 0 | 0 | 1 | 0 | 1 | 0 | 0 | 1 |
| 4 | Chap54 | BFSStPer | 1 | 0 | 0 | 1 | 0 | 1 | 0 | 0 | 1 |

Key observations:
- **No `verus!` blocks** in any file. All code is pure Rust outside Verus verification.
- **No specs** (`requires`/`ensures`) on any function.
- **No proof functions** or spec functions.
- 5 total exec functions across 4 modules.

## Phase 2: Prose Inventory

Source: `prompts/Chap54.txt` and `prompts/Chap54part2.txt`.

### Definitions

| # | Name | Description |
|---|------|-------------|
| 1 | Definition 54.1 â€” Distance of a Vertex | Î´_G(s,v) = shortest distance from s to v (edge count) |
| 2 | Definition 54.2 â€” Breadth First Search | Graph search visiting vertices in increasing distance order |

### Algorithms

| # | Name | Description | Implemented? |
|---|------|-------------|:------------:|
| 1 | Algorithm 54.3 â€” Sequential BFS: Reachability | Queue-based BFS visiting one vertex per round; returns reachable set X and max distance | Yes (BFSStEph, BFSStPer) |
| 2 | Algorithm 54.4 â€” Parallel BFS: Reachability | Layer-by-layer BFS visiting all frontier vertices per round; returns X and max distance | Partially (BFSMtEph, BFSMtPer) |
| 3 | Algorithm 54.5 â€” Unweighted Shortest Paths (BFSDistance) | Parallel BFS returning table mapping each reachable vertex to its distance | No |
| 4 | Algorithm 54.6 â€” BFS Tree with Sequences | Parallel BFS computing shortest-path tree via inject; returns parent sequence | No |

### Cost Specs

| # | Algorithm | Work | Span | Notes |
|---|-----------|------|------|-------|
| 1 | Sequential BFS (54.3, queue-based) | O(\|V\| + \|E\|) | O(\|V\| + \|E\|) | Sequential â€” Span == Work |
| 2 | Parallel BFS (54.4, set-based) | O(mÂ·lg n) | O(dÂ·lgÂ² n) | Tree-based sets; d = max distance |
| 3 | Parallel BFS (54.6, sequence-based) | O(n + m) | O(dÂ·lg n) | Ephemeral array sequences |

### Theorems/Properties

| # | Name | Description | Proved? |
|---|------|-------------|:-------:|
| 1 | Lemma 54.1 â€” Parallel BFS and Distances | At round i: X = {v : Î´(s,v) < i}, F = {v : Î´(s,v) = i} | No |
| 2 | Theorem 54.2 â€” BFS Tree Gives Shortest Paths | Path from v to s in BFS tree reversed is a shortest path | No |

### Exercises

| # | Name | Description | Text proof? | Implemented? |
|---|------|-------------|:-----------:|:------------:|
| 1 | Exercise 54.1 | Prove frontier update is consistent with generic graph search | Yes | No |
| 2 | Exercise 54.2 | Prove sequential BFS correctness (visits in distance order) | Yes | No |
| 3 | Exercise 54.3 | Prove queue-based sequential BFS is correct | Yes | No |
| 4 | Exercise 54.4 | Identify which frontiers contribute neighbors in N_G(F_i) | Yes | No |

All exercises are text proofs; none require code implementations.

## Phase 3: Algorithmic Analysis

### 3a. Cost Annotations

| # | File | Function | APAS Cost | Claude-Opus-4.6 Cost | Agreement |
|---|------|----------|-----------|----------------------|:---------:|
| 1 | BFSStEph.rs | `bfs` | W O(\|V\|+\|E\|), S O(\|V\|+\|E\|) | W O(\|V\|+\|E\|), S O(\|V\|+\|E\|) | âœ… Agrees |
| 2 | BFSStPer.rs | `bfs` | W O(\|V\|+\|E\|), S O(\|V\|+\|E\|) | W O(\|V\|+\|E\|), S O(\|V\|+\|E\|) | âœ… Agrees |
| 3 | BFSMtEph.rs | `bfs` | W O(\|V\|+\|E\|), S O(dÂ·lg n) | W O(\|V\|+\|E\|), S O(\|V\|+\|E\|) | âŒ Disagrees |
| 4 | BFSMtPer.rs | `bfs` | W O(\|V\|+\|E\|), S O(dÂ·lg n) | W O(\|V\|+\|E\|), S O(dÂ·lg \|F_i\|) | âš ï¸ Partial |
| 5 | BFSMtPer.rs | `process_layer_parallel` | N/A (scaffolding) | W O(\|F_i\|), S O(lg \|F_i\|) | N/A |

**Disagreement details:**
- **BFSMtEph.rs `bfs`**: Despite being in an Mt module, the implementation processes each layer vertex sequentially in a `for` loop. No `thread::spawn` or parallel primitive is used. Span equals Work.
- **BFSMtPer.rs `bfs`**: Uses `process_layer_parallel` with `thread::spawn` fork-join for neighbor collection, achieving parallelism within layers. However, distance updates after each layer are applied sequentially via a `for` loop over `distance_updates`. The APAS algorithm computes `N_G(F) \ X` in parallel using set operations; here the deduplication is done by the sequential update loop.

### 3b. Implementation Fidelity

| # | Module | APAS Algorithm | Fidelity | Notes |
|---|--------|----------------|:--------:|-------|
| 1 | BFSStEph | Alg 54.3 (Sequential BFS) | âœ… Faithful | Queue-based BFS with distance array. Uses `VecDeque` as queue. Matches prose: pop front, mark visited, push unvisited neighbors. |
| 2 | BFSStPer | Alg 54.3 (Sequential BFS) | âœ… Faithful | Same algorithm as StEph but uses persistent `ArraySeqStPerS::update` instead of mutable `set`. |
| 3 | BFSMtEph | Alg 54.4 (Parallel BFS) | âŒ Sequential | Layer-by-layer structure matches prose (processes all frontier vertices per round), but within each layer, vertices are processed sequentially. No parallelism despite Mt name. |
| 4 | BFSMtPer | Alg 54.4 (Parallel BFS) | âš ï¸ Partial | Layer-by-layer structure with genuine fork-join parallelism in `process_layer_parallel`. However: (a) deduplication is not parallel â€” APAS uses `N_G(F) \ X` as a set difference, code uses sequential update; (b) distance updates applied sequentially after layer completes. |

**Deviation: Return type.** The prose algorithms return `(X, max_distance)` â€” the reachable set and the maximum distance. The implementations return only a distance array (with UNREACHABLE for unvisited vertices). The reachable set and max distance can be derived from this array, so this is a reasonable representation choice, not a bug.

**Deviation: No BFSDistance or BFSTree.** Algorithms 54.5 and 54.6 are not implemented. The implementations approximate 54.5's functionality (they compute distances) but without the table-based representation or shortest-path tree construction from 54.6.

### 3c. Spec Fidelity

All functions have **no specs** (no `requires`/`ensures`). None of the code is inside `verus!` blocks. Therefore:

- No preconditions are expressed (e.g., `source < graph.length()` is checked at runtime but not specified).
- No postconditions are expressed (e.g., returned distances are correct BFS distances is not specified).
- None of the prose properties (Lemma 54.1, Theorem 54.2) are formalized.

**Spec fidelity: N/A â€” no specs exist to compare against prose.**

## Phase 4: Parallelism Review

### 4a. Mt Function Classification

| # | Module | Function | Classification | Evidence |
|---|--------|----------|:--------------:|----------|
| 1 | BFSMtEph | `bfs` | Sequential | No `thread::spawn`, no `ParaPair!`, no `join`. Uses sequential `for` loop within layers. |
| 2 | BFSMtPer | `bfs` | Parallel (partial) | Calls `process_layer_parallel` which uses `thread::spawn`. But distance update loop is sequential. |
| 3 | BFSMtPer | `process_layer_parallel` | Parallel | Fork-join via `thread::spawn` + `join`. Splits layer in half recursively. |

### 4b. Span Audit

| # | Module | Function | APAS Span | Actual Span | Match? | Notes |
|---|--------|----------|-----------|-------------|:------:|-------|
| 1 | BFSMtEph | `bfs` | O(dÂ·lg n) | O(\|V\|+\|E\|) | âŒ | Span == Work. Aspirational annotation only. |
| 2 | BFSMtPer | `bfs` | O(dÂ·lg n) | O(dÂ·lg \|F_i\|) | âš ï¸ | Neighbor collection is parallel, but distance updates are sequential per layer. |
| 3 | BFSMtPer | `process_layer_parallel` | N/A | O(lg \|F_i\|) | N/A | Scaffolding function. |

### 4c. Parallelism Gap Table

| # | Function | APAS Span | Actual | Parallel? | Notes |
|---|----------|-----------|--------|:---------:|-------|
| 1 | BFSMtEph::bfs | O(dÂ·lg n) | O(\|V\|+\|E\|) | No | Layer-structured but entirely sequential. Needs thread::spawn or equivalent. |
| 2 | BFSMtPer::bfs | O(dÂ·lg n) | O(dÂ·lg \|F_i\|) | Partial | Neighbor collection parallel; distance updates sequential. Needs parallel inject. |
| 3 | BFSMtPer::process_layer_parallel | N/A | O(lg \|F_i\|) | Yes | Genuine fork-join parallelism. |

## Phase 5: Runtime Test Review

### 5a. Coverage Check

**No test files found.** No files in `tests/` match Chap54 or BFS patterns.

| # | Source Module | Test File | Status |
|---|-------------|----------|--------|
| 1 | BFSStEph | â€” | âŒ Missing |
| 2 | BFSStPer | â€” | âŒ Missing |
| 3 | BFSMtEph | â€” | âŒ Missing |
| 4 | BFSMtPer | â€” | âŒ Missing |

### 5b. Test Quality

N/A â€” no tests exist.

### 5c. Missing Tests

All 4 modules need runtime tests. Priority:

| # | Module | Priority | Reason |
|---|--------|:--------:|--------|
| 1 | BFSStEph | High | No specs, no verification â€” runtime test is the only correctness evidence |
| 2 | BFSStPer | High | Same as above |
| 3 | BFSMtEph | High | Same; also verify layer-by-layer structure produces correct distances |
| 4 | BFSMtPer | High | Same; also verify parallel version produces same results as sequential |

Recommended test cases:
- Example 54.1 graph (7 vertices, known distances)
- Example 54.2 graph (7 vertices, directed)
- Single vertex graph
- Disconnected graph (unreachable vertices)
- Source vertex out of range
- Linear chain (worst case d = n-1)
- Complete graph (best case d = 1)

## Phase 6: Proof-Time Test (PTT) Review

**No PTTs needed.** All code is outside `verus!` blocks â€” there are no verified loops, no iterators with ghost state, and no Verus-verified patterns to exercise. PTTs become relevant only when the modules are Verusified.

### 6a. Unified Test Inventory Table

| # | Source Module | RTT File | PTT File | Status |
|---|-------------|----------|----------|--------|
| 1 | BFSStEph | â€” | â€” | Missing both |
| 2 | BFSStPer | â€” | â€” | Missing both |
| 3 | BFSMtEph | â€” | â€” | Missing both |
| 4 | BFSMtPer | â€” | â€” | Missing both |

Note: PTTs are not applicable until Verusification. RTTs are the immediate priority.

## Phase 7: Gap Analysis

### Prose Items with No Implementation

| # | Prose Item | Type | Notes |
|---|-----------|------|-------|
| 1 | Algorithm 54.5 â€” BFSDistance | Algorithm | Returns table mapping vertices to distances; current impls return distance array (similar but not table-based) |
| 2 | Algorithm 54.6 â€” BFS Tree with Sequences | Algorithm | Computes shortest-path tree via inject; not implemented |
| 3 | Shortest-path tree post-processing | Algorithm | T = {v â†’ u : (u,v) âˆˆ E \| X[u] < X[v]}; not implemented |
| 4 | Lemma 54.1 â€” Parallel BFS and Distances | Theorem | Inductive proof about X_i and F_i invariants; not formalized |
| 5 | Theorem 54.2 â€” BFS Tree Gives Shortest Paths | Theorem | Shortest path property of BFS tree; not formalized |
| 6 | Example 54.1 | Example | Distance layer illustration; no test |
| 7 | Example 54.2 | Example | Enumerable graph representation; no test |
| 8 | Example 54.3 | Example | BFS visit order illustration; no test |
| 9 | Example 54.4 | Example | BFS tree with distances; no test |
| 10 | Exercise 54.1 | Text proof | Not formalized |
| 11 | Exercise 54.2 | Text proof | Not formalized |
| 12 | Exercise 54.3 | Text proof | Not formalized |
| 13 | Exercise 54.4 | Text proof | Not formalized |

### Code with No Prose Counterpart

| # | Module | Function | Purpose |
|---|--------|----------|---------|
| 1 | BFSMtPer | `process_layer_parallel` | Verus-specific scaffolding: fork-join helper for parallel layer processing |

## Phase 8: Table of Contents Review

### TOC Presence

| # | File | TOC Present? | Notes |
|---|------|:------------:|-------|
| 1 | BFSStEph.rs | No | No TOC comment block |
| 2 | BFSStPer.rs | No | No TOC comment block |
| 3 | BFSMtEph.rs | No | No TOC comment block |
| 4 | BFSMtPer.rs | No | No TOC comment block |

None of the files have TOC headers. This is expected for non-Verusified modules â€” the TOC standard primarily applies to files with `verus!` blocks containing structured sections (spec fns, proof fns, traits, impls, iterators, derive impls).

### In/Out Table

| # | File | Clone | PartialEq/Eq | Default | Drop | Iterator | Debug | Display | Macro | Other |
|---|------|:-----:|:------------:|:-------:|:----:|:--------:|:-----:|:-------:|:-----:|-------|
| 1 | BFSStEph.rs | - | - | - | - | - | - | - | - | - |
| 2 | BFSStPer.rs | - | - | - | - | - | - | - | - | - |
| 3 | BFSMtEph.rs | - | - | - | - | - | - | - | - | - |
| 4 | BFSMtPer.rs | - | - | - | - | - | - | - | - | - |

No derive impls in any file. The BFS modules define only algorithmic functions, not data types.

## Proof Holes Summary

```
âœ“ BFSMtEph.rs
âœ“ BFSMtPer.rs
âœ“ BFSStEph.rs
âœ“ BFSStPer.rs

Modules: 4 clean, 0 holed
Proof Functions: 0 clean, 0 holed
Holes Found: 0 total

ðŸŽ‰ No proof holes found! All proofs are complete.
```

Note: "No proof holes" is vacuously true â€” there is no Verus verification code to have holes in. All code is pure Rust outside `verus!` blocks.

## Spec Strength Summary

| Classification | Count |
|---------------|:-----:|
| strong | 0 |
| partial | 0 |
| weak | 0 |
| none | 5 |

All 5 functions have **no specs**. The entire chapter is unverified pure Rust.

## Overall Assessment

Chapter 54 implements the basic sequential BFS algorithm (Algorithm 54.3) faithfully across two representations (StEph, StPer) and provides two parallel variants (MtEph, MtPer), though with parallelism gaps.

### Strengths
1. Sequential implementations (BFSStEph, BFSStPer) are algorithmically correct and match the prose.
2. BFSMtPer has genuine fork-join parallelism for neighbor collection.
3. Zero proof holes (vacuously â€” no Verus code exists).

### Weaknesses
1. **No Verus verification at all.** No `verus!` blocks, no specs, no proofs. The `#[cfg(..., not(verus_keep_ghost))]` gate in `lib.rs` confirms this chapter is excluded from Verus compilation.
2. **No tests.** No RTTs or PTTs exist. The only evidence of correctness is code inspection.
3. **BFSMtEph is not parallel.** Despite the Mt module name, it processes layers entirely sequentially.
4. **Missing algorithms.** Algorithm 54.5 (BFSDistance table) and Algorithm 54.6 (BFS Tree with Sequences) are not implemented. The inject-based deduplication pattern from 54.6 is notably absent.
5. **No shortest-path tree.** The prose devotes significant attention to BFS trees and shortest paths; the code computes only distances.
6. **`N = usize` element type.** Per the exile-on-N-street rule, distances should use `u64`, not `N` (which is `usize`). However, since distances here represent graph distances (bounded by vertex count), `usize` is defensible for indexing-adjacent values.

### Priority Actions
1. Add runtime tests for all 4 modules using prose examples.
2. Make BFSMtEph genuinely parallel (or rename/document as sequential-layered).
3. Implement Algorithm 54.6 (BFS Tree with Sequences) â€” the most algorithmically interesting variant.
4. Begin Verusification with BFSStEph as the simplest starting point.
