<style>
body { max-width: 100% !important; width: 100% !important; margin: 0 !important; padding: 1em !important; }
.markdown-body { max-width: 100% !important; width: 100% !important; }
.container, .container-lg, .container-xl, main, article { max-width: 100% !important; width: 100% !important; }
table { width: 100% !important; table-layout: fixed; }
</style>

# Chapter 57 — Dijkstra's Algorithm: Review Against Prose

**Date:** 2026-02-13
**Reviewer:** Claude-Opus-4.6

## Phase 1: Inventory (tool-generated)

Generated by `veracity-review-module-fn-impls -d src/Chap57`.

| # | Dir | Module | Tr | IT | IBI | ML | V! | -V! | Unk | Hole | NoSpec |
|---|-----|--------|:--:|:--:|:---:|:--:|:--:|:---:|:---:|:----:|:------:|
| 1 | Chap57 | DijkstraStEphFloat | 1 | 2 | 0 | 2 | 0 | 4 | 0 | 0 | 4 |
| 2 | Chap57 | DijkstraStEphInt | 1 | 2 | 0 | 2 | 0 | 4 | 0 | 0 | 4 |
| 3 | Chap57 | StackStEph | 4 | 1 | 6 | 0 | 0 | 7 | 0 | 0 | 7 |

**Key observation:** All 15 functions are outside `verus!` (column -V!). Zero functions have specs. Zero functions are inside `verus!`. This chapter is entirely unverified.

## Phase 2: Prose Inventory

Source: `prompts/Chap57.txt` (Chapter 57 — Dijkstra's Algorithm)

### Definitions
| # | Item | Description |
|---|------|-------------|
| 1 | Frontier | Vertices that are neighbors of X but not in X: N+(X) \ X |
| 2 | Priority p(v) | min_{x in X}(delta_G(s, x) + w(x, v)) for frontier vertex v |
| 3 | SSSP+ problem | Single source shortest path with non-negative edge weights |

### Algorithms
| # | Item | Description |
|---|------|-------------|
| 1 | Algorithm 57.1 | Dijkstra's Algorithm — priority-first search with d(s)=0, p(v)=min, sets d(v)=p(v) |
| 2 | Algorithm 57.2 | Dijkstra's Algorithm using Priority Queues — the concrete PQ-based implementation |

### Cost Specs
| # | Item | Cost |
|---|------|------|
| 1 | Dijkstra (PQ-based) | Work O(m log n), Span O(m log n) — sequential algorithm |
| 2 | PQ.deleteMin | O(log m) per call, m calls total |
| 3 | PQ.insert | O(log m) per call, m calls total |
| 4 | Table find | O(log n) per call, m calls total |
| 5 | Table insert | O(log n) per call, n calls total |
| 6 | N+_G(v) | O(log n) per call, n calls total |

### Theorems/Properties
| # | Item | Description |
|---|------|-------------|
| 1 | Lemma 57.1 (Dijkstra's Property) | min_{y in Y} p(y) = min_{y in Y} delta_G(s, y) for non-negative weights |
| 2 | Theorem 57.2 | Correctness: Dijkstra returns d(v) = delta_G(s, v) for reachable v |

### Exercises
| # | Item | Description |
|---|------|-------------|
| 1 | Exercise 57.1 | Give a version of Dijkstra using decreaseKey operation |

## Phase 3: Algorithmic Analysis

### 3a. Cost Annotations

All exec functions now have APAS/Claude-Opus-4.6 cost comment pairs. Summary:

| # | Function | File | APAS Cost | Claude-Opus-4.6 Cost | Agreement |
|---|----------|------|-----------|-------------|-----------|
| 1 | `dijkstra` (trait) | DijkstraStEphInt.rs | Work O(m log n), Span O(m log n) | Work O(m log n), Span O(m log n) | Agree |
| 2 | `dijkstra` (impl) | DijkstraStEphInt.rs | Work O(m log n), Span O(m log n) | Work O(m log n), Span O(m log n) | Agree |
| 3 | `pq_entry_new` | DijkstraStEphInt.rs | N/A — scaffolding | Work Θ(1), Span Θ(1) | N/A |
| 4 | `cmp` | DijkstraStEphInt.rs | N/A — scaffolding | Work Θ(1), Span Θ(1) | N/A |
| 5 | `partial_cmp` | DijkstraStEphInt.rs | N/A — scaffolding | Work Θ(1), Span Θ(1) | N/A |
| 6 | `dijkstra` (trait) | DijkstraStEphFloat.rs | Work O(m log n), Span O(m log n) | Work O(m log n), Span O(m log n) | Agree |
| 7 | `dijkstra` (impl) | DijkstraStEphFloat.rs | Work O(m log n), Span O(m log n) | Work O(m log n), Span O(m log n) | Agree |
| 8 | `pq_entry_new` | DijkstraStEphFloat.rs | N/A — scaffolding | Work Θ(1), Span Θ(1) | N/A |
| 9 | `cmp` | DijkstraStEphFloat.rs | N/A — scaffolding | Work Θ(1), Span Θ(1) | N/A |
| 10 | `partial_cmp` | DijkstraStEphFloat.rs | N/A — scaffolding | Work Θ(1), Span Θ(1) | N/A |
| 11 | `new` | StackStEph.rs | Work Θ(1), Span Θ(1) | Work Θ(1), Span Θ(1) | Agree |
| 12 | `push` | StackStEph.rs | Work Θ(1), Span Θ(1) | Work Θ(1) amortized | Minor — amortized vs worst-case |
| 13 | `pop` | StackStEph.rs | Work Θ(1), Span Θ(1) | Work Θ(1) amortized | Minor — amortized vs worst-case |
| 14 | `peek` | StackStEph.rs | (no cost stated) | Work Θ(1), Span Θ(1) | N/A |
| 15 | `is_empty` | StackStEph.rs | Work Θ(1), Span Θ(1) | Work Θ(1), Span Θ(1) | Agree |
| 16 | `size` | StackStEph.rs | (no cost stated) | Work Θ(1), Span Θ(1) | N/A |
| 17 | `default` | StackStEph.rs | N/A — Rust scaffolding | Work Θ(1), Span Θ(1) | N/A |

**Cost disagreements:** None significant. The Vec-backed push/pop are amortized Θ(1) rather than worst-case Θ(1) — this is a standard implementation choice that matches the prose's asymptotic expectation.

### 3b. Implementation Fidelity

#### DijkstraStEphInt / DijkstraStEphFloat

The implementations faithfully follow **Algorithm 57.2** from the prose:

1. **Priority queue with deleteMin/insert** — uses `BinaryHeapPQ` which is the project's verified min-heap from Chap45. Matches the prose's PQ operations.
2. **Visited set X** — implemented as `HashMap<usize, i64>` / `HashMap<usize, OrderedF64>`. The prose says "table mapping visited vertex u to d(u)." A HashMap provides O(1) expected lookup vs the prose's O(log n) tree table — this is better, not worse.
3. **Duplicate handling** — the code checks `visited.contains_key(&v)` on line 7 of the pseudocode, exactly matching the prose's "if (v, _) ∈ X then skip."
4. **Relax function** — iterates over out-neighbors, inserting `(d + w, u)` into PQ. Matches the prose's `relax (Q, (u, w)) = PQ.insert (d + w, u) Q`.
5. **Predecessor tracking** — the code additionally tracks predecessors (not in the Algorithm 57.2 pseudocode but mentioned in the result type). This is an extension that doesn't change the algorithm's structure or cost.

**Deviations:**
- The code adds an extra optimization: skipping already-visited neighbors during relaxation (line 112-114 in Int, line 113-115 in Float). The prose mentions this as a valid variant in the Remark after Algorithm 57.2: "One variant checks whether u is already in X inside the relax function." This does not affect asymptotic bounds.
- The predecessor update logic (`if result.get_distance(u_idx) > new_dist`) is done eagerly during relaxation. This is correct because the final predecessor will be set when the vertex is first dequeued with minimum distance, but intermediate predecessor updates happen for all shorter paths discovered. The final result is correct because the PQ ordering ensures the minimum distance path is processed first.

#### StackStEph

A standard Vec-backed LIFO stack. The prose does not define a stack ADT in Chapter 57 — the stack module appears to be infrastructure created because the prompt said "Definitely make a separate stack module." However, the stack is **not actually used** by either Dijkstra implementation. The Dijkstra implementations use `BinaryHeapPQ` (priority queue), not a stack.

### 3c. Spec Fidelity

**No specs exist.** All 15 functions are outside `verus!` with no `requires`/`ensures`. There is nothing to compare against the prose's stated properties.

Key specs that should exist but don't:
1. **Dijkstra correctness (Theorem 57.2):** `ensures forall |v| reachable(graph, source, v) ==> result.distance(v) == delta_G(source, v)`
2. **Non-negative weight precondition:** `requires forall |e| graph.weight(e) >= 0`
3. **Stack LIFO property:** `ensures pop result == last pushed element`
4. **Stack size tracking:** `ensures self@.len() == old(self@.len()) + 1` (for push)

## Phase 4: Parallelism Review

**No Mt (multi-threaded) modules exist in Chapter 57.** The prose explicitly states: "It is a sequential algorithm." This is correctly reflected in the implementation — both Dijkstra variants are sequential (`StEph` suffix).

No parallelism gap table is needed.

## Phase 5: Runtime Test Review

### 5a. Coverage Check

**No runtime test files found** for Chap57 in `tests/`.

| # | Source Module | Expected Test File | Status |
|---|-------------|-------------------|--------|
| 1 | `DijkstraStEphInt.rs` | `tests/Chap57/TestDijkstraStEphInt.rs` | **Missing** |
| 2 | `DijkstraStEphFloat.rs` | `tests/Chap57/TestDijkstraStEphFloat.rs` | **Missing** |
| 3 | `StackStEph.rs` | `tests/Chap57/TestStackStEph.rs` | **Missing** |

### 5b. Test Quality

N/A — no tests exist.

### 5c. Missing Tests (Proposed)

| # | Priority | Module | Proposed Tests |
|---|----------|--------|---------------|
| 1 | High | DijkstraStEphInt | Single vertex, linear chain, diamond graph, disconnected vertices, zero-weight edges, Example 57.3 from prose |
| 2 | High | DijkstraStEphFloat | Same scenarios with float weights, near-zero weights |
| 3 | Low | StackStEph | Push/pop/peek sequence, empty pop returns None, size tracking |

Priority is high for Dijkstra because there are **no specs and no tests** — runtime tests are the only evidence of correctness.

## Phase 6: Proof-Time Test (PTT) Review

**No PTTs needed.** Chapter 57 has no iterators, no verified loops (no code inside `verus!`), no `GhostIterator`/`ForLoopGhostIterator` implementations. The `verus!` block contains only a trivial `View` impl for `PQEntry`.

### 6a. Unified Test Inventory

| # | Source Module | RTT File | PTT File | Status |
|---|-------------|----------|----------|--------|
| 1 | DijkstraStEphInt | — | — | Missing RTT |
| 2 | DijkstraStEphFloat | — | — | Missing RTT |
| 3 | StackStEph | — | — | Missing RTT |

## Phase 7: Gap Analysis

### Prose Items With No Implementation

| # | Prose Item | Type | Notes |
|---|-----------|------|-------|
| 1 | Algorithm 57.1 (abstract Dijkstra) | Algorithm | Implemented via Algorithm 57.2 (PQ version). This is expected — 57.1 is the abstract description. |
| 2 | Lemma 57.1 (Dijkstra's Property) | Theorem | No proof lemma exists. Would require spec-level graph distance definitions. |
| 3 | Theorem 57.2 (Correctness) | Theorem | No proof exists. The `ensures` clause of `dijkstra` should express this. |
| 4 | Exercise 57.1 (decreaseKey variant) | Exercise | Not implemented. |
| 5 | Example 57.1 (BFS counterexample) | Example | Not implemented (illustrative only). |
| 6 | Example 57.2 (frontier example) | Example | Not implemented (illustrative only). |
| 7 | Example 57.3 (trace of Dijkstra) | Example | Not implemented as test. Should be a runtime test. |

### Code With No Prose Counterpart

| # | Code Item | Type | Notes |
|---|----------|------|-------|
| 1 | `StackStEph` | Module | Prompt-requested stack; not used by Dijkstra implementations |
| 2 | `PQEntry` struct | Type | Implementation detail for PQ integration |
| 3 | `pq_entry_new` | Function | Constructor scaffolding |
| 4 | `Ord`/`PartialOrd` impls | Trait impls | Required by BinaryHeapPQ |
| 5 | `Display` impl | Trait impl | Debug/display scaffolding |
| 6 | `View` impl for PQEntry | Verus impl | Minimal Verus scaffolding inside `verus!` |
| 7 | Predecessor tracking | Feature | Result includes predecessors; prose Algorithm 57.2 only returns distances |
| 8 | DijkstraStEphFloat | Module | Float variant; prose uses generic weights but the code duplicates for Int/Float |

## Phase 8: Table of Contents Review

### TOC Presence

| # | File | TOC Present? | Section Headers? |
|---|------|:------------:|:----------------:|
| 1 | `DijkstraStEphInt.rs` | No | No |
| 2 | `DijkstraStEphFloat.rs` | No | No |
| 3 | `StackStEph.rs` | No | No |

None of the files have the standard Table of Contents block or section headers.

### In/Out Table

| # | File | Clone | PartialEq/Eq | Default | Drop | Iterator | Debug | Display | Macro | Other |
|---|------|:-----:|:------------:|:-------:|:----:|:--------:|:-----:|:-------:|:-----:|-------|
| 1 | DijkstraStEphInt.rs | ❌ out | ❌ out | - | - | - | ❌ out | ❌ out | - | Ord/PartialOrd ❌ out |
| 2 | DijkstraStEphFloat.rs | ❌ out | ❌ out | - | - | - | ❌ out | ❌ out | - | Ord/PartialOrd ❌ out |
| 3 | StackStEph.rs | ❌ out | - | ❌ out | - | - | ❌ out | - | - | - |

**Notes:**
- `Clone`, `PartialEq`, `Eq` on `PQEntry` are `#[derive]` outside `verus!` — should be inside with specs per project standard.
- `Debug` is correctly outside `verus!` (Verus limitation). Marked ❌ out because it's derived alongside Clone/PartialEq which should be inside.
- `Display` must stay outside `verus!` — this is correct placement but currently shares the wrong side with other traits.
- `Default` on `StackStEph` is outside `verus!` — should be inside.
- `Ord`/`PartialOrd` are outside `verus!` — these need to be inside with specs for verified PQ interaction.

## Proof Holes Summary

```
✓ DijkstraStEphFloat.rs
✓ DijkstraStEphInt.rs
✓ StackStEph.rs

Modules: 3 clean, 0 holed
Holes Found: 0 total
```

Zero proof holes — but this is vacuously true because there is essentially no verified code. The only `verus!` block contains a trivial `View` impl.

## Spec Strength Summary

| Classification | Count |
|---------------|------:|
| strong | 0 |
| partial | 0 |
| weak | 0 |
| none | 15 |

**All 15 functions have no specs.** This chapter is entirely unverified.

## Overall Assessment

Chapter 57 is a **functional but unverified** implementation of Dijkstra's algorithm.

### Strengths
1. **Algorithmic fidelity** — both Int and Float variants faithfully implement Algorithm 57.2 from the prose.
2. **Correct use of BinaryHeapPQ** — leverages the project's existing verified PQ from Chap45.
3. **Zero proof holes** — no `assume`, `admit`, or `external_body` hacks.
4. **Cost analysis agrees** — APAS and Claude-Opus-4.6 costs match for all functions.

### Weaknesses
1. **No verification** — 0/15 functions have specs. No `requires`/`ensures` on any function. The `verus!` block is purely ceremonial (just a `View` impl).
2. **No runtime tests** — zero test files for the entire chapter. No empirical evidence of correctness.
3. **No TOC or section structure** — files don't follow the project's table-of-contents standard.
4. **Trait impls in wrong placement** — `Clone`, `PartialEq`, `Eq`, `Default`, `Ord`, `PartialOrd` are all outside `verus!` where they should be inside with specs.
5. **Unused module** — `StackStEph` was requested by the prompt but is not used by either Dijkstra implementation.
6. **Code duplication** — `DijkstraStEphInt` and `DijkstraStEphFloat` are nearly identical. A generic approach (parameterized by weight type) would reduce maintenance.
7. **HashMap instead of verified table** — the visited set uses `std::collections::HashMap` which is outside Verus verification. The prose suggests a table (Chap42) which has verified implementations in the project.
8. **DijkstraStEphFloat gated** — `DijkstraStEphFloat` is behind `#[cfg(feature = "all_chapters")]` in `lib.rs`, meaning it's not compiled by default.
9. **Missing prose items** — Lemma 57.1, Theorem 57.2, and Exercise 57.1 have no corresponding code.

### Priority Action Items
1. Add runtime tests for `DijkstraStEphInt` (highest priority — no tests, no specs).
2. Move code inside `verus!` and add `requires`/`ensures` specs.
3. Add TOC headers and restructure files per project standard.
4. Move `Clone`/`PartialEq`/`Eq`/`Ord`/`PartialOrd` inside `verus!` with specs.
5. Replace `HashMap` with verified table for visited set.
6. Consider whether `StackStEph` should be removed or repurposed.
