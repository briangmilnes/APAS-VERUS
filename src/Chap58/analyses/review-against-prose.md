<style>
body { max-width: 100% !important; width: 100% !important; margin: 0 !important; padding: 1em !important; }
.markdown-body { max-width: 100% !important; width: 100% !important; }
.container, .container-lg, .container-xl, main, article { max-width: 100% !important; width: 100% !important; }
table { width: 100% !important; table-layout: fixed; }
</style>

# Chapter 58 — Bellman-Ford's Algorithm: Review Against Prose

**Date:** 2026-02-13
**Reviewer:** Claude-Opus-4.6

## Phase 1: Inventory (tool-generated)

Generated by `veracity-review-module-fn-impls -d src/Chap58`.

| # | Dir | Module | Tr | IT | IBI | ML | V! | -V! | Unk | Hole | NoSpec |
|---|-----|--------|:--:|:--:|:---:|:--:|:--:|:---:|:---:|:----:|:------:|
| 1 | Chap58 | BellmanFordStEphFloat | 1 | 0 | 0 | 2 | 0 | 2 | 0 | 0 | 2 |
| 2 | Chap58 | BellmanFordStEphInt | 1 | 0 | 0 | 2 | 0 | 2 | 0 | 0 | 2 |

**Key observation:** All 4 functions are outside `verus!` (column -V!). Zero functions have specs. Zero functions are inside `verus!`. This chapter is entirely unverified.

## Phase 2: Prose Inventory

Source: `prompts/Chap58.txt` (Chapter 58 — Bellman-Ford's Algorithm)

### Definitions
| # | Item | Description |
|---|------|-------------|
| 1 | k-hop distance δ^k_G(u,v) | Shortest path from u to v considering only paths with at most k ≥ 0 edges |
| 2 | Negative-weight cycle | A cycle where the sum of edge weights is negative; makes shortest paths undefined (−∞) |
| 3 | In-neighbors N⁻(v) | Vertices u such that edge (u,v) exists |

### Algorithms
| # | Item | Description |
|---|------|-------------|
| 1 | Algorithm 58.2 | Bellman-Ford Algorithm — iterative k-hop distance computation with convergence check and negative-cycle detection |

### Cost Specs
| # | Item | Cost (with sequences) | Cost (with tables) |
|---|------|-----------------------|--------------------|
| 1 | One round of BF (Lines 5-6) | Work O(n + m), Span O(lg n) | Work O((n + m) lg n), Span O(lg n) |
| 2 | Line 9 (convergence check) | Work O(n lg n), Span O(lg n) | Work O(n lg n), Span O(lg n) |
| 3 | Total Bellman-Ford (sequences) | Work O(nm), Span O(n lg n) | — |
| 4 | Total Bellman-Ford (tables) | — | Work O(nm lg n), Span O(n lg n) |

### Theorems/Properties
| # | Item | Description |
|---|------|-------------|
| 1 | Theorem 58.1 (Correctness) | BellmanFord returns δ_G(s,v) for all reachable v, or indicates a negative-weight cycle |
| 2 | Sub-path property | Any sub-path of a shortest path is a shortest path |
| 3 | Simple path bound | In absence of negative cycles, shortest paths are simple (≤ |V|−1 edges) |

### Exercises
| # | Item | Description |
|---|------|-------------|
| 1 | Exercise 58.1 | What does a negative weight cycle imply in currency exchange? |
| 2 | Exercise 58.2 | Prove that if no negative-weight cycles, shortest path is simple |

### Examples
| # | Item | Description |
|---|------|-------------|
| 1 | Example 58.1 | Reducing currency exchange to shortest paths |
| 2 | Example 58.2 | Where Dijkstra's property fails with negative weights |
| 3 | Example 58.3 | Computing k+1-hop distance from k-hop distances |
| 4 | Example 58.4 | Several steps of Bellman-Ford execution |

## Phase 3: Algorithmic Analysis

### 3a. Cost Annotations

All exec functions now have APAS/Claude-Opus-4.6 cost comment pairs. Summary:

| # | Function | File | APAS Cost | Claude-Opus-4.6 Cost | Agreement |
|---|----------|------|-----------|-------------|-----------|
| 1 | `bellman_ford` (trait) | BellmanFordStEphInt.rs | Work O(nm), Span O(n lg n) | Work O(nm), Span O(nm) | **Disagree** — sequential |
| 2 | `bellman_ford` (impl) | BellmanFordStEphInt.rs | Work O(nm), Span O(n lg n) | Work O(nm), Span O(nm) | **Disagree** — sequential |
| 3 | `reconstruct_predecessors` | BellmanFordStEphInt.rs | N/A — scaffolding | Work O(n + m), Span O(n + m) | N/A |
| 4 | `bellman_ford` (trait) | BellmanFordStEphFloat.rs | Work O(nm), Span O(n lg n) | Work O(nm), Span O(nm) | **Disagree** — sequential |
| 5 | `bellman_ford` (impl) | BellmanFordStEphFloat.rs | Work O(nm), Span O(n lg n) | Work O(nm), Span O(nm) | **Disagree** — sequential |
| 6 | `reconstruct_predecessors` | BellmanFordStEphFloat.rs | N/A — scaffolding | Work O(n + m), Span O(n + m) | N/A |

**Cost disagreements:** The APAS Span of O(n lg n) assumes parallelism over vertices within each round (Lines 5-6 parallelized). The code uses sequential `for v in 0..n`, so the actual Span equals Work = O(nm). The Work agrees: HashMap gives O(1) expected lookup (matching the sequence-based O(n + m) per round × n rounds = O(nm)).

### 3b. Implementation Fidelity

#### BellmanFordStEphInt / BellmanFordStEphFloat

Both implementations faithfully follow **Algorithm 58.2** from the prose:

1. **Initialization (Line 13)** — `d(s) = 0`, `d(v) = ∞` for v ≠ s. Code uses `HashMap<usize, i64/OrderedF64>` with `i64::MAX` / `f64::INFINITY` as ∞. Matches prose.
2. **Inner loop (Lines 5-6)** — For each vertex v, computes `D_in(v) = min over u ∈ N⁻(v) of (D[u] + w(u,v))`, then `D'[v] = min(D[v], D_in(v))`. Code correctly implements this with `graph.in_neighbors_weighed(&v)` / `graph.in_neighbors_weighted(&v)`.
3. **Convergence check (Line 9-10)** — `if all {D[v] = D'[v] : v ∈ V}` then return. Code tracks `changed` flag and returns `Ok(result)` when no distances changed.
4. **Negative cycle detection (Line 8)** — `if k = |V|` then return None. Code checks `if round == n - 1` and returns `Err("Negative-weight cycle detected")`.
5. **Predecessor reconstruction** — Not in Algorithm 58.2 pseudocode but necessary for the `SSSPResult` type. Implemented as a post-processing step that scans in-neighbors to find the edge that achieves each vertex's final distance.

**Deviations:**
- The code performs n iterations (0..n) but checks `round == n - 1` for cycle detection. The prose says "if k = |V| then None" where k starts at 0. After n-1 rounds (rounds 0 through n-1), the algorithm has computed up to n-hop distances. If distances are still changing after n rounds, there's a negative cycle. The code's check at `round == n - 1` is equivalent — it runs n rounds total and reports a cycle if convergence hasn't happened by the last round.
- The Int variant uses `saturating_add` to avoid overflow. The prose assumes unbounded arithmetic. This is a necessary implementation detail.
- The code uses `HashMap` instead of sequences/tables. HashMap provides O(1) expected lookup, which is at least as good as the sequence-based O(1) assumed by the prose.

### 3c. Spec Fidelity

**No specs exist.** All 4 functions are outside `verus!` with no `requires`/`ensures`. There is nothing to compare against the prose's stated properties.

Key specs that should exist but don't:
1. **Bellman-Ford correctness (Theorem 58.1):** `ensures result.is_ok() ==> forall |v| reachable(graph, source, v) ==> result.unwrap().distance(v) == delta_G(source, v)`
2. **Negative-cycle detection:** `ensures result.is_err() ==> graph has reachable negative-weight cycle from source`
3. **No negative-weight cycle precondition variant:** For the `Ok` case, `ensures result.is_ok() ==> no reachable negative-weight cycle`
4. **Source distance:** `ensures result.is_ok() ==> result.unwrap().distance(source) == 0`

## Phase 4: Parallelism Review

**No Mt (multi-threaded) modules exist in Chapter 58.** The prose notes that the algorithm is parallelizable ("For each vertex v in parallel" on Lines 5-6), but only sequential (`StEph`) variants have been implemented.

The prose explicitly describes Bellman-Ford as having significant parallelism — the per-vertex computation within each round is embarrassingly parallel. A future `BellmanFordMtEph` variant would achieve the APAS Span of O(n lg n).

No parallelism gap table is needed (no Mt modules to audit).

## Phase 5: Runtime Test Review

### 5a. Coverage Check

**No runtime test files found** for Chap58 in `tests/`.

| # | Source Module | Expected Test File | Status |
|---|-------------|-------------------|--------|
| 1 | `BellmanFordStEphInt.rs` | `tests/Chap58/TestBellmanFordStEphInt.rs` | **Missing** |
| 2 | `BellmanFordStEphFloat.rs` | `tests/Chap58/TestBellmanFordStEphFloat.rs` | **Missing** |

### 5b. Test Quality

N/A — no tests exist.

### 5c. Missing Tests (Proposed)

| # | Priority | Module | Proposed Tests |
|---|----------|--------|---------------|
| 1 | High | BellmanFordStEphInt | Single vertex, linear chain with positive weights, graph with negative edges but no negative cycle, graph with negative-weight cycle (expect Err), Example 58.4 trace, diamond graph, disconnected vertices |
| 2 | High | BellmanFordStEphFloat | Same scenarios with float weights, near-zero weights, Example 58.1 currency exchange reduction |

Priority is high for both because there are **no specs and no tests** — runtime tests are the only evidence of correctness.

## Phase 6: Proof-Time Test (PTT) Review

**No PTTs needed.** Chapter 58 has no iterators, no verified loops (no code inside `verus!`), no `GhostIterator`/`ForLoopGhostIterator` implementations.

### 6a. Unified Test Inventory

| # | Source Module | RTT File | PTT File | Status |
|---|-------------|----------|----------|--------|
| 1 | BellmanFordStEphInt | — | — | Missing RTT |
| 2 | BellmanFordStEphFloat | — | — | Missing RTT |

## Phase 7: Gap Analysis

### Prose Items With No Implementation

| # | Prose Item | Type | Notes |
|---|-----------|------|-------|
| 1 | Theorem 58.1 (Correctness) | Theorem | No proof lemma. The `ensures` clause of `bellman_ford` should express this. |
| 2 | Exercise 58.1 (neg cycle in currency) | Exercise | Not implemented (conceptual). |
| 3 | Exercise 58.2 (simple path proof) | Exercise | Not implemented. |
| 4 | Example 58.1 (currency exchange) | Example | Not implemented as test. Could be a runtime test. |
| 5 | Example 58.4 (BF trace) | Example | Not implemented as test. Should be a runtime test. |
| 6 | Mt (parallel) variant | Algorithm | Prose says the algorithm has "significant parallelism" (Lines 5-6). No Mt variant exists. |
| 7 | Table-based variant | Algorithm | Prose analyzes cost with both tables and sequences. Only HashMap variant exists. |

### Code With No Prose Counterpart

| # | Code Item | Type | Notes |
|---|----------|------|-------|
| 1 | `reconstruct_predecessors` | Function | Scaffolding to build predecessor tree from final distances. Not in Algorithm 58.2 pseudocode. |
| 2 | `BellmanFordStEphFloat` | Module | Float variant; prose uses generic weights but the code duplicates for Int/Float. |
| 3 | `SSSPResultStEphInt/Float` | Type | Result type from Chap56; prose just says "return distances." |

## Phase 8: Table of Contents Review

### TOC Presence

| # | File | TOC Present? | Section Headers? |
|---|------|:------------:|:----------------:|
| 1 | `BellmanFordStEphInt.rs` | No | No |
| 2 | `BellmanFordStEphFloat.rs` | No | No |

Neither file has the standard Table of Contents block or section headers.

### In/Out Table

| # | File | Clone | PartialEq/Eq | Default | Drop | Iterator | Debug | Display | Macro | Other |
|---|------|:-----:|:------------:|:-------:|:----:|:--------:|:-----:|:-------:|:-----:|-------|
| 1 | BellmanFordStEphInt.rs | - | - | - | - | - | - | - | - | - |
| 2 | BellmanFordStEphFloat.rs | - | - | - | - | - | - | - | - | - |

**Notes:** Neither file implements any derive traits. No `verus!` block exists. The files are pure Rust with no Verus verification infrastructure.

## Proof Holes Summary

```
✓ BellmanFordStEphFloat.rs
✓ BellmanFordStEphInt.rs

Modules: 2 clean, 0 holed
Holes Found: 0 total
```

Zero proof holes — but this is vacuously true because there is no verified code. No `verus!` block exists in either file.

## Spec Strength Summary

| Classification | Count |
|---------------|------:|
| strong | 0 |
| partial | 0 |
| weak | 0 |
| none | 4 |

**All 4 functions have no specs.** This chapter is entirely unverified.

## Overall Assessment

Chapter 58 is a **functional but unverified** implementation of Bellman-Ford's algorithm.

### Strengths
1. **Algorithmic fidelity** — both Int and Float variants faithfully implement Algorithm 58.2 from the prose, including initialization, k-hop iteration, convergence check, and negative-cycle detection.
2. **Correct structure** — the iterative relaxation with convergence detection and the n-round negative-cycle bound are correctly implemented.
3. **Zero proof holes** — no `assume`, `admit`, or `external_body` hacks.
4. **Work analysis agrees** — APAS and Claude-Opus-4.6 work costs match at O(nm) thanks to HashMap's O(1) expected lookup.

### Weaknesses
1. **No verification** — 0/4 functions have specs. No `requires`/`ensures` on any function. No `verus!` block exists.
2. **No runtime tests** — zero test files for the entire chapter. No empirical evidence of correctness.
3. **No TOC or section structure** — files don't follow the project's table-of-contents standard.
4. **Span disagreement** — the code achieves Span O(nm) (sequential), not the APAS Span of O(n lg n) which requires parallelism. No Mt variant exists despite the prose describing the algorithm as having "significant parallelism."
5. **Code duplication** — `BellmanFordStEphInt` and `BellmanFordStEphFloat` are nearly identical. A generic approach parameterized by weight type would reduce maintenance.
6. **HashMap instead of verified table/sequence** — the distance structure uses `std::collections::HashMap` which is outside Verus verification. The prose suggests either tables (Chap42) or sequences (Chap18), both of which have verified implementations in the project.
7. **BellmanFordStEphFloat gated** — behind `#[cfg(feature = "all_chapters")]` in `lib.rs`, meaning it's not compiled by default.
8. **Float equality comparison** — `BellmanFordStEphFloat` compares `OrderedF64` values for exact equality when checking convergence (`min_dist != current_dist`) and predecessor reconstruction (`path_dist == v_dist`). Floating-point equality comparison is fragile and could fail to detect convergence or misidentify predecessors due to rounding.
9. **Missing prose items** — Theorem 58.1, Exercises 58.1-58.2, and the Mt parallel variant have no corresponding code.
10. **Trait return type mismatch** — `BellmanFordStEphFloatTrait::bellman_ford` declares return type `SSSPResultStEphFloat` but the implementation returns `Result<SSSPResultStEphFloat, String>`. The trait signature doesn't account for negative-cycle errors.

### Priority Action Items
1. Add runtime tests for `BellmanFordStEphInt` (highest priority — no tests, no specs).
2. Fix the Float trait signature to return `Result<SSSPResultStEphFloat, String>` to match the implementation.
3. Move code inside `verus!` and add `requires`/`ensures` specs.
4. Add TOC headers and restructure files per project standard.
5. Replace `HashMap` with verified table or sequence for distance storage.
6. Implement a parallel `BellmanFordMtEph` variant to achieve the APAS Span of O(n lg n).
7. Add Example 58.4 as a runtime test to validate the algorithm trace.
