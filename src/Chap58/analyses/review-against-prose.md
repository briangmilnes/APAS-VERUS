<style>
body { max-width: 100% !important; width: 100% !important; margin: 0 !important; padding: 1em !important; }
.markdown-body { max-width: 100% !important; width: 100% !important; }
.container, .container-lg, .container-xl, main, article { max-width: 100% !important; width: 100% !important; }
table { width: 100% !important; table-layout: fixed; }
</style>

# Chapter 58 — Bellman-Ford's Algorithm: Review Against Prose

**Date:** 2026-02-18 (updated 2026-02-18: file rename Int→I64; tests present; hole detector clean)
**Reviewer:** Claude-Opus-4.6

## Phase 1: Inventory (tool-generated)

Generated by `veracity-review-module-fn-impls -d src/Chap58`.

| # | Dir | Module | Tr | IT | IBI | ML | V! | -V! | Unk | Hole | NoSpec |
|---|-----|--------|:--:|:--:|:---:|:--:|:--:|:---:|:---:|:----:|:------:|
| 1 | Chap58 | BellmanFordStEphFloat | 1 | 0 | 0 | 2 | 0 | 2 | 0 | 0 | 2 |
| 2 | Chap58 | BellmanFordStEphI64 | 1 | 0 | 0 | 2 | 1 | 1 | 0 | 0 | 2 |

**Key observation:** BellmanFordStEphI64 has been partially verusified — the trait definition (`BellmanFordStEphI64Trait`) is now inside `verus!` (V!=1), while the impl function `reconstruct_predecessors` remains outside (-V!=1). The standalone `bellman_ford` function is `#[cfg(not(verus_keep_ghost))]` and its trait signature inside `verus!` counts as the V! item. BellmanFordStEphFloat remains entirely outside `verus!` with no verus block. All 4 functions across both modules still have no specs (NoSpec=4 total).

## Phase 2: Prose Inventory

Source: `prompts/Chap58.txt` (Chapter 58 — Bellman-Ford's Algorithm)

### Definitions
| # | Item | Description |
|---|------|-------------|
| 1 | k-hop distance δ^k_G(u,v) | Shortest path from u to v considering only paths with at most k ≥ 0 edges |
| 2 | Negative-weight cycle | A cycle where the sum of edge weights is negative; makes shortest paths undefined (−∞) |
| 3 | In-neighbors N⁻(v) | Vertices u such that edge (u,v) exists |

### Algorithms
| # | Item | Description |
|---|------|-------------|
| 1 | Algorithm 58.2 | Bellman-Ford Algorithm — iterative k-hop distance computation with convergence check and negative-cycle detection |

### Cost Specs
| # | Item | Cost (with sequences) | Cost (with tables) |
|---|------|-----------------------|--------------------|
| 1 | One round of BF (Lines 5-6) | Work O(n + m), Span O(lg n) | Work O((n + m) lg n), Span O(lg n) |
| 2 | Line 9 (convergence check) | Work O(n lg n), Span O(lg n) | Work O(n lg n), Span O(lg n) |
| 3 | Total Bellman-Ford (sequences) | Work O(nm), Span O(n lg n) | — |
| 4 | Total Bellman-Ford (tables) | — | Work O(nm lg n), Span O(n lg n) |

### Theorems/Properties
| # | Item | Description |
|---|------|-------------|
| 1 | Theorem 58.1 (Correctness) | BellmanFord returns δ_G(s,v) for all reachable v, or indicates a negative-weight cycle |
| 2 | Sub-path property | Any sub-path of a shortest path is a shortest path |
| 3 | Simple path bound | In absence of negative cycles, shortest paths are simple (≤ |V|−1 edges) |

### Exercises
| # | Item | Description |
|---|------|-------------|
| 1 | Exercise 58.1 | What does a negative weight cycle imply in currency exchange? |
| 2 | Exercise 58.2 | Prove that if no negative-weight cycles, shortest path is simple |

### Examples
| # | Item | Description |
|---|------|-------------|
| 1 | Example 58.1 | Reducing currency exchange to shortest paths |
| 2 | Example 58.2 | Where Dijkstra's property fails with negative weights |
| 3 | Example 58.3 | Computing k+1-hop distance from k-hop distances |
| 4 | Example 58.4 | Several steps of Bellman-Ford execution |

## Phase 3: Algorithmic Analysis

### 3a. Cost Annotations

All exec functions now have APAS/Claude-Opus-4.6 cost comment pairs. Summary:

| # | Function | File | APAS Cost | Claude-Opus-4.6 Cost | Agreement |
|---|----------|------|-----------|-------------|-----------|
| 1 | `bellman_ford` (trait) | BellmanFordStEphI64.rs | Work O(nm), Span O(n lg n) | Work O(nm), Span O(nm) | **Disagree** — sequential |
| 2 | `bellman_ford` (impl) | BellmanFordStEphI64.rs | Work O(nm), Span O(n lg n) | Work O(nm), Span O(nm) | **Disagree** — sequential |
| 3 | `reconstruct_predecessors` | BellmanFordStEphI64.rs | N/A — scaffolding | Work O(n + m), Span O(n + m) | N/A |
| 4 | `bellman_ford` (trait) | BellmanFordStEphFloat.rs | Work O(nm), Span O(n lg n) | Work O(nm), Span O(nm) | **Disagree** — sequential |
| 5 | `bellman_ford` (impl) | BellmanFordStEphFloat.rs | Work O(nm), Span O(n lg n) | Work O(nm), Span O(nm) | **Disagree** — sequential |
| 6 | `reconstruct_predecessors` | BellmanFordStEphFloat.rs | N/A — scaffolding | Work O(n + m), Span O(n + m) | N/A |

**Cost disagreements:** The APAS Span of O(n lg n) assumes parallelism over vertices within each round (Lines 5-6 parallelized). The code uses sequential `for v in 0..n`, so the actual Span equals Work = O(nm). The Work agrees: HashMap gives O(1) expected lookup (matching the sequence-based O(n + m) per round × n rounds = O(nm)).

### 3b. Implementation Fidelity

#### BellmanFordStEphI64 / BellmanFordStEphFloat

Both implementations faithfully follow **Algorithm 58.2** from the prose:

1. **Initialization (Line 13)** — `d(s) = 0`, `d(v) = ∞` for v ≠ s. Code uses `HashMap<usize, i64/OrderedF64>` with `i64::MAX` / `f64::INFINITY` as ∞. Matches prose.
2. **Inner loop (Lines 5-6)** — For each vertex v, computes `D_in(v) = min over u ∈ N⁻(v) of (D[u] + w(u,v))`, then `D'[v] = min(D[v], D_in(v))`. Code correctly implements this with `graph.in_neighbors_weighed(&v)` / `graph.in_neighbors_weighted(&v)`.
3. **Convergence check (Line 9-10)** — `if all {D[v] = D'[v] : v ∈ V}` then return. Code tracks `changed` flag and returns `Ok(result)` when no distances changed.
4. **Negative cycle detection (Line 8)** — `if k = |V|` then return None. Code checks `if round == n - 1` and returns `Err("Negative-weight cycle detected")`.
5. **Predecessor reconstruction** — Not in Algorithm 58.2 pseudocode but necessary for the `SSSPResult` type. Implemented as a post-processing step that scans in-neighbors to find the edge that achieves each vertex's final distance.

**Deviations:**
- The code performs n iterations (0..n) but checks `round == n - 1` for cycle detection. The prose says "if k = |V| then None" where k starts at 0. After n-1 rounds (rounds 0 through n-1), the algorithm has computed up to n-hop distances. If distances are still changing after n rounds, there's a negative cycle. The code's check at `round == n - 1` is equivalent — it runs n rounds total and reports a cycle if convergence hasn't happened by the last round.
- The I64 variant uses `saturating_add` to avoid overflow. The prose assumes unbounded arithmetic. This is a necessary implementation detail.
- The code uses `HashMap` instead of sequences/tables. HashMap provides O(1) expected lookup, which is at least as good as the sequence-based O(1) assumed by the prose.

### 3c. Spec Fidelity

**Partial verusification (I64 only).** The `BellmanFordStEphI64Trait` trait definition is now inside `verus!`, so Verus type-checks the trait's function signature. However, the trait has **no `requires`/`ensures` specs** — the signature is:

```rust
fn bellman_ford(graph: &WeightedDirGraphStEphI128<usize>, source: usize)
    -> (result: Result<SSSPResultStEphI64, String>);
```

This means Verus verifies the type signature but proves no functional properties. The Float variant (`BellmanFordStEphFloat`) remains entirely outside `verus!` with no Verus processing at all.

Key specs that should exist but don't:
1. **Bellman-Ford correctness (Theorem 58.1):** `ensures result.is_ok() ==> forall |v| reachable(graph, source, v) ==> result.unwrap().distance(v) == delta_G(source, v)`
2. **Negative-cycle detection:** `ensures result.is_err() ==> graph has reachable negative-weight cycle from source`
3. **No negative-weight cycle precondition variant:** For the `Ok` case, `ensures result.is_ok() ==> no reachable negative-weight cycle`
4. **Source distance:** `ensures result.is_ok() ==> result.unwrap().distance(source) == 0`

## Phase 4: Parallelism Review

**No Mt (multi-threaded) modules exist in Chapter 58.** The prose notes that the algorithm is parallelizable ("For each vertex v in parallel" on Lines 5-6), but only sequential (`StEph`) variants have been implemented.

The prose explicitly describes Bellman-Ford as having significant parallelism — the per-vertex computation within each round is embarrassingly parallel. A future `BellmanFordMtEph` variant would achieve the APAS Span of O(n lg n).

No parallelism gap table is needed (no Mt modules to audit).

## Phase 5: Runtime Test Review

### 5a. Coverage Check

**Runtime test files exist** for Chap58 in `tests/`.

| # | Source Module | Expected Test File | Status |
|---|-------------|-------------------|--------|
| 1 | `BellmanFordStEphI64.rs` | `tests/Chap58/TestBellmanFordStEphI64.rs` | **Present** |
| 2 | `BellmanFordStEphFloat.rs` | `tests/Chap58/TestBellmanFordStEphFloat.rs` | **Present** |

### 5b. Test Quality

Tests exist for both BellmanFordStEphI64 and BellmanFordStEphFloat. See test files for coverage details.

**lib.rs gate change:** Chap58 modules are no longer behind `#[cfg(not(verus_keep_ghost))]` in `lib.rs`. The chapter is now compiled by Verus (the `verus!` block in BellmanFordStEphI64 is processed during verification). BellmanFordStEphFloat still has no `verus!` block but is no longer gated out of Verus compilation.

### 5c. Missing Tests (Proposed)

| # | Priority | Module | Proposed Tests |
|---|----------|--------|---------------|
| 1 | Medium | BellmanFordStEphI64 | Single vertex, linear chain with positive weights, graph with negative edges but no negative cycle, graph with negative-weight cycle (expect Err), Example 58.4 trace, diamond graph, disconnected vertices |
| 2 | Medium | BellmanFordStEphFloat | Same scenarios with float weights, near-zero weights, Example 58.1 currency exchange reduction |

Priority reduced from High to Medium for both because tests now exist. Additional coverage (Example 58.4 trace, etc.) would strengthen confidence.

## Phase 6: Proof-Time Test (PTT) Review

**No PTTs needed.** Chapter 58 has no iterators, no verified loops, and no verified exec code inside `verus!` (only the trait signature). No `GhostIterator`/`ForLoopGhostIterator` implementations.

### 6a. Unified Test Inventory

| # | Source Module | RTT File | PTT File | Status |
|---|-------------|----------|----------|--------|
| 1 | BellmanFordStEphI64 | 1 | — | RTT Present |
| 2 | BellmanFordStEphFloat | 1 | — | RTT Present |

## Phase 7: Gap Analysis

### Prose Items With No Implementation

| # | Prose Item | Type | Notes |
|---|-----------|------|-------|
| 1 | Theorem 58.1 (Correctness) | Theorem | No proof lemma. The `ensures` clause of `bellman_ford` should express this. |
| 2 | Exercise 58.1 (neg cycle in currency) | Exercise | Not implemented (conceptual). |
| 3 | Exercise 58.2 (simple path proof) | Exercise | Not implemented. |
| 4 | Example 58.1 (currency exchange) | Example | Not implemented as test. Could be a runtime test. |
| 5 | Example 58.4 (BF trace) | Example | Not implemented as test. Should be a runtime test. |
| 6 | Mt (parallel) variant | Algorithm | Prose says the algorithm has "significant parallelism" (Lines 5-6). No Mt variant exists. |
| 7 | Table-based variant | Algorithm | Prose analyzes cost with both tables and sequences. Only HashMap variant exists. |

### Code With No Prose Counterpart

| # | Code Item | Type | Notes |
|---|----------|------|-------|
| 1 | `reconstruct_predecessors` | Function | Scaffolding to build predecessor tree from final distances. Not in Algorithm 58.2 pseudocode. |
| 2 | `BellmanFordStEphFloat` | Module | Float variant; prose uses generic weights but the code duplicates for I64/Float. |
| 3 | `SSSPResultStEphI64/Float` | Type | Result type from Chap56; prose just says "return distances." |

## Phase 8: Table of Contents Review

### TOC Presence

| # | File | TOC Present? | Section Headers? |
|---|------|:------------:|:----------------:|
| 1 | `BellmanFordStEphI64.rs` | No | No |
| 2 | `BellmanFordStEphFloat.rs` | No | No |

Neither file has the standard Table of Contents block or section headers. BellmanFordStEphI64 now has a `verus!` block but it contains only the trait definition — not enough structure to warrant the full TOC.

### In/Out Table

| # | File | Clone | PartialEq/Eq | Default | Drop | Iterator | Debug | Display | Macro | Other |
|---|------|:-----:|:------------:|:-------:|:----:|:--------:|:-----:|:-------:|:-----:|-------|
| 1 | BellmanFordStEphI64.rs | - | - | - | - | - | - | - | - | Trait ✅ in |
| 2 | BellmanFordStEphFloat.rs | - | - | - | - | - | - | - | - | Trait ❌ out |

**Notes:** BellmanFordStEphI64 has its trait inside `verus!` and impl functions outside with `#[cfg(not(verus_keep_ghost))]`. BellmanFordStEphFloat has no `verus!` block — the trait and all functions are plain Rust outside Verus verification.

## Proof Holes Summary

```
✓ BellmanFordStEphFloat.rs
✓ BellmanFordStEphI64.rs

Modules: 2 clean, 0 holed
Holes Found: 0 total
```

Zero proof holes — vacuously true for BellmanFordStEphFloat (no `verus!` block). For BellmanFordStEphI64, the `verus!` block contains only the trait signature with no proof obligations.

## Spec Strength Summary

| Classification | Count |
|---------------|------:|
| strong | 0 |
| partial | 0 |
| weak | 0 |
| none | 4 |

**All 4 functions have no specs.** The trait signature inside `verus!` in BellmanFordStEphI64 has no `requires`/`ensures`, so it counts as `none`.

## Overall Assessment

Chapter 58 is a **partially verusified but unspecified** implementation of Bellman-Ford's algorithm. The I64 variant has its trait definition inside `verus!` and its impl functions cfg-gated behind `#[cfg(not(verus_keep_ghost))]`. The Float variant remains entirely outside `verus!`.

### Strengths
1. **Algorithmic fidelity** — both I64 and Float variants faithfully implement Algorithm 58.2 from the prose, including initialization, k-hop iteration, convergence check, and negative-cycle detection.
2. **Correct structure** — the iterative relaxation with convergence detection and the n-round negative-cycle bound are correctly implemented.
3. **Zero proof holes** — no `assume`, `admit`, or `external_body` hacks.
4. **Work analysis agrees** — APAS and Claude-Opus-4.6 work costs match at O(nm) thanks to HashMap's O(1) expected lookup.
5. **Partial verusification (I64)** — BellmanFordStEphI64 trait is inside `verus!`, establishing a foundation for future spec work. The module is no longer gated out of Verus compilation in `lib.rs`.
6. **Runtime tests present** — both `TestBellmanFordStEphI64.rs` and `TestBellmanFordStEphFloat.rs` exist.

### Weaknesses
1. **No specifications** — 0/4 functions have `requires`/`ensures`. The trait signature inside `verus!` is type-checked but proves no functional properties.
2. **No TOC or section structure** — files don't follow the project's table-of-contents standard.
3. **Span disagreement** — the code achieves Span O(nm) (sequential), not the APAS Span of O(n lg n) which requires parallelism. No Mt variant exists despite the prose describing the algorithm as having "significant parallelism."
4. **Code duplication** — `BellmanFordStEphI64` and `BellmanFordStEphFloat` are nearly identical. A generic approach parameterized by weight type would reduce maintenance.
5. **HashMap instead of verified table/sequence** — the distance structure uses `std::collections::HashMap` which is outside Verus verification. The prose suggests either tables (Chap42) or sequences (Chap18), both of which have verified implementations in the project.
6. **Float variant not verusified** — BellmanFordStEphFloat has no `verus!` block at all. The trait and all functions are plain Rust.
7. **Float equality comparison** — `BellmanFordStEphFloat` compares `OrderedF64` values for exact equality when checking convergence (`min_dist != current_dist`) and predecessor reconstruction (`path_dist == v_dist`). Floating-point equality comparison is fragile and could fail to detect convergence or misidentify predecessors due to rounding.
8. **Missing prose items** — Theorem 58.1, Exercises 58.1-58.2, and the Mt parallel variant have no corresponding code.
9. **Trait return type mismatch** — `BellmanFordStEphFloatTrait::bellman_ford` declares return type `SSSPResultStEphFloat` but the implementation returns `Result<SSSPResultStEphFloat, String>`. The trait signature doesn't account for negative-cycle errors.

### Priority Action Items
1. Add `requires`/`ensures` specs to the trait methods in both I64 and Float variants.
2. Fix the Float trait signature to return `Result<SSSPResultStEphFloat, String>` to match the implementation.
3. Verusify BellmanFordStEphFloat — move trait inside `verus!` block, cfg-gate impl functions.
4. Add TOC headers and restructure files per project standard.
5. Replace `HashMap` with verified table or sequence for distance storage.
6. Implement a parallel `BellmanFordMtEph` variant to achieve the APAS Span of O(n lg n).
7. Add Example 58.4 as a runtime test to validate the algorithm trace.
