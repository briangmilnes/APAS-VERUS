<style>
body { max-width: 100% !important; width: 100% !important; margin: 0 !important; padding: 1em !important; }
.markdown-body { max-width: 100% !important; width: 100% !important; }
.container, .container-lg, .container-xl, main, article { max-width: 100% !important; width: 100% !important; }
table { width: 100% !important; table-layout: fixed; }
</style>

# Chapter 59: Johnson's Algorithm — Review Against Prose

**Date:** 2026-02-19
**Reviewer:** Claude-Opus-4.6

## Phase 1: Inventory (tool-generated)

Generated by `veracity-review-module-fn-impls -d src/Chap59`.

| # | Dir | Module | Tr | IT | IBI | ML | V! | -V! | Unk | Hole | NoSpec |
|---|-----|--------|:--:|:--:|:---:|:--:|:--:|:---:|:---:|:----:|:------:|
| 1 | Chap59 | JohnsonMtEphFloat | 1 | 0 | 0 | 5 | 0 | 5 | 0 | 0 | 5 |
| 2 | Chap59 | JohnsonMtEphI64 | 1 | 0 | 0 | 5 | 1 | 4 | 0 | 0 | 5 |
| 3 | Chap59 | JohnsonStEphFloat | 1 | 0 | 0 | 4 | 0 | 4 | 0 | 0 | 4 |
| 4 | Chap59 | JohnsonStEphI64 | 1 | 0 | 0 | 4 | 1 | 3 | 0 | 0 | 4 |

18 functions total across 4 files. The I64 variants have been partially verusified — `JohnsonMtEphI64` (V!=1, trait inside `verus!`) and `JohnsonStEphI64` (V!=1, trait inside `verus!`). The Float variants remain entirely outside `verus!` (V!=0 for both). All 18 functions still have no specs (NoSpec=18 total).

## Phase 2: Prose Inventory

Source: `prompts/Chap59.txt` (Chapter 59 of APAS textbook)

### Definitions

| # | Item | Description |
|---|------|-------------|
| 1 | Potentials | Assignment p(v): V → R used to reweight edges |
| 2 | Reweighted graph G' | G' = (V, E, w') where w'(u,v) = w(u,v) + p(u) - p(v) |

### Algorithms

| # | Item | Description |
|---|------|-------------|
| 1 | Algorithm 59.1: JohnsonAPSP | All-pairs shortest paths using Bellman-Ford + n Dijkstras |

### Cost Specs

| # | Item | Work | Span |
|---|------|------|------|
| 1 | All Pairs from Single Source (naive) | O(mn^2) | — |
| 2 | Johnson APSP total | O(mn log n) | O(m log n) |
| 3 | Phase 1: 1 × Bellman-Ford | O(mn) | O(n log n) |
| 4 | Phase 2: Reweighting | O(m) | O(m) (implied) |
| 5 | Phase 3: n × Dijkstra | O(mn log n) | O(m log n) |
| 6 | Parallelism | Θ(n) | — |

### Theorems/Properties

| # | Item | Description |
|---|------|-------------|
| 1 | Lemma 59.1 (Path Potentials) | For w'(u,v) = w(u,v) + p(u) - p(v), δG(u,v) = δG'(u,v) - p(u) + p(v). Reweighting preserves shortest paths. |
| 2 | Lemma 59.2 (Non-Negative Weights) | For p(v) = δG+(s,v), all reweighted edges w'(u,v) ≥ 0 |

### Exercises/Problems

None specified in the prose.

## Phase 3: Algorithmic Analysis

### 3a. Cost Annotations

Cost annotation pairs (APAS / Claude-Opus-4.6) have been added to all 18 exec functions across all 4 files.

#### Cost Disagreements

| # | File | Function | APAS | Claude-Opus-4.6 | Reason |
|---|------|----------|------|-----------------|--------|
| 1 | JohnsonStEphI64 | `johnson_apsp` | Work O(mn log n), Span O(m log n) | Work O(mn log n), Span O(mn log n) | Sequential loop over n Dijkstra runs; St variant cannot achieve parallel span |
| 2 | JohnsonStEphFloat | `johnson_apsp` | Work O(mn log n), Span O(m log n) | Work O(mn log n), Span O(mn log n) | Same — sequential loop |
| 3 | JohnsonMtEphFloat | `add_dummy_source` | N/A | Work O(nm), Span O(nm) | Uses nested loop over `out_neighbors_weighted` per vertex instead of flat edge iteration |
| 4 | JohnsonMtEphFloat | `reweight_graph` | Work O(m), Span O(m) | Work O(nm), Span O(nm) | Same nested loop structure via `out_neighbors_weighted` |

Notes:
- The St variants correctly have Span = Work (sequential), but the APAS span in the trait doc comments states O(m log n) which is the parallel bound. The trait comments are aspirational for the parallel case.
- The Mt variants achieve the APAS span through ParaPair! divide-and-conquer.
- MtEphFloat's `add_dummy_source` and `reweight_graph` iterate vertices × neighbors rather than a flat edge list, giving O(nm) worst-case instead of O(n+m). This differs from the I64 variants which use `labeled_arcs()` for flat O(m) edge iteration.

### 3b. Implementation Fidelity

| # | Prose Item | Implementation | Fidelity | Notes |
|---|-----------|----------------|----------|-------|
| 1 | Algorithm 59.1: JohnsonAPSP | `johnson_apsp` in all 4 files | Faithful | Three-phase structure matches prose: add dummy source, Bellman-Ford, reweight, n × Dijkstra, adjust distances |
| 2 | Add dummy source s | `add_dummy_source` | Faithful | Adds vertex n with zero-weight edges to all original vertices |
| 3 | Reweight: w'(u,v) = w(u,v) + D[u] - D[v] | `reweight_graph` | Faithful | Implements the exact reweighting formula |
| 4 | Adjust distances: δG(u,v) = δG'(u,v) - D[u] + D[v] | Inline in `johnson_apsp` Phase 3 loop | Faithful | Correctly de-adjusts Dijkstra distances |
| 5 | Phase 3 parallelism (∪ u∈V Dijkstra' u) | Mt: ParaPair! divide-and-conquer; St: sequential loop | Mt faithful, St sequential by design | Mt uses binary split over vertex range, matching the "in parallel" specification |
| 6 | Negative cycle handling | Returns infinity matrix via `create_negative_cycle_result` | Extension | Prose does not specify behavior for negative cycles; code gracefully handles Bellman-Ford error |

#### Deviations

| # | Deviation | Impact |
|---|-----------|--------|
| 1 | MtEphFloat uses `out_neighbors_weighted` per-vertex loop instead of flat edge iteration for `add_dummy_source` and `reweight_graph` | Worst-case O(nm) vs O(n+m); does not affect correctness |
| 2 | St variants use sequential loop for Phase 3 | Span = O(mn log n) instead of O(m log n); expected for St files |
| 3 | Bellman-Ford span in prose is O(n log n) but actual Bellman-Ford implementation is sequential O(nm) | The Bellman-Ford span O(n log n) assumes parallel edge relaxation; both St and Mt call sequential Bellman-Ford |

### 3c. Spec Fidelity

**Partial verusification (I64 variants only).** The `JohnsonStEphI64Trait` and `JohnsonMtEphI64Trait` trait definitions are now inside `verus!`, so Verus type-checks the trait function signatures. However, the traits have **no `requires`/`ensures` specs** — the signatures are:

```rust
fn johnson_apsp(graph: &WeightedDirGraphStEphI128<usize>) -> AllPairsResultStEphI64;
```

This means Verus verifies the type signatures but proves no functional properties. The Float variants (`JohnsonStEphFloat`, `JohnsonMtEphFloat`) remain entirely outside `verus!` with no Verus processing at all.

Key specs/lemmas that remain unformalized:

- Lemma 59.1 (Path Potentials) — **not formalized**
- Lemma 59.2 (Non-Negative Weights) — **not formalized**
- No precondition that graph has no negative cycles
- No postcondition that result contains correct shortest path distances
- No postcondition relating Dijkstra results back through potential adjustment

## Phase 4: Parallelism Review

### 4a. Mt Function Classification

| # | File | Function | Classification | Mechanism |
|---|------|----------|---------------|-----------|
| 1 | JohnsonMtEphI64 | `johnson_apsp` | Parallel | Calls `parallel_dijkstra_all` |
| 2 | JohnsonMtEphI64 | `parallel_dijkstra_all` | Parallel | ParaPair! binary split over vertex range |
| 3 | JohnsonMtEphI64 | `add_dummy_source` | Sequential | Loop over vertices and edges |
| 4 | JohnsonMtEphI64 | `reweight_graph` | Sequential | Loop over edges |
| 5 | JohnsonMtEphI64 | `create_negative_cycle_result` | Sequential | Tabulate calls |
| 6 | JohnsonMtEphFloat | `johnson_apsp` | Parallel | Calls `parallel_dijkstra_all` |
| 7 | JohnsonMtEphFloat | `parallel_dijkstra_all` | Parallel | ParaPair! binary split over vertex range |
| 8 | JohnsonMtEphFloat | `add_dummy_source` | Sequential | Nested vertex/neighbor loops |
| 9 | JohnsonMtEphFloat | `reweight_graph` | Sequential | Nested vertex/neighbor loops |
| 10 | JohnsonMtEphFloat | `create_negative_cycle_result` | Sequential | Tabulate calls |

### 4b. Span Audit

- **Phase 1 (Bellman-Ford):** Both Mt variants call sequential Bellman-Ford. Actual span is O(nm), not O(n log n) as APAS specifies. This is because the underlying `bellman_ford` implementation is itself sequential.
- **Phase 3 (Dijkstra):** Mt variants use ParaPair! divide-and-conquer giving O(log n) recursion depth × O(m log n) per leaf = O(m log n) effective span. This matches APAS.
- **Phases 2, helpers:** Sequential in all variants.

### 4c. Parallelism Gap Table

| # | Function | APAS Span | Actual Span | Parallel? | Notes |
|---|----------|-----------|-------------|-----------|-------|
| 1 | `johnson_apsp` (Mt) | O(m log n) | O(nm + m log n) = O(nm) | Partial | Phase 1 (Bellman-Ford) is sequential O(nm), dominating the parallel Phase 3 span |
| 2 | `johnson_apsp` (St) | O(m log n) | O(mn log n) | No | Sequential — Span = Work |
| 3 | `parallel_dijkstra_all` (Mt) | N/A | O(m log n) | Yes | ParaPair! achieves full parallelism |
| 4 | `add_dummy_source` (all) | N/A | O(n + m) or O(nm) | No | Sequential helper |
| 5 | `reweight_graph` (all) | N/A | O(m) or O(nm) | No | Sequential helper |

**Key gap:** The Bellman-Ford in the textbook has Span O(n log n) assuming parallel edge relaxation. The current implementation uses sequential Bellman-Ford with Span O(nm). This means the overall Johnson Mt span is dominated by Bellman-Ford at O(nm) rather than achieving the APAS-stated O(m log n).

## Phase 5: Runtime Test Review

### 5a. Coverage Check

**Runtime tests exist for all 4 modules.**

| # | Source Module | RTT File | Status |
|---|-------------|----------|--------|
| 1 | JohnsonStEphI64 | tests/Chap59/TestJohnsonStEphI64.rs | Present |
| 2 | JohnsonStEphFloat | tests/Chap59/TestJohnsonStEphFloat.rs | Present |
| 3 | JohnsonMtEphI64 | tests/Chap59/TestJohnsonMtEphI64.rs | Present |
| 4 | JohnsonMtEphFloat | tests/Chap59/TestJohnsonMtEphFloat.rs | Present |

### 5b. Test Quality

Tests cover basic APSP, negative cycle detection, and float variants. See individual test files for details.

**lib.rs gating:** Chap59 is **verus_keep_ghost only** — compiled only when Verus runs verification. Pending Chap57/Chap45/Chap23 fix for cargo, Chap59 is excluded from normal `cargo test` builds. For Verus, only trait signatures in I64 variants are verified; impls are cfg-gated. Float variants have no `verus!` blocks.

### 5c. Missing Tests (Proposed)

| # | Priority | Test | Rationale |
|---|----------|------|-----------|
| 1 | Medium | Example 59.1 from textbook | Known-answer test from prose |
| 2 | Medium | Single vertex graph, disconnected graph | Edge cases |

## Phase 6: Proof-Time Test (PTT) Review

**No PTTs needed.** Chapter 59 has no iterators, no verified loops, and no verified exec code inside `verus!` (only trait signatures in I64 variants). All executable code is outside `verus!` blocks.

| # | Source Module | RTT File | PTT File | Status |
|---|-------------|----------|----------|--------|
| 1 | JohnsonStEphI64 | TestJohnsonStEphI64.rs | — | RTT Present, PTT N/A |
| 2 | JohnsonStEphFloat | TestJohnsonStEphFloat.rs | — | RTT Present, PTT N/A |
| 3 | JohnsonMtEphI64 | TestJohnsonMtEphI64.rs | — | RTT Present, PTT N/A |
| 4 | JohnsonMtEphFloat | TestJohnsonMtEphFloat.rs | — | RTT Present, PTT N/A |

## Phase 7: Gap Analysis

### Prose Items With No Implementation

| # | Prose Item | Status |
|---|-----------|--------|
| 1 | Lemma 59.1 (Path Potentials) | **Not formalized** — no proof fn or spec fn |
| 2 | Lemma 59.2 (Non-Negative Weights) | **Not formalized** — no proof fn or spec fn |
| 3 | APAS Bellman-Ford Span O(n log n) | **Not achieved** — Bellman-Ford is sequential O(nm) |

### Code With No Prose Counterpart

| # | Function | Rationale |
|---|----------|-----------|
| 1 | `add_dummy_source` | Implementation detail of "add dummy vertex s" step in Algorithm 59.1 |
| 2 | `reweight_graph` | Implementation detail of the w' computation in Algorithm 59.1 |
| 3 | `create_negative_cycle_result` | Error-path scaffolding; prose assumes no negative cycles |
| 4 | `parallel_dijkstra_all` | ParaPair! recursion helper for Mt Phase 3; prose says "in parallel" without specifying mechanism |

## Phase 8: Table of Contents Review

### TOC Presence

| # | File | TOC Present | Section Headers | Notes |
|---|------|:-----------:|:---------------:|-------|
| 1 | JohnsonStEphI64.rs | No | No | Has `verus!` block with trait only |
| 2 | JohnsonStEphFloat.rs | No | No | No `verus!` block; standard Rust module structure |
| 3 | JohnsonMtEphI64.rs | No | No | Has `verus!` block with trait only |
| 4 | JohnsonMtEphFloat.rs | No | No | No `verus!` block; standard Rust module structure |

The I64 files now have `verus!` blocks but they contain only trait definitions — not enough structure to warrant the full TOC. The Float files remain fully outside `verus!`. The files follow a consistent internal structure: imports → type alias → trait → main function → helpers.

### In/Out Table

| # | File | Clone | PartialEq/Eq | Default | Drop | Iterator | Debug | Display | Macro | Other |
|---|------|:-----:|:------------:|:-------:|:----:|:--------:|:-----:|:-------:|:-----:|-------|
| 1 | JohnsonStEphI64.rs | - | - | - | - | - | - | - | - | Trait ✅ in |
| 2 | JohnsonStEphFloat.rs | - | - | - | - | - | - | - | - | Trait ❌ out |
| 3 | JohnsonMtEphI64.rs | - | - | - | - | - | - | - | - | Trait ✅ in |
| 4 | JohnsonMtEphFloat.rs | - | - | - | - | - | - | - | - | Trait ❌ out, uses `ParaPair!` macro |

**Notes:** The I64 variants (`JohnsonStEphI64`, `JohnsonMtEphI64`) have traits inside `verus!` and impls cfg-gated. The Float variants (`JohnsonStEphFloat`, `JohnsonMtEphFloat`) are plain Rust with no `verus!` blocks. No derive impls to audit — these are pure algorithm modules with no custom types.

## Proof Holes Summary

```
veracity-review-proof-holes output (2026-02-18):

✓ JohnsonMtEphFloat.rs
✓ JohnsonMtEphI64.rs
✓ JohnsonStEphFloat.rs
✓ JohnsonStEphI64.rs

Modules: 4 clean, 0 holed
Proof Functions: 0 total
Holes Found: 0 total
```

**0 proof holes** — vacuously true for the Float variants (no `verus!` block). For the I64 variants, the `verus!` blocks contain only trait signatures with no proof obligations.

## Spec Strength Summary

| Classification | Count |
|----------------|------:|
| strong | 0 |
| partial | 0 |
| weak | 0 |
| none | 18 |

**All 18 functions have no specification** (`none`). The trait signatures inside `verus!` in the I64 variants have no `requires`/`ensures`, so they count as `none`.

## Overall Assessment

Chapter 59 implements Algorithm 59.1 (Johnson's APSP) faithfully across 4 files (St/Mt × I64/Float variants). The three-phase structure — add dummy source, Bellman-Ford for potentials, reweight, n × Dijkstra with distance readjustment — correctly matches the textbook. The I64 variants have been partially verusified with trait definitions inside `verus!` and impl functions cfg-gated. Chap59 is verus_keep_ghost only (pending Chap57/Chap45/Chap23 fix for cargo).

### Strengths

1. **Algorithmic fidelity** — all four variants follow the prose algorithm closely
2. **Parallel structure** — Mt variants use ParaPair! divide-and-conquer for Phase 3, achieving Θ(n) parallelism as APAS specifies
3. **Negative cycle handling** — graceful error path not in prose but practically important
4. **Clean proof holes** — no `assume`, `admit`, or `external_body` (vacuously for Float; trivially for I64 since `verus!` blocks contain only trait signatures)
5. **Partial verusification (I64)** — `JohnsonStEphI64` and `JohnsonMtEphI64` traits are inside `verus!`, establishing a foundation for future spec work
6. **Runtime tests present** — all 4 modules have RTT coverage (TestJohnsonStEphI64, TestJohnsonStEphFloat, TestJohnsonMtEphI64, TestJohnsonMtEphFloat)

### Weaknesses

1. **No specifications** — 0/18 functions have `requires`/`ensures`. The trait signatures inside `verus!` are type-checked but prove no functional properties.
2. **Lemmas 59.1 and 59.2 not formalized** — the key correctness properties of Johnson's algorithm have no formal proofs
3. **Bellman-Ford span gap** — prose states Bellman-Ford has Span O(n log n); actual implementation is sequential O(nm), making Mt Johnson's overall span O(nm) rather than O(m log n)
4. **MtEphFloat helper cost** — `add_dummy_source` and `reweight_graph` use nested vertex/neighbor loops giving O(nm) instead of flat O(n+m) edge iteration used by the I64 variants
5. **Float variants not verusified** — `JohnsonStEphFloat` and `JohnsonMtEphFloat` have no `verus!` blocks at all. Their traits and all functions are plain Rust.
6. **Cargo gating** — Chap59 excluded from cargo builds pending Chap57/Chap45/Chap23 fix

### Priority Actions

| # | Priority | Action |
|---|----------|--------|
| 1 | High | Verusify Float variants — move traits inside `verus!` blocks, cfg-gate impl functions |
| 2 | High | Add `requires`/`ensures` specs to the trait methods in all 4 variants |
| 3 | High | Formalize Lemma 59.1 (Path Potentials) and Lemma 59.2 (Non-Negative Weights) as proof functions |
| 4 | Medium | Fix MtEphFloat `add_dummy_source` and `reweight_graph` to use flat edge iteration instead of nested vertex/neighbor loops |
| 5 | Medium | Add Example 59.1 and edge-case tests (single vertex, disconnected) |
| 6 | Medium | Add TOC headers once files are verusified |
| 7 | Low | Consider parallel Bellman-Ford to close the span gap (depends on Chap58 parallelism) |
