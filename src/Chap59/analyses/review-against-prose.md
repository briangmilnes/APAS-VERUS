<style>
body { max-width: 100% !important; width: 100% !important; margin: 0 !important; padding: 1em !important; }
.markdown-body { max-width: 100% !important; width: 100% !important; }
.container, .container-lg, .container-xl, main, article { max-width: 100% !important; width: 100% !important; }
table { width: 100% !important; table-layout: fixed; }
</style>

# Chapter 59: Johnson's Algorithm — Review Against Prose

**Date:** 2026-02-18 (updated 2026-02-18: verusification — trait inside verus!, impl cfg-gated)
**Reviewer:** Claude-Opus-4.6

## Phase 1: Inventory (tool-generated)

Generated by `veracity-review-module-fn-impls -d src/Chap59`.

| # | Dir | Module | Tr | IT | IBI | ML | V! | -V! | Unk | Hole | NoSpec |
|---|-----|--------|:--:|:--:|:---:|:--:|:--:|:---:|:---:|:----:|:------:|
| 1 | Chap59 | JohnsonMtEphFloat | 1 | 0 | 0 | 5 | 0 | 5 | 0 | 0 | 5 |
| 2 | Chap59 | JohnsonMtEphInt | 1 | 0 | 0 | 5 | 1 | 4 | 0 | 0 | 5 |
| 3 | Chap59 | JohnsonStEphFloat | 1 | 0 | 0 | 4 | 0 | 4 | 0 | 0 | 4 |
| 4 | Chap59 | JohnsonStEphInt | 1 | 0 | 0 | 4 | 1 | 3 | 0 | 0 | 4 |

18 functions total across 4 files. The Int variants have been partially verusified — `JohnsonMtEphInt` (V!=1, trait inside `verus!`) and `JohnsonStEphInt` (V!=1, trait inside `verus!`). The Float variants remain entirely outside `verus!` (V!=0 for both). All 18 functions still have no specs (NoSpec=18 total).

## Phase 2: Prose Inventory

Source: `prompts/Chap59.txt` (Chapter 59 of APAS textbook)

### Definitions

| # | Item | Description |
|---|------|-------------|
| 1 | Potentials | Assignment p(v): V → R used to reweight edges |
| 2 | Reweighted graph G' | G' = (V, E, w') where w'(u,v) = w(u,v) + p(u) - p(v) |

### Algorithms

| # | Item | Description |
|---|------|-------------|
| 1 | Algorithm 59.1: JohnsonAPSP | All-pairs shortest paths using Bellman-Ford + n Dijkstras |

### Cost Specs

| # | Item | Work | Span |
|---|------|------|------|
| 1 | All Pairs from Single Source (naive) | O(mn^2) | — |
| 2 | Johnson APSP total | O(mn log n) | O(m log n) |
| 3 | Phase 1: 1 × Bellman-Ford | O(mn) | O(n log n) |
| 4 | Phase 2: Reweighting | O(m) | O(m) (implied) |
| 5 | Phase 3: n × Dijkstra | O(mn log n) | O(m log n) |
| 6 | Parallelism | Θ(n) | — |

### Theorems/Properties

| # | Item | Description |
|---|------|-------------|
| 1 | Lemma 59.1 (Path Potentials) | For w'(u,v) = w(u,v) + p(u) - p(v), δG(u,v) = δG'(u,v) - p(u) + p(v). Reweighting preserves shortest paths. |
| 2 | Lemma 59.2 (Non-Negative Weights) | For p(v) = δG+(s,v), all reweighted edges w'(u,v) ≥ 0 |

### Exercises/Problems

None specified in the prose.

## Phase 3: Algorithmic Analysis

### 3a. Cost Annotations

Cost annotation pairs (APAS / Claude-Opus-4.6) have been added to all 18 exec functions across all 4 files.

#### Cost Disagreements

| # | File | Function | APAS | Claude-Opus-4.6 | Reason |
|---|------|----------|------|-----------------|--------|
| 1 | JohnsonStEphInt | `johnson_apsp` | Work O(mn log n), Span O(m log n) | Work O(mn log n), Span O(mn log n) | Sequential loop over n Dijkstra runs; St variant cannot achieve parallel span |
| 2 | JohnsonStEphFloat | `johnson_apsp` | Work O(mn log n), Span O(m log n) | Work O(mn log n), Span O(mn log n) | Same — sequential loop |
| 3 | JohnsonMtEphFloat | `add_dummy_source` | N/A | Work O(nm), Span O(nm) | Uses nested loop over `out_neighbors_weighted` per vertex instead of flat edge iteration |
| 4 | JohnsonMtEphFloat | `reweight_graph` | Work O(m), Span O(m) | Work O(nm), Span O(nm) | Same nested loop structure via `out_neighbors_weighted` |

Notes:
- The St variants correctly have Span = Work (sequential), but the APAS span in the trait doc comments states O(m log n) which is the parallel bound. The trait comments are aspirational for the parallel case.
- The Mt variants achieve the APAS span through ParaPair! divide-and-conquer.
- MtEphFloat's `add_dummy_source` and `reweight_graph` iterate vertices × neighbors rather than a flat edge list, giving O(nm) worst-case instead of O(n+m). This differs from the Int variants which use `labeled_arcs()` for flat O(m) edge iteration.

### 3b. Implementation Fidelity

| # | Prose Item | Implementation | Fidelity | Notes |
|---|-----------|----------------|----------|-------|
| 1 | Algorithm 59.1: JohnsonAPSP | `johnson_apsp` in all 4 files | Faithful | Three-phase structure matches prose: add dummy source, Bellman-Ford, reweight, n × Dijkstra, adjust distances |
| 2 | Add dummy source s | `add_dummy_source` | Faithful | Adds vertex n with zero-weight edges to all original vertices |
| 3 | Reweight: w'(u,v) = w(u,v) + D[u] - D[v] | `reweight_graph` | Faithful | Implements the exact reweighting formula |
| 4 | Adjust distances: δG(u,v) = δG'(u,v) - D[u] + D[v] | Inline in `johnson_apsp` Phase 3 loop | Faithful | Correctly de-adjusts Dijkstra distances |
| 5 | Phase 3 parallelism (∪ u∈V Dijkstra' u) | Mt: ParaPair! divide-and-conquer; St: sequential loop | Mt faithful, St sequential by design | Mt uses binary split over vertex range, matching the "in parallel" specification |
| 6 | Negative cycle handling | Returns infinity matrix via `create_negative_cycle_result` | Extension | Prose does not specify behavior for negative cycles; code gracefully handles Bellman-Ford error |

#### Deviations

| # | Deviation | Impact |
|---|-----------|--------|
| 1 | MtEphFloat uses `out_neighbors_weighted` per-vertex loop instead of flat edge iteration for `add_dummy_source` and `reweight_graph` | Worst-case O(nm) vs O(n+m); does not affect correctness |
| 2 | St variants use sequential loop for Phase 3 | Span = O(mn log n) instead of O(m log n); expected for St files |
| 3 | Bellman-Ford span in prose is O(n log n) but actual Bellman-Ford implementation is sequential O(nm) | The Bellman-Ford span O(n log n) assumes parallel edge relaxation; both St and Mt call sequential Bellman-Ford |

### 3c. Spec Fidelity

**Partial verusification (Int variants only).** The `JohnsonStEphIntTrait` and `JohnsonMtEphIntTrait` trait definitions are now inside `verus!`, so Verus type-checks the trait function signatures. However, the traits have **no `requires`/`ensures` specs** — the signatures are:

```rust
fn johnson_apsp(graph: &WeightedDirGraphStEphI128<usize>) -> AllPairsResultStEphInt;
```

This means Verus verifies the type signatures but proves no functional properties. The Float variants (`JohnsonStEphFloat`, `JohnsonMtEphFloat`) remain entirely outside `verus!` with no Verus processing at all.

Key specs/lemmas that remain unformalized:

- Lemma 59.1 (Path Potentials) — **not formalized**
- Lemma 59.2 (Non-Negative Weights) — **not formalized**
- No precondition that graph has no negative cycles
- No postcondition that result contains correct shortest path distances
- No postcondition relating Dijkstra results back through potential adjustment

## Phase 4: Parallelism Review

### 4a. Mt Function Classification

| # | File | Function | Classification | Mechanism |
|---|------|----------|---------------|-----------|
| 1 | JohnsonMtEphInt | `johnson_apsp` | Parallel | Calls `parallel_dijkstra_all` |
| 2 | JohnsonMtEphInt | `parallel_dijkstra_all` | Parallel | ParaPair! binary split over vertex range |
| 3 | JohnsonMtEphInt | `add_dummy_source` | Sequential | Loop over vertices and edges |
| 4 | JohnsonMtEphInt | `reweight_graph` | Sequential | Loop over edges |
| 5 | JohnsonMtEphInt | `create_negative_cycle_result` | Sequential | Tabulate calls |
| 6 | JohnsonMtEphFloat | `johnson_apsp` | Parallel | Calls `parallel_dijkstra_all` |
| 7 | JohnsonMtEphFloat | `parallel_dijkstra_all` | Parallel | ParaPair! binary split over vertex range |
| 8 | JohnsonMtEphFloat | `add_dummy_source` | Sequential | Nested vertex/neighbor loops |
| 9 | JohnsonMtEphFloat | `reweight_graph` | Sequential | Nested vertex/neighbor loops |
| 10 | JohnsonMtEphFloat | `create_negative_cycle_result` | Sequential | Tabulate calls |

### 4b. Span Audit

- **Phase 1 (Bellman-Ford):** Both Mt variants call sequential Bellman-Ford. Actual span is O(nm), not O(n log n) as APAS specifies. This is because the underlying `bellman_ford` implementation is itself sequential.
- **Phase 3 (Dijkstra):** Mt variants use ParaPair! divide-and-conquer giving O(log n) recursion depth × O(m log n) per leaf = O(m log n) effective span. This matches APAS.
- **Phases 2, helpers:** Sequential in all variants.

### 4c. Parallelism Gap Table

| # | Function | APAS Span | Actual Span | Parallel? | Notes |
|---|----------|-----------|-------------|-----------|-------|
| 1 | `johnson_apsp` (Mt) | O(m log n) | O(nm + m log n) = O(nm) | Partial | Phase 1 (Bellman-Ford) is sequential O(nm), dominating the parallel Phase 3 span |
| 2 | `johnson_apsp` (St) | O(m log n) | O(mn log n) | No | Sequential — Span = Work |
| 3 | `parallel_dijkstra_all` (Mt) | N/A | O(m log n) | Yes | ParaPair! achieves full parallelism |
| 4 | `add_dummy_source` (all) | N/A | O(n + m) or O(nm) | No | Sequential helper |
| 5 | `reweight_graph` (all) | N/A | O(m) or O(nm) | No | Sequential helper |

**Key gap:** The Bellman-Ford in the textbook has Span O(n log n) assuming parallel edge relaxation. The current implementation uses sequential Bellman-Ford with Span O(nm). This means the overall Johnson Mt span is dominated by Bellman-Ford at O(nm) rather than achieving the APAS-stated O(m log n).

## Phase 5: Runtime Test Review

### 5a. Coverage Check

**No runtime test files exist for Chapter 59.**

No files matching `tests/*59*`, `tests/*Johnson*`, or `tests/*johnson*` were found.

| # | Source Module | RTT File | Status |
|---|-------------|----------|--------|
| 1 | JohnsonStEphInt | — | Missing RTT |
| 2 | JohnsonStEphFloat | — | Missing RTT |
| 3 | JohnsonMtEphInt | — | Missing RTT |
| 4 | JohnsonMtEphFloat | — | Missing RTT |

### 5b. Test Quality

N/A — no tests exist.

**lib.rs gate change:** Chap59 modules are no longer behind `#[cfg(not(verus_keep_ghost))]` in `lib.rs`. The Int variants (`JohnsonStEphInt`, `JohnsonMtEphInt`) are now compiled by Verus — their `verus!` blocks containing trait definitions are processed during verification. The Float variants (`JohnsonStEphFloat`, `JohnsonMtEphFloat`) still have no `verus!` blocks but are no longer gated out of Verus compilation.

### 5c. Missing Tests (Proposed)

| # | Priority | Test | Rationale |
|---|----------|------|-----------|
| 1 | High | `TestJohnsonStEphInt` — basic APSP on small graph with negative edges | Core algorithm; validates distance computation with negative weights |
| 2 | High | `TestJohnsonStEphInt` — negative cycle detection | Validates Bellman-Ford error handling path |
| 3 | High | `TestJohnsonStEphFloat` — same tests with float weights | Validates float variant |
| 4 | High | `TestJohnsonMtEphInt` — parallel variant produces same results as St | Validates parallelism correctness |
| 5 | Medium | Example 59.1 from textbook | Known-answer test from prose |
| 6 | Medium | Single vertex graph, disconnected graph | Edge cases |

## Phase 6: Proof-Time Test (PTT) Review

**No PTTs needed.** Chapter 59 has no iterators, no verified loops, and no verified exec code inside `verus!` (only trait signatures in Int variants). All executable code is outside `verus!` blocks.

| # | Source Module | RTT File | PTT File | Status |
|---|-------------|----------|----------|--------|
| 1 | JohnsonStEphInt | — | — | Missing RTT, PTT N/A |
| 2 | JohnsonStEphFloat | — | — | Missing RTT, PTT N/A |
| 3 | JohnsonMtEphInt | — | — | Missing RTT, PTT N/A |
| 4 | JohnsonMtEphFloat | — | — | Missing RTT, PTT N/A |

## Phase 7: Gap Analysis

### Prose Items With No Implementation

| # | Prose Item | Status |
|---|-----------|--------|
| 1 | Lemma 59.1 (Path Potentials) | **Not formalized** — no proof fn or spec fn |
| 2 | Lemma 59.2 (Non-Negative Weights) | **Not formalized** — no proof fn or spec fn |
| 3 | APAS Bellman-Ford Span O(n log n) | **Not achieved** — Bellman-Ford is sequential O(nm) |

### Code With No Prose Counterpart

| # | Function | Rationale |
|---|----------|-----------|
| 1 | `add_dummy_source` | Implementation detail of "add dummy vertex s" step in Algorithm 59.1 |
| 2 | `reweight_graph` | Implementation detail of the w' computation in Algorithm 59.1 |
| 3 | `create_negative_cycle_result` | Error-path scaffolding; prose assumes no negative cycles |
| 4 | `parallel_dijkstra_all` | ParaPair! recursion helper for Mt Phase 3; prose says "in parallel" without specifying mechanism |

## Phase 8: Table of Contents Review

### TOC Presence

| # | File | TOC Present | Section Headers | Notes |
|---|------|:-----------:|:---------------:|-------|
| 1 | JohnsonStEphInt.rs | No | No | Has `verus!` block with trait only |
| 2 | JohnsonStEphFloat.rs | No | No | No `verus!` block; standard Rust module structure |
| 3 | JohnsonMtEphInt.rs | No | No | Has `verus!` block with trait only |
| 4 | JohnsonMtEphFloat.rs | No | No | No `verus!` block; standard Rust module structure |

The Int files now have `verus!` blocks but they contain only trait definitions — not enough structure to warrant the full TOC. The Float files remain fully outside `verus!`. The files follow a consistent internal structure: imports → type alias → trait → main function → helpers.

### In/Out Table

| # | File | Clone | PartialEq/Eq | Default | Drop | Iterator | Debug | Display | Macro | Other |
|---|------|:-----:|:------------:|:-------:|:----:|:--------:|:-----:|:-------:|:-----:|-------|
| 1 | JohnsonStEphInt.rs | - | - | - | - | - | - | - | - | Trait ✅ in |
| 2 | JohnsonStEphFloat.rs | - | - | - | - | - | - | - | - | Trait ❌ out |
| 3 | JohnsonMtEphInt.rs | - | - | - | - | - | - | - | - | Trait ✅ in |
| 4 | JohnsonMtEphFloat.rs | - | - | - | - | - | - | - | - | Trait ❌ out, uses `ParaPair!` macro |

**Notes:** The Int variants (`JohnsonStEphInt`, `JohnsonMtEphInt`) now have `verus!` blocks containing their trait definitions. The impl functions are outside `verus!` with `#[cfg(not(verus_keep_ghost))]`. The Float variants (`JohnsonStEphFloat`, `JohnsonMtEphFloat`) have no `verus!` blocks — their traits and all functions are plain Rust outside Verus verification. No derive impls to audit — these are pure algorithm modules with no custom types.

## Proof Holes Summary

```
✓ JohnsonMtEphFloat.rs
✓ JohnsonMtEphInt.rs
✓ JohnsonStEphFloat.rs
✓ JohnsonStEphInt.rs

Modules: 4 clean, 0 holed
Holes Found: 0 total
```

**0 proof holes** — vacuously true for the Float variants (no `verus!` block). For the Int variants, the `verus!` blocks contain only trait signatures with no proof obligations.

## Spec Strength Summary

| Classification | Count |
|----------------|------:|
| strong | 0 |
| partial | 0 |
| weak | 0 |
| none | 18 |

**All 18 functions have no specification** (`none`). The trait signatures inside `verus!` in the Int variants have no `requires`/`ensures`, so they count as `none`.

## Overall Assessment

Chapter 59 implements Algorithm 59.1 (Johnson's APSP) faithfully across 4 files (St/Mt × Int/Float variants). The three-phase structure — add dummy source, Bellman-Ford for potentials, reweight, n × Dijkstra with distance readjustment — correctly matches the textbook. The Int variants have been partially verusified with trait definitions inside `verus!` and impl functions cfg-gated behind `#[cfg(not(verus_keep_ghost))]`.

### Strengths

1. **Algorithmic fidelity** — all four variants follow the prose algorithm closely
2. **Parallel structure** — Mt variants use ParaPair! divide-and-conquer for Phase 3, achieving Θ(n) parallelism as APAS specifies
3. **Negative cycle handling** — graceful error path not in prose but practically important
4. **Clean proof holes** — no `assume`, `admit`, or `external_body` (vacuously for Float; trivially for Int since `verus!` blocks contain only trait signatures)
5. **Partial verusification (Int)** — `JohnsonStEphInt` and `JohnsonMtEphInt` traits are inside `verus!`, establishing a foundation for future spec work. The modules are no longer gated out of Verus compilation in `lib.rs`.

### Weaknesses

1. **No specifications** — 0/18 functions have `requires`/`ensures`. The trait signatures inside `verus!` are type-checked but prove no functional properties.
2. **No runtime tests** — 0 test files for any of the 4 modules
3. **Lemmas 59.1 and 59.2 not formalized** — the key correctness properties of Johnson's algorithm have no formal proofs
4. **Bellman-Ford span gap** — prose states Bellman-Ford has Span O(n log n); actual implementation is sequential O(nm), making Mt Johnson's overall span O(nm) rather than O(m log n)
5. **MtEphFloat helper cost** — `add_dummy_source` and `reweight_graph` use nested vertex/neighbor loops giving O(nm) instead of flat O(n+m) edge iteration used by the Int variants
6. **Float variants not verusified** — `JohnsonStEphFloat` and `JohnsonMtEphFloat` have no `verus!` blocks at all. Their traits and all functions are plain Rust.

### Priority Actions

| # | Priority | Action |
|---|----------|--------|
| 1 | High | Add runtime tests for all 4 modules (basic APSP, negative cycles, Example 59.1) |
| 2 | High | Verusify Float variants — move traits inside `verus!` blocks, cfg-gate impl functions |
| 3 | High | Add `requires`/`ensures` specs to the trait methods in all 4 variants |
| 4 | High | Formalize Lemma 59.1 (Path Potentials) and Lemma 59.2 (Non-Negative Weights) as proof functions |
| 5 | Medium | Fix MtEphFloat `add_dummy_source` and `reweight_graph` to use flat edge iteration instead of nested vertex/neighbor loops |
| 6 | Medium | Add TOC headers once files are verusified |
| 7 | Low | Consider parallel Bellman-Ford to close the span gap (depends on Chap58 parallelism) |
