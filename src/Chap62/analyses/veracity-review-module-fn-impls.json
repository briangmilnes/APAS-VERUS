[
  {
    "id": 1,
    "function": "star_contract_mt",
    "file": "Chap62/StarContractionMtEph.rs",
    "lines": "31-35",
    "spec_strength": "",
    "snippet": "            fn star_contract_mt<V, R, F, G>(graph: &UnDirGraphMtEph<V>, seed: u64, base: &F, expand: &G) -> R\n            where\n                V: StT + MtT + Hash + Ord + 'static,\n                F: Fn(&SetStEph<V>) -> R,\n                G: Fn(&SetStEph<V>, &SetStEph<Edge<V>>, &SetStEph<V>, &HashMap<V, V>, R) -> R;"
  },
  {
    "id": 2,
    "function": "contract_to_vertices_mt",
    "file": "Chap62/StarContractionMtEph.rs",
    "lines": "39",
    "spec_strength": "",
    "snippet": "            fn contract_to_vertices_mt<V: StT + MtT + Hash + Ord + 'static>(graph: &UnDirGraphMtEph<V>, seed: u64) -> SetStEph<V>;"
  },
  {
    "id": 3,
    "function": "build_quotient_graph_parallel",
    "file": "Chap62/StarContractionMtEph.rs",
    "lines": "83-104",
    "spec_strength": "",
    "snippet": "    /// Build quotient graph from partition (parallel version)\n    ///\n    /// Routes edges through partition map using divide-and-conquer parallelism.\n    ///\n    /// - APAS: (no cost stated) — helper not in prose.\n    /// - Claude-Opus-4.6: Work O(m), Span O(lg m) — delegates to route_edges_parallel which uses ParaPair fork-join.\n    #[cfg(not(verus_keep_ghost))]\n    fn build_quotient_graph_parallel<V: StT + MtT + Hash + Ord + 'static>(\n        graph: &UnDirGraphMtEph<V>,\n        centers: &SetStEph<V>,\n        partition_map: &HashMap<V, V>,\n    ) -> UnDirGraphMtEph<V> {\n        let edges_vec = graph.edges().iter().cloned().collect::<Vec<Edge<V>>>();\n        let edges_seq = ArraySeqStEphS::from_vec(edges_vec);\n        let n_edges = edges_seq.length();\n\n        let part_map_arc = Arc::new(partition_map.clone());\n\n        let quotient_edges = route_edges_parallel(&edges_seq, part_map_arc, 0, n_edges);\n\n        <UnDirGraphMtEph<V> as UnDirGraphMtEphTrait<V>>::from_sets(centers.clone(), quotient_edges)\n    }"
  },
  {
    "id": 4,
    "function": "route_edges_parallel",
    "file": "Chap62/StarContractionMtEph.rs",
    "lines": "106-156",
    "spec_strength": "",
    "snippet": "    /// Parallel edge routing using divide-and-conquer\n    ///\n    /// - APAS: (no cost stated) — helper not in prose.\n    /// - Claude-Opus-4.6: Work O(k), Span O(lg k) — binary fork-join via ParaPair; k = end - start.\n    #[cfg(not(verus_keep_ghost))]\n    fn route_edges_parallel<V: StT + MtT + Hash + Ord + 'static>(\n        edges: &ArraySeqStEphS<Edge<V>>,\n        partition_map: Arc<HashMap<V, V>>,\n        start: usize,\n        end: usize,\n    ) -> SetStEph<Edge<V>> {\n        let size = end - start;\n\n        if size == 0 {\n            return SetLit![];\n        }\n\n        if size == 1 {\n            let edge = edges.nth(start as N);\n            let Edge(u, v) = edge;\n            let u_center = partition_map.get(u).unwrap_or(u);\n            let v_center = partition_map.get(v).unwrap_or(v);\n\n            if u_center != v_center {\n                let new_edge = if u_center < v_center {\n                    Edge(u_center.clone(), v_center.clone())\n                } else {\n                    Edge(v_center.clone(), u_center.clone())\n                };\n                return SetLit![new_edge];\n            }\n            return SetLit![];\n        }\n\n        let mid = start + size / 2;\n\n        let edges1 = edges.clone();\n        let map1 = partition_map.clone();\n        let edges2 = edges.clone();\n        let map2 = partition_map;\n\n        let pair = ParaPair!(move || route_edges_parallel(&edges1, map1, start, mid), move || {\n            route_edges_parallel(&edges2, map2, mid, end)\n        });\n\n        let mut result = pair.0;\n        for edge in pair.1.iter() {\n            let _ = result.insert(edge.clone());\n        }\n        result\n    }"
  },
  {
    "id": 5,
    "function": "star_contract",
    "file": "Chap62/StarContractionStEph.rs",
    "lines": "26-30",
    "spec_strength": "",
    "snippet": "            fn star_contract<V, R, F, G>(graph: &UnDirGraphStEph<V>, base: &F, expand: &G) -> R\n            where\n                V: StT + Hash + Ord,\n                F: Fn(&SetStEph<V>) -> R,\n                G: Fn(&SetStEph<V>, &SetStEph<Edge<V>>, &SetStEph<V>, &HashMap<V, V>, R) -> R;"
  },
  {
    "id": 6,
    "function": "contract_to_vertices",
    "file": "Chap62/StarContractionStEph.rs",
    "lines": "34",
    "spec_strength": "",
    "snippet": "            fn contract_to_vertices<V: StT + Hash + Ord>(graph: &UnDirGraphStEph<V>) -> SetStEph<V>;"
  },
  {
    "id": 7,
    "function": "build_quotient_graph",
    "file": "Chap62/StarContractionStEph.rs",
    "lines": "77-108",
    "spec_strength": "",
    "snippet": "    /// Build quotient graph from partition\n    ///\n    /// Routes edges through partition map, removing self-loops.\n    ///\n    /// - APAS: (no cost stated) — helper not in prose.\n    /// - Claude-Opus-4.6: Work O(m), Span O(m) — sequential loop over all edges.\n    #[cfg(not(verus_keep_ghost))]\n    fn build_quotient_graph<V: StT + Hash + Ord>(\n        graph: &UnDirGraphStEph<V>,\n        centers: &SetStEph<V>,\n        partition_map: &HashMap<V, V>,\n    ) -> UnDirGraphStEph<V> {\n        let mut quotient_edges: SetStEph<Edge<V>> = SetLit![];\n\n        for edge in graph.edges().iter() {\n            let Edge(u, v) = edge;\n\n            let u_center = partition_map.get(u).unwrap_or(u);\n            let v_center = partition_map.get(v).unwrap_or(v);\n\n            if u_center != v_center {\n                let new_edge = if u_center < v_center {\n                    Edge(u_center.clone(), v_center.clone())\n                } else {\n                    Edge(v_center.clone(), u_center.clone())\n                };\n                let _ = quotient_edges.insert(new_edge);\n            }\n        }\n\n        <UnDirGraphStEph<V> as UnDirGraphStEphTrait<V>>::from_sets(centers.clone(), quotient_edges)\n    }"
  },
  {
    "id": 8,
    "function": "parallel_star_partition",
    "file": "Chap62/StarPartitionMtEph.rs",
    "lines": "26-29",
    "spec_strength": "",
    "snippet": "            fn parallel_star_partition<V: StT + MtT + Hash + Ord + 'static>(\n                graph: &UnDirGraphMtEph<V>,\n                seed: u64,\n            ) -> (SetStEph<V>, HashMap<V, V>);"
  },
  {
    "id": 9,
    "function": "sequential_star_partition",
    "file": "Chap62/StarPartitionStEph.rs",
    "lines": "25",
    "spec_strength": "",
    "snippet": "            fn sequential_star_partition<V: StT + Hash + Ord>(graph: &UnDirGraphStEph<V>) -> (SetStEph<V>, HashMap<V, V>);"
  }
]