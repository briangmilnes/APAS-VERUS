<style>
body { max-width: 100% !important; width: 100% !important; margin: 0 !important; padding: 1em !important; }
.markdown-body { max-width: 100% !important; width: 100% !important; }
.container, .container-lg, .container-xl, main, article { max-width: 100% !important; width: 100% !important; }
table { width: 100% !important; table-layout: fixed; }
</style>

# Chapter 66: Parallel MST Algorithms (Boruvka) — Review Against Prose

**Date:** 2026-02-13
**Reviewer:** Claude-Opus-4.6

## Phase 1: Inventory (tool-generated)

Generated by `veracity-review-module-fn-impls -d src/Chap66`.

| # | Dir | Module | Tr | IT | IBI | ML | V! | -V! | NoSpec | SpecStr |
|---|-----|--------|:--:|:--:|:---:|:--:|:--:|:---:|:------:|:-------:|
| 1 | Chap66 | BoruvkaMtEph | 5 | 0 | 0 | 7 | 0 | 7 | 7 | none |
| 2 | Chap66 | BoruvkaStEph | 5 | 0 | 0 | 5 | 0 | 5 | 5 | none |

**Key observation:** All functions in both modules are outside `verus!`. No function has `requires`/`ensures`. All spec strengths are **none**. The chapter is gated behind `#[cfg(feature = "all_chapters")]` — it is cargo-only code with no Verus verification. The only `verus!` blocks contain `View` impls for `LabeledEdge`.

## Phase 2: Prose Inventory

Source: `prompts/Chap66.txt` (Chapter 66: Parallel MST Algorithms)

### Definitions

| # | Definition | Description |
|---|-----------|-------------|
| 1 | Vertex Bridges | For each vertex v, the minimum weight edge between v and its neighbors. All vertex bridges are in the MST. |
| 2 | LabeledEdge | (vertex x vertex x weight x label) — endpoints change during contraction, weight and label stay fixed. |

### Algorithms

| # | Algorithm | Description |
|---|----------|-------------|
| 1 | Algorithm 66.1 — Boruvka | While edges remain: select min-weight edge per vertex, contract bridges into vertices, remove self-edges and redundant edges, add selected edges to MST. |
| 2 | Algorithm 66.2 — `bridgeStarPartition` | Star contraction along vertex bridges: find bridges, coin flip, contract Tail-to-Head edges. |
| 3 | Algorithm 66.3 — `vertexBridges` + `bridgeStarPartition` + `MST` | Full implementation with labeled edges. `vertexBridges` uses reduce with union/select. `MST` recurses: partition, remap edges, recur, accumulate MST labels. |

### Cost Specs

| # | Item | Work | Span |
|---|------|------|------|
| 1 | Boruvka via tree contraction (S1.2) | O(m log n) | O(log^3 n) |
| 2 | Boruvka via star contraction (S1.3) | O(m log n) | O(log^2 n) |
| 3 | `vertexBridges` (implicit in Algorithm 66.3) | O(m) | O(log m) |
| 4 | Tree contraction per round | O(n) | O(log^2 n) |
| 5 | Edge re-routing per round | O(m) | O(log m) |

### Theorems/Properties

| # | Item | Description |
|---|------|-------------|
| 1 | Light Edge Rule (Lemma 64.3) | All light edges crossing a cut are in the MST. |
| 2 | Lemma 66.1 — Number of Bridged Satellites | For a graph with n non-isolated vertices, E[Xn] >= n/4 vertices removed per round. |
| 3 | Contraction Ratio | Each round removes >= n/2 vertices (tree contraction) or >= n/4 in expectation (star contraction). |

### Exercises/Problems

| # | Item | Type | Implemented? |
|---|------|------|:------------:|
| 1 | Exercise 66.1 | Compare bridged-satellites lemma to original star-partition lemma (text proof) | No |

## Phase 3: Algorithmic Analysis

### 3a. Cost Annotations

All exec functions already have paired APAS / Claude-Opus-4.6 cost comments.

| # | Function | File | APAS Cost | Claude-Opus-4.6 Cost | Agreement |
|---|----------|------|-----------|---------------------|:---------:|
| 1 | `vertex_bridges` | BoruvkaStEph.rs | Work O(m), Span O(log m) | Work O(m), Span O(m) | X |
| 2 | `bridge_star_partition` | BoruvkaStEph.rs | Work O(n), Span O(log n) | Work O(n), Span O(n) | X |
| 3 | `boruvka_mst` | BoruvkaStEph.rs | Work O(m log n), Span O(log^2 n) | Work O(m log n), Span O(m log n) | X |
| 4 | `boruvka_mst_with_seed` | BoruvkaStEph.rs | Work O(m log n), Span O(log^2 n) | Work O(m log n), Span O(m log n) | X |
| 5 | `mst_weight` | BoruvkaStEph.rs | N/A (utility) | Work O(m), Span O(m) | -- |
| 6 | `vertex_bridges_mt` | BoruvkaMtEph.rs | Work O(m), Span O(log m) | Work O(m), Span O(log m) | OK |
| 7 | `bridge_star_partition_mt` | BoruvkaMtEph.rs | Work O(n), Span O(log n) | Work O(n), Span O(n) | X |
| 8 | `filter_tail_to_head_mt` | BoruvkaMtEph.rs | N/A (helper) | Work O(n), Span O(log n) | -- |
| 9 | `boruvka_mst_mt` | BoruvkaMtEph.rs | Work O(m log n), Span O(log^2 n) | Work O(m log n), Span O(n log n) | X |
| 10 | `reroute_edges_mt` | BoruvkaMtEph.rs | N/A (helper) | Work O(m), Span O(log m) | -- |
| 11 | `boruvka_mst_mt_with_seed` | BoruvkaMtEph.rs | Work O(m log n), Span O(log^2 n) | Work O(m log n), Span O(n log n) | X |
| 12 | `mst_weight` | BoruvkaMtEph.rs | N/A (utility) | Work O(m), Span O(m) | -- |

**Span disagreements:** All St functions are sequential (Span = Work). The Mt module achieves parallel span on `vertex_bridges_mt` (O(log m)) and `reroute_edges_mt` (O(log m)), but `bridge_star_partition_mt` has sequential bottlenecks (coin flips O(n), remaining-vertex computation O(n)), which dominate the per-round span to O(n). Over O(log n) rounds, the overall Mt span is O(n log n), not the APAS target of O(log^2 n).

### 3b. Implementation Fidelity

| # | Function | Prose Reference | Fidelity | Notes |
|---|----------|----------------|:--------:|-------|
| 1 | `vertex_bridges` | Algorithm 66.3 `vertexBridges` | **Good** | Follows prose: for each edge, update bridges for both endpoints keeping minimum weight. Prose uses table reduce; code uses sequential HashMap iteration. |
| 2 | `bridge_star_partition` | Algorithm 66.2 `bridgeStarPartition` | **Good** | Follows prose: coin flip, select Tail-to-Head edges, compute V' = V \ domain(P). |
| 3 | `boruvka_mst` | Algorithm 66.3 `MST` | **Good** | Matches prose: base on |E|=0, partition, collect MST labels, build full partition map, re-route edges, recurse. |
| 4 | `boruvka_mst_with_seed` | (wrapper) | **Good** | Convenience wrapper initializing RNG. |
| 5 | `vertex_bridges_mt` | Algorithm 66.3 `vertexBridges` | **Good** | Parallel divide-and-conquer via ParaPair! with merge keeping min-weight. Faithful parallel reduce. |
| 6 | `bridge_star_partition_mt` | Algorithm 66.2 `bridgeStarPartition` | **Partial** | Coin flips are sequential (required for RNG consistency). Filter is parallel via `filter_tail_to_head_mt`. But remaining-vertex computation is sequential. |
| 7 | `boruvka_mst_mt` | Algorithm 66.3 `MST` | **Partial** | Structure matches prose. `vertex_bridges_mt` and `reroute_edges_mt` are parallel, but `bridge_star_partition_mt` has sequential bottlenecks, and MST label collection / full partition map building are sequential loops. |

### 3c. Spec Fidelity

No Verus specs exist. All code is outside `verus!` blocks. There are no `requires`/`ensures` to compare against the prose.

**Gap:** The prose specifies:
- `vertexBridges` returns a table mapping each vertex to (neighbor, weight, label) with the minimum weight edge
- `bridgeStarPartition` returns (V', PT) where V' = V \ domain(PT) and PT maps tails to heads along bridges
- `MST` returns a set of edge labels that form the MST
- All vertex bridges are in the MST (Light Edge Rule)
- Each round removes >= n/4 vertices in expectation (Lemma 66.1)

None of these are formally specified.

## Phase 4: Parallelism Review

### 4a. Mt Function Classification

| # | Function | Classification | Mechanism |
|---|----------|:-------------:|-----------|
| 1 | `vertex_bridges_mt` | **Parallel** | Binary fork-join via `ParaPair!` over edge array. |
| 2 | `bridge_star_partition_mt` | **Partial** | Coin flips sequential, filter parallel via `filter_tail_to_head_mt`, remaining-vertex computation sequential. |
| 3 | `filter_tail_to_head_mt` | **Parallel** | Binary fork-join via `ParaPair!` over vertex array. |
| 4 | `boruvka_mst_mt` | **Partial** | Bridges parallel, partition partially parallel, MST label collection sequential, partition map building sequential, edge rerouting parallel. |
| 5 | `reroute_edges_mt` | **Parallel** | Binary fork-join via `ParaPair!` over edge array. |
| 6 | `boruvka_mst_mt_with_seed` | **Delegating** | Delegates to `boruvka_mst_mt`. |
| 7 | `mst_weight` | **Sequential** | Sequential scan over edges. |

### 4b. Span Audit

| # | Function | APAS Span | Actual Span | Match? | Notes |
|---|----------|-----------|-------------|:------:|-------|
| 1 | `vertex_bridges_mt` | O(log m) | O(log m) | OK | Genuinely parallel divide-and-conquer. |
| 2 | `bridge_star_partition_mt` | O(log n) | O(n) | X | Coin flips O(n) sequential + remaining vertices O(n) sequential. |
| 3 | `filter_tail_to_head_mt` | -- | O(log n) | -- | Genuinely parallel. |
| 4 | `boruvka_mst_mt` | O(log^2 n) | O(n log n) | X | Per round: O(n) from partition bottleneck. Over log n rounds: O(n log n). |
| 5 | `reroute_edges_mt` | -- | O(log m) | -- | Genuinely parallel. |
| 6 | `boruvka_mst_mt_with_seed` | O(log^2 n) | O(n log n) | X | Delegates to `boruvka_mst_mt`. |
| 7 | `mst_weight` | -- | O(m) | -- | Sequential. |

### 4c. Parallelism Gap Table

| # | Function | APAS Span | Actual Span | Parallel? | Notes |
|---|----------|-----------|-------------|:---------:|-------|
| 1 | `vertex_bridges_mt` | O(log m) | O(log m) | Yes | Fork-join via `ParaPair!`. |
| 2 | `bridge_star_partition_mt` | O(log n) | O(n) | Partial | Filter is parallel; coin flips and remaining-vertex loops are sequential. |
| 3 | `filter_tail_to_head_mt` | -- | O(log n) | Yes | Fork-join via `ParaPair!`. |
| 4 | `boruvka_mst_mt` | O(log^2 n) | O(n log n) | Partial | Bridges and edge rerouting are parallel; partition, label collection, and partition map are sequential. |
| 5 | `reroute_edges_mt` | -- | O(log m) | Yes | Fork-join via `ParaPair!`. |
| 6 | `boruvka_mst_mt_with_seed` | O(log^2 n) | O(n log n) | Partial | Delegates to `boruvka_mst_mt`. |
| 7 | `mst_weight` | -- | O(m) | No | Sequential scan. |

**Key finding:** `bridge_star_partition_mt` is the bottleneck. It needs parallel implementations of:
1. Coin flipping (parallel map over vertices — requires parallel RNG or pre-generated random bits)
2. Remaining-vertex computation (parallel filter)
3. MST label collection in `boruvka_mst_mt` (parallel union)
4. Full partition map building in `boruvka_mst_mt` (parallel map construction)

Without parallel partition, the Mt algorithm cannot achieve its O(log^2 n) span.

## Phase 5: Runtime Test Review

### 5a. Coverage Check

**No runtime test files exist for Chap66.** No `tests/` files match `Chap66`, `Boruvka`, or `66`.

| # | Source Module | RTT File | Status |
|---|-------------|----------|--------|
| 1 | BoruvkaStEph | -- | **Missing** |
| 2 | BoruvkaMtEph | -- | **Missing** |

### 5b. Test Quality

N/A — no tests exist.

### 5c. Missing Tests (Recommended)

| # | Priority | Test | Rationale |
|---|:--------:|------|-----------|
| 1 | High | `TestBoruvkaStEph` | Validate MST correctness on small graphs (triangle, square, Example 66.2). Compare MST weight against known optimal. |
| 2 | High | `TestBoruvkaMtEph` | Validate parallel MST matches sequential MST weight on same graphs. |
| 3 | Medium | Deterministic seed test | Verify `boruvka_mst_with_seed` produces consistent results across runs with same seed. |
| 4 | Medium | Edge case tests | Empty graph, single vertex, single edge, disconnected components. |

## Phase 6: Proof-Time Test (PTT) Review

**No PTTs are needed.** Chapter 66 has no verified loops, no iterators inside `verus!`, and no `for`/`while`/`loop` inside `verus!` blocks. All code is outside `verus!`. The only `verus!` blocks contain `View` impls (no loops).

## Phase 7: Gap Analysis

### Prose Items with No Implementation

| # | Prose Item | Status |
|---|-----------|--------|
| 1 | Lemma 66.1 — Number of Bridged Satellites | Not implemented (probabilistic lemma; text proof). |
| 2 | Exercise 66.1 — Compare bridged-satellites to star-partition lemma | Not implemented (text proof). |
| 3 | Algorithm 66.1 — Simple Boruvka (tree contraction version) | Not implemented. Only the star-contraction version (Algorithm 66.2/66.3) is implemented. |
| 4 | Redundant edge elimination | Code keeps all edges including redundant ones between contracted vertices. Prose mentions keeping only the minimum-weight among redundant edges (lines 85-86). The MST result is still correct since redundant heavy edges won't be selected as bridges, but it increases work per round. |

### Code with No Prose Counterpart

| # | Function | Notes |
|---|----------|-------|
| 1 | `filter_tail_to_head_mt` | Internal parallel helper for edge filtering. Implementation detail. |
| 2 | `reroute_edges_mt` | Internal parallel helper for edge re-routing. Implementation detail. |
| 3 | `mst_weight` | Utility function to compute MST total weight. Not in prose. |
| 4 | `boruvka_mst_with_seed` / `boruvka_mst_mt_with_seed` | Convenience wrappers initializing RNG. Not in prose. |

## Phase 8: Table of Contents Review

### TOC Presence

| # | File | TOC Present? | Section Headers? | Notes |
|---|------|:------------:|:----------------:|-------|
| 1 | BoruvkaStEph.rs | No | No | No TOC, no section headers. |
| 2 | BoruvkaMtEph.rs | No | No | No TOC, no section headers. |

### In/Out Table

| # | File | Clone | PartialEq/Eq | Default | Drop | Iterator | Debug | Display | Macro | Other |
|---|------|:-----:|:------------:|:-------:|:----:|:--------:|:-----:|:-------:|:-----:|-------|
| 1 | BoruvkaStEph.rs | out | out | - | - | - | out | out | - | `View` impl inside `verus!` |
| 2 | BoruvkaMtEph.rs | out | out | - | - | - | out | out | - | `View` impl inside `verus!` |

Note: `Clone`, `PartialEq`, `Eq`, `PartialOrd`, `Ord`, `Hash`, `Debug`, and `Copy` are all derived via `#[derive(...)]` on `LabeledEdge<V>` outside `verus!`. `Display` is manually implemented outside `verus!`. These are on a simple data struct, not the main ADT. Per the style guide, `PartialEq`/`Eq` and `Clone` should ideally be inside `verus!` with specs, but since the entire module is unverified, the current placement is acceptable for now.

## Proof Holes Summary

```
BoruvkaMtEph.rs  — clean
BoruvkaStEph.rs  — clean

Modules:  2 clean, 0 holed
Holes Found: 0
```

No proof holes — but this is vacuously true since there is no Verus-verified code beyond the `View` impls.

## Spec Strength Summary

| Classification | Count |
|:-------------:|:-----:|
| strong | 0 |
| partial | 0 |
| weak | 0 |
| none | 12 |

All 12 functions have **no specs** (no `requires`/`ensures`). The entire chapter is outside `verus!`.

## Overall Assessment

Chapter 66 implements Boruvka's MST algorithm using star contraction (Algorithms 66.2 and 66.3) in both sequential and parallel variants. The code is gated behind `#[cfg(feature = "all_chapters")]` and has no Verus verification.

### Strengths

1. **Algorithmic correctness**: Both `BoruvkaStEph` and `BoruvkaMtEph` faithfully implement Algorithm 66.3's structure: vertex bridges, bridge star partition, edge re-routing, recurse.
2. **Genuine parallelism in key phases**: `vertex_bridges_mt` (parallel reduce), `filter_tail_to_head_mt` (parallel filter), and `reroute_edges_mt` (parallel map) all use `ParaPair!` fork-join correctly.
3. **Labeled edges**: Correctly implements the (vertex, vertex, weight, label) representation from the prose, allowing edge tracking through contraction.
4. **Cost annotations**: All 12 exec functions have paired APAS/Claude-Opus-4.6 cost comments with honest span disagreements.

### Weaknesses

1. **No Verus verification** — 0/12 functions have specs. No `requires`/`ensures` anywhere.
2. **No runtime tests** — 0/2 modules have test files.
3. **Parallelism gap** — `bridge_star_partition_mt` has O(n) sequential bottlenecks (coin flips, remaining-vertex computation). This means `boruvka_mst_mt` achieves O(n log n) span instead of the APAS target O(log^2 n).
4. **No redundant edge elimination** — Prose says to keep only the minimum-weight among redundant edges between contracted vertices. Code re-routes all edges, keeping duplicates. This does not affect correctness but increases work.
5. **No TOC headers** — neither file follows the table-of-contents standard.
6. **Trait signatures don't match implementations** — Trait functions in `BoruvkaStEphTrait` and `BoruvkaMtEphTrait` declare different parameter types than the free functions (e.g., trait takes `&SetStEph<LabeledEdge<V>>` but implementation takes additional parameters like `&SetStEph<V>`, `SetStEph<usize>`, `&mut StdRng`). The trait functions are never called through the trait.

### Priority Actions

| # | Priority | Action |
|---|:--------:|--------|
| 1 | High | Add runtime tests for both modules (MST correctness, weight validation, edge cases). |
| 2 | High | Parallelize coin flips and remaining-vertex computation in `bridge_star_partition_mt` to achieve O(log n) span. |
| 3 | Medium | Add redundant edge elimination (keep minimum weight among edges between same contracted pair) to match prose. |
| 4 | Medium | Verusify modules — add `verus!` blocks, specs for `vertex_bridges`, `bridge_star_partition`, `boruvka_mst`. |
| 5 | Low | Add TOC headers to both files. |
| 6 | Low | Fix trait/impl signature mismatch or remove unused traits. |
